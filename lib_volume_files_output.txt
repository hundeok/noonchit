\n\n// ====== lib/core/di/volume_provider.dart ======\n
// lib/core/di/volume_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import 'trade_provider.dart' show marketsProvider; // ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ì¬ì‚¬ìš©
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart'; // ğŸ†• UseCase import
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import ì¶”ê°€!


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• VOLUME ì „ìš© Providerë“¤ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ¯ ë³¼ë¥¨ ì „ìš© RemoteDataSource (TradeRemoteDataSourceì™€ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤)
final volumeRemoteDSProvider = Provider<TradeRemoteDataSource>((ref) {
  return TradeRemoteDataSource(
    ref.read(wsClientProvider),
    ref.read(signalBusProvider),
    useTestData: AppConfig.useTestDataInDev,
  );
});

/// ğŸ†• VolumeRepository
final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  return VolumeRepositoryImpl(
    ref.read(volumeRemoteDSProvider),
  );
});

/// ğŸ†• VolumeUsecase
final volumeUsecaseProvider = Provider<VolumeUsecase>((ref) {
  return VolumeUsecase(
    ref.read(volumeRepositoryProvider),
  );
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ìƒíƒœ (ê¸°ë³¸ê°’: 1ë¶„)
final volumeTimeFrameIndexProvider = StateProvider<int>((_) => 0); // 1ë¶„ì´ ê¸°ë³¸ (0:1m, 1:5m, 2:15m)

final volumeTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(volumeTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m'; // fallback (ê¸°ë³¸ê°’ 1ë¶„)
});

/// ğŸ†• ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (ì‹¤ì‹œê°„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  try {
    // í˜„ì¬ ì‹œê°„ëŒ€ì™€ marketsë¥¼ ì½ì–´ì„œ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    final timeFrame = ref.watch(volumeTimeFrameProvider);
    final markets = await ref.watch(marketsProvider.future);
    final usecase = ref.read(volumeUsecaseProvider); // ğŸ†• UseCase ì‚¬ìš©

    if (AppConfig.enableTradeLog) {
      log.i('Volume stream started: $timeFrame, ${markets.length} markets');
    }

    // ğŸš€ ì‹¤ì‹œê°„ ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ (UseCaseë¥¼ í†µí•´)
    yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (volumes) => volumes,
        err: (error) {
          log.e('Volume UseCase error: ${error.message}');
          return <Volume>[]; // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Volume stream error: $e', e, stackTrace);
    
    // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
    yield <Volume>[];
  }
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ì»¨íŠ¸ë¡¤ëŸ¬
final volumeTimeFrameController = Provider((ref) => VolumeTimeFrameController(ref));

class VolumeTimeFrameController {
  final Ref ref;
  VolumeTimeFrameController(this.ref);

  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid timeFrame index: $index');
      return;
    }
    
    ref.read(volumeTimeFrameProvider.notifier).state = timeFrame;
    ref.read(volumeTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Volume TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (UseCaseë¥¼ í†µí•´)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(volumeTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Volume reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Volume reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(volumeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Volume reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Volume reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ (UseCaseë¥¼ í†µí•´)
  DateTime? getNextResetTime() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(volumeTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get reset time failed: ${error.message}');
        return null;
      },
    );
  }

  /// Getters
  String get currentTimeFrame => ref.read(volumeTimeFrameProvider);
  int get currentIndex => ref.read(volumeTimeFrameIndexProvider);
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }
}\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import
import '../../domain/repositories/volume_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ë³¼ë¥¨ ì „ìš© Repository - ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ TradeRemoteDataSource ê³µìœ 
class VolumeRepositoryImpl implements VolumeRepository {
  final TradeRemoteDataSource _remote;

  // ğŸ“Š ë³¼ë¥¨ ìƒíƒœ ê´€ë¦¬ (ì‹¤ì‹œê°„ ëˆ„ì )
  final Map<String, Map<String, double>> _volumeByTimeFrame = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„)
  final Map<String, StreamController<Map<String, double>>> _volumeControllers = {};
  
  // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
  final Map<String, DateTime> _timeFrameStartTimes = {};
  
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _volumeStream;
  StreamSubscription<Trade>? _volumeSubscription;
  
  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxCacheSize = 1000;

  VolumeRepositoryImpl(this._remote) {
    // ğŸ†• ë³¼ë¥¨ ê´€ë ¨ ì´ˆê¸°í™”
    _initializeVolumeTracking();
    
    // ğŸ†• ë³¼ë¥¨ ë¦¬ì…‹ ì²´í¬ íƒ€ì´ë¨¸ (30ì´ˆë§ˆë‹¤)
    Timer.periodic(const Duration(seconds: 30), (_) => _checkVolumeResets());
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ†• VOLUME ì „ìš© ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ì¶”ì  ì´ˆê¸°í™”
  void _initializeVolumeTracking() {
    final now = DateTime.now();
    
    for (final timeFrameMinutes in AppConfig.timeFrames) {
      final timeFrameStr = '${timeFrameMinutes}m';
      
      // ë¹ˆ ë³¼ë¥¨ ë§µ ì´ˆê¸°í™”
      _volumeByTimeFrame[timeFrameStr] = <String, double>{};
      
      // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
      _volumeControllers[timeFrameStr] = StreamController<Map<String, double>>.broadcast();
      
      // ì‹œì‘ ì‹œê°„ ì„¤ì •
      _timeFrameStartTimes[timeFrameStr] = now;
    }
    
    if (kDebugMode) {
      debugPrint('ğŸ¯ Volume tracking initialized for ${AppConfig.timeFrames.length} timeframes');
    }
  }

  /// ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryì™€ ë…ë¦½ì )
  void _initializeVolumeStream(List<String> markets) {
    if (_volumeStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
    
    debugPrint('VolumeRepositoryImpl: initializing volume stream for ${markets.length} markets');
    
    // ğŸ¯ TradeRemoteDataSource ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _volumeStream = _remote.watch(markets).asBroadcastStream();
    
    // ğŸ¯ ë³¼ë¥¨ ì „ìš© êµ¬ë… (ì›ì‹œ ë°ì´í„° ë°”ë¡œ ì²˜ë¦¬)
    _volumeSubscription = _volumeStream!.listen(
      _processRawTradeForVolume,
      onError: (error, stackTrace) {
        debugPrint('Volume stream error: $error');
        debugPrint('StackTrace: $stackTrace');
      },
      onDone: () {
        debugPrint('Volume stream done');
      },
    );
  }

  /// Map<String, double>ì„ Volume ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ì •ë ¬ í¬í•¨)
  List<Volume> _createVolumeList(Map<String, double> volumeMap, String timeFrame) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame] ?? now;
    
    final volumeList = volumeMap.entries
        .where((entry) => entry.value > 0) // ë³¼ë¥¨ì´ 0ë³´ë‹¤ í° ê²ƒë§Œ
        .map((entry) => Volume(
              market: entry.key,
              totalVolume: entry.value,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame,
              timeFrameStartMs: startTime.millisecondsSinceEpoch,
            ))
        .toList();

    // ë³¼ë¥¨ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ìˆœ)
    volumeList.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    
    return volumeList;
  }

  @override
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets) {
    debugPrint('VolumeRepositoryImpl: watchVolumeByTimeFrame() - timeFrame: $timeFrame');
    
    // ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeVolumeStream(markets);
    
    // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (Volume ë¦¬ìŠ¤íŠ¸ë¡œ)
    return _volumeControllers[timeFrame]?.stream
        .map((volumeMap) => _createVolumeList(volumeMap, timeFrame))
        ?? const Stream.empty();
  }

  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ë³¼ë¥¨ìœ¼ë¡œ ì¦‰ì‹œ ëˆ„ì  (ë°°ì¹˜ ì—†ìŒ!)
  void _processRawTradeForVolume(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
      if (!_seenIds.add(key)) return;

      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ğŸ†• ë³¼ë¥¨ ì¦‰ì‹œ ëˆ„ì  (ë°°ì¹˜ ì—†ì´ ì‹¤ì‹œê°„!)
      _accumulateVolumeInstantly(trade);
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTradeForVolume error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// ê±°ë˜ ë°ì´í„°ë¥¼ ë°›ì„ ë•Œë§ˆë‹¤ ë³¼ë¥¨ ì¦‰ì‹œ ëˆ„ì  (ì‹¤ì‹œê°„!)
  void _accumulateVolumeInstantly(Trade trade) {
    final market = trade.market;
    final totalAmount = trade.total;
    
    // ëª¨ë“  ì‹œê°„ëŒ€ì— ë™ì‹œ ëˆ„ì 
    for (final timeFrameStr in _volumeByTimeFrame.keys) {
      final currentVolume = _volumeByTimeFrame[timeFrameStr]![market] ?? 0.0;
      _volumeByTimeFrame[timeFrameStr]![market] = currentVolume + totalAmount;
    }
    
    // ğŸš€ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ (ë°°ì¹˜ ì—†ìŒ!)
    _updateVolumeStreamsInstantly();
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸ (ì‹¤ì‹œê°„!)
  void _updateVolumeStreamsInstantly() {
    try {
      for (final entry in _volumeByTimeFrame.entries) {
        final timeFrameStr = entry.key;
        final volumeMap = Map<String, double>.from(entry.value);
        
        // í•´ë‹¹ ì‹œê°„ëŒ€ ìŠ¤íŠ¸ë¦¼ì— ë°ì´í„° ì¦‰ì‹œ ì „ì†¡
        final controller = _volumeControllers[timeFrameStr];
        if (controller != null && !controller.isClosed) {
          controller.add(volumeMap);
        }
      }
      
      if (kDebugMode) {
        final totalMarkets = _volumeByTimeFrame.values.isNotEmpty 
            ? _volumeByTimeFrame.values.first.length 
            : 0;
        if (totalMarkets > 0) {
          debugPrint('âš¡ Volume streams updated instantly: $totalMarkets markets');
        }
      }
    } catch (e, stackTrace) {
      debugPrint('_updateVolumeStreamsInstantly error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì²´í¬ (30ì´ˆë§ˆë‹¤ í˜¸ì¶œ)
  void _checkVolumeResets() {
    final now = DateTime.now();
    
    for (final timeFrameMinutes in AppConfig.timeFrames) {
      final timeFrameStr = '${timeFrameMinutes}m';
      final startTime = _timeFrameStartTimes[timeFrameStr];
      
      if (startTime != null) {
        final elapsed = now.difference(startTime).inMinutes;
        
        // í•´ë‹¹ ì‹œê°„ëŒ€ê°€ ì§€ë‚˜ë©´ ë¦¬ì…‹
        if (elapsed >= timeFrameMinutes) {
          _resetTimeFrame(timeFrameStr);
          _timeFrameStartTimes[timeFrameStr] = now;
          
          if (kDebugMode) {
            debugPrint('ğŸ”„ Volume reset: $timeFrameStr (after ${elapsed}min)');
          }
        }
      }
    }
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ë¦¬ì…‹
  void _resetTimeFrame(String timeFrameStr) {
    _volumeByTimeFrame[timeFrameStr]?.clear();
    _updateVolumeStreamsInstantly(); // ë¦¬ì…‹ í›„ ë¹ˆ ë°ì´í„° ì¦‰ì‹œ ì „ì†¡
  }

  @override
  void resetTimeFrame(String timeFrame) {
    debugPrint('ğŸ”„ Manual reset timeFrame: $timeFrame');
    _resetTimeFrame(timeFrame);
  }

  @override
  void resetAllTimeFrames() {
    debugPrint('ğŸ”„ Manual reset all timeFrames');
    for (final timeFrameStr in _volumeByTimeFrame.keys) {
      _volumeByTimeFrame[timeFrameStr]?.clear();
    }
    _updateVolumeStreamsInstantly();
  }

  @override
  DateTime? getNextResetTime(String timeFrame) {
    final startTime = _timeFrameStartTimes[timeFrame];
    if (startTime == null) return null;
    
    final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (timeFrameMinutes == null) return null;
    
    return startTime.add(Duration(minutes: timeFrameMinutes));
  }

  @override
  List<String> getActiveTimeFrames() {
    return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  }

  @override
  bool isTimeFrameActive(String timeFrame) {
    return getActiveTimeFrames().contains(timeFrame);
  }

  @override
  Future<void> dispose() async {
    debugPrint('VolumeRepositoryImpl: dispose() called');
    
    // ë³¼ë¥¨ êµ¬ë… ì •ë¦¬
    await _volumeSubscription?.cancel();
    _volumeStream = null;
    
    // ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    for (final controller in _volumeControllers.values) {
      await controller.close();
    }
    
    debugPrint('VolumeRepositoryImpl: dispose completed');
  }
}\n\n// ====== lib/data/models/volume_dto.dart ======\n
\n\n// ====== lib/data/processors/volume_aggregator.dart ======\n
\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
// lib/domain/repositories/volume_repository.dart

import '../entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import

/// ë³¼ë¥¨ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ëˆ„ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class VolumeRepository {
  /// ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ìŠ¤íŠ¸ë¦¼ ì œê³µ (Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³¼ë¥¨ìˆœ ì •ë ¬)
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/volume.dart';
import '../repositories/volume_repository.dart';

/// Volume ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class VolumeUsecase {
  final VolumeRepository _repository;

  VolumeUsecase(this._repository);

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë­í‚¹ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
  Stream<Result<List<Volume>, AppException>> getVolumeRanking(
    String timeFrame,
    List<String> markets,
  ) {
    return _repository
        .watchVolumeByTimeFrame(timeFrame, markets)
        .transform(_wrapWithErrorHandling<List<Volume>>('Volume ranking failed'));
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetTimeFrame(String timeFrame) {
    try {
      _repository.resetTimeFrame(timeFrame);
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset timeframe failed: $e'));
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetAllTimeFrames() {
    try {
      _repository.resetAllTimeFrames();
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset all timeframes failed: $e'));
    }
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  Result<DateTime?, AppException> getNextResetTime(String timeFrame) {
    try {
      final resetTime = _repository.getNextResetTime(timeFrame);
      return Ok(resetTime);
    } catch (e) {
      return Err(AppException('Get reset time failed: $e'));
    }
  }

  /// í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  Result<List<String>, AppException> getActiveTimeFrames() {
    try {
      final timeFrames = _repository.getActiveTimeFrames();
      return Ok(timeFrames);
    } catch (e) {
      return Err(AppException('Get active timeframes failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦
  Result<bool, AppException> validateTimeFrame(String timeFrame) {
    try {
      final isActive = _repository.isTimeFrameActive(timeFrame);
      return Ok(isActive);
    } catch (e) {
      return Err(AppException('Validate timeframe failed: $e'));
    }
  }

  /// ë³¼ë¥¨ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Volume>, AppException> validateVolumeData(List<Volume> volumes) {
    try {
      // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ë³¼ë¥¨ì´ ìˆëŠ” ê²ƒë§Œ, ì¤‘ë³µ ì œê±°, ì •ë ¬ í™•ì¸
      final validVolumes = volumes
          .where((v) => v.hasVolume && v.market.isNotEmpty)
          .toSet() // ì¤‘ë³µ ì œê±°
          .toList();

      // ì •ë ¬ í™•ì¸ (ë³¼ë¥¨ ë‚´ë¦¼ì°¨ìˆœ)
      final isSorted = _isVolumeSorted(validVolumes);
      if (!isSorted) {
        validVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
      }

      return Ok(validVolumes);
    } catch (e) {
      return Err(AppException('Volume data validation failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë¹„êµ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<Map<String, double>, AppException> compareVolumeAcrossTimeFrames(
    String market,
    List<String> timeFrames,
  ) {
    try {
      // ì—¬ëŸ¬ ì‹œê°„ëŒ€ì˜ íŠ¹ì • ì½”ì¸ ë³¼ë¥¨ ë¹„êµ
      // ì‹¤ì œ êµ¬í˜„ì€ Repositoryì—ì„œ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¦¼ì„ ì¡°í•©í•´ì•¼ í•¨
      final comparison = <String, double>{};
      
      // TODO: ì‹¤ì œ êµ¬í˜„ ì‹œ ì—¬ëŸ¬ timeFrameì˜ ë°ì´í„°ë¥¼ ì¡°í•©
      // í˜„ì¬ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ
      for (final tf in timeFrames) {
        comparison[tf] = 0.0; // ì‹¤ì œ ë°ì´í„° ì¡°íšŒ í•„ìš”
      }
      
      return Ok(comparison);
    } catch (e) {
      return Err(AppException('Volume comparison failed: $e'));
    }
  }

  /// í—¬í¼: ë³¼ë¥¨ ì •ë ¬ í™•ì¸
  bool _isVolumeSorted(List<Volume> volumes) {
    if (volumes.length <= 1) return true;
    
    for (int i = 0; i < volumes.length - 1; i++) {
      if (volumes[i].totalVolume < volumes[i + 1].totalVolume) {
        return false;
      }
    }
    return true;
  }

  /// í—¬í¼: ì—ëŸ¬ ì²˜ë¦¬ ë³€í™˜ê¸°
  StreamTransformer<T, Result<T, AppException>> _wrapWithErrorHandling<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/entities/volume.dart ======\n
// lib/domain/entities/volume.dart

import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë³¼ë¥¨ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Volume extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì´ ê±°ë˜ëŸ‰ (ì›í™” ê¸°ì¤€)
  final double totalVolume;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Volume({
    required this.market,
    required this.totalVolume,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    totalVolume,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³¼ë¥¨ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ë³´ë‹¤ í¼)
  bool get hasVolume => totalVolume > 0;
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Volume copyWith({
    String? market,
    double? totalVolume,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Volume(
      market: market ?? this.market,
      totalVolume: totalVolume ?? this.totalVolume,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/presentation/providers/volume_provider.dart ======\n
\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
// lib/presentation/controllers/volume_controller.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/volume_provider.dart'; // ğŸ†• volume_provider ì‚¬ìš©
import '../../domain/entities/volume.dart';

/// ğŸ¯ ì‹¬í”Œí•œ ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ëŸ¬ - VolumeTimeFrameController í™œìš©
class VolumeController {
  final Ref ref;
  VolumeController(this.ref);

  /// ì‹œê°„ëŒ€ ì„¤ì •
  void setTimeFrame(String timeFrame, int index) {
    // volume_provider.dartì˜ VolumeTimeFrameController ì‚¬ìš©
    final controller = ref.read(volumeTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€
  String get currentTimeFrame => ref.read(volumeTimeFrameController).currentTimeFrame;

  /// í˜„ì¬ ì¸ë±ìŠ¤
  int get currentIndex => ref.read(volumeTimeFrameController).currentIndex;

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë“¤
  List<String> get availableTimeFrames => ref.read(volumeTimeFrameController).availableTimeFrames;

  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    return ref.read(volumeTimeFrameController).getTimeFrameName(timeFrame);
  }

  /// ë³¼ë¥¨ ë°ì´í„°ë¥¼ ê±°ë˜ëŸ‰ ìˆœìœ¼ë¡œ ì •ë ¬
  List<Volume> sortVolumeData(List<Volume> volumeData) {
    final filteredData = volumeData.where((v) => v.totalVolume > 0).toList();
    filteredData.sort((a, b) => b.totalVolume.compareTo(a.totalVolume)); // ë‚´ë¦¼ì°¨ìˆœ
    return filteredData;
  }

  /// ì½”ì¸ëª… í•„í„°ë§
  List<Volume> filterByMarket(List<Volume> sortedData, String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return sortedData;
    }
    final upper = marketFilter.toUpperCase();
    return sortedData.where((volume) => volume.market.contains(upper)).toList();
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    ref.read(volumeTimeFrameController).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    ref.read(volumeTimeFrameController).resetAllTimeFrames();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    return ref.read(volumeTimeFrameController).getNextResetTime();
  }
}

/// Provider ì„ ì–¸ - ì‹¬í”Œí•˜ê²Œ!
final volumeControllerProvider = Provider((ref) => VolumeController(ref));\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
// lib/presentation/pages/volume_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/volume_provider.dart'; // ğŸ†• volume_provider ì‚¬ìš©!
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹°
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';
// âœ‚ï¸ CommonAppBar import ì œê±° (MainPageì—ì„œ ì²˜ë¦¬)

class VolumePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const VolumePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) TimeFrame ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(volumeTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(volumeTimeFrameController);
    
    // 2) ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼
    final volumesAsync = ref.watch(volumeDataProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬ (í•„í„°/ì •ë ¬)
    final uiController = ref.watch(volumeControllerProvider);
    
    // 4) ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ì€ ScrollController ì‚¬ìš© (ë¡œì»¬ ìƒì„± ì œê±°)

    // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(timeFrames, index, timeFrameCtrl);
    
    // ğŸ†• ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final volumeListWidget = _buildVolumeList(volumesAsync, uiController, scrollController, timeFrames, index, context);

    // âœ… PrimaryScrollControllerë¡œ ìƒíƒœë°” í„°ì¹˜ í™œì„±í™” + ì •í™•í•œ ScrollController ì—°ê²°
    return PrimaryScrollController(
      controller: scrollController, // âœ… ì´ì œ MainPageì™€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤!
      child: Column(
        children: [
          // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: volumeListWidget),
          
          // ğŸ†• ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± (ì‹œê°„ëŒ€ ì„ íƒ + ì¹´ìš´íŠ¸ë‹¤ìš´)
  Widget _buildSliderWidget(List<String> timeFrames, int index, VolumeTimeFrameController timeFrameCtrl) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì‹œê°„ëŒ€ì™€ ì¹´ìš´íŠ¸ë‹¤ìš´ì„ Rowë¡œ ë°°ì¹˜
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
                style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              _buildCountdownWidget(timeFrameCtrl),
            ],
          ),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (timeFrames.length - 1).toDouble(),
            divisions: timeFrames.length - 1,
            label: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
            onChanged: (v) {
              HapticFeedback.mediumImpact(); // ğŸ¯ í–…í‹± í”¼ë“œë°±
              final i = v.round();
              timeFrameCtrl.updateTimeFrame(timeFrames[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ¯ ì¹´ìš´íŠ¸ë‹¤ìš´ ìœ„ì ¯ ìƒì„±
  Widget _buildCountdownWidget(VolumeTimeFrameController timeFrameCtrl) {
    final nextResetTime = timeFrameCtrl.getNextResetTime();
    
    if (nextResetTime == null) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: const [
          Icon(Icons.access_time, size: 16, color: Colors.grey),
          SizedBox(width: 4),
          Text(
            '--:--',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final now = DateTime.now();
    final remaining = nextResetTime.difference(now);
    
    if (remaining.isNegative) {
      return Row(
        mainAxisSize: MainAxisSize.min,
        children: const [
          Icon(Icons.access_time, size: 16, color: Colors.orange),
          SizedBox(width: 4),
          Text(
            '00:00',
            style: TextStyle(
              fontSize: 14,
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final minutes = remaining.inMinutes;
    final seconds = remaining.inSeconds % 60;
    
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.access_time, size: 16, color: Colors.orange),
        const SizedBox(width: 4),
        Text(
          '${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}',
          style: const TextStyle(
            fontSize: 14,
            color: Colors.orange,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  /// ğŸ†• ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ë“œë˜ê·¸ ê¸°ëŠ¥ ê°•í™”
  Widget _buildVolumeList(
    AsyncValue<List<Volume>> volumesAsync, 
    VolumeController uiController, 
    ScrollController scrollController,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    return volumesAsync.when(
      data: (volumes) {
        // List<Volume>ì„ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        final sortedVolumes = uiController.sortVolumeData(volumes);
        
        if (sortedVolumes.isEmpty) {
          return Center(
            child: Text(
              'ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ë” ê°•ë ¥í•œ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ìŠ¤í¬ë¡¤ë°”
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: true,
          trackVisibility: true, // íŠ¸ë™ í‘œì‹œ
          thickness: 8, // âœ… ë‘ê»˜ ì¤„ì´ê¸° (16 â†’ 8)
          radius: const Radius.circular(4), // âœ… ë°˜ì§€ë¦„ë„ ì¡°ì •
          thumbColor: Colors.orange.withValues(alpha: 0.5), // âœ… ê¸°ì¡´ ì£¼í™© ë°˜íˆ¬ëª…
          trackColor: Colors.transparent, // âœ… íŠ¸ë™ì€ íˆ¬ëª…í•˜ê²Œ
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 50, // ìµœì†Œ ì¸ ê¸¸ì´
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 24, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¤„ì´ê¸°
            itemCount: sortedVolumes.length,
            itemBuilder: (_, i) => VolumeTile(
              market: sortedVolumes[i].market,
              totalVolume: sortedVolumes[i].totalVolume,
              rank: i + 1, // ğŸ¯ ìˆœìœ„ ì „ë‹¬ (1ìœ„ë¶€í„° ì‹œì‘)
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ë³¼ë¥¨ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
// lib/presentation/widgets/volume_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart'; // DisplayMode import
import '../../shared/widgets/coin_logo_provider.dart'; // ğŸ†• ì½”ì¸ ë¡œê³  í”„ë¡œë°”ì´ë” import (ì˜¬ë°”ë¥¸ ê²½ë¡œ)

// ğŸ¯ ìˆœìœ„ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (marketë³„ ì´ì „ ìˆœìœ„ ì €ì¥)
final Map<String, int> _previousRanks = {};

class VolumeTile extends ConsumerStatefulWidget {
  // í¬ë§·í„°ë¥¼ staticìœ¼ë¡œ ìºì‹±í•´ ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šë„ë¡ ìµœì í™”
  static final _integerFormat = NumberFormat('#,###'); // ì •ìˆ˜ìš©
  
  final String market; // ğŸ”„ Volume ì—”í‹°í‹° ëŒ€ì‹  ë‹¨ìˆœ ë°ì´í„°
  final double totalVolume;
  final int rank; // ğŸ¯ ìˆœìœ„ (1ìœ„ë¶€í„°)
  final bool showHotIcon; // ğŸš€ ê¸‰ìƒìŠ¹ í‘œì‹œ ì—¬ë¶€
  final bool enableBlinkAnimation; // ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ ì—¬ë¶€
  
  const VolumeTile({
    Key? key, 
    required this.market,
    required this.totalVolume,
    required this.rank,
    this.showHotIcon = false,
    this.enableBlinkAnimation = false,
  }) : super(key: key);

  @override
  ConsumerState<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends ConsumerState<VolumeTile> 
    with SingleTickerProviderStateMixin {
  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    _checkRankChange();
  }

  void _checkRankChange() {
    final previousRank = _previousRanks[widget.market];
    final currentRank = widget.rank;
    
    // ì´ì „ ìˆœìœ„ê°€ ìˆê³ , ìˆœìœ„ê°€ ì˜¬ë¼ê°„ ê²½ìš°ì—ë§Œ ë°˜ì§
    if (previousRank != null && currentRank < previousRank) {
      _shouldBlink = true;
      _blinkController.forward().then((_) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _shouldBlink = false;
            });
          }
        });
      });
    }
    
    // í˜„ì¬ ìˆœìœ„ë¥¼ ì €ì¥
    _previousRanks[widget.market] = currentRank;
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  // ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë¡œì§ (TradeTileê³¼ ë™ì¼)
  String _getDisplayName(WidgetRef ref) {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final marketInfoAsync = ref.watch(marketInfoProvider);
    
    // ê¸°ë³¸ í‹°ì»¤ (fallback)
    final ticker = widget.market.replaceFirst('KRW-', '');
    
    // marketInfoê°€ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì—ëŸ¬ì¸ ê²½ìš° í‹°ì»¤ ë°˜í™˜
    return marketInfoAsync.when(
      data: (marketInfoMap) {
        final marketInfo = marketInfoMap[widget.market];
        
        switch (displayMode) {
          case DisplayMode.ticker:
            return ticker;
          case DisplayMode.korean:
            return marketInfo?.koreanName ?? ticker;
          case DisplayMode.english:
            return marketInfo?.englishName ?? ticker;
        }
      },
      loading: () => ticker, // ë¡œë”© ì¤‘ì—ëŠ” í‹°ì»¤ í‘œì‹œ
      error: (_, __) => ticker, // ì—ëŸ¬ ì‹œì—ë„ í‹°ì»¤ í‘œì‹œ
    );
  }

  // ğŸ¯ ê±°ë˜ëŸ‰ í¬ë§·íŒ… (ì–µ ë‹¨ìœ„ ê°„ì†Œí™”)
  String _formatVolume(double totalVolume) {
    if (totalVolume >= 100000000) { // 1ì–µ ì´ìƒ
      final eok = totalVolume / 100000000;
      if (eok >= 10) {
        return '${eok.toInt()}ì–µì›'; // "12ì–µì›"
      } else {
        return '${eok.toStringAsFixed(1)}ì–µì›'; // "1.2ì–µì›"
      }
    } else if (totalVolume >= 10000000) { // 1ì²œë§Œ ì´ìƒ
      final man = totalVolume / 10000;
      return '${man.toInt()}ë§Œì›'; // "5,000ë§Œì›"
    } else {
      return '${VolumeTile._integerFormat.format(totalVolume)}ì›'; // "500ë§Œì›"
    }
  }

  // ğŸ¯ ìˆœìœ„ì— ë”°ë¥¸ ìƒ‰ìƒ
  Color _getRankColor(BuildContext context) {
    final theme = Theme.of(context);
    switch (widget.rank) {
      case 1:
        return Colors.amber; // ğŸ¥‡ 1ìœ„ - ê¸ˆìƒ‰
      case 2:
        return Colors.grey.shade400; // ğŸ¥ˆ 2ìœ„ - ì€ìƒ‰
      case 3:
        return Colors.orange.shade300; // ğŸ¥‰ 3ìœ„ - ë™ìƒ‰
      default:
        return theme.colorScheme.onSurface.withValues(alpha: 0.6); // ê¸°ë³¸
    }
  }

  // ğŸ¯ ìˆœìœ„ ì•„ì´ì½˜
  Widget _buildRankWidget(BuildContext context) {
    final rankColor = _getRankColor(context);
    final isTopThree = widget.rank <= 3;
    
    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: isTopThree ? rankColor.withValues(alpha: 0.2) : Colors.transparent,
        border: isTopThree ? Border.all(color: rankColor, width: 2) : null,
      ),
      child: Center(
        child: Text(
          '${widget.rank}',
          style: TextStyle(
            fontSize: 14,
            fontWeight: isTopThree ? FontWeight.bold : FontWeight.normal,
            color: rankColor,
          ),
        ),
      ),
    );
  }

  // ğŸ¯ HOT ì•„ì´ì½˜ (ê¸‰ìƒìŠ¹ ì‹œ)
  Widget? _buildHotIcon() {
    if (!widget.showHotIcon) return null;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: Colors.red,
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Text(
        'ğŸš€ HOT',
        style: TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // ğŸ¯ ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ (ì„¤ì •ì— ë”°ë¼)
    Widget cardWidget = Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          children: [
            // ğŸ† ìˆœìœ„ ë¶€ë¶„: ê³ ì • í¬ê¸°
            _buildRankWidget(context),
            
            const SizedBox(width: 12),
            
            // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
            
            const SizedBox(width: 12),
            
            // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„: flex 25 (í™•ì¥ ê°€ëŠ¥)
            Expanded(
              flex: 25,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          _getDisplayName(ref), // âœ… ë™ì  ì½”ì¸ëª… í‘œì‹œ
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            color: theme.colorScheme.primary,
                            fontSize: 16,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                      ),
                      const SizedBox(width: 4),
                      // ğŸš€ HOT ì•„ì´ì½˜
                      if (_buildHotIcon() != null) _buildHotIcon()!,
                    ],
                  ),
                  const SizedBox(height: 2),
                  Row(
                    children: [
                      Text(
                        widget.market.replaceFirst('KRW-', ''), // í•­ìƒ í‹°ì»¤ëŠ” í‘œì‹œ
                        style: TextStyle(
                          color: onSurface70,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(width: 4),
                      // ğŸ¯ ë¡œê³  ì§€ì› ì—¬ë¶€ í‘œì‹œ (ê°œë°œìš© - ë‚˜ì¤‘ì— ì œê±° ê°€ëŠ¥)
                      if (CoinLogoProvider.isSupported(widget.market.replaceFirst('KRW-', '')))
                        Container(
                          width: 4,
                          height: 4,
                          decoration: const BoxDecoration(
                            color: Colors.green,
                            shape: BoxShape.circle,
                          ),
                        ),
                    ],
                  ),
                ],
              ),
            ),
            
            // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 30
            Expanded(
              flex: 30,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    _formatVolume(widget.totalVolume),
                    style: TextStyle(
                      color: onSurface,
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                  const SizedBox(height: 2),
                  const Text(
                    'â° ì‹¤ì‹œê°„', // TODO: ì¹´ìš´íŠ¸ë‹¤ìš´ êµ¬í˜„
                    style: TextStyle(
                      color: Colors.orange,
                      fontSize: 11,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ì´ ìˆì„ ë•Œì™€ ì—†ì„ ë•Œ ë¶„ê¸°
    Widget finalWidget = cardWidget;
    
    if (_shouldBlink) {
      finalWidget = AnimatedBuilder(
        animation: _blinkAnimation,
        builder: (context, child) {
          return Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.amber.withValues(alpha: 1.0 - _blinkAnimation.value),
                  blurRadius: 12,
                  spreadRadius: 3,
                ),
              ],
            ),
            child: cardWidget,
          );
        },
      );
    } else if (widget.enableBlinkAnimation) {
      finalWidget = TweenAnimationBuilder<double>(
        tween: Tween(begin: 1.0, end: 0.7),
        duration: const Duration(milliseconds: 300),
        builder: (context, value, child) {
          return AnimatedContainer(
            duration: const Duration(milliseconds: 150),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: theme.colorScheme.primary.withValues(alpha: 1.0 - value),
                  blurRadius: 8,
                  spreadRadius: 2,
                ),
              ],
            ),
            child: cardWidget,
          );
        },
      );
    }
    
    return finalWidget;
  }
}