\n\n// ====== lib/core/di/market_mood_provider copy.dart ======\n
\n\n// ====== lib/core/di/market_mood_provider.dart ======\n
// lib/core/di/market_mood_provider.dart
// ğŸ”¥ Providerë“¤ë§Œ ê¹”ë”í•˜ê²Œ ë¶„ë¦¬ (DI íŒ¨í„´) - ì™„ì„±í˜•

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../network/api_client_coingecko.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show hiveServiceProvider; // ğŸ”¥ ê¸°ì¡´ hiveServiceProvider ì‚¬ìš©
import '../../data/datasources/market_mood_remote_ds.dart';
import '../../data/datasources/market_mood_local_ds.dart';
import '../../data/repositories/market_mood_repository_impl.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/usecases/market_mood_usecase.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸ Provider
final coinGeckoApiClientProvider = Provider<CoinGeckoApiClient>((ref) {
  return CoinGeckoApiClient();
});

/// ğŸ”¥ Remote DataSource Provider
final marketMoodRemoteDSProvider = Provider<MarketMoodRemoteDataSource>((ref) {
  final client = ref.read(coinGeckoApiClientProvider);
  return MarketMoodRemoteDataSource(client);
});

/// ğŸ”¥ Local DataSource Provider
final marketMoodLocalDSProvider = Provider<MarketMoodLocalDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return MarketMoodLocalDataSource(hive);
});

/// ğŸ”¥ Repository Provider
final marketMoodRepositoryProvider = Provider<MarketMoodRepositoryImpl>((ref) {
  final remoteDS = ref.read(marketMoodRemoteDSProvider);
  final localDS = ref.read(marketMoodLocalDSProvider);
  return MarketMoodRepositoryImpl(remoteDS, localDS);
});

/// ğŸ”¥ UseCase Provider
final marketMoodUsecaseProvider = Provider<MarketMoodUsecase>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  return MarketMoodUsecase(repository);
});

/// ğŸ”¥ í™˜ìœ¨ Provider (UseCase í†µí•´ì„œ)
final exchangeRateProvider = FutureProvider.autoDispose<double>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);
  
  try {
    final rate = await usecase.getExchangeRate();
    log.d('í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate');
    return rate;
  } catch (e) {
    log.w('í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ 1400 ì‚¬ìš©: $e');
    return 1400.0;
  }
});

/// ğŸ”¥ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° Provider (Repository í†µí•´ì„œ) - ë©”ì¸ ë°ì´í„° ì†ŒìŠ¤
final marketMoodProvider = StreamProvider.autoDispose<MarketMoodData>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  
  ref.onDispose(() {
    repository.dispose();
  });

  return repository.getMarketDataStream();
});

/// ğŸ“ˆ ë³¼ë¥¨ ë¹„êµ ë°ì´í„° Provider
final volumeComparisonProvider = FutureProvider.autoDispose<ComparisonData>((ref) async {
  final moodAsync = ref.watch(marketMoodProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (data) async => await usecase.calculateVolumeComparison(data.totalVolumeUsd),
    loading: () async => ComparisonData.loading(),
    error: (_, __) async => ComparisonData.error(),
  );
});

/// ğŸ¯ í˜„ì¬ ë§ˆì¼“ ë¬´ë“œ Provider (30ë¶„ ê¸°ì¤€)
final currentMarketMoodProvider = FutureProvider.autoDispose<MarketMood>((ref) async {
  final moodAsync = ref.watch(marketMoodProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (data) async => await usecase.calculateCurrentMood(data.totalVolumeUsd),
    loading: () async => MarketMood.sideways,
    error: (_, __) async => MarketMood.sideways,
  );
});

/// ğŸ“Š ë§ˆì¼“ ë¬´ë“œ ìƒíƒœ ìš”ì•½ Provider
final marketMoodSummaryProvider = FutureProvider.autoDispose<String>((ref) async {
  final moodAsync = ref.watch(currentMarketMoodProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);
  
  return moodAsync.when(
    data: (mood) => usecase.generateMoodSummary(mood),
    loading: () => 'ë¡œë”©ì¤‘...',
    error: (_, __) => 'ì˜¤ë¥˜',
  );
});

/// ğŸŒ ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ Provider
final marketMoodSystemProvider = FutureProvider.autoDispose<MarketMoodSystemState>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);

  // ê° Providerì˜ í˜„ì¬ ê°’ë“¤ì„ ê°€ì ¸ì˜¤ê¸°
  final moodAsync = ref.watch(marketMoodProvider);
  final comparisonAsync = ref.watch(volumeComparisonProvider);
  final currentMoodAsync = ref.watch(currentMarketMoodProvider);
  final exchangeAsync = ref.watch(exchangeRateProvider);

  // AsyncValueì—ì„œ ë°ì´í„° ì¶”ì¶œ
  final marketData = moodAsync.asData?.value;
  final comparison = comparisonAsync.asData?.value ?? ComparisonData.loading();
  final currentMood = currentMoodAsync.asData?.value ?? MarketMood.sideways;
  final exchangeRate = exchangeAsync.asData?.value ?? 1400.0;

  final isLoading = moodAsync.isLoading || comparisonAsync.isLoading || 
                   currentMoodAsync.isLoading || exchangeAsync.isLoading;
  final hasError = moodAsync.hasError || comparisonAsync.hasError || 
                  currentMoodAsync.hasError || exchangeAsync.hasError;

  return usecase.createSystemState(
    marketData: marketData,
    comparisonData: comparison,
    currentMood: currentMood,
    exchangeRate: exchangeRate,
    isLoading: isLoading,
    hasError: hasError,
  );
});

/// ğŸ® ë§ˆì¼“ ë¬´ë“œ ì»¨íŠ¸ë¡¤ëŸ¬ Provider
final marketMoodControllerProvider = Provider((ref) => MarketMoodController(ref));

class MarketMoodController {
  final Ref ref;
  MarketMoodController(this.ref);

  void refresh() {
    ref.invalidate(marketMoodProvider);
    ref.invalidate(exchangeRateProvider);
  }

  Future<MarketMood> getCurrentMood() async {
    final moodAsync = ref.read(currentMarketMoodProvider);
    return moodAsync.when(
      data: (mood) => mood,
      loading: () => MarketMood.sideways,
      error: (_, __) => MarketMood.sideways,
    );
  }

  Future<ComparisonData> getComparisonData() async {
    final comparisonAsync = ref.read(volumeComparisonProvider);
    return comparisonAsync.when(
      data: (data) => data,
      loading: () => ComparisonData.loading(),
      error: (_, __) => ComparisonData.error(),
    );
  }

  Future<void> refreshExchangeRate() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.refreshExchangeRate();
    ref.invalidate(exchangeRateProvider);
  }

  Future<Map<String, dynamic>> getSystemHealth() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    return await usecase.getSystemHealth();
  }

  Future<void> logSystemStatus() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.logSystemStatus();
  }
}\n\n// ====== lib/shared/widgets/market_mood_modal.dart ======\n
\n\n// ====== lib/shared/widgets/market_mood_indicator.dart ======\n
// lib/shared/widgets/market_mood_indicator.dart
// ğŸ¨ Shared Widget: Market Mood ì¸ë””ì¼€ì´í„° (í´ë¦° ì•„í‚¤í…ì²˜ ì™„ì „ ëŒ€ì‘)

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/controllers/market_mood_controller.dart';

/// ğŸ¨ ë©”ì¸ ë§ˆì¼“ë¬´ë“œ ì¸ë””ì¼€ì´í„° ìœ„ì ¯
class MarketMoodIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const MarketMoodIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false,
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final marketMoodAsync = ref.watch(marketMoodProvider);
    final currentMoodAsync = ref.watch(currentMarketMoodProvider);
    
    Widget indicator = marketMoodAsync.when(
      data: (data) => currentMoodAsync.when(
        data: (mood) => _buildMoodIcon(context, ref, data, mood),
        loading: () => _buildLoadingIcon(),
        error: (_, __) => _buildErrorIcon(),
      ),
      loading: () => _buildLoadingIcon(),
      error: (_, __) => _buildErrorIcon(),
    );
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildMoodIcon(BuildContext context, WidgetRef ref, MarketMoodData data, MarketMood mood) {
    Widget moodIcon = _getMoodIcon(mood);
    
    // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜ ì¶”ê°€
    return GestureDetector(
      onLongPressStart: (details) => _showMarketMoodModal(context, ref, details.globalPosition, data),
      onLongPressEnd: (_) => _hideMarketMoodModal(),
      onLongPressCancel: () => _hideMarketMoodModal(),
      child: moodIcon,
    );
  }

  Widget _buildLoadingIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.refresh,
      color: Colors.grey,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë”© ì¤‘...' : null,
      animationType: MoodAnimationType.rotate,
      size: size,
    );
  }

  Widget _buildErrorIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.error_outline,
      color: Colors.red,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨' : null,
      animationType: MoodAnimationType.blink,
      size: size,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ í‘œì‹œ - ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
  void _showMarketMoodModal(BuildContext context, WidgetRef ref, Offset globalPosition, MarketMoodData data) {
    HapticFeedback.mediumImpact();
    Tooltip.dismissAllToolTips();
    
    // í™”ë©´ í¬ê¸°ì™€ ëª¨ë‹¬ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = screenSize.width * 0.9; // 90% ë„ˆë¹„ ì‚¬ìš©
    
    // í™”ë©´ ê²½ê³„ ê³ ë ¤í•œ ìœ„ì¹˜ ê³„ì‚°
    double adjustedX = globalPosition.dx - (modalWidth / 2); // ì¤‘ì•™ ì •ë ¬
    double adjustedY = globalPosition.dy + size + 40; // ğŸ”¥ ë¬´ì¡°ê±´ ì•„ë˜ìª½ìœ¼ë¡œ (ìœ„ìª½ ê³„ì‚° ì œê±°)
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16;
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16;
    }
    
    // í•˜ë‹¨ ê²½ê³„ ì²´í¬ - í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ìœ„ë¡œ ì¡°ì •
    final bottomSafeArea = MediaQuery.of(context).padding.bottom;
    final maxY = screenSize.height - bottomSafeArea - 300; // ëª¨ë‹¬ ìµœì†Œ ë†’ì´ ê³ ë ¤
    if (adjustedY > maxY) {
      adjustedY = globalPosition.dy - 250; // ì¶©ë¶„íˆ ìœ„ë¡œ ì˜¬ë ¤ì„œ í‘œì‹œ
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
    MarketMoodModalManager.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
      data: data,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  void _hideMarketMoodModal() {
    MarketMoodModalManager.hide();
  }

  Widget _getMoodIcon(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull:
        return _AnimatedMoodIcon(
          icon: Icons.rocket_launch,
          color: const Color(0xFFFF6B35), // ğŸš€ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸš€ ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +15% ì´ìƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fastPulse,
          size: size,
        );
        
      case MarketMood.weakBull:
        return _AnimatedMoodIcon(
          icon: Icons.local_fire_department,
          color: const Color(0xFFFF6B35), // ğŸ”¥ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸ”¥ ì•½ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +5~15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fireFlicker,
          size: size,
        );
        
      case MarketMood.sideways:
        return _AnimatedMoodIcon(
          icon: Icons.balance,
          color: const Color(0xFF757575), // âš–ï¸ ì¤‘ì„± íšŒìƒ‰
          tooltip: showTooltip ? 'âš–ï¸ ì¤‘ê°„ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~+5% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.wiggle,
          size: size,
        );
        
      case MarketMood.bear:
        return _AnimatedMoodIcon(
          icon: Icons.water_drop,
          color: const Color(0xFF4A90E2), // ğŸ’§ ë¬¼ë°©ìš¸ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ’§ ë¬¼ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~-15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.waterDrop,
          size: size,
        );
        
      case MarketMood.deepBear:
        return _AnimatedMoodIcon(
          icon: Icons.ac_unit,
          color: const Color(0xFF4A90E2), // ğŸ§Š ì–¼ìŒì¥ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ§Š ì–¼ìŒì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -15% ì´í•˜ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.coldShiver,
          size: size,
        );
    }
  }
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… enum
enum MoodAnimationType { 
  none, 
  fastPulse, 
  fireFlicker, 
  wiggle, 
  waterDrop, 
  coldShiver, 
  rotate, 
  blink 
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ ì•„ì´ì½˜ ìœ„ì ¯
class _AnimatedMoodIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final MoodAnimationType animationType;
  final double size;

  const _AnimatedMoodIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedMoodIcon> createState() => _AnimatedMoodIconState();
}

class _AnimatedMoodIconState extends State<_AnimatedMoodIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case MoodAnimationType.fastPulse:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.6, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.fireFlicker:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 600),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.elasticOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.wiggle:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2000),
          vsync: this,
        );
        _animation = Tween<double>(begin: -0.15, end: 0.15).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.waterDrop:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2500),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.85, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.coldShiver:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 150),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.95, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.linear),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case MoodAnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedMoodIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case MoodAnimationType.fastPulse:
            return Transform.translate(
              offset: Offset(0, (_animation.value - 1) * 2),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.5, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.fireFlicker:
            return Transform.scale(
              scale: _animation.value,
              child: Transform.rotate(
                angle: (_animation.value - 1) * 0.1,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.4, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.wiggle:
            return Transform.rotate(
              angle: _animation.value,
              child: Transform.scale(
                scale: 0.95 + (_animation.value.abs() * 0.1),
                child: icon,
              ),
            );
            
          case MoodAnimationType.waterDrop:
            return Transform.translate(
              offset: Offset(0, (1 - _animation.value) * 1.5),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.6, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.coldShiver:
            return Transform.translate(
              offset: Offset(
                (_animation.value - 0.975) * 40,
                (_animation.value - 0.975) * 20,
              ),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.8, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case MoodAnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value.clamp(0.3, 1.0),
                child: icon,
              ),
            );
            
          case MoodAnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        preferBelow: false,
        verticalOffset: 20,
        waitDuration: const Duration(milliseconds: 500),
        showDuration: const Duration(seconds: 3),
        decoration: BoxDecoration(
          color: Colors.black87,
          borderRadius: BorderRadius.circular(8),
        ),
        textStyle: const TextStyle(
          fontSize: 11,
          color: Colors.white,
        ),
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/data/datasources/market_mood_remote_ds.dart ======\n
// lib/data/datasources/market_mood_remote_ds.dart
// ğŸŒ Data Layer: ì›ê²© ë°ì´í„° ì†ŒìŠ¤ (CoinGecko API)

import 'dart:async';
import '../../core/network/api_client_coingecko.dart';
import '../../core/utils/logger.dart';

/// ğŸŒ ë§ˆì¼“ë¬´ë“œ ì›ê²© ë°ì´í„° ì†ŒìŠ¤
/// Provider íŒŒì¼ ê¸°ì¤€ìœ¼ë¡œ í•„ìš”í•œ API í˜¸ì¶œ ë‹´ë‹¹
class MarketMoodRemoteDataSource {
  final CoinGeckoApiClient _apiClient;
  Timer? _globalDataTimer;
  StreamController<CoinGeckoGlobalData>? _globalDataController;

  MarketMoodRemoteDataSource(this._apiClient);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (30ë¶„ ì£¼ê¸°)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (Providerì—ì„œ ìš”êµ¬í•˜ëŠ” í˜•íƒœ)
  Stream<CoinGeckoGlobalData> getGlobalMarketDataStream() {
    // broadcast ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€ê²½ (ì—¬ëŸ¬ ë¦¬ìŠ¤ë„ˆ ì§€ì›)
    _globalDataController = StreamController<CoinGeckoGlobalData>.broadcast();
    
    Future<void> fetch() async {
      try {
        final response = await _apiClient.getGlobalMarketData();
        final data = response.data;
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.add(data);
          log.d('ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìˆ˜ì‹  ì„±ê³µ: ${data.totalVolumeUsd.toStringAsFixed(0)}B USD');
        }
      } catch (e) {
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.addError(e);
          log.e('âŒ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: $e');
        }
      }
    }

    // ì²« í˜¸ì¶œ
    fetch();

    // 30ë¶„ë§ˆë‹¤ í˜¸ì¶œ
    _globalDataTimer = Timer.periodic(const Duration(minutes: 30), (_) => fetch());

    // ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
    _globalDataController!.onCancel = () {
      _globalDataTimer?.cancel();
      _globalDataTimer = null;
      log.d('ğŸ”„ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ');
    };

    return _globalDataController!.stream;
  }

  /// ë‹¨ì¼ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ
  Future<CoinGeckoGlobalData> getGlobalMarketData() async {
    try {
      final response = await _apiClient.getGlobalMarketData();
      log.d('ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì„±ê³µ');
      return response.data;
    } catch (e) {
      log.e('âŒ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: $e');
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’± í™˜ìœ¨ ë°ì´í„°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// USD/KRW í™˜ìœ¨ ì¡°íšŒ (ìºì‹œ ì—†ëŠ” ìˆœìˆ˜ API í˜¸ì¶œ)
  Future<double> getUsdToKrwRate() async {
    try {
      final rate = await _apiClient.getUsdToKrwRate();
      log.d('ğŸ’± í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate KRW');
      return rate;
    } catch (e) {
      log.e('âŒ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨: $e');
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// API ì—°ê²° ìƒíƒœ í™•ì¸
  Future<bool> checkApiHealth() async {
    try {
      await getGlobalMarketData();
      log.d('âœ… CoinGecko API ì—°ê²° ì •ìƒ');
      return true;
    } catch (e) {
      log.w('âš ï¸ CoinGecko API ì—°ê²° ì‹¤íŒ¨: $e');
      return false;
    }
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _globalDataTimer?.cancel();
    _globalDataTimer = null;
    _globalDataController?.close();
    _globalDataController = null;
    log.d('ğŸ§¹ MarketMoodRemoteDataSource ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/datasources/market_mood_local_ds.dart ======\n
// lib/data/datasources/market_mood_local_ds.dart
// ğŸ’¾ Data Layer: ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤ (Hive ê¸°ë°˜, DI íŒ¨í„´)

import 'package:hive_flutter/hive_flutter.dart';
import '../../core/services/hive_service.dart';
import '../../core/utils/logger.dart';
import '../models/market_mood_dto.dart'; // ğŸ”¥ TimestampedVolumeì´ ì—¬ê¸° ìˆìŒ

/// ğŸ’¾ ë§ˆì¼“ë¬´ë“œ ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤
/// HiveServiceë¥¼ í†µí•œ ë³¼ë¥¨ ë°ì´í„° ì €ì¥/ì¡°íšŒ, í™˜ìœ¨ ìºì‹± (DI íŒ¨í„´)
class MarketMoodLocalDataSource {
  final HiveService _hiveService;
  
  static const String _exchangeRateKey = 'exchange_rate';
  static const String _appStartTimeKey = 'app_start_time';

  MarketMoodLocalDataSource(this._hiveService);

  /// Volume Box ì ‘ê·¼
  Box<TimestampedVolume> get _volumeBox => _hiveService.marketMoodVolumeBox;
  
  /// Cache Box ì ‘ê·¼ 
  Box get _cacheBox => _hiveService.marketMoodCacheBox;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ ìŠ¬ë¡¯)
  Future<void> addVolumeData(TimestampedVolume volume) async {
    try {
      // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”ëœ í‚¤ ìƒì„±
      final slotKey = _getSlotKey(volume.timestamp);
      
      await _volumeBox.put(slotKey, volume);
      log.d('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥: $slotKey -> ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<TimestampedVolume?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final targetTime = DateTime.now().subtract(Duration(minutes: minutes));
      final slotKey = _getSlotKey(targetTime);
      
      final volume = _volumeBox.get(slotKey);
      if (volume != null) {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${volume.volumeUsd.toStringAsFixed(0)}B');
      } else {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì—†ìŒ');
      }
      
      return volume;
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days) async {
    try {
      final now = DateTime.now();
      final cutoffTime = now.subtract(Duration(days: days));
      
      final volumes = _volumeBox.values
          .where((volume) => volume.timestamp.isAfter(cutoffTime))
          .map((volume) => volume.volumeUsd)
          .toList();
      
      if (volumes.isEmpty) {
        log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ë°ì´í„° ì—†ìŒ');
        return null;
      }
      
      final average = volumes.reduce((a, b) => a + b) / volumes.length;
      log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ${average.toStringAsFixed(0)}B (${volumes.length}ê°œ ë°ì´í„°)');
      
      return average;
    } catch (e, st) {
      log.e('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ê³„ì‚° ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount() async {
    try {
      final count = _volumeBox.length;
      log.d('ğŸ“Š ì´ ë°ì´í„° ê°œìˆ˜: $count');
      return count;
    } catch (e, st) {
      log.e('ğŸ“Š ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return 0;
    }
  }

  /// ëˆ„ë½ëœ 30ë¶„ ìŠ¬ë¡¯ í™•ì¸ ë° ë³´ì •
  Future<void> checkAndFillMissingSlots() async {
    try {
      final appStartTime = getAppStartTime();
      final now = DateTime.now();
      final totalMinutes = now.difference(appStartTime).inMinutes;
      final expectedSlots = (totalMinutes / 30).floor();
      
      log.i('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬: ì˜ˆìƒ $expectedSlotsê°œ, ì‹¤ì œ ${_volumeBox.length}ê°œ');
      
      if (_volumeBox.length < expectedSlots) {
        final missing = expectedSlots - _volumeBox.length;
        log.w('âš ï¸ $missingê°œ ìŠ¬ë¡¯ ëˆ„ë½ ê°ì§€');
        // ì‹¤ì œ ë³´ì • ë¡œì§ì€ í•„ìš” ì‹œ êµ¬í˜„
      }
    } catch (e, st) {
      log.e('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬ ì‹¤íŒ¨', e, st);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’± í™˜ìœ¨ ìºì‹±
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í™˜ìœ¨ ìºì‹œ ì €ì¥
  Future<void> cacheExchangeRate(double rate) async {
    try {
      await _cacheBox.put(_exchangeRateKey, {
        'rate': rate,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });
      log.d('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ (12ì‹œê°„ ìœ íš¨)
  Future<double?> getCachedExchangeRate() async {
    try {
      final cached = _cacheBox.get(_exchangeRateKey);
      if (cached == null) return null;
      
      final timestamp = DateTime.fromMillisecondsSinceEpoch(cached['timestamp']);
      final rate = cached['rate'] as double;
      
      // 12ì‹œê°„ ì´ë‚´ì¸ì§€ í™•ì¸ (Providerì™€ ë™ì¼í•œ ìºì‹œ ì •ì±…)
      if (DateTime.now().difference(timestamp).inHours < 12) {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì‚¬ìš©: $rate KRW');
        return rate;
      } else {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ë§Œë£Œ');
        return null;
      }
    } catch (e, st) {
      log.e('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ•°ï¸ ì‹œê°„ ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime() {
    try {
      final cached = _cacheBox.get(_appStartTimeKey);
      if (cached != null) {
        return cached as DateTime;
      }
      
      // ìµœì´ˆ ì‹¤í–‰ ì‹œ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      final now = DateTime.now();
      _cacheBox.put(_appStartTimeKey, now);
      log.i('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì„¤ì •: ${now.toIso8601String()}');
      return now;
    } catch (e, st) {
      log.e('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return DateTime.now(); // fallback
    }
  }

  /// 30ë¶„ ìŠ¬ë¡¯ í‚¤ ìƒì„± (ì •ê·œí™”)
  String _getSlotKey(DateTime timestamp) {
    // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”: ì˜ˆ) 14:23 -> 14:00, 14:47 -> 14:30
    final normalized = DateTime(
      timestamp.year,
      timestamp.month,
      timestamp.day,
      timestamp.hour,
      (timestamp.minute ~/ 30) * 30, // 30ë¶„ ë‹¨ìœ„ë¡œ ë‚´ë¦¼
    );
    
    return normalized.toIso8601String();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë””ë²„ê¹…ìš© ì •ë³´ ë°˜í™˜
  Map<String, Object> getDebugInfo() {
    try {
      final volumeInfo = {
        'total_count': _volumeBox.length,
        'box_open': _volumeBox.isOpen,
        'first_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.first.timestamp.toIso8601String() 
            : 'none',
        'last_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.last.timestamp.toIso8601String() 
            : 'none',
      };
      
      final cacheInfo = {
        'cache_keys': _cacheBox.keys.toList(),
        'app_start_time': getAppStartTime().toIso8601String(),
        'has_exchange_rate': _cacheBox.containsKey(_exchangeRateKey),
        'box_open': _cacheBox.isOpen,
      };

      return {
        'volume_storage': volumeInfo,
        'cache_storage': cacheInfo,
        'hive_service': 'injected',
        'status': 'healthy',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  /// ìƒíƒœ ë¡œê¹…
  void logStatus() {
    final info = getDebugInfo();
    log.i('ğŸ’¾ MarketMoodLocalDataSource ìƒíƒœ: $info');
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    try {
      // HiveServiceê°€ Box ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì •ë¦¬ ì•ˆí•¨
      log.i('ğŸ§¹ MarketMoodLocalDataSource ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', e, st);
    }
  }

  /// ê°œë°œìš©: ëª¨ë“  ë°ì´í„° ì‚­ì œ
  Future<void> clearAllData() async {
    try {
      await _volumeBox.clear();
      await _cacheBox.clear();
      log.w('ğŸ—‘ï¸ ëª¨ë“  ë¡œì»¬ ë°ì´í„° ì‚­ì œ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ—‘ï¸ ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ê°œë°œìš©: ìµœê·¼ Nê°œ ë°ì´í„°ë§Œ ìœ ì§€
  Future<void> trimOldData({int keepCount = 100}) async {
    try {
      if (_volumeBox.length <= keepCount) return;

      final allEntries = _volumeBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp)); // ìµœì‹ ìˆœ

      final toKeep = allEntries.take(keepCount).toList();
      
      await _volumeBox.clear();
      for (final volume in toKeep) {
        await addVolumeData(volume);
      }
      
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬: ${allEntries.length} -> $keepCountê°œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/repositories/market_mood_repository_impl.dart ======\n
// lib/data/repositories/market_mood_repository_impl.dart
// ğŸ—ï¸ Data Layer: Repository êµ¬í˜„ì²´ (Domain ì¸í„°í˜ì´ìŠ¤ ì™„ì „ ë§¤ì¹­)

import 'dart:async';
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/repositories/market_mood_repository.dart';
import '../datasources/market_mood_local_ds.dart';
import '../datasources/market_mood_remote_ds.dart';
import '../models/market_mood_dto.dart';

/// ğŸ—ï¸ ë§ˆì¼“ë¬´ë“œ Repository êµ¬í˜„ì²´
/// Remote + Local DataSourceë¥¼ í†µí•©í•˜ì—¬ Domain Entityë¡œ ë³€í™˜í•˜ì—¬ ì œê³µ
class MarketMoodRepositoryImpl implements MarketMoodRepository {
  final MarketMoodRemoteDataSource _remoteDataSource;
  final MarketMoodLocalDataSource _localDataSource;

  // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ (ë¸Œë¡œë“œìºìŠ¤íŠ¸)
  StreamController<MarketMoodData>? _marketDataController;
  StreamSubscription? _remoteSubscription;

  MarketMoodRepositoryImpl(this._remoteDataSource, this._localDataSource);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸŒ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Stream<MarketMoodData> getMarketDataStream() {
    // ì´ë¯¸ í™œì„±í™”ëœ ìŠ¤íŠ¸ë¦¼ì´ ìˆìœ¼ë©´ ì¬ì‚¬ìš©
    if (_marketDataController != null && !_marketDataController!.isClosed) {
      return _marketDataController!.stream;
    }

    // ìƒˆë¡œìš´ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    _marketDataController = StreamController<MarketMoodData>.broadcast();

    // ì›ê²© ë°ì´í„° ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _remoteSubscription?.cancel(); // ê¸°ì¡´ êµ¬ë… ì •ë¦¬
    _remoteSubscription = _remoteDataSource.getGlobalMarketDataStream().listen(
      (globalData) async {
        try {
          // RemoteDSì—ì„œ ë°›ì€ CoinGeckoGlobalDataë¥¼ MarketMoodData Entityë¡œ ë³€í™˜
          final marketData = MarketMoodData(
            totalMarketCapUsd: globalData.totalMarketCapUsd,
            totalVolumeUsd: globalData.totalVolumeUsd,
            btcDominance: globalData.btcDominance,
            marketCapChange24h: globalData.marketCapChangePercentage24hUsd,
            updatedAt: DateTime.fromMillisecondsSinceEpoch(globalData.updatedAt * 1000),
          );
          
          // ë¡œì»¬ì— ë³¼ë¥¨ ë°ì´í„° ì €ì¥ (Entity -> DTO ë³€í™˜)
          final volumeDto = TimestampedVolume(
            timestamp: marketData.updatedAt,
            volumeUsd: marketData.totalVolumeUsd,
          );
          await _localDataSource.addVolumeData(volumeDto);
          
          // ìŠ¤íŠ¸ë¦¼ì— Domain Entity ì „ë‹¬
          if (_marketDataController != null && !_marketDataController!.isClosed) {
            _marketDataController!.add(marketData);
          }
          
          log.d('ğŸ“Š ë§ˆì¼“ ë°ì´í„° ì²˜ë¦¬ ì™„ë£Œ: ${marketData.totalVolumeUsd.toStringAsFixed(0)}B USD');
        } catch (e, st) {
          log.e('ğŸ“Š ë§ˆì¼“ ë°ì´í„° ì²˜ë¦¬ ì‹¤íŒ¨', e, st);
          if (_marketDataController != null && !_marketDataController!.isClosed) {
            _marketDataController!.addError(e, st);
          }
        }
      },
      onError: (error, stackTrace) {
        log.e('ğŸŒ ì›ê²© ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜', error, stackTrace);
        if (_marketDataController != null && !_marketDataController!.isClosed) {
          _marketDataController!.addError(error, stackTrace);
        }
      },
    );

    return _marketDataController!.stream;
  }

  @override
  Future<MarketMoodData?> getCurrentMarketData() async {
    try {
      final data = await _remoteDataSource.getGlobalMarketData();
      
      final marketData = MarketMoodData(
        totalMarketCapUsd: data.totalMarketCapUsd,
        totalVolumeUsd: data.totalVolumeUsd,
        btcDominance: data.btcDominance,
        marketCapChange24h: data.marketCapChangePercentage24hUsd,
        updatedAt: DateTime.fromMillisecondsSinceEpoch(data.updatedAt * 1000),
      );
      
      log.d('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì„±ê³µ');
      return marketData;
    } catch (e, st) {
      log.e('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double> getExchangeRate() async {
    try {
      // ë¡œì»¬ ìºì‹œ ë¨¼ì € í™•ì¸
      final cachedRate = await _localDataSource.getCachedExchangeRate();
      if (cachedRate != null) {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì‚¬ìš©: $cachedRate KRW');
        return cachedRate;
      }

      // ì›ê²©ì—ì„œ í™˜ìœ¨ ì¡°íšŒ
      final rate = await _remoteDataSource.getUsdToKrwRate();
      
      // ë¡œì»¬ì— ìºì‹œ ì €ì¥
      await _localDataSource.cacheExchangeRate(rate);
      
      log.d('ğŸ’± ì›ê²© í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate KRW');
      return rate;
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©', e, st);
      return 1400.0;
    }
  }

  @override
  Future<void> refreshExchangeRate() async {
    try {
      log.i('ğŸ’± í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
      
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      
      log.i('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (ë³¼ë¥¨ ë²„í¼) - Domain Entity ì‚¬ìš©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> addVolumeData(VolumeData volume) async {
    try {
      // Domain Entity -> Data DTO ë³€í™˜
      final volumeDto = TimestampedVolume.fromEntity(volume);
      await _localDataSource.addVolumeData(volumeDto);
      
      log.d('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ ì™„ë£Œ: ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final volumeDto = await _localDataSource.getVolumeNMinutesAgo(minutes);
      if (volumeDto == null) return null;
      
      // Data DTO -> Domain Entity ë³€í™˜
      final volumeEntity = volumeDto.toEntity();
      
      log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${volumeEntity.volumeUsd.toStringAsFixed(0)}B');
      return volumeEntity;
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double?> getAverageVolume(int days) async {
    try {
      final average = await _localDataSource.getAverageVolume(days);
      if (average != null) {
        log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${average.toStringAsFixed(0)}B');
      }
      return average;
    } catch (e, st) {
      log.e('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<int> getCollectedDataCount() async {
    try {
      final count = await _localDataSource.getCollectedDataCount();
      log.d('ğŸ“Š ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜: $count');
      return count;
    } catch (e, st) {
      log.e('ğŸ“Š ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return 0;
    }
  }

  @override
  DateTime getAppStartTime() {
    try {
      final startTime = _localDataSource.getAppStartTime();
      log.d('â° ì•± ì‹œì‘ ì‹œê°„: ${startTime.toIso8601String()}');
      return startTime;
    } catch (e, st) {
      log.e('â° ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return DateTime.now();
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> syncMissingData() async {
    try {
      log.i('ğŸ”„ ëˆ„ë½ ë°ì´í„° ë™ê¸°í™” ì‹œì‘');
      
      await _localDataSource.checkAndFillMissingSlots();
      
      log.i('ğŸ”„ ëˆ„ë½ ë°ì´í„° ë™ê¸°í™” ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ”„ ëˆ„ë½ ë°ì´í„° ë™ê¸°í™” ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<void> clearOldData() async {
    try {
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬ ì‹œì‘');
      
      // LocalDSì˜ trimOldData í™œìš©
      await _localDataSource.trimOldData(keepCount: 336); // 7ì¼ * 48ìŠ¬ë¡¯/ì¼
      
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    try {
      final localInfo = _localDataSource.getDebugInfo();
      final remoteHealth = await _remoteDataSource.checkApiHealth();
      final dataCount = await getCollectedDataCount();
      final appStartTime = getAppStartTime();
      final elapsedMinutes = DateTime.now().difference(appStartTime).inMinutes;

      return {
        'status': 'healthy',
        'local_storage': localInfo,
        'remote_api': {'healthy': remoteHealth, 'status': remoteHealth ? 'ok' : 'error'},
        'data_count': dataCount,
        'app_start_time': appStartTime.toIso8601String(),
        'elapsed_minutes': elapsedMinutes,
        'stream_active': _marketDataController != null && !_marketDataController!.isClosed,
        'subscription_active': _remoteSubscription != null,
        'last_check': DateTime.now().toIso8601String(),
      };
    } catch (e, st) {
      log.e('ğŸ” ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨', e, st);
      return {
        'status': 'error',
        'error': e.toString(),
        'last_check': DateTime.now().toIso8601String(),
      };
    }
  }

  @override
  Future<void> logCurrentStatus() async {
    try {
      final health = await getSystemHealth();
      _localDataSource.logStatus();
      log.i('ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì‹œìŠ¤í…œ ìƒíƒœ: $health');
    } catch (e, st) {
      log.e('ğŸ“Š ìƒíƒœ ë¡œê¹… ì‹¤íŒ¨', e, st);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> injectTestVolumeData(List<VolumeData> testData) async {
    if (testData.isEmpty) return;
    
    try {
      log.i('ğŸ§ª í…ŒìŠ¤íŠ¸ ë°ì´í„° ${testData.length}ê°œ ì£¼ì… ì‹œì‘');
      
      for (final volume in testData) {
        await addVolumeData(volume); // Domain Entity ì‚¬ìš©
      }
      
      log.i('ğŸ§ª í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì… ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§ª í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì… ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ì•± ì¢…ë£Œ ì‹œ í˜¸ì¶œ)
  Future<void> dispose() async {
    try {
      log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘');
      
      // ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì •ë¦¬
      await _remoteSubscription?.cancel();
      _remoteSubscription = null;
      
      // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
      if (_marketDataController != null && !_marketDataController!.isClosed) {
        await _marketDataController!.close();
      }
      _marketDataController = null;
      
      // DataSource ì •ë¦¬
      _remoteDataSource.dispose();
      await _localDataSource.dispose();
      
      log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', e, st);
    }
  }

  /// ê°œë°œìš©: ìŠ¤íŠ¸ë¦¼ ê°•ì œ ì¬ì‹œì‘
  Future<void> restartStream() async {
    try {
      log.i('ğŸ”„ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì¬ì‹œì‘');
      
      // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
      await _remoteSubscription?.cancel();
      if (_marketDataController != null && !_marketDataController!.isClosed) {
        await _marketDataController!.close();
      }
      
      // ìƒˆë¡œìš´ ìŠ¤íŠ¸ë¦¼ ì‹œì‘
      _marketDataController = null;
      getMarketDataStream(); // ìƒˆë¡œìš´ ìŠ¤íŠ¸ë¦¼ ìƒì„±
      
      log.i('ğŸ”„ ìŠ¤íŠ¸ë¦¼ ì¬ì‹œì‘ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ”„ ìŠ¤íŠ¸ë¦¼ ì¬ì‹œì‘ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/models/market_mood_model.dart ======\n
\n\n// ====== lib/data/models/market_mood_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'market_mood_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TimestampedVolumeAdapter extends TypeAdapter<TimestampedVolume> {
  @override
  final int typeId = 1;

  @override
  TimestampedVolume read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TimestampedVolume(
      timestamp: fields[0] as DateTime,
      volumeUsd: fields[1] as double,
    );
  }

  @override
  void write(BinaryWriter writer, TimestampedVolume obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.volumeUsd);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimestampedVolumeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalDataDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalDataDto> {
  @override
  final int typeId = 2;

  @override
  CoinGeckoGlobalDataDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalDataDto(
      totalMarketCapUsd: fields[0] as double,
      totalVolumeUsd: fields[1] as double,
      btcDominance: fields[2] as double,
      marketCapChangePercentage24hUsd: fields[3] as double,
      updatedAt: fields[4] as int,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalDataDto obj) {
    writer
      ..writeByte(5)
      ..writeByte(0)
      ..write(obj.totalMarketCapUsd)
      ..writeByte(1)
      ..write(obj.totalVolumeUsd)
      ..writeByte(2)
      ..write(obj.btcDominance)
      ..writeByte(3)
      ..write(obj.marketCapChangePercentage24hUsd)
      ..writeByte(4)
      ..write(obj.updatedAt);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalDataDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalResponseDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalResponseDto> {
  @override
  final int typeId = 3;

  @override
  CoinGeckoGlobalResponseDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalResponseDto(
      data: fields[0] as CoinGeckoGlobalDataDto,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalResponseDto obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.data);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalResponseDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/market_mood_dto.dart ======\n
// lib/data/models/market_mood_dto.dart
// ğŸŒ Data Layer: í†µí•© DTO ëª¨ë¸ (Trade ìŠ¤íƒ€ì¼)

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../core/utils/date_time.dart'; // DateTime extension
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';

part 'market_mood_dto.g.dart';

/// ğŸ“ˆ ì¸íŠ¸ë¼ë°ì´ ë³¼ë¥¨ ë°ì´í„° (30ë¶„ ë‹¨ìœ„) - Hive ëª¨ë¸
@HiveType(typeId: 1) // TradeDtoê°€ typeId: 0 ì‚¬ìš©í•˜ë¯€ë¡œ 1 ì‚¬ìš©
class TimestampedVolume extends HiveObject {
  @HiveField(0)
  final DateTime timestamp;

  @HiveField(1)
  final double volumeUsd;

  TimestampedVolume({
    required this.timestamp,
    required this.volumeUsd,
  });

  /// Domain Entityë¡œ ë³€í™˜
  VolumeData toEntity() => VolumeData(
    timestamp: timestamp,
    volumeUsd: volumeUsd,
  );

  /// Domain Entityì—ì„œ ìƒì„±
  factory TimestampedVolume.fromEntity(VolumeData entity) => TimestampedVolume(
    timestamp: entity.timestamp,
    volumeUsd: entity.volumeUsd,
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'timestamp': timestamp.toIso8601String(),
    'volumeUsd': volumeUsd,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹±
  static TimestampedVolume? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final timestampStr = m['timestamp']?.toString() ?? '';
      final volumeUsd = (m['volumeUsd'] as num?)?.toDouble() ?? 0.0;

      if (timestampStr.isEmpty) return null;

      return TimestampedVolume(
        timestamp: DateTime.parse(timestampStr),
        volumeUsd: volumeUsd,
      );
    } catch (e) {
      log.w('TimestampedVolume.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TimestampedVolume.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TimestampedVolume(
        timestamp: DateTime.now(),
        volumeUsd: 0.0,
      );

  /// DateTime extension í™œìš©
  String get formattedTime => timestamp.yyyyMMddhhmm();
  String get timeAgoText => timestamp.timeAgo();
  String get shortTime => timestamp.hhmmss();

  @override
  String toString() => 'TimestampedVolume($formattedTime, ${volumeUsd.toStringAsFixed(2)}B)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° DTO
@HiveType(typeId: 2)
class CoinGeckoGlobalDataDto extends HiveObject {
  @HiveField(0)
  final double totalMarketCapUsd;

  @HiveField(1)
  final double totalVolumeUsd;

  @HiveField(2)
  final double btcDominance;

  @HiveField(3)
  final double marketCapChangePercentage24hUsd;

  @HiveField(4)
  final int updatedAt;

  CoinGeckoGlobalDataDto({
    required this.totalMarketCapUsd,
    required this.totalVolumeUsd,
    required this.btcDominance,
    required this.marketCapChangePercentage24hUsd,
    required this.updatedAt,
  });

  /// Domain Entityë¡œ ë³€í™˜
  MarketMoodData toEntity() => MarketMoodData(
    totalMarketCapUsd: totalMarketCapUsd,
    totalVolumeUsd: totalVolumeUsd,
    btcDominance: btcDominance,
    marketCapChange24h: marketCapChangePercentage24hUsd,
    updatedAt: DateTime.fromMillisecondsSinceEpoch(updatedAt * 1000),
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'total_market_cap_usd': totalMarketCapUsd,
    'total_volume_usd': totalVolumeUsd,
    'btc_dominance': btcDominance,
    'market_cap_change_percentage_24h_usd': marketCapChangePercentage24hUsd,
    'updated_at': updatedAt,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (CoinGecko API ì‘ë‹µ í˜•íƒœ)
  static CoinGeckoGlobalDataDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch ~/ 1000
            : DateTime.now().millisecondsSinceEpoch ~/ 1000;
      }

      // CoinGecko API êµ¬ì¡°: nested maps
      final totalMarketCap = m['total_market_cap'] as Map<String, dynamic>?;
      final totalVolume = m['total_volume'] as Map<String, dynamic>?;
      final marketCapPercentage = m['market_cap_percentage'] as Map<String, dynamic>?;

      return CoinGeckoGlobalDataDto(
        totalMarketCapUsd: parseDouble(totalMarketCap?['usd']),
        totalVolumeUsd: parseDouble(totalVolume?['usd']),
        btcDominance: parseDouble(marketCapPercentage?['btc']),
        marketCapChangePercentage24hUsd: parseDouble(m['market_cap_change_percentage_24h_usd']),
        updatedAt: parseInt(m['updated_at']),
      );
    } catch (e) {
      log.w('CoinGeckoGlobalDataDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory CoinGeckoGlobalDataDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalDataDto(
        totalMarketCapUsd: 0.0,
        totalVolumeUsd: 0.0,
        btcDominance: 0.0,
        marketCapChangePercentage24hUsd: 0.0,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

  @override
  String toString() => 'CoinGeckoGlobalDataDto(volume: ${totalVolumeUsd.toStringAsFixed(0)}B USD)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ì‘ë‹µ ë˜í¼ DTO
@HiveType(typeId: 3)
class CoinGeckoGlobalResponseDto extends HiveObject {
  @HiveField(0)
  final CoinGeckoGlobalDataDto data;

  CoinGeckoGlobalResponseDto({
    required this.data,
  });

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'data': data.toMap(),
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹±
  static CoinGeckoGlobalResponseDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final dataMap = m['data'] as Map<String, dynamic>?;
      if (dataMap == null) return null;

      final data = CoinGeckoGlobalDataDto.tryParse(dataMap);
      if (data == null) return null;

      return CoinGeckoGlobalResponseDto(data: data);
    } catch (e) {
      log.w('CoinGeckoGlobalResponseDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory CoinGeckoGlobalResponseDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalResponseDto(
        data: CoinGeckoGlobalDataDto(
          totalMarketCapUsd: 0.0,
          totalVolumeUsd: 0.0,
          btcDominance: 0.0,
          marketCapChangePercentage24hUsd: 0.0,
          updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        ),
      );

  @override
  String toString() => 'CoinGeckoGlobalResponseDto(data: $data)';
}\n\n// ====== lib/domain/repositories/market_mood_repository.dart ======\n
// lib/domain/repositories/market_mood_repository.dart
// ğŸ¯ Domain Layer: Repository ì¸í„°í˜ì´ìŠ¤ (í´ë¦° ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)

import '../entities/market_mood.dart';

/// ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
/// Data Layerì—ì„œ êµ¬í˜„í•´ì•¼ í•  ê³„ì•½ì„ ì •ì˜ (Domain â†’ Data ì˜ì¡´ì„± ì œê±°)
abstract class MarketMoodRepository {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¡ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (30ë¶„ ì£¼ê¸°)
  Stream<MarketMoodData> getMarketDataStream();
  
  /// í˜„ì¬ ë§ˆì¼“ ë°ì´í„° í•œ ë²ˆ ì¡°íšŒ
  Future<MarketMoodData?> getCurrentMarketData();
  
  /// í˜„ì¬ USD/KRW í™˜ìœ¨ ì¡°íšŒ (ìºì‹œ í¬í•¨)
  Future<double> getExchangeRate();
  
  /// í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (Hive ë³¼ë¥¨ ë²„í¼)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ë§ˆë‹¤)
  Future<void> addVolumeData(VolumeData volume);
  
  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes);
  
  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days);
  
  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount();
  
  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ëˆ„ë½ëœ ìŠ¬ë¡¯ ë³´ì •
  Future<void> syncMissingData();
  
  /// ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
  Future<void> clearOldData();
  
  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth();
  
  /// í˜„ì¬ ìƒíƒœ ë¡œê¹…
  Future<void> logCurrentStatus();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì…
  Future<void> injectTestVolumeData(List<VolumeData> testData);
}\n\n// ====== lib/domain/usecases/market_mood_usecase.dart ======\n
// lib/domain/usecases/market_mood_usecase.dart
// ğŸ¯ Domain Layer: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ìˆœìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜)

import 'dart:math';
import '../entities/market_mood.dart';
import '../repositories/market_mood_repository.dart';

/// ğŸ’° ë§ˆì¼“ ë¬´ë“œ ê³„ì‚°ê¸° (ìˆœìˆ˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
class MarketMoodCalculator {
  static MarketMood calculateMoodByComparison(double current, double previous) {
    if (previous <= 0) return MarketMood.sideways;
    final changePercent = ((current - previous) / previous) * 100;
    
    if (changePercent >= 15) return MarketMood.bull;
    if (changePercent >= 5) return MarketMood.weakBull;
    if (changePercent >= -5) return MarketMood.sideways;
    if (changePercent >= -15) return MarketMood.bear;
    return MarketMood.deepBear;
  }

  static MarketMood calculateMoodByAbsolute(double volumeUsd) {
    if (volumeUsd >= 150e9) return MarketMood.bull;
    if (volumeUsd >= 100e9) return MarketMood.weakBull;
    if (volumeUsd >= 70e9) return MarketMood.sideways;
    if (volumeUsd >= 50e9) return MarketMood.bear;
    return MarketMood.deepBear;
  }
}

/// ğŸ§® ë³¼ë¥¨ ë¹„êµ ê³„ì‚°ê¸° (ìˆœìˆ˜ ê³„ì‚° ë¡œì§)
class VolumeComparator {
  final MarketMoodRepository _repository;

  VolumeComparator(this._repository);

  double _calculateChangePercent(double current, double previous) {
    if (previous <= 0) return 0.0;
    return ((current - previous) / previous) * 100;
  }

  /// ì§„í–‰ë¥  ê³„ì‚° (ì²« ì£¼ê¸°ëŠ” targetMinutes, ì´í›„ ìˆœí™˜)
  double _calculateProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    if (elapsed < targetMinutes) {
      return min(elapsed / targetMinutes, 1.0);
    }
    final cycleElapsed = (elapsed - targetMinutes) % targetMinutes;
    return cycleElapsed / targetMinutes;
  }

  /// ì¥ê¸° ë¹„êµ ì§„í–‰ë¥  ê³„ì‚°
  double _calculateLongTermProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    return min(elapsed / targetMinutes, 1.0);
  }

  Future<ComparisonResult> _compareGeneric({
    required double currentVolume,
    required int targetMinutes,
    required bool isLongTermAverage,
    required int daysForAverage,
  }) async {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;

    // ì¥ê¸° í‰ê·  ë¹„êµ(ì˜ˆ: 3ì¼, 7ì¼)
    if (isLongTermAverage) {
      if (elapsed < targetMinutes) {
        final prog = _calculateLongTermProgress(targetMinutes);
        return ComparisonResult.collecting(prog);
      }
      final average = await _repository.getAverageVolume(daysForAverage);
      if (average == null) {
        return ComparisonResult.unavailable('ìƒ˜í”Œ ë¶€ì¡±');
      }
      final change = _calculateChangePercent(currentVolume, average);
      return ComparisonResult.ready(change);
    }

    // ë‹¨ê¸° ë¹„êµ(ì˜ˆ: 30ë¶„, 1ì‹œê°„, 2ì‹œê°„, 4ì‹œê°„, 8ì‹œê°„, 12ì‹œê°„, 24ì‹œê°„)
    if (elapsed < targetMinutes * 1) {
      final prog = _calculateProgress(targetMinutes);
      return ComparisonResult.collecting(prog);
    }
    final past = await _repository.getVolumeNMinutesAgo(targetMinutes);
    if (past == null) {
      final prog = _calculateProgress(targetMinutes);
      return ComparisonResult.collecting(prog);
    }
    final change = _calculateChangePercent(currentVolume, past.volumeUsd);
    return ComparisonResult.ready(change);
  }

  Future<ComparisonResult> compare30Minutes(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 30,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare1Hour(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 60,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare2Hours(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 120,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare4Hours(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 240,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare8Hours(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 480,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare12Hours(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 720,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare24Hours(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 1440,
        isLongTermAverage: false,
        daysForAverage: 0,
      );

  Future<ComparisonResult> compare3DayAverage(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 4320, // 3ì¼ = 4320ë¶„
        isLongTermAverage: true,
        daysForAverage: 3,
      );

  Future<ComparisonResult> compareWeeklyAverage(double currentVolume) =>
      _compareGeneric(
        currentVolume: currentVolume,
        targetMinutes: 10080, // 7ì¼ = 10080ë¶„
        isLongTermAverage: true,
        daysForAverage: 7,
      );

  /// ì „ì²´ ë¹„êµ ë°ì´í„° ê³„ì‚°
  Future<ComparisonData> calculateAll(double currentVolume) async {
    return ComparisonData(
      thirtyMin: await compare30Minutes(currentVolume),
      oneHour: await compare1Hour(currentVolume),
      twoHour: await compare2Hours(currentVolume),
      fourHour: await compare4Hours(currentVolume),
      eightHour: await compare8Hours(currentVolume),
      twelveHour: await compare12Hours(currentVolume),
      twentyFourHour: await compare24Hours(currentVolume),
      threeDayAverage: await compare3DayAverage(currentVolume),
      weeklyAverage: await compareWeeklyAverage(currentVolume),
    );
  }
}

/// ğŸ¯ ë§ˆì¼“ë¬´ë“œ UseCase (ì „ì²´ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¡°í•©) - Providerì™€ ë§¤ì¹­
class MarketMoodUsecase {
  final MarketMoodRepository _repository;
  final VolumeComparator _comparator;

  MarketMoodUsecase(this._repository) : _comparator = VolumeComparator(_repository);

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (Providerì—ì„œ í˜¸ì¶œ)
  Future<void> addVolumeData(double volumeUsd) async {
    final volumeData = VolumeData(
      timestamp: DateTime.now(),
      volumeUsd: volumeUsd,
    );
    await _repository.addVolumeData(volumeData);
  }

  /// í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ê³„ì‚° (Providerì—ì„œ í˜¸ì¶œ)
  Future<MarketMood> calculateCurrentMood(double currentVolume) async {
    final thirtyMinAgo = await _repository.getVolumeNMinutesAgo(30);
    if (thirtyMinAgo != null) {
      return MarketMoodCalculator.calculateMoodByComparison(
        currentVolume, 
        thirtyMinAgo.volumeUsd
      );
    }
    return MarketMoodCalculator.calculateMoodByAbsolute(currentVolume);
  }

  /// ì „ì²´ ë³¼ë¥¨ ë¹„êµ ë°ì´í„° ê³„ì‚° (Providerì—ì„œ í˜¸ì¶œ)
  Future<ComparisonData> calculateVolumeComparison(double currentVolume) {
    return _comparator.calculateAll(currentVolume);
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ìƒì„±
  MarketMoodSystemState createSystemState({
    required MarketMoodData? marketData,
    required ComparisonData comparisonData,
    required MarketMood currentMood,
    required double exchangeRate,
    required bool isLoading,
    required bool hasError,
  }) {
    return MarketMoodSystemState(
      marketData: marketData,
      comparisonData: comparisonData,
      currentMood: currentMood,
      exchangeRate: exchangeRate,
      isLoading: isLoading,
      hasError: hasError,
    );
  }

  /// ë§ˆì¼“ë¬´ë“œ ìš”ì•½ ë¬¸ìì—´ ìƒì„±
  String generateMoodSummary(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull:
        return 'ğŸš€ ë¶ˆì¥';
      case MarketMood.weakBull:
        return 'ğŸ”¥ ì•½ë¶ˆì¥';
      case MarketMood.sideways:
        return 'âš–ï¸ ì¤‘ê°„ì¥';
      case MarketMood.bear:
        return 'ğŸ’§ ë¬¼ì¥';
      case MarketMood.deepBear:
        return 'ğŸ§Š ì–¼ìŒì¥';
    }
  }

  /// ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ë³´ì • ì‘ì—…
  Future<void> handleBackgroundResume() async {
    await _repository.syncMissingData();
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ
  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  /// ìƒíƒœ ë¡œê¹…
  Future<void> logSystemStatus() async {
    await _repository.logCurrentStatus();
  }

  /// ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ
  Future<int> getCollectedDataCount() async {
    return await _repository.getCollectedDataCount();
  }

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime() {
    return _repository.getAppStartTime();
  }

  /// í™˜ìœ¨ ì¡°íšŒ
  Future<double> getExchangeRate() async {
    return await _repository.getExchangeRate();
  }

  /// í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    await _repository.refreshExchangeRate();
  }
}\n\n// ====== lib/domain/entities/market_mood.dart ======\n
// lib/domain/entities/market_mood.dart
// ğŸ¯ Domain Layer: ìˆœìˆ˜ ì—”í‹°í‹°ë“¤ (VolumeData ì¶”ê°€)

import '../../core/utils/date_time.dart'; // DateTime extension

/// ğŸ•’ ë³¼ë¥¨ ê´€ë ¨ ìƒìˆ˜ ì •ì˜
class VolumeConstants {
 static const int minutesPerSlot = 30;
 static const int slotsPerHour = 60 ~/ minutesPerSlot; // 2
 static const int hoursPerDay = 24;
 static const int daysInBuffer = 7;
 static const int totalSlots = slotsPerHour * hoursPerDay * daysInBuffer; // 336
 static const int maxMinutesBuffer = minutesPerSlot * totalSlots; // 10080
 static const String volumeBoxName = 'market_volumes';
}

/// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° enum
enum MarketMood {
 bull,       // ğŸš€ ë¶ˆì¥
 weakBull,   // ğŸ”¥ ì•½ë¶ˆì¥
 sideways,   // âš–ï¸ ì¤‘ê°„ì¥
 bear,       // ğŸ’§ ë¬¼ì¥
 deepBear,   // ğŸ§Š ì–¼ìŒì¥
}

/// ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì—”í‹°í‹° (30ë¶„ ë‹¨ìœ„)
class VolumeData {
 final DateTime timestamp;
 final double volumeUsd;

 const VolumeData({
   required this.timestamp,
   required this.volumeUsd,
 });

 /// DateTime extension í™œìš©
 String get formattedTime => timestamp.yyyyMMddhhmm();
 String get timeAgoText => timestamp.timeAgo();
 String get shortTime => timestamp.hhmmss();

 /// JSON ì§ë ¬í™”
 Map<String, dynamic> toJson() => {
   'timestamp': timestamp.toIso8601String(),
   'volume_usd': volumeUsd,
 };

 factory VolumeData.fromJson(Map<String, dynamic> json) {
   return VolumeData(
     timestamp: DateTime.parse(json['timestamp']),
     volumeUsd: (json['volume_usd'] as num).toDouble(),
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is VolumeData &&
         runtimeType == other.runtimeType &&
         timestamp == other.timestamp &&
         volumeUsd == other.volumeUsd;

 @override
 int get hashCode => timestamp.hashCode ^ volumeUsd.hashCode;

 @override
 String toString() =>
     'VolumeData(${volumeUsd.toStringAsFixed(0)}B USD at ${timestamp.hhmmss()})';
}

/// ğŸ“Š ë§ˆì¼“ ë¬´ë“œ ë°ì´í„° ì—”í‹°í‹°
class MarketMoodData {
 final double totalMarketCapUsd;
 final double totalVolumeUsd;
 final double btcDominance;
 final double marketCapChange24h;
 final DateTime updatedAt;

 const MarketMoodData({
   required this.totalMarketCapUsd,
   required this.totalVolumeUsd,
   required this.btcDominance,
   required this.marketCapChange24h,
   required this.updatedAt,
 });

 /// JSON ì§ë ¬í™” (DTO í˜¸í™˜ìš©)
 Map<String, dynamic> toJson() => {
   'total_market_cap_usd': totalMarketCapUsd,
   'total_volume_usd': totalVolumeUsd,
   'btc_dominance': btcDominance,
   'market_cap_change_24h': marketCapChange24h,
   'updated_at': updatedAt.toIso8601String(),
 };

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodData &&
         runtimeType == other.runtimeType &&
         totalMarketCapUsd == other.totalMarketCapUsd &&
         totalVolumeUsd == other.totalVolumeUsd &&
         btcDominance == other.btcDominance &&
         marketCapChange24h == other.marketCapChange24h;

 @override
 int get hashCode =>
     totalMarketCapUsd.hashCode ^
     totalVolumeUsd.hashCode ^
     btcDominance.hashCode ^
     marketCapChange24h.hashCode;

 @override
 String toString() =>
     'MarketMoodData(volume: ${totalVolumeUsd.toStringAsFixed(0)}, '
     'cap: ${totalMarketCapUsd.toStringAsFixed(0)}, '
     'btc: ${btcDominance.toStringAsFixed(1)}%)';
}

/// ğŸ“Š ë¹„êµ ê²°ê³¼ ì—”í‹°í‹°
class ComparisonResult {
 final bool isReady;
 final double? changePercent;
 final double progressPercent;
 final String status;

 const ComparisonResult({
   required this.isReady,
   this.changePercent,
   required this.progressPercent,
   required this.status,
 });

 factory ComparisonResult.collecting(double progress) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: progress,
     status: 'ìˆ˜ì§‘ì¤‘',
   );
 }

 factory ComparisonResult.ready(double changePercent) {
   return ComparisonResult(
     isReady: true,
     changePercent: changePercent,
     progressPercent: 1.0,
     status: 'ì™„ë£Œ',
   );
 }

 factory ComparisonResult.unavailable(String message) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: 0.0,
     status: message,
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonResult &&
         runtimeType == other.runtimeType &&
         isReady == other.isReady &&
         changePercent == other.changePercent &&
         progressPercent == other.progressPercent &&
         status == other.status;

 @override
 int get hashCode =>
     isReady.hashCode ^
     changePercent.hashCode ^
     progressPercent.hashCode ^
     status.hashCode;

 @override
 String toString() =>
     'ComparisonResult(ready: $isReady, change: $changePercent%, progress: ${(progressPercent * 100).round()}%)';
}

/// ğŸ“ˆ ì „ì²´ ë¹„êµ ë°ì´í„° ì—”í‹°í‹°
class ComparisonData {
 final ComparisonResult thirtyMin;
 final ComparisonResult oneHour;
 final ComparisonResult twoHour;
 final ComparisonResult fourHour;
 final ComparisonResult eightHour;
 final ComparisonResult twelveHour;
 final ComparisonResult twentyFourHour;
 final ComparisonResult threeDayAverage;
 final ComparisonResult weeklyAverage;

 const ComparisonData({
   required this.thirtyMin,
   required this.oneHour,
   required this.twoHour,
   required this.fourHour,
   required this.eightHour,
   required this.twelveHour,
   required this.twentyFourHour,
   required this.threeDayAverage,
   required this.weeklyAverage,
 });

 factory ComparisonData.loading() {
   final loading = ComparisonResult.collecting(0.0);
   return ComparisonData(
     thirtyMin: loading,
     oneHour: loading,
     twoHour: loading,
     fourHour: loading,
     eightHour: loading,
     twelveHour: loading,
     twentyFourHour: loading,
     threeDayAverage: loading,
     weeklyAverage: loading,
   );
 }

 factory ComparisonData.error() {
   final error = ComparisonResult.unavailable('ì˜¤ë¥˜');
   return ComparisonData(
     thirtyMin: error,
     oneHour: error,
     twoHour: error,
     fourHour: error,
     eightHour: error,
     twelveHour: error,
     twentyFourHour: error,
     threeDayAverage: error,
     weeklyAverage: error,
   );
 }

 /// ëª¨ë“  ë¹„êµ ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜
 List<ComparisonResult> get allResults => [
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     ];

 /// ì¤€ë¹„ëœ ë¹„êµ ê²°ê³¼ ê°œìˆ˜
 int get readyCount => allResults.where((r) => r.isReady).length;

 /// ì „ì²´ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get overallProgress =>
     allResults.map((r) => r.progressPercent).reduce((a, b) => a + b) / 9;

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonData &&
         runtimeType == other.runtimeType &&
         thirtyMin == other.thirtyMin &&
         oneHour == other.oneHour &&
         twoHour == other.twoHour &&
         fourHour == other.fourHour &&
         eightHour == other.eightHour &&
         twelveHour == other.twelveHour &&
         twentyFourHour == other.twentyFourHour &&
         threeDayAverage == other.threeDayAverage &&
         weeklyAverage == other.weeklyAverage;

 @override
 int get hashCode => Object.hash(
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     );

 @override
 String toString() =>
     'ComparisonData(ready: $readyCount/9, progress: ${(overallProgress * 100).round()}%)';
}

/// ğŸ“¦ ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì—”í‹°í‹°
class MarketMoodSystemState {
 final MarketMoodData? marketData;
 final ComparisonData comparisonData;
 final MarketMood currentMood;
 final double exchangeRate;
 final bool isLoading;
 final bool hasError;

 const MarketMoodSystemState({
   required this.marketData,
   required this.comparisonData,
   required this.currentMood,
   required this.exchangeRate,
   required this.isLoading,
   required this.hasError,
 });

 /// ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸
 bool get isHealthy => !hasError && marketData != null;

 /// ë°ì´í„° ìˆ˜ì§‘ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get dataProgress => comparisonData.overallProgress;

 /// ìƒíƒœ ìš”ì•½ ë¬¸ìì—´
 String get statusSummary {
   if (hasError) return 'ì˜¤ë¥˜ ë°œìƒ';
   if (isLoading) return 'ë¡œë”© ì¤‘';
   if (marketData == null) return 'ë°ì´í„° ì—†ìŒ';
   return 'ì •ìƒ ì‘ë™';
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodSystemState &&
         runtimeType == other.runtimeType &&
         marketData == other.marketData &&
         comparisonData == other.comparisonData &&
         currentMood == other.currentMood &&
         exchangeRate == other.exchangeRate &&
         isLoading == other.isLoading &&
         hasError == other.hasError;

 @override
 int get hashCode => Object.hash(
       marketData,
       comparisonData,
       currentMood,
       exchangeRate,
       isLoading,
       hasError,
     );

 @override
 String toString() =>
     'MarketMoodSystemState(mood: $currentMood, status: $statusSummary, progress: ${(dataProgress * 100).round()}%)';
}\n\n// ====== lib/presentation/controllers/market_mood_controller.dart ======\n
// lib/presentation/controllers/market_mood_controller.dart
// ğŸ® Presentation Layer: Market Mood ì»¨íŠ¸ë¡¤ëŸ¬ (í´ë¦° ì•„í‚¤í…ì²˜ ë§ì¶¤)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/utils/date_time.dart';
import '../pages/market_mood_page.dart';

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬
class MarketMoodPageController extends StateNotifier<MarketMoodPageState> {
  final Ref _ref;

  MarketMoodPageController(this._ref) : super(MarketMoodPageState.initial()) {
    _init();
  }

  /// ì´ˆê¸°í™”
  void _init() {
    loadData();
  }

  /// ë°ì´í„° ë¡œë“œ (í´ë¦° ì•„í‚¤í…ì²˜ Provider ì‚¬ìš©)
  Future<void> loadData() async {
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      // AsyncValueì—ì„œ ê°’ ì§ì ‘ ì½ê¸°
      final systemStateAsync = _ref.read(marketMoodSystemProvider);
      
      systemStateAsync.when(
        data: (systemState) {
          state = state.copyWith(
            isLoading: false,
            systemState: systemState,
          );
        },
        loading: () {
          // ë¡œë”© ìƒíƒœ ìœ ì§€
        },
        error: (error, _) {
          state = state.copyWith(
            isLoading: false,
            error: error.toString(),
          );
        },
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  /// ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  Future<void> refresh() async {
    final controller = _ref.read(marketMoodControllerProvider);
    controller.refresh();
    await loadData();
  }

  /// í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ì¡°íšŒ (Future ëŒ€ì‘)
  Future<MarketMood> getCurrentMood() async {
    final moodAsync = _ref.read(currentMarketMoodProvider);
    return moodAsync.when(
      data: (mood) => mood,
      loading: () => MarketMood.sideways,
      error: (_, __) => MarketMood.sideways,
    );
  }

  /// í™˜ìœ¨ ì¡°íšŒ (Future ëŒ€ì‘)
  Future<double> getExchangeRate() async {
    final exchangeAsync = _ref.read(exchangeRateProvider);
    return exchangeAsync.when(
      data: (rate) => rate,
      loading: () => 1400.0,
      error: (_, __) => 1400.0,
    );
  }

  /// ë³¼ë¥¨ ë¹„êµ ë°ì´í„° ì¡°íšŒ (Future ëŒ€ì‘)
  Future<ComparisonData> getVolumeComparisons() async {
    final comparisonAsync = _ref.read(volumeComparisonProvider);
    return comparisonAsync.when(
      data: (data) => data,
      loading: () => ComparisonData.loading(),
      error: (_, __) => ComparisonData.error(),
    );
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<void> checkSystemHealth() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      final health = await controller.getSystemHealth();
      
      state = state.copyWith(
        systemHealth: health,
        lastHealthCheck: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.refreshExchangeRate();
      await loadData();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ë¡œê¹…
  Future<void> logSystemStatus() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.logSystemStatus();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ë¶„ìœ„ê¸° ì´ëª¨ì§€ ì¡°íšŒ
  String getMoodEmoji(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ğŸš€',
      MarketMood.weakBull => 'ğŸ”¥',
      MarketMood.sideways => 'âš–ï¸',
      MarketMood.bear => 'ğŸ’§',
      MarketMood.deepBear => 'ğŸ§Š',
    };
  }

  /// ë¶„ìœ„ê¸° ì´ë¦„ ì¡°íšŒ
  String getMoodName(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ë¶ˆì¥',
      MarketMood.weakBull => 'ì•½ë¶ˆì¥',
      MarketMood.sideways => 'ì¤‘ê°„ì¥',
      MarketMood.bear => 'ë¬¼ì¥',
      MarketMood.deepBear => 'ì–¼ìŒì¥',
    };
  }

  /// ë¶„ìœ„ê¸° ìš”ì•½ í…ìŠ¤íŠ¸ ì¡°íšŒ (Provider ì§ì ‘ ì‚¬ìš©)
  Future<String> getMoodSummary() async {
    final summaryAsync = _ref.read(marketMoodSummaryProvider);
    return summaryAsync.when(
      data: (summary) => summary,
      loading: () => 'ë¡œë”©ì¤‘...',
      error: (_, __) => 'ì˜¤ë¥˜',
    );
  }

  /// ë³¼ë¥¨ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatVolume(double volumeUsd) async {
    final rate = await getExchangeRate();
    final volumeKrw = volumeUsd * rate;
    
    if (volumeKrw >= 1e12) {
      final trillions = (volumeKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    if (volumeKrw >= 1e8) {
      final hundreds = (volumeKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    return '${(volumeKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì‹œê°€ì´ì•¡ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatMarketCap(double marketCapUsd) async {
    final rate = await getExchangeRate();
    final marketCapKrw = marketCapUsd * rate;
    
    if (marketCapKrw >= 1e12) {
      final trillions = (marketCapKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    if (marketCapKrw >= 1e8) {
      final hundreds = (marketCapKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    return '${(marketCapKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì—…ë°ì´íŠ¸ ì‹œê°„ í¬ë§·íŒ…
  String formatUpdateTime(DateTime updatedAt) {
    return updatedAt.hhmmss(); // DateTime extension ì‚¬ìš©
  }

  /// ë¹„êµ ê²°ê³¼ ê°’ í¬ë§·íŒ…
  String formatComparisonValue(ComparisonResult result) {
    if (result.isReady && result.changePercent != null) {
      final value = result.changePercent!;
      final arrow = value > 5 ? 'â†—ï¸' : value < -5 ? 'â†˜ï¸' : 'â¡ï¸';
      return '${value >= 0 ? '+' : ''}${value.toStringAsFixed(1)}% $arrow';
    }
    return '${(result.progressPercent * 100).round()}% (${result.status})';
  }

  /// ì§„í–‰ë¥  ê³„ì‚°
  int getProgressPercent(ComparisonResult result) {
    return (result.progressPercent * 100).round();
  }

  /// í•˜ì´ë¼ì´íŠ¸ ìƒ‰ìƒ íŒë‹¨
  bool isHighlight(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) > 5;
  }

  /// ê²½ê³  ìƒ‰ìƒ íŒë‹¨
  bool isWarning(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) < -5;
  }

  /// ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë‹ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
  void startListening() {
    // MarketMoodData ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë‹
    _ref.listen<AsyncValue<MarketMoodData>>(
      marketMoodProvider,
      (previous, next) {
        next.when(
          data: (data) {
            if (state.systemState?.marketData != data) {
              // ìƒˆë¡œìš´ ë°ì´í„° ê°ì§€ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
              loadData();
            }
          },
          loading: () {
            // ë¡œë”© ìƒíƒœ ì²˜ë¦¬
            state = state.copyWith(isLoading: true);
          },
          error: (error, _) {
            // ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
            state = state.copyWith(
              isLoading: false,
              error: error.toString(),
            );
          },
        );
      },
    );
  }

  /// ìˆ«ìì— ì½¤ë§ˆ ì¶”ê°€
  String _addCommas(String numberStr) {
    final parts = numberStr.split('.');
    final integerPart = parts[0];
    final reversedInteger = integerPart.split('').reversed.join('');
    final withCommas = reversedInteger
        .replaceAllMapped(RegExp(r'.{3}'), (match) => '${match.group(0)},')
        .split('')
        .reversed
        .join('');
    final result = withCommas.startsWith(',') ? withCommas.substring(1) : withCommas;
    return parts.length > 1 ? '$result.${parts[1]}' : result;
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ìƒíƒœ
class MarketMoodPageState {
  final bool isLoading;
  final String? error;
  final MarketMoodSystemState? systemState;
  final Map<String, dynamic>? systemHealth;
  final DateTime? lastHealthCheck;

  const MarketMoodPageState({
    required this.isLoading,
    this.error,
    this.systemState,
    this.systemHealth,
    this.lastHealthCheck,
  });

  factory MarketMoodPageState.initial() {
    return const MarketMoodPageState(isLoading: false);
  }

  MarketMoodPageState copyWith({
    bool? isLoading,
    String? error,
    MarketMoodSystemState? systemState,
    Map<String, dynamic>? systemHealth,
    DateTime? lastHealthCheck,
  }) {
    return MarketMoodPageState(
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      systemState: systemState ?? this.systemState,
      systemHealth: systemHealth ?? this.systemHealth,
      lastHealthCheck: lastHealthCheck ?? this.lastHealthCheck,
    );
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬ Provider
final marketMoodPageControllerProvider = 
    StateNotifierProvider.autoDispose<MarketMoodPageController, MarketMoodPageState>((ref) {
  final controller = MarketMoodPageController(ref);
  controller.startListening(); // ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë‹ ì‹œì‘
  return controller;
});

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ ê´€ë¦¬ì (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalManager {
  static OverlayEntry? _overlayEntry;

  /// ëª¨ë‹¬ í‘œì‹œ
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
    required MarketMoodData data,
  }) {
    hide(); // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°

    _overlayEntry = OverlayEntry(
      builder: (context) => MarketMoodModalOverlay(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
        data: data,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalOverlay extends StatelessWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;
  final MarketMoodData data;

  const MarketMoodModalOverlay({
    super.key,
    required this.position,
    required this.statusIconSize,
    required this.ref,
    required this.data,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => MarketMoodModalManager.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ MarketMoodPage ìœ„ì ¯
            Positioned(
              left: position.dx,
              top: position.dy,
              child: Consumer(
                builder: (context, ref, child) {
                  return MarketMoodPage(
                    statusIconSize: statusIconSize,
                    data: data,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/market_mood_page.dart ======\n
// lib/presentation/pages/market_mood_page.dart
// ğŸ“± Presentation Layer: Market Mood í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ, í´ë¦° ì•„í‚¤í…ì²˜)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../controllers/market_mood_controller.dart';

/// ğŸ“± ë§ˆì¼“ë¬´ë“œ ìƒì„¸ í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ)
class MarketMoodPage extends ConsumerStatefulWidget {
  final double statusIconSize;
  final MarketMoodData data;

  const MarketMoodPage({
    super.key,
    required this.statusIconSize,
    required this.data,
  });

  @override
  ConsumerState<MarketMoodPage> createState() => _MarketMoodPageState();
}

class _MarketMoodPageState extends ConsumerState<MarketMoodPage>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _animationController.forward();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.5),
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          alignment: Alignment.center,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildPageContent(),
          ),
        );
      },
    );
  }

  Widget _buildPageContent() {
    // í™”ë©´ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final maxWidth = screenSize.width * 0.9;

    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: widget.statusIconSize * 4.2,
          maxWidth: maxWidth,
        ),
        decoration: _buildContainerDecoration(),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              const SizedBox(height: 8),
              _buildCoreMetrics(),
              const SizedBox(height: 8),
              _buildIntradayAnalysis(),
              const SizedBox(height: 8),
              _buildLongTermAnalysis(),
            ],
          ),
        ),
      ),
    );
  }

  BoxDecoration _buildContainerDecoration() {
    return BoxDecoration(
      color: Theme.of(context).colorScheme.surface,
      borderRadius: BorderRadius.circular(16),
      boxShadow: [
        BoxShadow(
          color: Colors.black.withValues(alpha: 0.08),
          blurRadius: 16,
          offset: const Offset(0, 6),
          spreadRadius: 2,
        ),
        BoxShadow(
          color: Colors.black.withValues(alpha: 0.04),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
        width: 0.8,
      ),
    );
  }

  Widget _buildHeader() {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final updateTime = controller.formatUpdateTime(widget.data.updatedAt);

    return Consumer(
      builder: (context, ref, child) {
        // AsyncValue Providerë“¤ì„ watch
        final currentMoodAsync = ref.watch(currentMarketMoodProvider);

        return currentMoodAsync.when(
          data: (currentMood) {
            final moodEmoji = controller.getMoodEmoji(currentMood);
            final moodName = controller.getMoodName(currentMood);

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // ë©”ì¸ íƒ€ì´í‹€
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      moodEmoji,
                      style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '$moodName - 30ë¶„ ì „ ëŒ€ë¹„',
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w700,
                          color: Theme.of(context).colorScheme.onSurface,
                          letterSpacing: 0.3,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                // ì—…ë°ì´íŠ¸ ì‹œê°„
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 9,
                      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      'ì‹¤ì‹œê°„ ê¸°ì¤€ â€¢ ',
                      style: TextStyle(
                        fontSize: 8,
                        fontWeight: FontWeight.w500,
                        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                      ),
                    ),
                    Icon(
                      Icons.access_time,
                      size: 9,
                      color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                    const SizedBox(width: 3),
                    Flexible(
                      child: Text(
                        '$updateTime ì—…ë°ì´íŠ¸',
                        style: TextStyle(
                          fontSize: 8,
                          color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
          loading: () => _buildLoadingHeader(),
          error: (_, __) => _buildErrorHeader(),
        );
      },
    );
  }

  Widget _buildLoadingHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            const CircularProgressIndicator(strokeWidth: 2),
            const SizedBox(width: 8),
            Text(
              'ë¡œë”©ì¤‘...',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.onSurface,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildErrorHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 12,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 4),
            Text(
              'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCoreMetrics() {
    return Consumer(
      builder: (context, ref, child) {
        final exchangeAsync = ref.watch(exchangeRateProvider);

        return exchangeAsync.when(
          data: (exchangeRate) => _buildCoreMetricsContent(exchangeRate),
          loading: () => _buildLoadingMetrics(),
          error: (_, __) => _buildCoreMetricsContent(1400.0), // ê¸°ë³¸ê°’ ì‚¬ìš©
        );
      },
    );
  }

  Widget _buildCoreMetricsContent(double exchangeRate) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    return FutureBuilder<List<String>>(
      future: Future.wait([
        controller.formatVolume(widget.data.totalVolumeUsd),
        controller.formatMarketCap(widget.data.totalMarketCapUsd),
      ]),
      builder: (context, snapshot) {
        if (snapshot.hasData) {
          final values = snapshot.data!;
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
              const SizedBox(height: 4),
              _buildStatRow(
                icon: Icons.monetization_on,
                label: '24ì‹œê°„ ê±°ë˜ëŒ€ê¸ˆ',
                value: values[0],
                isHighlight: true,
              ),
              _buildStatRow(
                icon: Icons.pie_chart,
                label: 'ì´ ì‹œê°€ì´ì•¡',
                value: values[1],
              ),
              _buildStatRow(
                icon: Icons.trending_up,
                label: 'ì‹œì´ 24ì‹œê°„ ë³€í™”',
                value: '${widget.data.marketCapChange24h >= 0 ? '+' : ''}${widget.data.marketCapChange24h.toStringAsFixed(2)}%',
                isHighlight: widget.data.marketCapChange24h > 0,
                isWarning: widget.data.marketCapChange24h < -2,
              ),
              _buildStatRow(
                icon: Icons.flash_on,
                label: 'BTC ë„ë¯¸ë„ŒìŠ¤',
                value: '${widget.data.btcDominance.toStringAsFixed(1)}%',
              ),
            ],
          );
        }
        return _buildLoadingMetrics();
      },
    );
  }

  Widget _buildLoadingMetrics() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
        const SizedBox(height: 4),
        const CircularProgressIndicator(strokeWidth: 2),
      ],
    );
  }

  Widget _buildIntradayAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final comparisonAsync = ref.watch(volumeComparisonProvider);

        return comparisonAsync.when(
          data: (comparisonData) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
              const SizedBox(height: 4),
              _buildComparisonRow('30ë¶„ ëŒ€ë¹„', comparisonData.thirtyMin, Icons.schedule),
              _buildComparisonRow('1ì‹œê°„ ëŒ€ë¹„', comparisonData.oneHour, Icons.access_time),
              _buildComparisonRow('2ì‹œê°„ ëŒ€ë¹„', comparisonData.twoHour, Icons.timer),
              _buildComparisonRow('4ì‹œê°„ ëŒ€ë¹„', comparisonData.fourHour, Icons.timer_3),
              _buildComparisonRow('8ì‹œê°„ ëŒ€ë¹„', comparisonData.eightHour, Icons.timer_outlined),
              _buildComparisonRow('12ì‹œê°„ ëŒ€ë¹„', comparisonData.twelveHour, Icons.access_time_filled),
            ],
          ),
          loading: () => _buildLoadingSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
          error: (_, __) => _buildErrorSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
        );
      },
    );
  }

  Widget _buildLongTermAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final comparisonAsync = ref.watch(volumeComparisonProvider);

        return comparisonAsync.when(
          data: (comparisonData) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
              const SizedBox(height: 4),
              _buildComparisonRow('24ì‹œê°„ ëŒ€ë¹„', comparisonData.twentyFourHour, Icons.calendar_today),
              _buildComparisonRow('3ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.threeDayAverage, Icons.view_day),
              _buildComparisonRow('ì¼ì£¼ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.weeklyAverage, Icons.date_range),
            ],
          ),
          loading: () => _buildLoadingSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
          error: (_, __) => _buildErrorSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
        );
      },
    );
  }

  Widget _buildLoadingSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        const CircularProgressIndicator(strokeWidth: 2),
      ],
    );
  }

  Widget _buildErrorSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        Text(
          'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
          style: TextStyle(
            fontSize: 9,
            color: Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  Widget _buildComparisonRow(String label, ComparisonResult result, IconData icon) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    
    if (result.isReady && result.changePercent != null) {
      // ë°ì´í„° ì¤€ë¹„ë¨ - ì‹¤ì œ ë¹„êµ ê°’ í‘œì‹œ
      return _buildStatRow(
        icon: icon,
        label: label,
        value: controller.formatComparisonValue(result),
        isHighlight: controller.isHighlight(result),
        isWarning: controller.isWarning(result),
      );
    } else {
      // ë°ì´í„° ì¤€ë¹„ ì•ˆë¨ - í”„ë¡œê·¸ë ˆìŠ¤ ë°” í‘œì‹œ
      return _buildProgressRow(icon, label, result);
    }
  }

  Widget _buildProgressRow(IconData icon, String label, ComparisonResult result) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final progressPercent = controller.getProgressPercent(result);
    
    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
          ),
          const SizedBox(width: 5),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '$label: $progressPercent% (${result.status})',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.w500,
                    color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: result.progressPercent.clamp(0.0, 1.0),
                  backgroundColor: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                  valueColor: AlwaysStoppedAnimation(
                    result.progressPercent >= 1.0 
                      ? Colors.green
                      : Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
                  ),
                  minHeight: 3,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Colors.green;
      if (isWarning) return Colors.red;
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight
            ? Colors.green.withValues(alpha: 0.08)
            : isWarning
            ? Colors.red.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}