\n\n// ====== lib/core/di/sector_provider.dart ======\n
// lib/core/di/sector_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'volume_provider.dart' show volumeUsecaseProvider;
import 'trade_provider.dart' show marketsProvider;
import '../../domain/entities/volume.dart';
import '../../shared/widgets/sector_classification.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• SECTOR ì „ìš© Providerë“¤ (SectorClassificationProvider ì—°ë™)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ†• ì„¹í„° ë¶„ë¥˜ Provider (SectorClassificationProvider ì—°ë™)
final sectorClassificationProvider = ChangeNotifierProvider<SectorClassificationProvider>(
  (ref) => SectorClassificationProvider(),
);

/// ğŸ†• ì„¹í„° ì‹œê°„ëŒ€ ìƒíƒœ (ë³¼ë¥¨ê³¼ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬)
final sectorTimeFrameIndexProvider = StateProvider<int>((ref) => 0);

final sectorTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(sectorTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m';
});

/// ğŸ†• ì„¹í„°ë³„ ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (SectorClassificationProvider í™œìš©)
final sectorVolumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
  ref.keepAlive();

  try {
    final timeFrame = ref.watch(sectorTimeFrameProvider);
    final usecase = ref.read(volumeUsecaseProvider);
    
    // markets AsyncValue ì²˜ë¦¬
    final marketsAsync = ref.watch(marketsProvider);
    final markets = marketsAsync.when(
      data: (data) => data,
      loading: () => <String>[],
      error: (_, __) => <String>[],
    );

    if (markets.isEmpty) {
      yield <Volume>[];
      return;
    }

    if (AppConfig.enableTradeLog) {
      log.i('Sector volume stream started: $timeFrame, ${markets.length} markets');
    }

    // ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ ë³€í™˜
    yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (coinVolumes) {
          // SectorClassificationProviderì—ì„œ í˜„ì¬ ì„¹í„° ë§¤í•‘ ê°€ì ¸ì˜¤ê¸°
          final sectorProvider = ref.read(sectorClassificationProvider);
          final sectorMapping = sectorProvider.currentSectors;
          
          final sectorVolumes = _aggregateVolumesBySector(coinVolumes, sectorMapping);
          
          if (AppConfig.enableTradeLog) {
            log.d('Sector volumes aggregated: ${sectorVolumes.length} sectors from ${coinVolumes.length} coins');
          }
          
          return sectorVolumes;
        },
        err: (error) {
          log.e('Sector Volume error: ${error.message}');
          return <Volume>[];
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Sector volume stream error: $e', e, stackTrace);
    yield <Volume>[];
  }
});

/// ğŸ¯ í•µì‹¬ ë¡œì§: ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ í•©ì‚°
List<Volume> _aggregateVolumesBySector(List<Volume> coinVolumes, Map<String, List<String>> sectorMapping) {
  if (coinVolumes.isEmpty) return [];
  
  final Map<String, double> sectorVolumeMap = {};
  final sampleVolume = coinVolumes.first;
  
  // ê° ì½”ì¸ì„ í•´ë‹¹ ì„¹í„°ì— í•©ì‚°
  for (final coinVolume in coinVolumes) {
    final ticker = coinVolume.market.replaceFirst('KRW-', '');
    final sectors = _findSectorsForCoin(ticker, sectorMapping);
    
    for (final sector in sectors) {
      sectorVolumeMap[sector] = (sectorVolumeMap[sector] ?? 0.0) + coinVolume.totalVolume;
    }
  }
  
  // ë³¼ë¥¨ì´ 0ì¸ ì„¹í„° ì œê±°
  sectorVolumeMap.removeWhere((key, value) => value <= 0);
  
  // Volume ê°ì²´ë¡œ ë³€í™˜
  final sectorVolumes = sectorVolumeMap.entries
      .map((entry) => Volume(
            market: 'SECTOR-${entry.key}', // ì„¹í„° êµ¬ë¶„ìš© prefix
            totalVolume: entry.value,
            lastUpdatedMs: sampleVolume.lastUpdatedMs,
            timeFrame: sampleVolume.timeFrame,
            timeFrameStartMs: sampleVolume.timeFrameStartMs,
          ))
      .toList();
  
  // ë³¼ë¥¨ ìˆœ ì •ë ¬ (ë†’ì€ ìˆœ)
  sectorVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
  return sectorVolumes;
}

/// ğŸ¯ íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì°¾ê¸°
List<String> _findSectorsForCoin(String ticker, Map<String, List<String>> sectorMapping) {
  final sectors = <String>[];
  sectorMapping.forEach((sectorName, coins) {
    if (coins.contains(ticker)) {
      sectors.add(sectorName);
    }
  });
  return sectors;
}

/// ğŸ†• ì„¹í„° ì»¨íŠ¸ë¡¤ëŸ¬
final sectorTimeFrameController = Provider((ref) => SectorTimeFrameController(ref));

class SectorTimeFrameController {
  final Ref ref;
  SectorTimeFrameController(this.ref);

  /// ì‹œê°„ëŒ€ ë³€ê²½
  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid sector timeFrame index: $index');
      return;
    }
    
    ref.read(sectorTimeFrameProvider.notifier).state = timeFrame;
    ref.read(sectorTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Sector TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ğŸ†• ì„¹í„° ë¶„ë¥˜ í† ê¸€ (SectorClassificationProvider ì—°ë™)
  void toggleSectorClassification() {
    ref.read(sectorClassificationProvider.notifier).toggleClassificationType();
    
    if (AppConfig.enableTradeLog) {
      final currentName = ref.read(sectorClassificationProvider).currentClassificationName;
      log.i('Sector classification toggled: $currentName');
    }
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€ ì •ë³´
  String get currentTimeFrame => ref.read(sectorTimeFrameProvider);
  int get currentIndex => ref.read(sectorTimeFrameIndexProvider);
  
  /// í˜„ì¬ ì„¹í„° ë¶„ë¥˜ ì •ë³´ (SectorClassificationProvider ì—°ë™)
  bool get isDetailedClassification => ref.read(sectorClassificationProvider).isDetailedClassification;
  String get currentSectorClassificationName => ref.read(sectorClassificationProvider).currentClassificationName;
  int get totalSectors => ref.read(sectorClassificationProvider).currentSectors.length;
  
  /// ê¸°ë³¸ ì •ë³´
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }

  /// ğŸ†• ì„¹í„° ê´€ë ¨ ìœ í‹¸ë¦¬í‹° (SectorClassificationProvider ì—°ë™)
  Map<String, int> getSectorSizes() {
    return ref.read(sectorClassificationProvider).sectorSizes;
  }

  List<String> getCoinsInSector(String sectorName) {
    return ref.read(sectorClassificationProvider).getCoinsInSector(sectorName);
  }

  List<String> getSectorsForCoin(String ticker) {
    return ref.read(sectorClassificationProvider).getSectorsForCoin(ticker);
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (ë³¼ë¥¨ UseCase ì¬ì‚¬ìš©)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Sector volume reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(volumeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Sector volume reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get sector reset time failed: ${error.message}');
        return null;
      },
    );
  }
}\n\n// ====== lib/shared/widgets/sector_names.dart ======\n
// lib/shared/widgets/sector_names.dart
// ğŸ†• ì‹¤ì œ ì„¹í„° ë¶„ë¥˜ì— ë§ì¶˜ ë„¤ì´ë° ë§¤í•‘

import '../../domain/entities/app_settings.dart';

class SectorNames {
  // ğŸ¯ ìƒì„¸ ë¶„ë¥˜ (28ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘
  static const Map<String, Map<String, String>> detailedSectorNaming = {
    // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
    'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': {
      'ticker': 'BTC-GRP',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹',
      'english': 'Bitcoin Group',
    },
    'ì´ë”ë¦¬ì›€ ê·¸ë£¹': {
      'ticker': 'ETH-GRP',
      'korean': 'ì´ë”ë¦¬ì›€ ê·¸ë£¹',
      'english': 'Ethereum Group',
    },
    'ìŠ¤í…Œì´í‚¹': {
      'ticker': 'STAKE',
      'korean': 'ìŠ¤í…Œì´í‚¹',
      'english': 'Staking',
    },

    // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
    'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MONO',
      'korean': 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸',
      'english': 'Monolithic Blockchain',
    },
    'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MODU',
      'korean': 'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸',
      'english': 'Modular Blockchain',
    },

    // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
    'ìŠ¤í…Œì´ë¸” ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸” ì½”ì¸',
      'english': 'Stablecoin',
    },

    // ==================== DeFi ìƒíƒœê³„ ====================
    'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': {
      'ticker': 'DEX',
      'korean': 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°',
      'english': 'DEX/Aggregator',
    },
    'ëœë”©': {
      'ticker': 'LEND',
      'korean': 'ëœë”©',
      'english': 'Lending',
    },
    'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': {
      'ticker': 'LSTAKE',
      'korean': 'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹',
      'english': 'Liquid Staking/Restaking',
    },
    'RWA': {
      'ticker': 'RWA',
      'korean': 'RWA',
      'english': 'Real World Assets',
    },

    // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
    'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': {
      'ticker': 'PAY',
      'korean': 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼',
      'english': 'Payment Infrastructure',
    },
    'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': {
      'ticker': 'BRIDGE',
      'korean': 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€',
      'english': 'Interoperability/Bridge',
    },
    'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': {
      'ticker': 'ENTER',
      'korean': 'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸',
      'english': 'Enterprise Blockchain',
    },
    'ì˜¤ë¼í´': {
      'ticker': 'ORACLE',
      'korean': 'ì˜¤ë¼í´',
      'english': 'Oracle',
    },
    'ë°ì´í„° ì¸í”„ë¼': {
      'ticker': 'DATA',
      'korean': 'ë°ì´í„° ì¸í”„ë¼',
      'english': 'Data Infrastructure',
    },
    'ìŠ¤í† ë¦¬ì§€': {
      'ticker': 'STORAGE',
      'korean': 'ìŠ¤í† ë¦¬ì§€',
      'english': 'Storage',
    },
    'AI': {
      'ticker': 'AI',
      'korean': 'AI',
      'english': 'Artificial Intelligence',
    },

    // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
    'ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'META',
      'korean': 'ë©”íƒ€ë²„ìŠ¤',
      'english': 'Metaverse',
    },
    'NFT/ê²Œì„': {
      'ticker': 'NFT-GAME',
      'korean': 'NFT/ê²Œì„',
      'english': 'NFT/Gaming',
    },

    // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
    'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': {
      'ticker': 'MEDIA',
      'korean': 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°',
      'english': 'Media/Streaming',
    },
    'ê´‘ê³ ': {
      'ticker': 'AD',
      'korean': 'ê´‘ê³ ',
      'english': 'Advertising',
    },
    'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': {
      'ticker': 'EDU',
      'korean': 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ',
      'english': 'Education/Content',
    },

    // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
    'ì†Œì…œ/DAO': {
      'ticker': 'SOCIAL',
      'korean': 'ì†Œì…œ/DAO',
      'english': 'Social/DAO',
    },
    'íŒ¬í† í°': {
      'ticker': 'FAN',
      'korean': 'íŒ¬í† í°',
      'english': 'Fan Token',
    },
    'ë°ˆ': {
      'ticker': 'MEME',
      'korean': 'ë°ˆ',
      'english': 'Meme',
    },

    // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
    'DID': {
      'ticker': 'DID',
      'korean': 'DID',
      'english': 'Decentralized Identity',
    },
    'ì˜ë£Œ': {
      'ticker': 'MED',
      'korean': 'ì˜ë£Œ',
      'english': 'Medical',
    },
    'ì›”ë ›/ë©”ì„¸ì§•': {
      'ticker': 'WALLET',
      'korean': 'ì›”ë ›/ë©”ì„¸ì§•',
      'english': 'Wallet/Messaging',
    },
  };

  // ğŸ¯ ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘ - ğŸ†• ì‹ ê·œìƒì¥ 4ê°œ ì„¹í„° ì¶”ê°€
  static const Map<String, Map<String, String>> basicSectorNaming = {
    'ë©”ì´ì € ì½”ì¸': {
      'ticker': 'MAJOR',
      'korean': 'ë©”ì´ì € ì½”ì¸',
      'english': 'Major Coins',
    },
    'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': {
      'ticker': 'BTC-FAM',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´',
      'english': 'Bitcoin Family',
    },
    'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': {
      'ticker': 'ETH-ECO',
      'korean': 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„',
      'english': 'Ethereum Ecosystem',
    },
    'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': {
      'ticker': 'L1',
      'korean': 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸',
      'english': 'Layer 1 Blockchain',
    },
    'ê³  ì‹œì´': {
      'ticker': 'HIGH-CAP',
      'korean': 'ê³  ì‹œì´',
      'english': 'High Market Cap',
    },
    'ì¤‘ ì‹œì´': {
      'ticker': 'MID-CAP',
      'korean': 'ì¤‘ ì‹œì´',
      'english': 'Mid Market Cap',
    },
    'ì € ì‹œì´': {
      'ticker': 'LOW-CAP',
      'korean': 'ì € ì‹œì´',
      'english': 'Low Market Cap',
    },
    'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': {
      'ticker': 'MINOR-ALT',
      'korean': 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸',
      'english': 'Minor Altcoins',
    },
    'DeFi í† í°': {
      'ticker': 'DEFI',
      'korean': 'DeFi í† í°',
      'english': 'DeFi Tokens',
    },
    'ìŠ¤í…Œì´ë¸”ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸”ì½”ì¸',
      'english': 'Stablecoins',
    },
    'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'GAMING',
      'korean': 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤',
      'english': 'Gaming/NFT/Metaverse',
    },
    'í•œêµ­ í”„ë¡œì íŠ¸': {
      'ticker': 'KOREA',
      'korean': 'í•œêµ­ í”„ë¡œì íŠ¸',
      'english': 'Korean Projects',
    },
    'ì†”ë¼ë‚˜ ìƒíƒœê³„': {
      'ticker': 'SOL-ECO',
      'korean': 'ì†”ë¼ë‚˜ ìƒíƒœê³„',
      'english': 'Solana Ecosystem',
    },
    'AI/ê¸°ìˆ  í† í°': {
      'ticker': 'AI-TECH',
      'korean': 'AI/ê¸°ìˆ  í† í°',
      'english': 'AI/Tech Tokens',
    },

    // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
    '2023ë…„ ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-23',
      'korean': '2023ë…„ ì‹ ê·œìƒì¥',
      'english': '2023 New Listings',
    },
    '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H1',
      'korean': '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H1 New Listings',
    },
    '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H2',
      'korean': '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H2 New Listings',
    },
    '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-25H1',
      'korean': '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2025 H1 New Listings',
    },
  };

  /// ğŸ¯ ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ ë³€í™˜ (ê¸°ë³¸/ìƒì„¸ ë¶„ë¥˜ ìë™ ê°ì§€)
  static String getDisplayName(String sectorKey, DisplayMode displayMode, {bool isDetailed = false}) {
    // ì •ê·œí™” (ì…ë ¥ëœ ì„¹í„°ëª… ê·¸ëŒ€ë¡œ ë§¤í•‘ì—ì„œ ì°¾ê¸°)
    final normalizedKey = sectorKey.trim();
    
    // ìƒì„¸/ê¸°ë³¸ ë¶„ë¥˜ì— ë”°ë¼ ì ì ˆí•œ ë§¤í•‘ ì„ íƒ
    final sectorData = isDetailed 
        ? detailedSectorNaming[normalizedKey] 
        : basicSectorNaming[normalizedKey];
    
    // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ë‹¤ë¥¸ ë¶„ë¥˜ì—ì„œ ì°¾ê¸° ì‹œë„
    final fallbackData = isDetailed 
        ? basicSectorNaming[normalizedKey]
        : detailedSectorNaming[normalizedKey];
    
    final finalData = sectorData ?? fallbackData;
    
    if (finalData == null) {
      // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ì›ë³¸ ë°˜í™˜ (fallback)
      return sectorKey;
    }

    switch (displayMode) {
      case DisplayMode.ticker:
        return finalData['ticker'] ?? sectorKey;
      case DisplayMode.korean:
        return finalData['korean'] ?? sectorKey;
      case DisplayMode.english:
        return finalData['english'] ?? sectorKey;
    }
  }

  /// ğŸ”§ ëª¨ë“  ì„¹í„° í‚¤ ëª©ë¡ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static List<String> getAllSectorKeys({bool isDetailed = false}) {
    return isDetailed 
        ? detailedSectorNaming.keys.toList()
        : basicSectorNaming.keys.toList();
  }

  /// ğŸ”§ íŠ¹ì • ì„¹í„°ê°€ ë§¤í•‘ì— ìˆëŠ”ì§€ í™•ì¸
  static bool hasSector(String sectorKey, {bool isDetailed = false}) {
    final normalizedKey = sectorKey.trim();
    
    return isDetailed 
        ? detailedSectorNaming.containsKey(normalizedKey)
        : basicSectorNaming.containsKey(normalizedKey);
  }

  /// ğŸ”§ ë””ë²„ê¹…ìš© - ë§¤í•‘ë˜ì§€ ì•Šì€ ì„¹í„° ì°¾ê¸°
  static List<String> findUnmappedSectors(List<String> actualSectorKeys, {bool isDetailed = false}) {
    final unmapped = <String>[];
    
    for (final sectorKey in actualSectorKeys) {
      if (!hasSector(sectorKey, isDetailed: isDetailed)) {
        unmapped.add(sectorKey);
      }
    }
    
    return unmapped;
  }

  /// ğŸ”§ ì „ì²´ ë§¤í•‘ ì •ë³´ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static Map<String, Map<String, String>> getAllMappings({bool isDetailed = false}) {
    return isDetailed ? detailedSectorNaming : basicSectorNaming;
  }
}

// ğŸ†• SectorTileì—ì„œ ì‚¬ìš©í•  í—¬í¼ í™•ì¥
extension SectorDisplayExtension on String {
  /// ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ í‘œì‹œ
  String toDisplayName(DisplayMode displayMode, {bool isDetailed = false}) {
    return SectorNames.getDisplayName(this, displayMode, isDetailed: isDetailed);
  }
}\n\n// ====== lib/shared/widgets/sector_classification.dart ======\n
// lib/shared/widgets/sector_classification.dart

import 'package:flutter/foundation.dart';

/// ì„¹í„° ë¶„ë¥˜ ê´€ë¦¬ ì „ìš© Provider (ê³µìœ  ìœ„ì ¯ ë ˆì´ì–´)
/// ìƒì„¸(28ê°œ) vs ê¸°ë³¸(18ê°œ) ë¶„ë¥˜ í† ê¸€ ë° ë§¤í•‘ ë°ì´í„° ì œê³µ
class SectorClassificationProvider extends ChangeNotifier {
  // í˜„ì¬ ì„ íƒëœ ë¶„ë¥˜ íƒ€ì… (true: ìƒì„¸, false: ê¸°ë³¸)
  bool _isDetailedClassification = true;
  
  bool get isDetailedClassification => _isDetailedClassification;
  
  /// ë¶„ë¥˜ íƒ€ì… í† ê¸€
  void toggleClassificationType() {
    _isDetailedClassification = !_isDetailedClassification;
    notifyListeners();
  }
  
  /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„°ë³„ ì½”ì¸ ë§¤í•‘ (28ê°œ ì„¹í„°)
  static const Map<String, List<String>> _detailedSectors = {
    // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
    'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': ['BTC', 'BCH', 'BSV', 'XEC'],
    'ì´ë”ë¦¬ì›€ ê·¸ë£¹': ['ETH', 'ETC'],
    'ìŠ¤í…Œì´í‚¹': ['ETH', 'SOL', 'ADA', 'POL', 'ATOM'],

    // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
    'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': [
      'SOL', 'ADA', 'TRX', 'SUI', 'AVAX', 'NEAR', 'CRO', 'APT', 'ETC', 'VET',
      'ATOM', 'ALGO', 'INJ', 'EOS', 'SEI', 'IOTA', 'XTZ', 'FLOW', 'KAVA', 'EGLD',
      'NEO', 'MINA', 'BERA', 'ZIL', 'QTUM', 'ASTR', 'GAS', 'VTHO', 'VANA', 'ELF',
      'WAVES', 'ICX', 'ONT', 'HIVE', 'SXP', 'POWR', 'ARDR', 'XEM', 'IOST', 'ONG',
      'GLMR', 'ARK', 'AERGO', 'QKC', 'META', 'TT', 'FCT2'
    ],
    'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': [
      'ETH', 'DOT', 'MNT', 'POL', 'ARB', 'STX', 'SONIC', 'MOVE', 'CKB', 'CELO',
      'LSK', 'BLAST', 'TAIKO', 'MTL', 'TOKAMAK'
    ],

    // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
    'ìŠ¤í…Œì´ë¸” ì½”ì¸': ['USDT', 'USDC'],

    // ==================== DeFi ìƒíƒœê³„ ====================
    'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': [
      'UNI', 'JUP', 'DEEP', '1INCH', 'ZRX', 'ORCA', 'COW', 'ORBS', 'AUCTION', 'KNC'
    ],
    'ëœë”©': ['AAVE', 'COMP', 'STRIKE'],
    'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': ['PENDLE', 'JTO', 'LAYER'],
    'RWA': ['ONDO', 'CTC'],

    // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
    'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': ['BTC', 'XRP', 'BCH', 'XLM', 'BSV', 'XEC', 'PUNDIX', 'GRS'],
    'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': ['ZRO', 'W', 'T', 'ZETA', 'STG'],
    'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': ['HBAR', 'POLYX', 'STRAX'],
    'ì˜¤ë¼í´': ['LINK', 'PYTH'],
    'ë°ì´í„° ì¸í”„ë¼': ['GRT', 'KAITO', 'ANKR', 'ARKM', 'MVL', 'CARV'],
    'ìŠ¤í† ë¦¬ì§€': ['FIL', 'THETA', 'BTT', 'WAL', 'AKT', 'LPT', 'GLM', 'TFUEL', 'SC', 'STORJ'],
    'AI': ['VIRTUAL', 'RENDER', 'ATH'],

    // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
    'ë©”íƒ€ë²„ìŠ¤': ['SAND', 'MANA', 'MOCA', 'MOC'],
    'NFT/ê²Œì„': [
      'IMX', 'AXS', 'BEAM', 'BLUR', 'ENJ', 'GMT', 'ANIME', 'ME', 'BORA',
      'BIGTIME', 'WAXP', 'AGLD', 'GAME2', 'AQT'
    ],

    // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
    'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': ['MBL'],
    'ê´‘ê³ ': ['BAT', 'MLK', 'STMX'],
    'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': ['IQ', 'AHT'],

    // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
    'ì†Œì…œ/DAO': ['G', 'UXLINK', 'STEEM', 'CBK'],
    'íŒ¬í† í°': ['CHZ'],
    'ë°ˆ': ['DOGE', 'SHIB', 'PEPE', 'TRUMP', 'BONK', 'MEW'],

    // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
    'DID': ['ENS', 'ID', 'CVC'],
    'ì˜ë£Œ': ['MED'],
    'ì›”ë ›/ë©”ì„¸ì§•': ['SAFE', 'MASK', 'WCT', 'SNT'],
  };

  /// ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) - ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
  static const Map<String, List<String>> _basicSectors = {
    'ë©”ì´ì € ì½”ì¸': [
      'BTC', 'ETH', 'XRP', 'ADA', 'SOL', 'DOT', 'AVAX', 'MATIC', 'POL', 'NEAR',
      'ATOM', 'LINK', 'UNI', 'ALGO', 'VET', 'SAND', 'MANA', 'AXS', 'THETA',
      'FIL', 'AAVE', 'DOGE', 'SHIB', 'PEPE'
    ],
    'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': [
      'BTC', 'BCH', 'BSV', 'BTT', '1000SATS', 'ORDI'
    ],
    'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': [
      'ETH', 'ETC', 'ENS', 'LPT', 'COMP', 'MKR', 'YFI', 'SUSHI', 'BAL',
      '1INCH', 'LRC', 'ZRX', 'BAT', 'ENJ', 'CRV', 'SNX', 'MASK', 'BLUR', 'GRT'
    ],
    'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': [
      'EGLD', 'INJ', 'APT', 'SUI', 'ARB', 'OP', 'STX', 'TIA', 'SEI', 'PYTH',
      'JTO', 'JUP', 'TNSR', 'W', 'ENA', 'OMNI', 'REZ', 'BB', 'NOT', 'IO',
      'ZK', 'LISTA', 'ZRO', 'G', 'BANANA', 'RENDER', 'TON', 'NEO', 'GAS',
      'ONT', 'ONG', 'QTUM', 'WAVES', 'LSK', 'STRAX', 'ARK', 'STORJ', 'SC',
      'ARDR', 'KMD', 'ZEC', 'DASH', 'XMR', 'ICX', 'ZIL', 'IOTA', 'XTZ',
      'CELO', 'FLOW', 'MINA', 'HBAR', 'CKB', 'BEAM', 'ZETA', 'TAIKO', 'AERGO'
    ],
    
    // ğŸ†• ì‹œì´ë³„ ë¶„ë¥˜ (í™˜ìœ¨ 1,400ì› ì ìš© ê¸°ì¤€)
    'ê³  ì‹œì´': [
      'BTC', 'ETH', 'XRP', 'SOL', 'DOGE', 'AVAX', 'TRUMP'
    ],
    'ì¤‘ ì‹œì´': [
      'SUI', 'APT', 'NEAR', 'UNI', 'LINK', 'AAVE', 'INJ', 'STX', 'AXS', 'FIL',
      'ATOM', 'DOT', 'PENDLE', 'RENDER', 'GAS', 'ORCA', 'BERA', 'ZRO', 'TIA',
      'MASK', 'VIRTUAL', 'KAITO', 'QTUM', 'JTO', 'OM', 'ONDO', 'ME', 'LAYER',
      'AGLD', 'THETA', 'MTL', 'MNT', 'ADA', 'TAIKO', 'EOS', 'DRIFT', 'CTC',
      'XTZ', 'IMX', 'ARKM', 'SAFE', 'JUP', 'WAL', 'LSK', 'KAVA', 'COW',
      'UXLINK', 'ARK', 'FLOW', 'CARV', 'ARB', 'CELO', 'PUNDIX', 'KNC',
      'MANA', 'TRX', 'SAND', 'STORJ', 'XLM', 'HUNT', 'SONIC', 'GLM', 'ZRX',
      'HIVE', 'ZETA', 'MINA', 'POL', '1INCH', 'ALGO', 'SEI', 'STG', 'IOTA',
      'ID', 'SXP', 'HBAR', 'POWR', 'DEEP', 'MOVE', 'POLYX', 'STEEM', 'ONT',
      'BAT', 'CVC', 'AERGO', 'ICX', 'PYTH', 'CRO', 'GRT', 'BLUR', 'ARDR',
      'BORA', 'W', 'MOCA', 'BIGTIME', 'GMT', 'STRAX', 'CHZ', 'SNT', 'TFUEL',
      'JST', 'VET', 'ANIME', 'WAXP', 'ORBS', 'ANKR', 'T', 'G', 'ZIL', 'PENGU',
      'XEM', 'BEAM', 'CKB', 'IQ', 'AHT', 'IOST'
    ],
    'ì € ì‹œì´': [
      'GAME2', 'MVL', 'SC', 'MEW', 'BLAST', 'STMX', 'TT', 'MBL', 'VTHO', 'XEC',
      'BONK', 'SHIB', 'PEPE', 'BTT', 'CBK', 'MLK', 'POKT', 'SIGN', 'MOC',
      'SOPH', 'AWE', 'ATH', 'BOUNTY', 'HP', 'FCT2', 'ASTR', 'META', 'DKA',
      'QKC', 'MED'
    ],
    
    // ğŸ†• ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸ (ê¸°ì¡´ ì•ŒíŠ¸ì½”ì¸ ë³µì›)
    'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': [
      'LTC', 'EOS', 'TRX', 'XLM', 'STEEM', 'IOST', 'MTL', 'GRS', 'POWR',
      'XEM', 'XEC', 'VTHO', 'TFUEL', 'HIVE', 'CVC', 'SNT', 'SXP', 'T', 'PUNDIX'
    ],
    
    'DeFi í† í°': [
      'CAKE', 'RUNE', 'ALPHA', 'DODO', 'RAY', 'SRM', 'KNC', 'ANKR', 'CELR',
      'KAVA', 'HARD', 'SWP', 'JST', 'SUN', 'CRO', 'CHZ', 'GLM', 'AUCTION',
      'PENDLE', 'STG', 'COW', 'OM', 'ONDO', 'SAFE'
    ],
    'ìŠ¤í…Œì´ë¸”ì½”ì¸': [
      'USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDD'
    ],
    'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': [
      'GALA', 'APE', 'GMT', 'GST', 'LOOKS', 'PLA', 'WAXP', 'TLM', 'SLP',
      'IMX', 'BIGTIME', 'GAME2', 'AGLD', 'YGG', 'ME', 'VIRTUAL', 'MOCA',
      'PENGU', 'MEW', 'ANIME', 'FLOKI', 'BONK', 'WIF', 'BOME'
    ],
    'í•œêµ­ í”„ë¡œì íŠ¸': [
      'KLAY', 'BORA', 'META', 'WEMIX', 'MBL', 'HUNT', 'TEMCO', 'SOLVE',
      'PROM', 'ORBS', 'MIX', 'CENNZ', 'STPT', 'MDT', 'LAMB', 'COTI',
      'WTC', 'NPXS', 'APIS', 'DAC', 'ELF', 'KARMA', 'MEET', 'QKC',
      'SSX', 'UPP', 'TOKAMAK', 'MLK', 'DKA', 'CBK', 'MOC', 'HP',
      'BOUNTY', 'MED', 'MVL', 'ASTR', 'TT', 'MNT', 'FCT2', 'IQ',
      'AHT', 'AWE', 'ATH', 'SOPH', 'SIGN'
    ],
    'ì†”ë¼ë‚˜ ìƒíƒœê³„': [
      'SOL', 'ORCA', 'DRIFT', 'SONIC', 'LAYER', 'DEEP', 'MOVE'
    ],
    'AI/ê¸°ìˆ  í† í°': [
      'ARKM', 'KAITO', 'NXPC', 'WCT', 'AKT', 'AQT', 'CARV', 'UXLINK',
      'WAL', 'CTC', 'POLYX', 'ID', 'VANA', 'STRIKE', 'BERA', 'TRUMP',
      'POKT', 'STMX', 'BLAST'
    ],

    // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
    '2023ë…„ ì‹ ê·œìƒì¥': [
      'SHIB', 'MASK', 'EGLD', 'SUI', 'GRT', 'BLUR', 'IMX', 'SEI', 'MINA', 'CTC', 'ASTR'
    ],
    '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
      'ID', 'PYTH', 'MNT', 'BIGTIME', 'AKT', 'ZETA', 'STG', 'BEAM', 'TAIKO', 'ONDO', 'ZRO', 'BLAST'
    ],
    '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': [
      'JUP', 'ENS', 'GAL', 'PENDLE', 'ATH', 'UXLINK', 'CKB', 'W', 'CARV', 'INJ', 'MEW', 'UNI', 
      'SAFE', 'DRIFT', 'AGLD', 'PEPE', 'BONK', 'RENDER', 'MOVE', 'ME', 'MOCA', 'VANA'
    ],
    '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
      'SONIC', 'VTHO', 'ANIME', 'VIRTUAL', 'BERA', 'LAYER', 'TRUMP', 'JTO', 'COW', 'KAITO', 
      'ARKM', 'ORCA', 'WAL', 'COMP', 'FIL', 'WCT', 'DEEP', 'SIGN', 'TIA', 'PENGU', 
      'NXPC', 'OM', 'SOPH', 'LPT', 'POKT'
    ],
  };

  /// í˜„ì¬ í™œì„±í™”ëœ ì„¹í„° ë§¤í•‘ ë°˜í™˜
  Map<String, List<String>> get currentSectors {
    return _isDetailedClassification ? _detailedSectors : _basicSectors;
  }

  /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
  Map<String, List<String>> get detailedSectors => _detailedSectors;

  /// ê¸°ë³¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
  Map<String, List<String>> get basicSectors => _basicSectors;

  /// ì„¹í„° ëª©ë¡ ë°˜í™˜
  List<String> get sectorNames => currentSectors.keys.toList();

  /// íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ë°˜í™˜
  List<String> getCoinsInSector(String sectorName) {
    return currentSectors[sectorName] ?? [];
  }

  /// íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ë°˜í™˜
  List<String> getSectorsForCoin(String ticker) {
    List<String> sectors = [];
    currentSectors.forEach((sector, coins) {
      if (coins.contains(ticker.toUpperCase())) {
        sectors.add(sector);
      }
    });
    return sectors;
  }

  /// í˜„ì¬ ë¶„ë¥˜ íƒ€ì… ë¬¸ìì—´ ë°˜í™˜
  String get currentClassificationName {
    return _isDetailedClassification ? 'ìƒì„¸' : 'ê¸°ë³¸';
  }

  /// ì„¹í„°ë³„ í†µê³„ ì •ë³´
  Map<String, int> get sectorSizes {
    return currentSectors.map((sector, coins) => 
        MapEntry(sector, coins.length));
  }

  /// ì „ì²´ ê³ ìœ  ì½”ì¸ ê°œìˆ˜
  int get totalUniqueCoins {
    return currentSectors.values
        .expand((coins) => coins)
        .toSet()
        .length;
  }

  /// ì¤‘ë³µë„ê°€ ë†’ì€ ì½”ì¸ë“¤ (ì—¬ëŸ¬ ì„¹í„°ì— ì†í•œ ì½”ì¸ë“¤)
  Map<String, int> getCoinDuplicationCount() {
    Map<String, int> duplications = {};
    
    currentSectors.forEach((sector, coins) {
      for (String coin in coins) {
        duplications[coin] = (duplications[coin] ?? 0) + 1;
      }
    });
    
    return Map.fromEntries(
      duplications.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value))
    );
  }
}\n\n// ====== lib/presentation/controllers/sector_controller.dart ======\n
// lib/presentation/controllers/sector_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/sector_provider.dart';
import '../../domain/entities/volume.dart';

/// ì„¹í„° í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class SectorState {
  final List<Volume> sectorVolumes;
  final bool isLoading;
  final bool isDetailedClassification;
  final String timeFrame;
  final int selectedTimeFrameIndex;
  final String? errorMessage;

  const SectorState({
    this.sectorVolumes = const [],
    this.isLoading = false,
    this.isDetailedClassification = true,
    this.timeFrame = '1m',
    this.selectedTimeFrameIndex = 0,
    this.errorMessage,
  });

  SectorState copyWith({
    List<Volume>? sectorVolumes,
    bool? isLoading,
    bool? isDetailedClassification,
    String? timeFrame,
    int? selectedTimeFrameIndex,
    String? errorMessage,
  }) {
    return SectorState(
      sectorVolumes: sectorVolumes ?? this.sectorVolumes,
      isLoading: isLoading ?? this.isLoading,
      isDetailedClassification: isDetailedClassification ?? this.isDetailedClassification,
      timeFrame: timeFrame ?? this.timeFrame,
      selectedTimeFrameIndex: selectedTimeFrameIndex ?? this.selectedTimeFrameIndex,
      errorMessage: errorMessage,
    );
  }
}

/// Sector í™”ë©´ ì „ìš© ViewModel
class SectorController extends StateNotifier<SectorState> {
  final Ref _ref;
  ProviderSubscription<AsyncValue<List<Volume>>>? _subscription;

  SectorController(this._ref) : super(const SectorState()) {
    _initializeStream();
  }

  /// ì„¹í„° ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì´ˆê¸°í™”
  void _initializeStream() {
    _subscription?.close();
    
    final controller = _ref.read(sectorTimeFrameController);
    
    state = state.copyWith(
      isLoading: true,
      isDetailedClassification: controller.isDetailedClassification,
      timeFrame: controller.currentTimeFrame,
      selectedTimeFrameIndex: controller.currentIndex,
      errorMessage: null,
    );

    // AsyncValue ì§ì ‘ êµ¬ë…
    _subscription = _ref.listen(sectorVolumeDataProvider, (previous, next) {
      next.when(
        data: (volumes) {
          state = state.copyWith(
            sectorVolumes: volumes,
            isLoading: false,
            errorMessage: null,
          );
        },
        loading: () {
          state = state.copyWith(
            isLoading: true,
            errorMessage: null,
          );
        },
        error: (error, stackTrace) {
          state = state.copyWith(
            isLoading: false,
            errorMessage: error.toString(),
          );
        },
      );
    });
  }

  /// ì‹œê°„ëŒ€ ë³€ê²½
  void setTimeFrame(String timeFrame, int index) {
    final controller = _ref.read(sectorTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
    
    state = state.copyWith(
      timeFrame: timeFrame,
      selectedTimeFrameIndex: index,
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _initializeStream();
  }

  /// ì„¹í„° ë¶„ë¥˜ í† ê¸€ (ìƒì„¸ â†” ê¸°ë³¸)
  void toggleSectorClassification() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.toggleSectorClassification();
    
    state = state.copyWith(
      isDetailedClassification: !state.isDetailedClassification,
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë… (ìƒˆë¡œìš´ ë¶„ë¥˜ë¡œ)
    _initializeStream();
  }

  /// ìƒˆë¡œê³ ì¹¨
  void refresh() {
    _initializeStream();
  }

  /// ì„¹í„° ëª©ë¡ í•„í„°ë§ (ì„¹í„°ëª…ìœ¼ë¡œ)
  List<Volume> filterBySector(String? sectorFilter) {
    if (sectorFilter == null || sectorFilter.isEmpty) {
      return state.sectorVolumes;
    }
    final upper = sectorFilter.toUpperCase();
    return state.sectorVolumes.where((volume) {
      final sectorName = volume.market.replaceFirst('SECTOR-', '');
      return sectorName.contains(upper);
    }).toList();
  }

  /// ì„¹í„° ëª©ë¡ ì •ë ¬
  void sortSectors(String field, bool ascending) {
    final list = [...state.sectorVolumes];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'sector':
          aValue = a.market.replaceFirst('SECTOR-', '');
          bValue = b.market.replaceFirst('SECTOR-', '');
          break;
        case 'volume':
          aValue = a.totalVolume;
          bValue = b.totalVolume;
          break;
        case 'timestamp':
          aValue = a.lastUpdatedMs;
          bValue = b.lastUpdatedMs;
          break;
        default:
          aValue = a.totalVolume;
          bValue = b.totalVolume;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(sectorVolumes: list);
  }

  /// ì„¹í„° ë³¼ë¥¨ ë°ì´í„° ì •ë ¬ ì ìš© (ê¸°ë³¸: ë³¼ë¥¨ ë‚´ë¦¼ì°¨ìˆœ)
  List<Volume> applySorting(List<Volume> volumes) {
    final sorted = [...volumes];
    sorted.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    return sorted;
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetCurrentTimeFrame();
    refresh();
  }

  void resetAllTimeFrames() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetAllTimeFrames();
    refresh();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getNextResetTime();
  }

  /// ìœ í‹¸ë¦¬í‹° Getters
  List<String> get availableTimeFrames {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.availableTimeFrames;
  }

  String getTimeFrameName(String timeFrame) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getTimeFrameName(timeFrame);
  }

  String get currentSectorClassificationName {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.currentSectorClassificationName;
  }

  int get totalSectors {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.totalSectors;
  }

  /// íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ì¡°íšŒ
  List<String> getCoinsInSector(String sectorName) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getCoinsInSector(sectorName);
  }

  /// íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì¡°íšŒ
  List<String> getSectorsForCoin(String ticker) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getSectorsForCoin(ticker);
  }

  @override
  void dispose() {
    _subscription?.close();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final sectorControllerProvider =
    StateNotifierProvider<SectorController, SectorState>((ref) {
  return SectorController(ref);
});\n\n// ====== lib/presentation/pages/sector_page.dart ======\n
// lib/presentation/pages/sector_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/sector_provider.dart';
import '../../core/di/settings_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/volume.dart';
import '../controllers/sector_controller.dart';
import '../widgets/sector_tile.dart';

class SectorPage extends ConsumerWidget {
  final ScrollController scrollController;
  
  const SectorPage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) TimeFrame ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(sectorTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(sectorTimeFrameController);
    
    // 2) ì„¹í„° ìŠ¤íŠ¸ë¦¼
    final sectorsAsync = ref.watch(sectorVolumeDataProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬
    final uiController = ref.watch(sectorControllerProvider.notifier);
    
    // 4) ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(timeFrames, index, timeFrameCtrl, ref);
    
    // ì„¹í„° ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final sectorListWidget = _buildSectorList(sectorsAsync, uiController, scrollController, timeFrames, index, context);

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ì„¹í„° ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: sectorListWidget),
          
          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± (ì‹œê°„ëŒ€ ì„ íƒ + ğŸ†• í† ê¸€ + ì¹´ìš´íŠ¸ë‹¤ìš´)
  Widget _buildSliderWidget(List<String> timeFrames, int index, SectorTimeFrameController timeFrameCtrl, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì‹œê°„ëŒ€, í† ê¸€, ì¹´ìš´íŠ¸ë‹¤ìš´ì„ Rowë¡œ ë°°ì¹˜ (3ë“±ë¶„)
          Row(
            children: [
              // ì¢Œì¸¡: ì‹œê°„ëŒ€ (1/3 ì˜ì—­)
              Expanded(
                flex: 1,
                child: Text(
                  'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              
              // ğŸ†• ì¤‘ì•™: í† ê¸€ ë²„íŠ¼ (1/3 ì˜ì—­, ì •ì¤‘ì•™ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Center(
                  child: _buildClassificationToggle(timeFrameCtrl, ref),
                ),
              ),
              
              // ìš°ì¸¡: ì¹´ìš´íŠ¸ë‹¤ìš´ (1/3 ì˜ì—­, ìš°ì¸¡ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.centerRight,
                  child: _buildCountdownWidget(timeFrameCtrl),
                ),
              ),
            ],
          ),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (timeFrames.length - 1).toDouble(),
            divisions: timeFrames.length - 1,
            label: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
            onChanged: (v) {
              HapticFeedback.mediumImpact();
              final i = v.round();
              timeFrameCtrl.updateTimeFrame(timeFrames[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ì‘ì€ ë¶„ë¥˜ í† ê¸€ ë²„íŠ¼ (ìƒì„¸/ê¸°ë³¸)
  Widget _buildClassificationToggle(SectorTimeFrameController timeFrameCtrl, WidgetRef ref) {
    final isDetailed = timeFrameCtrl.isDetailedClassification;
    final currentName = timeFrameCtrl.currentSectorClassificationName;
    
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact(); // ğŸ¯ light haptic ì¶”ê°€
        timeFrameCtrl.toggleSectorClassification();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: isDetailed ? Colors.orange : Colors.transparent, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ íˆ¬ëª…
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange, // ğŸ¯ ë‘˜ ë‹¤ ì£¼í™© í…Œë‘ë¦¬
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              isDetailed ? Icons.view_module : Icons.view_list,
              size: 14,
              color: isDetailed ? Colors.white : Colors.orange, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ ì£¼í™© ì•„ì´ì½˜
            ),
            const SizedBox(width: 4),
            Text(
              currentName,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isDetailed ? Colors.white : Colors.orange, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ ì£¼í™© í…ìŠ¤íŠ¸
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ì¹´ìš´íŠ¸ë‹¤ìš´ ìœ„ì ¯ ìƒì„±
  Widget _buildCountdownWidget(SectorTimeFrameController timeFrameCtrl) {
    final nextResetTime = timeFrameCtrl.getNextResetTime();
    
    if (nextResetTime == null) {
      return const Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.grey),
          SizedBox(width: 4),
          Text(
            '--:--',
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final now = DateTime.now();
    final remaining = nextResetTime.difference(now);
    
    if (remaining.isNegative) {
      return const Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.orange),
          SizedBox(width: 4),
          Text(
            '00:00',
            style: TextStyle(
              fontSize: 14,
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final minutes = remaining.inMinutes;
    final seconds = remaining.inSeconds % 60;
    final minutesStr = minutes.toString().padLeft(2, '0');
    final secondsStr = seconds.toString().padLeft(2, '0');
    
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.access_time, size: 16, color: Colors.orange),
        const SizedBox(width: 4),
        Container(
          width: 52, // ğŸ¯ 48 â†’ 52ë¡œ 4px ë” ë„“íˆê¸° (6ìë¦¬ ëŒ€ì‘)
          alignment: Alignment.center,
          child: Text(
            '$minutesStr:$secondsStr',
            style: const TextStyle(
              fontSize: 12, // ğŸ¯ 13 â†’ 12ë¡œ ë” ì¤„ì´ê¸°
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ],
    );
  }

  /// ì„¹í„° ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
  Widget _buildSectorList(
    AsyncValue<List<Volume>> sectorsAsync, 
    SectorController uiController, 
    ScrollController scrollController,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    return sectorsAsync.when(
      data: (sectorVolumes) {
        // List<Volume>ì„ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        final sortedSectors = uiController.applySorting(sectorVolumes);
        
        if (sortedSectors.isEmpty) {
          return Center(
            child: Text(
              'ì„¹í„° ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: true,
          trackVisibility: true,
          thickness: 8,
          radius: const Radius.circular(4),
          thumbColor: Colors.orange.withValues(alpha: 0.5),
          trackColor: Colors.transparent,
          interactive: true,
          minThumbLength: 50,
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 24, top: 16, bottom: 16),
            itemCount: sortedSectors.length,
            itemBuilder: (_, i) => SectorTile(
              sectorName: sortedSectors[i].market.replaceFirst('SECTOR-', ''),
              totalVolume: sortedSectors[i].totalVolume,
              rank: i + 1,
              timeFrame: sortedSectors[i].timeFrame,
              lastUpdated: sortedSectors[i].lastUpdated,
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ì„¹í„° ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/widgets/sector_tile.dart ======\n
// lib/presentation/widgets/sector_tile.dart (ìˆ˜ì •ë¨)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart'; // ğŸ†• sectorClassificationProvider ì¶”ê°€
import '../../shared/widgets/sector_names.dart'; // ğŸ†• ì„¹í„° ë„¤ì´ë° ì¶”ê°€

// ğŸ¯ ìˆœìœ„ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (ì„¹í„°ë³„ ì´ì „ ìˆœìœ„ ì €ì¥)
final Map<String, int> _previousSectorRanks = {};

class SectorTile extends ConsumerStatefulWidget {
  final String sectorName; // ì„¹í„°ëª… (ì˜ˆ: "ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸")
  final double totalVolume; // ì„¹í„°ë³„ ì´ ê±°ë˜ëŒ€ê¸ˆ
  final int rank; // ğŸ¯ ìˆœìœ„ (1ìœ„ë¶€í„°)
  final String timeFrame; // ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m")
  final DateTime lastUpdated; // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
  final bool showHotIcon; // ğŸš€ ê¸‰ìƒìŠ¹ í‘œì‹œ ì—¬ë¶€
  final bool enableBlinkAnimation; // ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ ì—¬ë¶€
  
  const SectorTile({
    Key? key, 
    required this.sectorName,
    required this.totalVolume,
    required this.rank,
    required this.timeFrame,
    required this.lastUpdated,
    this.showHotIcon = false,
    this.enableBlinkAnimation = false,
  }) : super(key: key);

  @override
  ConsumerState<SectorTile> createState() => _SectorTileState();
}

class _SectorTileState extends ConsumerState<SectorTile> 
    with SingleTickerProviderStateMixin {
  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SectorTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    _checkRankChange();
  }

  void _checkRankChange() {
    final previousRank = _previousSectorRanks[widget.sectorName];
    final currentRank = widget.rank;
    
    // ì´ì „ ìˆœìœ„ê°€ ìˆê³ , ìˆœìœ„ê°€ ì˜¬ë¼ê°„ ê²½ìš°ì—ë§Œ ë°˜ì§
    if (previousRank != null && currentRank < previousRank) {
      _shouldBlink = true;
      _blinkController.forward().then((_) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _shouldBlink = false;
            });
          }
        });
      });
    }
    
    // í˜„ì¬ ìˆœìœ„ë¥¼ ì €ì¥
    _previousSectorRanks[widget.sectorName] = currentRank;
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  // ğŸ†• ì„¹í„°ëª… í‘œì‹œ ë¡œì§ (ì„¤ì •ì— ë”°ë¼ ë™ì  ë³€ê²½)
  String _getDisplaySectorName() {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    
    // ğŸ¯ ì‹¤ì œ ìƒì„¸/ê¸°ë³¸ ë¶„ë¥˜ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°!
    final isDetailed = ref.watch(sectorClassificationProvider).isDetailedClassification;
    
    return SectorNames.getDisplayName(widget.sectorName, displayMode, isDetailed: isDetailed);
  }

  // ğŸ¯ ê±°ë˜ëŸ‰ í¬ë§·íŒ… (ìƒˆë¡œìš´ í†µí•© ê·œì¹™)
  String _formatVolume(double totalVolume) {
    if (totalVolume < 0) return '0ì›';
    
    final decimalFormat = NumberFormat('#,##0.##'); // ì†Œìˆ˜ì  2ìë¦¬
    final integerFormat = NumberFormat('#,###'); // ì •ìˆ˜ìš© ì½¤ë§ˆ
    
    // 1ë§Œì› ë¯¸ë§Œ: 1ì› ~ 9,999ì› (ì½¤ë§ˆ í¬í•¨)
    if (totalVolume < 10000) {
      return '${integerFormat.format(totalVolume.toInt())}ì›';
    }
    // 1ë§Œì› ~ 9999ë§Œì›: x,xxxë§Œì› (ì½¤ë§ˆ í¬í•¨)
    else if (totalVolume < 100000000) {
      final man = (totalVolume / 10000).toInt();
      return '${integerFormat.format(man)}ë§Œì›';
    }
    // 1ì–µ ~ 9999ì–µ: x.xxì–µì› (ì†Œìˆ˜ì  2ìë¦¬)
    else if (totalVolume < 1000000000000) {
      final eok = totalVolume / 100000000;
      return '${decimalFormat.format(eok)}ì–µì›';
    }
    // 1ì¡° ~ 9999ì¡°: x.xxì¡°ì› (ì†Œìˆ˜ì  2ìë¦¬)
    else if (totalVolume < 10000000000000000) {
      final jo = totalVolume / 1000000000000;
      return '${decimalFormat.format(jo)}ì¡°ì›';
    }
    // 1ê²½ ì´ìƒ: x,xxxê²½ì› (ì½¤ë§ˆ í¬í•¨)
    else {
      final gyeong = (totalVolume / 10000000000000000).toInt();
      return '${integerFormat.format(gyeong)}ê²½ì›';
    }
  }

  // ğŸ¯ ìˆœìœ„ì— ë”°ë¥¸ ìƒ‰ìƒ
  Color _getRankColor(BuildContext context) {
    final theme = Theme.of(context);
    switch (widget.rank) {
      case 1:
        return Colors.amber; // ğŸ¥‡ 1ìœ„ - ê¸ˆìƒ‰
      case 2:
        return Colors.grey.shade400; // ğŸ¥ˆ 2ìœ„ - ì€ìƒ‰
      case 3:
        return Colors.orange.shade300; // ğŸ¥‰ 3ìœ„ - ë™ìƒ‰
      default:
        return theme.colorScheme.onSurface.withValues(alpha: 0.6); // ê¸°ë³¸
    }
  }

  // ğŸ¯ ìˆœìœ„ ì•„ì´ì½˜
  Widget _buildRankWidget(BuildContext context) {
    final rankColor = _getRankColor(context);
    final isTopThree = widget.rank <= 3;
    
    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: isTopThree ? rankColor.withValues(alpha: 0.2) : Colors.transparent,
        border: isTopThree ? Border.all(color: rankColor, width: 2) : null,
      ),
      child: Center(
        child: Text(
          '${widget.rank}',
          style: TextStyle(
            fontSize: 14,
            fontWeight: isTopThree ? FontWeight.bold : FontWeight.normal,
            color: rankColor,
          ),
        ),
      ),
    );
  }

  // ğŸ¯ ì„¹í„° ì•„ì´ì½˜/ì´ëª¨ì§€ (ë‚˜ì¤‘ì— ì»¤ìŠ¤í…€ ì•„ì´ì½˜ìœ¼ë¡œ ëŒ€ì²´ ì˜ˆì •)
  Widget _buildSectorIcon() {
    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: Colors.blue.withValues(alpha: 0.1),
        border: Border.all(color: Colors.blue.withValues(alpha: 0.3), width: 1),
      ),
      child: const Center(
        child: Text(
          'ğŸ“Š', // ì„ì‹œ ì´ëª¨ì§€ (ë‚˜ì¤‘ì— ì„¹í„°ë³„ ì»¤ìŠ¤í…€ ì•„ì´ì½˜ìœ¼ë¡œ)
          style: TextStyle(fontSize: 16),
        ),
      ),
    );
  }

  // ğŸ¯ HOT ì•„ì´ì½˜ (ê¸‰ìƒìŠ¹ ì‹œ)
  Widget? _buildHotIcon() {
    if (!widget.showHotIcon) return null;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: Colors.red,
        borderRadius: BorderRadius.circular(8),
      ),
      child: const Text(
        'ğŸš€ HOT',
        style: TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // ğŸ¯ ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ (ì„¤ì •ì— ë”°ë¼)
    Widget cardWidget = Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          children: [
            // ğŸ† ìˆœìœ„ ë¶€ë¶„: ê³ ì • í¬ê¸°
            _buildRankWidget(context),
            
            const SizedBox(width: 12),
            
            // ğŸ¨ ì„¹í„° ì•„ì´ì½˜ ë¶€ë¶„ (ë‚˜ì¤‘ì— ì»¤ìŠ¤í…€ ì•„ì´ì½˜ìœ¼ë¡œ ëŒ€ì²´)
            _buildSectorIcon(),
            
            const SizedBox(width: 12),
            
            // ğŸ“± ì„¹í„°ëª… ë¶€ë¶„: flex 25 (í™•ì¥ ê°€ëŠ¥) - ğŸ†• ë™ì  í‘œì‹œ ì ìš©!
            Expanded(
              flex: 25,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          _getDisplaySectorName(), // ğŸ†• ì„¤ì •ì— ë”°ë¼ ë™ì  í‘œì‹œ!
                          style: TextStyle(
                            fontWeight: FontWeight.bold,
                            color: theme.colorScheme.primary,
                            fontSize: 16,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        ),
                      ),
                      const SizedBox(width: 4),
                      // ğŸš€ HOT ì•„ì´ì½˜
                      if (_buildHotIcon() != null) _buildHotIcon()!,
                    ],
                  ),
                  const SizedBox(height: 2),
                  // ğŸ¯ ìƒì„¸ ì„¤ëª… ê³µê°„ (ì¼ë‹¨ ë¹„ì›Œë‘  - ë‚˜ì¤‘ì— ì„¹í„° ì„¤ëª… ì¶”ê°€)
                  Text(
                    '', // ë‚˜ì¤‘ì— ì„¹í„° ìƒì„¸ ì„¤ëª… ì¶”ê°€ ì˜ˆì •
                    style: TextStyle(
                      color: onSurface70,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            
            // ğŸ’° ê±°ë˜ëŒ€ê¸ˆ ë¶€ë¶„: flex 30
            Expanded(
              flex: 30,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    _formatVolume(widget.totalVolume),
                    style: TextStyle(
                      color: onSurface,
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                  const SizedBox(height: 2),
                  const Text(
                    'â° ì‹¤ì‹œê°„',
                    style: TextStyle(
                      color: Colors.orange,
                      fontSize: 11,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ì´ ìˆì„ ë•Œì™€ ì—†ì„ ë•Œ ë¶„ê¸°
    Widget finalWidget = cardWidget;
    
    if (_shouldBlink) {
      finalWidget = AnimatedBuilder(
        animation: _blinkAnimation,
        builder: (context, child) {
          return Container(
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.amber.withValues(alpha: 1.0 - _blinkAnimation.value),
                  blurRadius: 12,
                  spreadRadius: 3,
                ),
              ],
            ),
            child: cardWidget,
          );
        },
      );
    } else if (widget.enableBlinkAnimation) {
      finalWidget = TweenAnimationBuilder<double>(
        tween: Tween(begin: 1.0, end: 0.7),
        duration: const Duration(milliseconds: 300),
        builder: (context, value, child) {
          return AnimatedContainer(
            duration: const Duration(milliseconds: 150),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: theme.colorScheme.primary.withValues(alpha: 1.0 - value),
                  blurRadius: 8,
                  spreadRadius: 2,
                ),
              ],
            ),
            child: cardWidget,
          );
        },
      );
    }
    
    return finalWidget;
  }
}