\n\n// ====== lib/data/datasources/trade_cache_ds.dart ======\n
// lib/data/datasources/trade_cache_ds.dart

import 'package:hive/hive.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Hive ê¸°ë°˜ ê°„ë‹¨ ê±°ë˜ ìºì‹œ ë°ì´í„°ì†ŒìŠ¤
/// - HiveServiceì—ì„œ ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ì•„ ì‚¬ìš©
/// - Box ìƒëª…ì£¼ê¸° ê´€ë¦¬ëŠ” HiveServiceê°€ ë‹´ë‹¹
class TradeCacheDataSource {
  static const _maxCacheSize = 1000;

  /// ğŸ¯ ì£¼ì…ë°›ì€ Box (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  final Box<TradeDto> _box;
  
  /// ìƒì„±ì: ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ìŒ
  TradeCacheDataSource(this._box);

  /// Tradeë¥¼ DTOë¡œ ë³€í™˜í•´ ì €ì¥, ì‚¬ì´ì¦ˆ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª© ì œê±°
  Future<void> cacheTrade(Trade trade) async {
    final dto = TradeDto(
      market: trade.market,
      price: trade.price,
      volume: trade.volume,
      side: trade.side,
      changePrice: trade.changePrice,
      changeState: trade.changeState,
      timestampMs: trade.timestampMs,
      sequentialId: trade.sequentialId,
    );
    
    await _box.put(trade.sequentialId, dto);
    
    // ìµœëŒ€ ìºì‹œ ì‚¬ì´ì¦ˆ ê´€ë¦¬
    if (_box.length > _maxCacheSize) {
      final toRemove = _box.keys.take(_box.length - _maxCacheSize);
      await _box.deleteAll(toRemove);
    }
  }

  /// ìºì‹œëœ Trade ì „ë¶€ ë°˜í™˜
  List<Trade> getCachedTrades() =>
      _box.values.map((dto) => dto.toEntity()).toList();

  /// ìºì‹œ í´ë¦¬ì–´
  Future<void> clearCache() => _box.clear();

  // ğŸ—‘ï¸ Box lifecycle ê´€ë¦¬ ë©”ì„œë“œë“¤ ì œê±°:
  // - init() : HiveServiceê°€ ë‹´ë‹¹
  // - dispose() : HiveServiceê°€ ë‹´ë‹¹
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Fetches a live trade stream; on error falls back to synthetic data.
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  StreamController<Trade>? _controller;
  StreamSubscription<List<Map<String, dynamic>>>? _wsSub;
  bool _disposed = false; // ğŸ¯ dispose ìƒíƒœ ì¶”ê°€

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData;

  /// Starts streaming trades for the given markets.
  Stream<Trade> watch(List<String> markets) {
    if (_useTestData) return _testStream();

    // ğŸ”§ dispose í›„ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì´ˆê¸°í™”
    if (_disposed) {
      debugPrint('TradeRemoteDataSource: resetting after dispose');
      _disposed = false;
    }

    // clean up any previous stream/subscription
    _controller?.close();
    _wsSub?.cancel();

    _controller = StreamController<Trade>.broadcast(
      onListen: () {
        if (!_disposed) _start(markets);
      },
      onCancel: () {
        _wsSub?.cancel();
        // ğŸš¨ controller.close()ëŠ” dispose()ì—ì„œë§Œ í˜¸ì¶œ
      },
    );

    return _controller!.stream;
  }

  Future<void> _start(List<String> markets) async {
    if (_disposed) return; // ğŸ”§ dispose ì²´í¬ ì¶”ê°€

    try {
      await _ws.connect(markets);
      _wsSub = _ws.stream.listen(
        (rawBatch) {
          // ğŸ¯ í•µì‹¬ ìˆ˜ì •: controllerê°€ ë‹«í˜”ê±°ë‚˜ disposedë©´ ì²˜ë¦¬ ì•ˆí•¨
          if (_disposed || _controller == null || _controller!.isClosed) {
            debugPrint('TradeRemoteDataSource: skipping data - disposed or closed');
            return;
          }

          for (final item in rawBatch) {
            final dto = TradeDto.tryParse(item);
            if (dto == null) continue;
            final entity = dto.toEntity();
            
            // ğŸ”§ ì•ˆì „í•œ add: controller ìƒíƒœ ì¬í™•ì¸
            if (!_disposed && _controller != null && !_controller!.isClosed) {
              _controller!.add(entity);
            }

            // dispatch as AppEvent with metadata
            final event = AppEvent.now(dto.toMap());
            _signalBus.fireTradeEvent(event);
          }
        },
        onError: (error, stackTrace) {
          debugPrint('WebSocket error: $error');
          if (!_disposed && _controller != null && !_controller!.isClosed) {
            _controller!.addStream(_testStream());
          }
        },
        onDone: () {
          debugPrint('WebSocket done');
          if (!_disposed && _controller != null && !_controller!.isClosed) {
            _controller!.addStream(_testStream());
          }
        },
        cancelOnError: false,
      );
    } catch (e) {
      debugPrint('WS connection failed: $e');
      if (!_disposed && _controller != null && !_controller!.isClosed) {
        _controller!.addStream(_testStream());
      }
    }
  }

  /// Synthetic fallback stream for dev/test.
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'KRW-BTC', 'KRW-ETH', 'KRW-XRP',
      'KRW-DOGE', 'KRW-SOL', 'KRW-ADA',
      'KRW-LINK', 'KRW-DOT', 'KRW-AVAX',
      'KRW-MATIC',
    ];

    while (!_disposed) { // ğŸ”§ dispose ì²´í¬ ì¶”ê°€
      await Future.delayed(const Duration(milliseconds: 500));
      if (_disposed) break; // ğŸ”§ loop ì¤‘ì—ë„ ì²´í¬
      
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final dto = TradeDto(
        market: symbols[rnd.nextInt(symbols.length)],
        price: (rnd.nextDouble() * 1000).roundToDouble(),
        volume: rnd.nextDouble(),
        side: rnd.nextBool() ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: nowMs,
        sequentialId: 'test-$nowMs-${rnd.nextInt(1000)}',
      );
      yield dto.toEntity();
      _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
    }
  }

  /// Clean up resources when no longer needed.
  Future<void> dispose() async {
    if (_disposed) return; // ğŸ”§ ì¤‘ë³µ dispose ë°©ì§€
    
    _disposed = true; // ğŸ¯ disposed í”Œë˜ê·¸ ë¨¼ì € ì„¤ì •
    
    debugPrint('TradeRemoteDataSource: disposing...');
    
    // WebSocket subscription ì •ë¦¬
    await _wsSub?.cancel();
    _wsSub = null;
    
    // StreamController ì •ë¦¬ (ë°ì´í„° ìˆ˜ì‹  ì™„ì „ ì°¨ë‹¨ í›„)
    if (_controller != null && !_controller!.isClosed) {
      await _controller!.close();
    }
    _controller = null;
    
    debugPrint('TradeRemoteDataSource: disposed');
    
    // do not dispose shared ws client here
  }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_cache_ds.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹ì˜ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ì ìš©í•œ Repository
class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remote;
  final TradeCacheDataSource _cache;
  final TradeAggregator _aggregator;

  // ğŸ“Š ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ TradeNotifier ë°©ì‹)
  final Map<double, List<Trade>> _filterLists = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
  final StreamController<List<Trade>> _filteredController = StreamController<List<Trade>>.broadcast();
  final StreamController<Trade> _aggregatedController = StreamController<Trade>.broadcast();
  
  // ğŸ”¥ í•µì‹¬: ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _masterStream;
  StreamSubscription<Trade>? _masterSubscription;
  Timer? _periodicFlushTimer;
  Timer? _batchUpdateTimer;
  
  // ğŸ¯ ë™ì  ì„ê³„ê°’ ê´€ë¦¬
  double _currentThreshold = 20000000.0; // ê¸°ë³¸ê°’: 2ì²œë§Œì›
  
  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxTrades = 200;
  static const int _maxCacheSize = 1000;
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

  TradeRepositoryImpl(this._remote, this._cache)
      : _aggregator = TradeAggregator() {
    
    // í•„í„° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
    for (final filter in AppConfig.tradeFilters) {
      _filterLists[filter] = [];
    }
    
    // ì£¼ê¸°ì  í”ŒëŸ¬ì‹œ íƒ€ì´ë¨¸
    _periodicFlushTimer = Timer.periodic(
      AppConfig.globalResetInterval,
      (_) => _aggregator.flushTrades(onTradeProcessed: _handleProcessedTrade),
    );
  }

  /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ í˜¸ì¶œ)
  void _initializeMasterStream(List<String> markets) {
    if (_masterStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
    
    debugPrint('TradeRepositoryImpl: initializing master stream for ${markets.length} markets');
    
    // ğŸ¯ ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    _masterStream = _remote.watch(markets).asBroadcastStream();
    
    // ğŸ¯ ë‹¨ì¼ êµ¬ë…ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì²˜ë¦¬
    _masterSubscription = _masterStream!.listen(
      _processRawTrade,
      onError: (error, stackTrace) {
        debugPrint('Master stream error: $error');
        debugPrint('StackTrace: $stackTrace');
      },
      onDone: () {
        debugPrint('Master stream done');
      },
    );
  }

  @override
  Stream<Trade> watchTrades(List<String> markets) {
    debugPrint('TradeRepositoryImpl: watchTrades() - ${markets.length} markets');
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì¶”ê°€ êµ¬ë… ì—†ìŒ)
    return _masterStream!;
  }

  @override
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
    debugPrint('TradeRepositoryImpl: watchFilteredTrades() - threshold: $threshold');
    
    // ğŸ¯ ìˆ˜ì •: ì„ê³„ê°’ ì—…ë°ì´íŠ¸
    _currentThreshold = threshold;
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ì„ê³„ê°’ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì¬í•„í„°ë§
    _scheduleBatchUpdate();
    
    // ë°°ì¹˜ ì²˜ë¦¬ëœ ê²°ê³¼ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
    return _filteredController.stream;
  }

  @override
  Stream<Trade> watchAggregatedTrades() {
    return _aggregatedController.stream;
  }

  /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  @override
  void updateThreshold(double threshold) {
    if (_currentThreshold != threshold) {
      _currentThreshold = threshold;
      debugPrint('ğŸ¯ Threshold updated to: ${threshold.toStringAsFixed(0)}');
      
      // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
      _scheduleBatchUpdate();
    }
  }
  
  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹)
  void _processRawTrade(Trade trade) async {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
      if (!_seenIds.add(key)) return;

      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ìºì‹œ ì €ì¥
      await _cache.cacheTrade(trade);

      // ğŸ”„ Aggregatorë¥¼ í†µí•œ ê±°ë˜ ì²˜ë¦¬
      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleProcessedTrade,
      );
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTrade error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }
  
  /// ğŸ¯ ì§‘ê³„ëœ ê±°ë˜ ì²˜ë¦¬ ë° í•„í„°ë§ (í•µì‹¬ ë¡œì§)
  void _handleProcessedTrade(Map<String, dynamic> processedTrade) {
    try {
      // Trade ì—”í‹°í‹°ë¡œ ë³€í™˜
      final trade = Trade(
        market: processedTrade['market'] as String,
        price: processedTrade['price'] as double,
        volume: processedTrade['volume'] as double,
        side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: processedTrade['timestamp'] as int,
        sequentialId: processedTrade['sequential_id'] as String,
      );
      
      // ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€
      if (!_aggregatedController.isClosed) {
        _aggregatedController.add(trade);
      }
      
      final total = trade.total;
      
      // ğŸ“‹ ê° í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê±°ë˜ ì¶”ê°€
      for (final filter in AppConfig.tradeFilters) {
        if (total >= filter) {
          final list = _filterLists[filter]!;
          list.insert(0, trade);
          
          // ìµœëŒ€ ê±°ë˜ ìˆ˜ ìœ ì§€
          if (list.length > _maxTrades) {
            list.removeLast();
          }
        }
      }
      
      // ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ê³¼ë„í•œ UI ì—…ë°ì´íŠ¸ ë°©ì§€)
      _scheduleBatchUpdate();
      
    } catch (e, stackTrace) {
      debugPrint('_handleProcessedTrade error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }
  
  /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ì˜ˆì „ í”„ë¡œì íŠ¸ì˜ _updateFilteredTrades ë°©ì‹)
  void _scheduleBatchUpdate() {
    // ì´ë¯¸ ìŠ¤ì¼€ì¤„ëœ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ë¦¬ì…‹
    _batchUpdateTimer?.cancel();
    
    _batchUpdateTimer = Timer(_batchUpdateInterval, () {
      _updateFilteredTrades();
    });
  }
  
  /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ì—…ë°ì´íŠ¸ (UI ì—…ë°ì´íŠ¸)
  void _updateFilteredTrades() {
    try {
      // ğŸ¯ ìˆ˜ì •: ë™ì  ì„ê³„ê°’ ì‚¬ìš©
      final threshold = _currentThreshold;
      
      final merged = <Trade>[];
      final seen = <String>{};

      // ğŸ” ì„ê³„ê°’ ì´ìƒì˜ ëª¨ë“  í•„í„°ì—ì„œ ê±°ë˜ ìˆ˜ì§‘
      for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
        for (final trade in _filterLists[filter] ?? <Trade>[]) {
          final id = '${trade.sequentialId}-${trade.timestampMs}';
          if (trade.total >= threshold && seen.add(id)) {
            merged.add(trade);
          }
        }
      }

      // ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹  ìˆœ)
      merged.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
      
      // ìµœëŒ€ ê±°ë˜ ìˆ˜ë¡œ ì œí•œ
      final result = merged.take(_maxTrades).toList();
      
      // ğŸš€ UIì— ì—…ë°ì´íŠ¸ ì „ì†¡
      if (!_filteredController.isClosed) {
        _filteredController.add(result);
        
        if (kDebugMode && result.isNotEmpty) {
          debugPrint('ğŸ¯ Batch update: ${result.length} filtered trades (threshold: ${threshold.toStringAsFixed(0)})');
        }
      }
      
    } catch (e, stackTrace) {
      debugPrint('_updateFilteredTrades error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  @override
  Future<void> dispose() async {
    debugPrint('TradeRepositoryImpl: dispose() called');
    
    // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
    _periodicFlushTimer?.cancel();
    _batchUpdateTimer?.cancel();
    
    // ë§ˆìŠ¤í„° êµ¬ë… ì •ë¦¬
    await _masterSubscription?.cancel();
    _masterStream = null;
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    await _filteredController.close();
    await _aggregatedController.close();
    
    // ë°ì´í„°ì†ŒìŠ¤ ì •ë¦¬ (remoteë§Œ)
    await _remote.dispose();
    
    // ğŸ—‘ï¸ TradeCacheDataSource.dispose() ì œê±° (HiveServiceê°€ Box ìƒëª…ì£¼ê¸° ê´€ë¦¬)
    // await _cache.dispose();  // â† ì œê±°ë¨
    
    // Aggregator í”ŒëŸ¬ì‹œ
    _aggregator.flushTrades(onTradeProcessed: (_) {});
  }
}\n\n// ====== lib/data/models/trade_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trade_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TradeDtoAdapter extends TypeAdapter<TradeDto> {
  @override
  final int typeId = 0;

  @override
  TradeDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TradeDto(
      market: fields[0] as String,
      price: fields[1] as double,
      volume: fields[2] as double,
      side: fields[3] as String,
      changePrice: fields[4] as double,
      changeState: fields[5] as String,
      timestampMs: fields[6] as int,
      sequentialId: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TradeDto obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.market)
      ..writeByte(1)
      ..write(obj.price)
      ..writeByte(2)
      ..write(obj.volume)
      ..writeByte(3)
      ..write(obj.side)
      ..writeByte(4)
      ..write(obj.changePrice)
      ..writeByte(5)
      ..write(obj.changeState)
      ..writeByte(6)
      ..write(obj.timestampMs)
      ..writeByte(7)
      ..write(obj.sequentialId);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TradeDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/trade_dto.dart ======\n
// lib/data/models/trade_dto.dart

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

part 'trade_dto.g.dart';

@HiveType(typeId: 0)
class TradeDto {
  @HiveField(0)
  final String market;

  @HiveField(1)
  final double price;

  @HiveField(2)
  final double volume;

  @HiveField(3)
  final String side;

  @HiveField(4)
  final double changePrice;

  @HiveField(5)
  final String changeState;

  @HiveField(6)
  final int timestampMs;

  @HiveField(7)
  final String sequentialId;

  TradeDto({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  Trade toEntity() => Trade(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestampMs,
        sequentialId: sequentialId,
      );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜ (camelCase í‚¤ ì‚¬ìš©ìœ¼ë¡œ ì‹œìŠ¤í…œ í†µì¼)
  Map<String, dynamic> toMap() => {
        'market': market,
        'price': price,
        'volume': volume,
        'side': side,
        'changePrice': changePrice,
        'changeState': changeState,
        'timestampMs': timestampMs,
        'sequentialId': sequentialId,
      };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (ì—¬ëŸ¬ í‚¤ ë„¤ì´ë° ì§€ì›)
  static TradeDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      log.d('TradeDto.tryParse: ${m.toString().substring(0, m.toString().length.clamp(0, 100))}');

      String parseString(dynamic v, [String fallback = '']) =>
          v != null ? v.toString() : fallback;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch
                              : DateTime.now().millisecondsSinceEpoch;
      }

      final market = parseString(m['market'] ?? m['symbol'] ?? m['code'], 'UNKNOWN');
      final price = parseDouble(m['price'] ?? m['trade_price']);
      final volume = parseDouble(m['volume'] ?? m['trade_volume']);
      final side = parseString(m['side'] ?? m['ask_bid'], 'UNKNOWN');

      final changePrice = parseDouble(m['changePrice'] ?? m['change_price']);
      final changeState = parseString(m['changeState'] ?? m['change_state'], 'EVEN');
      final timestamp = parseInt(m['timestampMs'] ?? m['timestamp_ms'] ?? m['timestamp']);
      final sequentialId = parseString(
        m['sequentialId'] ?? m['sequential_id'] ?? m['sid'], 
        timestamp.toString(),
      );

      return TradeDto(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestamp,
        sequentialId: sequentialId,
      );
    } catch (e) {
      log.w('TradeDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TradeDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TradeDto(
        market: 'ERROR',
        price: 0.0,
        volume: 0.0,
        side: 'UNKNOWN',
        changePrice: 0.0,
        changeState: 'UNKNOWN',
        timestampMs: DateTime.now().millisecondsSinceEpoch,
        sequentialId: 'ERROR',
      );
}
\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/features/trade/data/utils/trade_aggregator.dart
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ì™€ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Map<String, dynamic>> _lastTrades = {};
  final int mergeWindow = AppConfig.mergeWindowMs;

  /// ê±°ë˜ ì²˜ë¦¬ ë° ë³‘í•© ë¡œì§
  void processTrade(
    Map<String, dynamic> trade, {
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      // ì•ˆì „í•œ null ì²´í¬ì™€ íƒ€ì… ìºìŠ¤íŒ…
      final market = trade['market'] as String? ?? '';
      final price = trade['price'] as double? ?? 0.0;
      final volume = trade['volume'] as double? ?? 0.0;
      final timestamp = trade['timestamp'] as int? ?? 0;
      final isBuy = trade['isBuy'] as bool? ?? true;
      final sequentialId = trade['sequential_id'] as String? ?? '';

      // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (market.isEmpty || price <= 0 || volume <= 0 || timestamp <= 0) {
        if (kDebugMode) {
          debugPrint('TradeAggregator: Invalid trade data, skipping: market=$market, price=$price, volume=$volume, timestamp=$timestamp');
        }
        return;
      }

      final total = price * volume;

      if (_lastTrades.containsKey(market)) {
        final lastTrade = _lastTrades[market]!;
        final lastTs = lastTrade['timestamp'] as int;

        // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê±°ë˜ë©´ ë³‘í•©
        if (timestamp - lastTs <= mergeWindow) {
          final lastTotal = lastTrade['total'] as double;
          final lastVolume = lastTrade['volume'] as double;
          final newTotal = lastTotal + total;
          final newVolume = lastVolume + volume;

          // ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°
          final avgPrice = newTotal / newVolume;

          // ë³‘í•©ëœ ê±°ë˜ ì •ë³´ ì—…ë°ì´íŠ¸
          lastTrade['price'] = avgPrice;
          lastTrade['volume'] = newVolume;
          lastTrade['total'] = newTotal;
          lastTrade['timestamp'] = timestamp; // ìµœì‹  ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          lastTrade['sequential_id'] = sequentialId;
          lastTrade['isBuy'] = isBuy; // ìµœì‹  ê±°ë˜ì˜ ë°©í–¥ ì‚¬ìš©

          if (kDebugMode) {
            debugPrint(
              'Merged trade: $market, total: ${newTotal.toStringAsFixed(0)}, avg_price: ${avgPrice.toStringAsFixed(2)}',
            );
          }
        } else {
          // ì‹œê°„ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚˜ë©´ ì´ì „ ê±°ë˜ ì²˜ë¦¬í•˜ê³  ìƒˆ ê±°ë˜ë¡œ êµì²´
          onTradeProcessed(Map<String, dynamic>.from(lastTrade));
          _lastTrades[market] = {
            'market': market,
            'price': price,
            'volume': volume,
            'total': total,
            'timestamp': timestamp,
            'isBuy': isBuy,
            'sequential_id': sequentialId,
          };
        }
      } else {
        // ìƒˆë¡œìš´ ë§ˆì¼“ì˜ ì²« ê±°ë˜
        final newTrade = {
          'market': market,
          'price': price,
          'volume': volume,
          'total': total,
          'timestamp': timestamp,
          'isBuy': isBuy,
          'sequential_id': sequentialId,
        };
        _lastTrades[market] = newTrade;
        // ğŸ”¥ ì¤‘ìš”: ì²« ê±°ë˜ë„ ë°”ë¡œ ì²˜ë¦¬í•˜ì—¬ UIì— ë°˜ì˜
        onTradeProcessed(Map<String, dynamic>.from(newTrade));
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator processTrade error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í”ŒëŸ¬ì‹œ
  void flushTrades({
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      final tradesCount = _lastTrades.length;
      for (final trade in _lastTrades.values) {
        onTradeProcessed(Map<String, dynamic>.from(trade));
      }
      _lastTrades.clear();
      
      if (kDebugMode) {
        debugPrint('TradeAggregator: $tradesCount trades flushed');
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator flushTrades error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê¹…ìš©)
  Map<String, dynamic>? getPendingTrade(String market) {
    return _lastTrades[market] != null
        ? Map<String, dynamic>.from(_lastTrades[market]!)
        : null;
  }

  /// í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _lastTrades.length;

  /// ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _lastTrades.clear();
  }
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart
import '../entities/trade.dart';

/// Provides streams of trade data and handles resource cleanup.
abstract class TradeRepository {
  /// Streams raw [Trade] events for the given list of market codes.
  Stream<Trade> watchTrades(List<String> markets);
  
  /// Streams lists of [Trade] filtered by a minimum total trade value.
  /// => markets íŒŒë¼ë¯¸í„° ì¶”ê°€
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);
  
  /// Streams aggregated [Trade] events over a merge window.
  Stream<Trade> watchAggregatedTrades();
  
  /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updateThreshold(double threshold);
  
  /// Releases any held resources (e.g., WebSocket connections, Hive boxes).
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// Trade ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  /// thresholdì™€ marketsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<List<Trade>, AppException>> filterTrades(
    double threshold,
    List<String> markets,
  ) {
    return _repository
        .watchFilteredTrades(threshold, markets)
        .transform(_wrap<List<Trade>>('Filter trades failed'));
  }

  /// ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<Trade, AppException>> aggregateTrades() {
    return _repository
        .watchAggregatedTrades()
        .transform(_wrap<Trade>('Aggregate trades failed'));
  }

  StreamTransformer<T, Result<T, AppException>> _wrap<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/services/trade_filter_service.dart ======\n
\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨
class Trade extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;

  /// ì²´ê²° ë‹¨ê°€
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰
  final double volume;

  /// 'BID' ë˜ëŠ” 'ASK'
  final String side;

  /// ê°€ê²© ë³€ë™ëŸ‰
  final double changePrice;

  /// ë³€ë™ ìƒíƒœ ('RISE'/'FALL'/'EVEN')
  final String changeState;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int timestampMs;

  /// ì¤‘ë³µ ì œê±°ìš© ê³ ìœ  ID
  final String sequentialId;

  const Trade({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  @override
  List<Object?> get props => [
        market,
        price,
        volume,
        side,
        changePrice,
        changeState,
        timestampMs,
        sequentialId,
      ];

  /// ì´ ì²´ê²° ê¸ˆì•¡
  double get total => price * volume;

  /// ë§¤ìˆ˜ ì—¬ë¶€
  bool get isBuy => side == 'BID';

  /// DateTime ë³€í™˜
  DateTime get timestamp => DateTime.fromMillisecondsSinceEpoch(timestampMs);
}
\n\n// ====== lib/presentation/providers/trade_provider.dart ======\n
\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart'; // usecaseProvider, repoProvider
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class TradeState {
  final List<Trade> trades;
  final bool isLoading;
  final bool isConnected;
  final double threshold;
  final int selectedIndex;
  final String? errorMessage;

  const TradeState({
    this.trades = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.threshold = 20000000,
    this.selectedIndex = 0,
    this.errorMessage,
  });

  TradeState copyWith({
    List<Trade>? trades,
    bool? isLoading,
    bool? isConnected,
    double? threshold,
    int? selectedIndex,
    String? errorMessage,
  }) {
    return TradeState(
      trades: trades ?? this.trades,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      threshold: threshold ?? this.threshold,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      errorMessage: errorMessage,
    );
  }
}

/// Trade í™”ë©´ ì „ìš© ViewModel
class TradeController extends StateNotifier<TradeState> {
  final TradeUsecase _usecase;
  final Ref _ref;  // ğŸ”¥ ì¶”ê°€: Repository ì ‘ê·¼ì„ ìœ„í•œ ref
  StreamSubscription<Result<List<Trade>, AppException>>? _subscription;

  TradeController(this._usecase, this._ref) : super(const TradeState());  // ğŸ”¥ ìˆ˜ì •: ref ë§¤ê°œë³€ìˆ˜ ì¶”ê°€

  /// ì„ê³„ê°’ ë° ì¸ë±ìŠ¤ ì„¤ì • í›„ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  void setThreshold(double threshold, int index, List<String> markets) {
    // ğŸ”¥ ì¶”ê°€: Repositoryì˜ updateThreshold í˜¸ì¶œ (í•µì‹¬ ëˆ„ë½ ë¶€ë¶„)
    final repository = _ref.read(repoProvider);
    repository.updateThreshold(threshold);
    
    state = state.copyWith(
      threshold: threshold,
      selectedIndex: index,
      isLoading: true,
      errorMessage: null,
    );
    _subscription?.cancel();
    _subscription = _usecase
        .filterTrades(threshold, markets)
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Trade>, AppException> result) {
    result.when(
      ok: (trades) {
        state = state.copyWith(
          trades: trades,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨: marketsë§Œ ë°›ì•„ì„œ ë‚´ë¶€ì ìœ¼ë¡œ setThreshold í˜¸ì¶œ
  void refresh(List<String> markets) {
    setThreshold(state.threshold, state.selectedIndex, markets);
  }

  /// ê±°ë˜ ëª©ë¡ ì¶”ê°€ í•„í„° (ì‹œì¥ëª…)
  List<Trade> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.trades;
    }
    final upper = marketFilter.toUpperCase();
    return state.trades.where((t) => t.market.contains(upper)).toList();
  }

  /// ê±°ë˜ ëª©ë¡ ì •ë ¬
  void sortTrades(String field, bool ascending) {
    final list = [...state.trades];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'volume':
          aValue = a.volume;
          bValue = b.volume;
          break;
        case 'total':
          aValue = a.total;
          bValue = b.total;
          break;
        case 'timestamp':
          aValue = a.timestampMs;
          bValue = b.timestampMs;
          break;
        default:
          aValue = a.timestampMs;
          bValue = b.timestampMs;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(trades: list);
  }

  /// ê±°ë˜ ëª©ë¡ í•„í„°ë§/ì •ë ¬ ì ìš©
  List<Trade> apply(List<Trade> trades) {
    // í˜„ì¬ thresholdë¡œ í•„í„°ë§
    final filtered = trades.where((trade) => trade.total >= state.threshold).toList();
    // ê¸°ë³¸ ì •ë ¬ (timestampMs ë‚´ë¦¼ì°¨ìˆœ)
    filtered.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return filtered;
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì„ê³„ê°’ ì˜µì…˜ë“¤
  List<double> get availableThresholds =>
    AppConfig.tradeFilters.where((f) => f >= 20000000).toList();

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final tradeControllerProvider =
    StateNotifierProvider<TradeController, TradeState>((ref) {
  final usecase = ref.read(usecaseProvider);
  return TradeController(usecase, ref);  // ğŸ”¥ ìˆ˜ì •: refë„ í•¨ê»˜ ì „ë‹¬
});\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart';
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';
// âœ‚ï¸ CommonAppBar import ì œê±° (MainPageì—ì„œ ì²˜ë¦¬)

class TradePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const TradePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) Threshold ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final thresholds = AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    final index = ref.watch(tradeFilterIndexProvider);
    final thresholdCtrl = ref.read(tradeThresholdController);
    
    // 2) ê±°ë˜ ìŠ¤íŠ¸ë¦¼
    final tradesAsync = ref.watch(tradeListProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬ (í•„í„°/ì •ë ¬)
    final uiController = ref.watch(tradeControllerProvider.notifier);
    
    // 4) ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ì€ ScrollController ì‚¬ìš© (ë¡œì»¬ ìƒì„± ì œê±°)

    // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(thresholds, index, thresholdCtrl);
    
    // ğŸ†• ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final tradeListWidget = _buildTradeList(tradesAsync, uiController, scrollController, thresholds, index, context);

    // âœ… PrimaryScrollControllerë¡œ ìƒíƒœë°” í„°ì¹˜ í™œì„±í™” + ì •í™•í•œ ScrollController ì—°ê²°
    return PrimaryScrollController(
      controller: scrollController, // âœ… ì´ì œ MainPageì™€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤!
      child: Column(
        children: [
          // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: tradeListWidget),
          
          // ğŸ†• ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
  Widget _buildSliderWidget(List<double> thresholds, int index, dynamic thresholdCtrl) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'ìµœì†Œ ê±°ë˜ ê¸ˆì•¡: ${AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0)}',
            style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
          ),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (thresholds.length - 1).toDouble(),
            divisions: thresholds.length - 1,
            label: AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0),
            onChanged: (v) {
              HapticFeedback.mediumImpact(); // ğŸ¯ ì—¬ê¸°ì— ì¶”ê°€!  
              final i = v.round();
              thresholdCtrl.updateThreshold(thresholds[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ë“œë˜ê·¸ ê¸°ëŠ¥ ê°•í™”
  Widget _buildTradeList(
    AsyncValue tradesAsync, 
    dynamic uiController, 
    ScrollController scrollController,
    List<double> thresholds,
    int index,
    BuildContext context,
  ) {
    return tradesAsync.when(
      data: (list) {
        final viewList = uiController.apply(list);
        if (viewList.isEmpty) {
          return Center(
            child: Text(
              'í¬ì°©ëœ ì²´ê²°ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì„ê³„ê°’: ${AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0)})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ë” ê°•ë ¥í•œ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ìŠ¤í¬ë¡¤ë°”
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: true,
          trackVisibility: true, // íŠ¸ë™ í‘œì‹œ
          thickness: 8, // âœ… ë‘ê»˜ ì¤„ì´ê¸° (16 â†’ 8)
          radius: const Radius.circular(4), // âœ… ë°˜ì§€ë¦„ë„ ì¡°ì •
          thumbColor: Colors.orange.withValues(alpha: 0.5), // âœ… ê¸°ì¡´ ì£¼í™© ë°˜íˆ¬ëª…
          trackColor: Colors.transparent, // âœ… íŠ¸ë™ì€ íˆ¬ëª…í•˜ê²Œ
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 50, // ìµœì†Œ ì¸ ê¸¸ì´
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 24, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¤„ì´ê¸°
            itemCount: viewList.length,
            itemBuilder: (_, i) => TradeTile(trade: viewList[i]),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ì²´ê²° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';
import '../../core/di/app_providers.dart'; // DisplayMode import
import '../../shared/widgets/amount_display_widget.dart'; // ğŸ’° AmountDisplayWidget import

class TradeTile extends ConsumerWidget { // âœ… StatelessWidget â†’ ConsumerWidget ë³€ê²½
  // í¬ë§·í„°ë¥¼ staticìœ¼ë¡œ ìºì‹±í•´ ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šë„ë¡ ìµœì í™”
  static final _timeFormat = DateFormat('HH:mm:ss');
  static final _integerFormat = NumberFormat('#,###'); // ì •ìˆ˜ìš©
  static final _decimalFormat = NumberFormat('#,##0.######'); // ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
  static final _decimal3Format = NumberFormat('#,##0.###'); // ì†Œìˆ˜ì  3ìë¦¬
  static final _decimal2Format = NumberFormat('#,##0.##'); // ì†Œìˆ˜ì  2ìë¦¬
  static final _decimal1Format = NumberFormat('#,##0.#'); // ì†Œìˆ˜ì  1ìë¦¬
  
  final Trade trade;
  
  const TradeTile({Key? key, required this.trade}) : super(key: key);
  
  // ğŸ¯ ì¡°ê±´ë¶€ ê°€ê²© í¬ë§·íŒ…
  String _formatPrice(double price) {
    if (price <= 1.0) {
      return _decimalFormat.format(price); // 1 ì´í•˜: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else if (price < 10.0) {
      return _decimal3Format.format(price); // 1 ì´ˆê³¼ ~ 10 ë¯¸ë§Œ: ì†Œìˆ˜ì  3ìë¦¬
    } else if (price < 100.0) {
      return _decimal2Format.format(price); // 10 ì´ˆê³¼ ~ 100 ë¯¸ë§Œ: ì†Œìˆ˜ì  2ìë¦¬
    } else if (price < 1000.0) {
      return _decimal1Format.format(price); // 100 ì´ˆê³¼ ~ 1000 ë¯¸ë§Œ: ì†Œìˆ˜ì  1ìë¦¬
    } else {
      return _integerFormat.format(price); // 1000 ì´ìƒ: ì •ìˆ˜
    }
  }
  
  // ğŸ¯ ì¡°ê±´ë¶€ ê±°ë˜ëŸ‰ í¬ë§·íŒ…
  String _formatVolume(double volume) {
    if (volume < 1.0) {
      return _decimalFormat.format(volume); // 1ê°œ ë¯¸ë§Œ: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else {
      return _integerFormat.format(volume); // 1ê°œ ì´ìƒ: ì •ìˆ˜ í‘œì‹œ
    }
  }

  // ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë¡œì§
  String _getDisplayName(WidgetRef ref) {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final marketInfoAsync = ref.watch(marketInfoProvider);
    
    // ê¸°ë³¸ í‹°ì»¤ (fallback)
    final ticker = trade.market.replaceFirst('KRW-', '');
    
    // marketInfoê°€ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì—ëŸ¬ì¸ ê²½ìš° í‹°ì»¤ ë°˜í™˜
    return marketInfoAsync.when(
      data: (marketInfoMap) {
        final marketInfo = marketInfoMap[trade.market];
        
        switch (displayMode) {
          case DisplayMode.ticker:
            return ticker;
          case DisplayMode.korean:
            return marketInfo?.koreanName ?? ticker;
          case DisplayMode.english:
            return marketInfo?.englishName ?? ticker;
        }
      },
      loading: () => ticker, // ë¡œë”© ì¤‘ì—ëŠ” í‹°ì»¤ í‘œì‹œ
      error: (_, __) => ticker, // ì—ëŸ¬ ì‹œì—ë„ í‹°ì»¤ í‘œì‹œ
    );
  }
  
  @override
  Widget build(BuildContext context, WidgetRef ref) { // âœ… WidgetRef íŒŒë¼ë¯¸í„° ì¶”ê°€
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7); // âœ… withAlpha â†’ withValues
    
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          children: [
            // ğŸ¯ ì‹œê°„ ë¶€ë¶„: flex 12 (1.2 ë¹„ìœ¨, 17.1%)
            Expanded(
              flex: 12,
              child: Text(
                _timeFormat.format(trade.timestamp),
                style: TextStyle(color: onSurface, fontSize: 11),
                // ì‹œê°„ì€ ê³ ì • í˜•ì‹ì´ë¯€ë¡œ overflow ë°©ì§€ ë¶ˆí•„ìš”
              ),
            ),
            
            // ğŸ”§ ì½”ì¸ëª… ë¶€ë¶„: flex 18 (1.8 ë¹„ìœ¨, 25.7%) - ë™ì  í‘œì‹œ ì ìš©
            Expanded(
              flex: 18,
              child: Text(
                _getDisplayName(ref), // âœ… ë™ì  ì½”ì¸ëª… í‘œì‹œ
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                  fontSize: 16,
                ),
                overflow: TextOverflow.ellipsis, // ê¸´ ì½”ì¸ëª… ë°©ì§€
                maxLines: 1,
              ),
            ),
            
            // ğŸ”§ ê°€ê²©/ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 20 (2.0 ë¹„ìœ¨, 28.6%)
            Expanded(
              flex: 20,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    '${_formatPrice(trade.price)}ì›', // ğŸ¯ ì¡°ê±´ë¶€ ê°€ê²© í¬ë§·
                    style: TextStyle(color: onSurface, fontSize: 14),
                    overflow: TextOverflow.ellipsis, // í° ê°€ê²© ë°©ì§€
                    maxLines: 1,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    '${_formatVolume(trade.volume)} ê°œ', // ğŸ¯ ì¡°ê±´ë¶€ ê±°ë˜ëŸ‰ í¬ë§·
                    style: TextStyle(color: onSurface70, fontSize: 12),
                    overflow: TextOverflow.ellipsis, // í° ê±°ë˜ëŸ‰ ë°©ì§€
                    maxLines: 1,
                  ),
                ],
              ),
            ),
            
            // ğŸ’° ì´ì•¡ ë¶€ë¶„: flex 20 (2.0 ë¹„ìœ¨, 28.6%) - AmountDisplayWidget ì‚¬ìš©!
            Expanded(
              flex: 20,
              child: Align(
                alignment: Alignment.centerRight,
                child: AmountDisplayWidget(
                  totalAmount: trade.total,
                  isBuy: trade.isBuy,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            
            // ì•„ì´ì½˜ì€ ê³ ì • í¬ê¸°ì´ë¯€ë¡œ ë³€ê²½ ì—†ìŒ
            Icon(
              trade.isBuy ? Icons.arrow_upward : Icons.arrow_downward,
              color: trade.isBuy ? Colors.green : Colors.red,
              size: 16,
            ),
          ],
        ),
      ),
    );
  }
}