\n\n// ====== lib/core/di/signal_provider.dart ======\n
// lib/core/di/signal_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'trade_provider.dart'; // ì „ì²´ import (app_providers.dart íŒ¨í„´)
import '../../data/repositories/signal_repository_impl.dart';
import '../../domain/entities/signal.dart';
import '../../domain/repositories/signal_repository.dart';
import '../../domain/usecases/signal_usecase.dart';

/// Signal Repository Provider
final signalRepoProvider = Provider<SignalRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider);
  return SignalRepositoryImpl(remoteDS);
});

/// Signal UseCase Provider
final signalUsecaseProvider = Provider<SignalUseCase>((ref) {
  final repository = ref.read(signalRepoProvider);
  return SignalUseCase(repository);
});

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ ì¸ë±ìŠ¤ (ìŠ¬ë¼ì´ë” ìœ„ì¹˜)
final signalPatternIndexProvider = StateProvider<int>((_) => 0);

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ íƒ€ì…
final signalPatternTypeProvider = StateProvider<PatternType>((ref) {
  final index = ref.watch(signalPatternIndexProvider);
  final patternName = AppConfig.getSignalPatternByIndex(index);
  
  // AppConfig íŒ¨í„´ëª…ì„ PatternTypeìœ¼ë¡œ ë³€í™˜
  switch (patternName) {
    case 'surge':
      return PatternType.surge;
    case 'flashFire':
      return PatternType.flashFire;
    case 'stackUp':
      return PatternType.stackUp;
    case 'stealthIn':
      return PatternType.stealthIn;
    case 'blackHole':
      return PatternType.blackHole;
    case 'reboundShot':
      return PatternType.reboundShot;
    default:
      return PatternType.surge; // ê¸°ë³¸ê°’
  }
});

/// íŒ¨í„´ë³„ ì„ê³„ê°’ ê´€ë¦¬ (AppConfig ê¸°ë³¸ê°’ ê¸°ë°˜)
final signalThresholdProvider = StateProvider.family<double, PatternType>((ref, pattern) {
  final patternName = _getPatternConfigName(pattern);
  return AppConfig.getSignalThreshold(patternName);
});

/// íŒ¨í„´ë³„ í™œì„±í™” ìƒíƒœ ê´€ë¦¬
final signalPatternEnabledProvider = StateProvider.family<bool, PatternType>((ref, pattern) => true);

/// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼
final signalListProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ ì„ íƒëœ íŒ¨í„´ê³¼ ë§ˆì¼“ ì •ë³´ êµ¬ë…
  final patternType = ref.watch(signalPatternTypeProvider);
  final repository = ref.read(signalRepoProvider);

  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);

  // íŒ¨í„´ ë³€ê²½ ì‹œ ë¡œê·¸
  if (AppConfig.enableTradeLog) {
    log.i('Signal pattern changed to: ${patternType.displayName}');
  }

  // ì„ê³„ê°’ ë³€ê²½ ê°ì§€ ë° Repository ì—…ë°ì´íŠ¸
  ref.listen<double>(signalThresholdProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('Signal threshold changed: ${patternType.displayName} ${prev.toStringAsFixed(2)} â†’ ${next.toStringAsFixed(2)}');
      }
      repository.updatePatternThreshold(patternType, next);
    }
  });

  // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ë³€ê²½ ê°ì§€
  ref.listen<bool>(signalPatternEnabledProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('Signal pattern ${next ? "enabled" : "disabled"}: ${patternType.displayName}');
      }
      repository.setPatternEnabled(patternType, next);
    }
  });

  // íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchSignalsByPattern(patternType, markets);
});

/// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ í†µí•© ìŠ¤íŠ¸ë¦¼
final allSignalsProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent dispose on background
  ref.keepAlive();
  
  final repository = ref.read(signalRepoProvider);
  
  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.i('All signals stream initialized with ${markets.length} markets');
  }
  
  yield* repository.watchAllSignals(markets);
});

/// Signal íŒ¨í„´ ì»¨íŠ¸ë¡¤ëŸ¬
final signalPatternController = Provider((ref) => SignalPatternController(ref));

class SignalPatternController {
  final Ref ref;
  SignalPatternController(this.ref);

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™)
  void updatePatternIndex(int index) {
    final maxIndex = AppConfig.signalPatterns.length - 1;
    if (index < 0 || index > maxIndex) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index (max: $maxIndex)');
      }
      return;
    }

    ref.read(signalPatternIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      final patternName = AppConfig.getSignalPatternByIndex(index);
      log.i('Pattern index updated: $index (${AppConfig.getSignalPatternName(patternName)})');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½
  void updateThreshold(double threshold) {
    final currentPattern = ref.read(signalPatternTypeProvider);
    ref.read(signalThresholdProvider(currentPattern).notifier).state = threshold;
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™”
  void setPatternEnabled(PatternType pattern, bool enabled) {
    ref.read(signalPatternEnabledProvider(pattern).notifier).state = enabled;
  }

  /// ì‹œê·¸ë„ ì´ˆê¸°í™”
  void clearSignals([PatternType? pattern]) {
    final repository = ref.read(signalRepoProvider);
    repository.clearSignals(pattern);
    
    if (AppConfig.enableTradeLog) {
      final message = pattern != null 
          ? 'Signals cleared for pattern: ${pattern.displayName}'
          : 'All signals cleared';
      log.i(message);
    }
  }

  /// í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  int get currentIndex => ref.read(signalPatternIndexProvider);
  PatternType get currentPattern => ref.read(signalPatternTypeProvider);
  double get currentThreshold => ref.read(signalThresholdProvider(currentPattern));
  bool get isCurrentPatternEnabled => ref.read(signalPatternEnabledProvider(currentPattern));

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ì •ë³´
  List<String> get availablePatterns => AppConfig.signalPatterns;
  List<String> get patternDisplayNames => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternName(p)).toList();
  List<String> get patternDescriptions => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternDescription(p)).toList();

  /// íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ ì¡°íšŒ
  double getDefaultThreshold(PatternType pattern) {
    final patternName = _getPatternConfigName(pattern);
    return AppConfig.getSignalThreshold(patternName);
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° ì¡°íšŒ
  int getTimeWindow(PatternType pattern) {
    final patternName = _getPatternConfigName(pattern);
    return AppConfig.getSignalTimeWindow(patternName);
  }

  /// íŒ¨í„´ í†µê³„ ì¡°íšŒ (ì„ íƒì  ê¸°ëŠ¥)
  Map<String, dynamic> getPatternStats() {
    final allSignals = ref.read(allSignalsProvider).value ?? [];
    final patternCounts = <PatternType, int>{};
    
    for (final signal in allSignals) {
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;
    }
    
    return {
      'totalSignals': allSignals.length,
      'patternCounts': patternCounts,
      'lastUpdate': allSignals.isNotEmpty ? allSignals.first.detectedAt : null,
    };
  }
}

/// Helper function: PatternTypeì„ AppConfig íŒ¨í„´ëª…ìœ¼ë¡œ ë³€í™˜
String _getPatternConfigName(PatternType pattern) {
  switch (pattern) {
    case PatternType.surge:
      return 'surge';
    case PatternType.flashFire:
      return 'flashFire';
    case PatternType.stackUp:
      return 'stackUp';
    case PatternType.stealthIn:
      return 'stealthIn';
    case PatternType.blackHole:
      return 'blackHole';
    case PatternType.reboundShot:
      return 'reboundShot';
  }
}

/// Repository dispose ê´€ë¦¬
final signalRepositoryDisposeProvider = Provider.autoDispose<SignalRepository>((ref) {
  final repository = ref.watch(signalRepoProvider);
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('Signal repository disposed');
    }
  });
  
  return repository;
});\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ì œë„¤ë¦­)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ í”Œë«í¼ë³„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} â†’ $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} â†’ ${msg.substring(0, 100)}â€¦');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/data/repositories/signal_repository_impl.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';
import '../../core/utils/rolling_window.dart';
import '../../core/utils/pattern_detector.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/signal_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';

/// Signal Repository êµ¬í˜„ì²´ - PatternDetector ìì²´ ì„¤ì • ê¸°ë°˜ (AppConfig ì˜ì¡´ì„± ì œê±°)
class SignalRepositoryImpl implements SignalRepository {
  final TradeRemoteDataSource _remote;
  final TradeAggregator _aggregator;

  // ğŸ“Š íŒ¨í„´ë³„ ìƒíƒœ ê´€ë¦¬ (AppConfig ì˜ì¡´ì„± ì œê±°)
  final Map<PatternType, List<Signal>> _signalLists = {};
  final Map<PatternType, bool> _patternEnabled = {};
  final Set<String> _seenIds = {};

  // ğŸ¯ íŒ¨í„´ë³„ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final Map<PatternType, StreamController<List<Signal>>> _patternControllers = {};
  final StreamController<List<Signal>> _allSignalsController = StreamController<List<Signal>>.broadcast();

  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _signalStream;
  StreamSubscription<Trade>? _signalSubscription;

  // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ íƒ€ì´ë¨¸
  Timer? _batchUpdateTimer;
  Timer? _cleanupTimer;

  // ğŸ“ˆ RollingWindow ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬ (ì‹œì¥ë³„)
  final Map<String, RollingWindow<double>> _priceWindows = {};
  final Map<String, RollingWindow<double>> _volumeWindows = {};
  final Map<String, RollingWindow<double>> _buyRatioWindows = {};
  final Map<String, RollingWindow<double>> _intervalWindows = {};

  // ğŸ”’ ì¤‘ë³µ ê°ì§€ ë°©ì§€ ë° ì“°ë¡œí‹€ë§
  final Map<String, int> _detectedMarkets = {};
  final Map<String, int> _lastAnalysisTs = {};

  SignalRepositoryImpl(this._remote) 
      : _aggregator = TradeAggregator() {
    _initializePatterns();
    _startCleanupTimer();
  }

  /// íŒ¨í„´ë³„ ì´ˆê¸°í™” (AppConfig ì˜ì¡´ì„± ì œê±°)
  void _initializePatterns() {
    for (final pattern in PatternType.values) {
      _signalLists[pattern] = [];
      _patternEnabled[pattern] = true;
      _patternControllers[pattern] = StreamController<List<Signal>>.broadcast();
    }

    if (kDebugMode) {
      log.i('ğŸ¯ Signal patterns initialized: ${PatternType.values.length} patterns (PatternDetector ìì²´ ì„¤ì •)');
    }
  }

  /// ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ íƒ€ì´ë¨¸ ì‹œì‘
  void _startCleanupTimer() {
    _cleanupTimer = Timer.periodic(const Duration(minutes: 5), (_) {
      _cleanupWindows();
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      _detectedMarkets.removeWhere((_, expiryMs) => nowMs >= expiryMs);
    });
  }

  /// ğŸ§¹ RollingWindow ë©”ëª¨ë¦¬ ì •ë¦¬
  void _cleanupWindows() {
    final now = DateTime.now();
    int removedMarkets = 0;

    final activeMarkets = <String>{};
    
    _priceWindows.removeWhere((market, window) {
      if (window.isEmpty) {
        removedMarkets++;
        return true;
      }
      final lastUpdate = window.timestamps.isNotEmpty ? window.timestamps.last : now;
      if (now.difference(lastUpdate).inMinutes > 30) {
        removedMarkets++;
        return true;
      }
      activeMarkets.add(market);
      return false;
    });

    _volumeWindows.removeWhere((market, _) => !activeMarkets.contains(market));
    _buyRatioWindows.removeWhere((market, _) => !activeMarkets.contains(market));
    _intervalWindows.removeWhere((market, _) => !activeMarkets.contains(market));

    if (kDebugMode && removedMarkets > 0) {
      log.d('ğŸ§¹ Cleanup: $removedMarkets inactive markets removed');
    }
  }

  /// ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  void _initializeSignalStream(List<String> markets) {
    if (_signalStream != null) return;

    log.i('SignalRepositoryImpl: initializing signal stream for ${markets.length} markets');

    _signalStream = _remote.watch(markets).asBroadcastStream();

    _signalSubscription = _signalStream!.listen(
      _processRawTradeForSignal,
      onError: (error, stackTrace) {
        log.e('Signal stream error', error, stackTrace);
      },
      onDone: () {
        log.i('Signal stream done');
      },
    );
  }

  @override
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    _initializeSignalStream(markets);
    return _patternControllers[patternType]?.stream ?? const Stream.empty();
  }

  @override
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    _initializeSignalStream(markets);
    return _allSignalsController.stream;
  }

  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ì‹œê·¸ë„ ë¶„ì„ìš©ìœ¼ë¡œ ì²˜ë¦¬
  void _processRawTradeForSignal(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      if (!_seenIds.add(key)) return;

      if (_seenIds.length > AppConfig.signalCacheSize) {
        _seenIds.remove(_seenIds.first);
      }

      _aggregator.processTrade(
        {
          'market': trade.market, 'price': trade.price, 'volume': trade.volume,
          'timestamp': trade.timestampMs, 'isBuy': trade.isBuy, 'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleAggregatedTrade,
      );

    } catch (e, stackTrace) {
      log.w('_processRawTradeForSignal error', e, stackTrace);
    }
  }

  /// ğŸ”„ ì§‘ê³„ëœ ê±°ë˜ ë°ì´í„°ë¡œ RollingWindow ì—…ë°ì´íŠ¸ ë° íŒ¨í„´ ë¶„ì„
  void _handleAggregatedTrade(Map<String, dynamic> aggregatedTrade) {
    try {
      final trade = Trade(
        market: aggregatedTrade['market'] as String,
        price: aggregatedTrade['price'] as double,
        volume: aggregatedTrade['volume'] as double,
        side: (aggregatedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: aggregatedTrade['timestamp'] as int,
        sequentialId: aggregatedTrade['sequential_id'] as String? ?? '',
      );

      _updateRollingWindows(trade);
      _analyzePatterns(trade);

    } catch (e, stackTrace) {
      log.w('_handleAggregatedTrade error', e, stackTrace);
    }
  }

  /// ğŸ“ˆ RollingWindow ë°ì´í„° ì—…ë°ì´íŠ¸
  void _updateRollingWindows(Trade trade) {
    final market = trade.market;
    final timestamp = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
    _priceWindows.putIfAbsent(market, () => RollingWindow<double>(span: const Duration(seconds: 60))).add(trade.price, timestamp: timestamp);
    _volumeWindows.putIfAbsent(market, () => RollingWindow<double>(span: const Duration(seconds: 300))).add(trade.total, timestamp: timestamp);
    final buyRatioWindow = _buyRatioWindows.putIfAbsent(market, () => RollingWindow<double>(span: const Duration(seconds: 180)));
    buyRatioWindow.add(trade.isBuy ? 1.0 : 0.0, timestamp: timestamp);
    final intervalWindow = _intervalWindows.putIfAbsent(market, () => RollingWindow<double>(span: const Duration(seconds: 600)));
    if (intervalWindow.timestamps.isNotEmpty) {
      final lastTimestamp = intervalWindow.timestamps.last;
      final intervalSeconds = timestamp.difference(lastTimestamp).inSeconds.toDouble();
      intervalWindow.add(intervalSeconds > 0 ? intervalSeconds : 1.0, timestamp: timestamp);
    } else {
      intervalWindow.add(10.0, timestamp: timestamp);
    }
  }
  
  /// ê°€ë²¼ìš´ ê°€ë“œ í—¬í¼ ë©”ì„œë“œ
  bool _shouldAnalyze(String mkt, int tsMs) {
    final last = _lastAnalysisTs[mkt] ?? 0;
    if (tsMs - last < 100) return false; // 100ms ì´ë‚´ ì¬ë¶„ì„ ë°©ì§€
    _lastAnalysisTs[mkt] = tsMs;
    return true;
  }

  /// ğŸ¯ RollingWindow ê¸°ë°˜ íŒ¨í„´ ë¶„ì„ (AppConfig threshold ì œê±°)
  void _analyzePatterns(Trade trade) {
    if (!_shouldAnalyze(trade.market, trade.timestampMs)) return;
    
    try {
      final now = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
      final market = trade.market;

      final priceWindow = _priceWindows[market];
      final volumeWindow = _volumeWindows[market];
      final buyRatioWindow = _buyRatioWindows[market];
      final intervalWindow = _intervalWindows[market];

      if (priceWindow == null || volumeWindow == null) return;

      final detectedSignals = <Signal>[];

      for (final pattern in PatternType.values) {
        if (!_patternEnabled[pattern]!) continue;

        Signal? detectedSignal;

        try {
          switch (pattern) {
            case PatternType.surge:
              detectedSignal = _analyzeSurgePattern(
                trade, now, priceWindow, volumeWindow);
              break;
            case PatternType.flashFire:
              detectedSignal = _analyzeFlashFirePattern(
                trade, now, volumeWindow, buyRatioWindow);
              break;
            case PatternType.stackUp:
              detectedSignal = _analyzeStackUpPattern(
                trade, now, volumeWindow);
              break;
            case PatternType.stealthIn:
              detectedSignal = _analyzeStealthInPattern(
                trade, now, priceWindow, volumeWindow, intervalWindow, buyRatioWindow);
              break;
            case PatternType.blackHole:
              detectedSignal = _analyzeBlackHolePattern(
                trade, now, priceWindow, volumeWindow, buyRatioWindow);
              break;
            case PatternType.reboundShot:
              detectedSignal = _analyzeReboundShotPattern(
                trade, now, priceWindow, volumeWindow);
              break;
          }
        } catch (e, stackTrace) {
          log.w('Pattern analysis error: ${pattern.displayName}', e, stackTrace);
          continue;
        }

        if (detectedSignal != null) {
          detectedSignals.add(detectedSignal);
        }
      }

      for (final signal in detectedSignals) {
        _addSignal(signal.patternType, signal);
      }

      if (detectedSignals.isNotEmpty) {
        _scheduleBatchUpdate();
      }

    } catch (e, stackTrace) {
      log.e('_analyzePatterns error', e, stackTrace);
    }
  }

  /// 1ï¸âƒ£ Surge íŒ¨í„´ ë¶„ì„ (threshold íŒŒë¼ë¯¸í„° ì œê±°)
  Signal? _analyzeSurgePattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> priceWindow,
    RollingWindow<double> volumeWindow,
  ) {
    final market = trade.market;
    final detectionKey = '${market}_surge';

    // ì¤‘ë³µ ë°©ì§€ ë½
    final unlockTime = _detectedMarkets[detectionKey];
    if (unlockTime != null && now.millisecondsSinceEpoch < unlockTime) {
      return null;
    }

    final signal = PatternDetector.detectSurge(
      trade: trade,
      timestamp: now,
      priceWindow: priceWindow,
      volumeWindow: volumeWindow,
    );

    if (signal != null) {
      _detectedMarkets[detectionKey] = now.add(const Duration(minutes: 1)).millisecondsSinceEpoch;
    }

    return signal;
  }

  /// 2ï¸âƒ£ FlashFire íŒ¨í„´ ë¶„ì„ (threshold íŒŒë¼ë¯¸í„° ì œê±°)
  Signal? _analyzeFlashFirePattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> volumeWindow,
    RollingWindow<double>? buyRatioWindow,
  ) {
    return PatternDetector.detectFlashFire(
      trade: trade,
      timestamp: now,
      volumeWindow: volumeWindow,
      buyRatioWindow: buyRatioWindow ?? RollingWindow<double>(span: const Duration(seconds: 180)),
    );
  }

  /// 3ï¸âƒ£ StackUp íŒ¨í„´ ë¶„ì„ (threshold íŒŒë¼ë¯¸í„° ì œê±°)
  Signal? _analyzeStackUpPattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> volumeWindow,
  ) {
    return PatternDetector.detectStackUp(
      trade: trade,
      timestamp: now,
      volumeWindow: volumeWindow,
    );
  }

  /// 4ï¸âƒ£ StealthIn íŒ¨í„´ ë¶„ì„ (priceWindow íŒŒë¼ë¯¸í„° ì¶”ê°€)
  Signal? _analyzeStealthInPattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> priceWindow,     // â† ì¶”ê°€ë¨
    RollingWindow<double> volumeWindow,
    RollingWindow<double>? intervalWindow,
    RollingWindow<double>? buyRatioWindow,
  ) {
    return PatternDetector.detectStealthIn(
      trade: trade,
      timestamp: now,
      priceWindow: priceWindow,            // â† ì¶”ê°€ë¨
      volumeWindow: volumeWindow,
      intervalWindow: intervalWindow ?? RollingWindow<double>(span: const Duration(seconds: 600)),
      buyRatioWindow: buyRatioWindow ?? RollingWindow<double>(span: const Duration(seconds: 180)),
    );
  }

  /// 5ï¸âƒ£ BlackHole íŒ¨í„´ ë¶„ì„ (threshold íŒŒë¼ë¯¸í„° ì œê±°)
  Signal? _analyzeBlackHolePattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> priceWindow,
    RollingWindow<double> volumeWindow,
    RollingWindow<double>? buyRatioWindow,
  ) {
    return PatternDetector.detectBlackHole(
      trade: trade,
      timestamp: now,
      priceWindow: priceWindow,
      volumeWindow: volumeWindow,
      buyRatioWindow: buyRatioWindow ?? RollingWindow<double>(span: const Duration(seconds: 180)),
    );
  }

  /// 6ï¸âƒ£ ReboundShot íŒ¨í„´ ë¶„ì„ (threshold íŒŒë¼ë¯¸í„° ì œê±°)
  Signal? _analyzeReboundShotPattern(
    Trade trade,
    DateTime now,
    RollingWindow<double> priceWindow,
    RollingWindow<double> volumeWindow,
  ) {
    return PatternDetector.detectReboundShot(
      trade: trade,
      timestamp: now,
      priceWindow: priceWindow,
      volumeWindow: volumeWindow,
    );
  }

  /// ğŸš€ ì‹œê·¸ë„ ì¶”ê°€ ë° ê´€ë¦¬
  void _addSignal(PatternType pattern, Signal signal) {
    final signalList = _signalLists[pattern]!;
    
    final cutoff = signal.detectedAt.subtract(const Duration(minutes: 5));
    final isDuplicate = signalList.any((existingSignal) =>
        existingSignal.market == signal.market &&
        existingSignal.detectedAt.isAfter(cutoff));

    if (isDuplicate) return;

    signalList.insert(0, signal);

    if (signalList.length > AppConfig.maxSignalsPerPattern) {
      signalList.removeLast();
    }

    if (kDebugMode) {
      log.i('ğŸš¨ Signal detected: ${signal.patternType.displayName} - ${signal.market} '
          '(${signal.changePercent.toStringAsFixed(2)}%) [PatternDetector ìì²´ ì„¤ì •]');
    }
  }

  /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    if (_batchUpdateTimer?.isActive != true) {
      _batchUpdateTimer = Timer(AppConfig.signalBatchInterval, _updateSignalStreams);
    }
  }

  /// ğŸ“Š ëª¨ë“  ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  void _updateSignalStreams() {
    try {
      for (final entry in _signalLists.entries) {
        final pattern = entry.key;
        final signals = List<Signal>.from(entry.value);

        final controller = _patternControllers[pattern];
        if (controller != null && !controller.isClosed) {
          controller.add(signals);
        }
      }

      final allSignals = _signalLists.values.expand((list) => list).toList();
      allSignals.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
      final recentSignals = allSignals.take(50).toList();

      if (!_allSignalsController.isClosed) {
        _allSignalsController.add(recentSignals);
      }

      if (kDebugMode && allSignals.isNotEmpty) {
        log.d('ğŸš€ Signal streams updated: ${allSignals.length} total signals [PatternDetector ìì²´ ì„¤ì •]');
      }
    } catch (e, stackTrace) {
      log.w('_updateSignalStreams error', e, stackTrace);
    }
  }

  @override
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // PatternDetector ìì²´ ì„¤ì • ì‚¬ìš©ìœ¼ë¡œ ë³€ê²½ë¨
    log.i('ğŸ¯ Pattern threshold update ignored (using PatternDetector internal config): ${patternType.displayName}');
  }

  @override
  double getPatternThreshold(PatternType patternType) {
    // PatternDetectorì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ê´€ë¦¬í•˜ë¯€ë¡œ ê¸°ë³¸ê°’ ë°˜í™˜
    return 0.0;
  }

  @override
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _patternEnabled[patternType] = enabled;
    log.i('ğŸ”„ Pattern ${enabled ? "enabled" : "disabled"}: ${patternType.displayName}');
  }

  @override
  bool isPatternEnabled(PatternType patternType) {
    return _patternEnabled[patternType] ?? true;
  }

  @override
  void clearSignals(PatternType? patternType) {
    if (patternType != null) {
      _signalLists[patternType]?.clear();
    } else {
      for (final signalList in _signalLists.values) {
        signalList.clear();
      }
      _detectedMarkets.clear();
    }
    _scheduleBatchUpdate();
  }
  
  @override
  Future<void> dispose() async {
    log.i('SignalRepositoryImpl: dispose() called');

    _batchUpdateTimer?.cancel();
    _cleanupTimer?.cancel();

    _aggregator.flushTrades(onTradeProcessed: (_) {});

    await _signalSubscription?.cancel();
    _signalStream = null;

    for (final controller in _patternControllers.values) {
      await controller.close();
    }
    await _allSignalsController.close();

    _priceWindows.clear();
    _volumeWindows.clear();
    _buyRatioWindows.clear();
    _intervalWindows.clear();

    log.i('SignalRepositoryImpl: dispose completed [PatternDetector ìì²´ ì„¤ì •]');
  }
}\n\n// ====== lib/data/factories/signal_stream_factory.dart ======\n
\n\n// ====== lib/domain/repositories/signal_repository.dart ======\n
// lib/domain/repositories/signal_repository.dart

import '../entities/signal.dart';

/// Signal Repository ì¸í„°í˜ì´ìŠ¤
abstract class SignalRepository {
  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  );

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets);

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updatePatternThreshold(PatternType patternType, double threshold);

  /// í˜„ì¬ ì„¤ì •ëœ íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType);

  /// íŒ¨í„´ë³„ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled);

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType);

  /// ê°ì§€ëœ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearSignals(PatternType? patternType);

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/signal_usecase.dart ======\n
// lib/domain/usecases/signal_usecase.dart

import '../entities/signal.dart';
import '../repositories/signal_repository.dart';

/// Signal ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì²˜ë¦¬í•˜ëŠ” UseCase
class SignalUseCase {
  final SignalRepository _repository;

  const SignalUseCase(this._repository);

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    return _repository.watchSignalsByPattern(patternType, markets);
  }

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    return _repository.watchAllSignals(markets);
  }

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    if (threshold <= 0) {
      throw ArgumentError('Threshold must be positive: $threshold');
    }

    // íŒ¨í„´ë³„ ì„ê³„ê°’ ë²”ìœ„ ê²€ì¦
    switch (patternType) {
      case PatternType.surge:
        if (threshold < 0.1 || threshold > 50.0) {
          throw ArgumentError('Surge threshold must be between 0.1% and 50%: $threshold');
        }
        break;
      case PatternType.flashFire:
        if (threshold < 1.1 || threshold > 10.0) {
          throw ArgumentError('FlashFire threshold must be between 1.1x and 10x: $threshold');
        }
        break;
      case PatternType.stackUp:
        if (threshold < 2 || threshold > 10) {
          throw ArgumentError('StackUp threshold must be between 2 and 10: $threshold');
        }
        break;
      case PatternType.stealthIn:
        if (threshold < 1000000 || threshold > 100000000) {
          throw ArgumentError('StealthIn threshold must be between 1M and 100M: $threshold');
        }
        break;
      case PatternType.blackHole:
        if (threshold < 0.01 || threshold > 5.0) {
          throw ArgumentError('BlackHole threshold must be between 0.01% and 5%: $threshold');
        }
        break;
      case PatternType.reboundShot:
        if (threshold < 0.5 || threshold > 20.0) {
          throw ArgumentError('ReboundShot threshold must be between 0.5% and 20%: $threshold');
        }
        break;
    }

    _repository.updatePatternThreshold(patternType, threshold);
  }

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType) {
    return _repository.getPatternThreshold(patternType);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _repository.setPatternEnabled(patternType, enabled);
  }

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType) {
    return _repository.isPatternEnabled(patternType);
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearPatternSignals(PatternType patternType) {
    _repository.clearSignals(patternType);
  }

  /// ëª¨ë“  ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearAllSignals() {
    _repository.clearSignals(null);
  }

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ ê³„ì‚°
  SignalStats calculateStats(List<Signal> signals) {
    if (signals.isEmpty) {
      return const SignalStats(
        totalCount: 0,
        patternCounts: {},
        avgChangePercent: 0.0,
        maxChangePercent: 0.0,
        minChangePercent: 0.0,
        totalTradeAmount: 0.0,
      );
    }

    final patternCounts = <PatternType, int>{};
    double totalChangePercent = 0.0;
    double maxChangePercent = signals.first.changePercent;
    double minChangePercent = signals.first.changePercent;
    double totalTradeAmount = 0.0;

    for (final signal in signals) {
      // íŒ¨í„´ë³„ ì¹´ìš´íŠ¸
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;

      // ë³€í™”ìœ¨ í†µê³„
      totalChangePercent += signal.changePercent;
      if (signal.changePercent > maxChangePercent) {
        maxChangePercent = signal.changePercent;
      }
      if (signal.changePercent < minChangePercent) {
        minChangePercent = signal.changePercent;
      }

      // ê±°ë˜ëŒ€ê¸ˆ í•©ê³„
      totalTradeAmount += signal.tradeAmount;
    }

    return SignalStats(
      totalCount: signals.length,
      patternCounts: patternCounts,
      avgChangePercent: totalChangePercent / signals.length,
      maxChangePercent: maxChangePercent,
      minChangePercent: minChangePercent,
      totalTradeAmount: totalTradeAmount,
    );
  }

  /// ì‹œê·¸ë„ í•„í„°ë§ (ë³€í™”ìœ¨, ê±°ë˜ëŒ€ê¸ˆ ë“±)
  List<Signal> filterSignals(
    List<Signal> signals, {
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
  }) {
    return signals.where((signal) {
      // ë³€í™”ìœ¨ í•„í„°
      if (minChangePercent != null && signal.changePercent < minChangePercent) {
        return false;
      }
      if (maxChangePercent != null && signal.changePercent > maxChangePercent) {
        return false;
      }

      // ê±°ë˜ëŒ€ê¸ˆ í•„í„°
      if (minTradeAmount != null && signal.tradeAmount < minTradeAmount) {
        return false;
      }
      if (maxTradeAmount != null && signal.tradeAmount > maxTradeAmount) {
        return false;
      }

      // íŒ¨í„´ íƒ€ì… í•„í„°
      if (patternTypes != null && !patternTypes.contains(signal.patternType)) {
        return false;
      }

      // ì‹œê°„ ìœˆë„ìš° í•„í„°
      if (timeWindow != null) {
        final cutoff = DateTime.now().subtract(timeWindow);
        if (signal.detectedAt.isBefore(cutoff)) {
          return false;
        }
      }

      return true;
    }).toList();
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    await _repository.dispose();
  }
}

/// Signal í†µê³„ ì •ë³´ í´ë˜ìŠ¤
class SignalStats {
  final int totalCount;
  final Map<PatternType, int> patternCounts;
  final double avgChangePercent;
  final double maxChangePercent;
  final double minChangePercent;
  final double totalTradeAmount;

  const SignalStats({
    required this.totalCount,
    required this.patternCounts,
    required this.avgChangePercent,
    required this.maxChangePercent,
    required this.minChangePercent,
    required this.totalTradeAmount,
  });

  @override
  String toString() {
    return 'SignalStats(total: $totalCount, avg: ${avgChangePercent.toStringAsFixed(2)}%, '
        'max: ${maxChangePercent.toStringAsFixed(2)}%, min: ${minChangePercent.toStringAsFixed(2)}%)';
  }
}\n\n// ====== lib/domain/entities/signal.dart ======\n
// lib/domain/entities/signal.dart

/// Signal íŒ¨í„´ íƒ€ì… ì •ì˜
enum PatternType {
  surge,       // 1. ê¸‰ë“± (1ë¶„ ì „ ëŒ€ë¹„ 1.1% ìƒìŠ¹)
  flashFire,   // 2. ë¶ˆí‹°ğŸ”¥ (3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦)
  stackUp,     // 3. ìŠ¤íƒì—…ğŸ’° (1ë¶„ì”© 3ì—°ì† ì¦ê°€)
  stealthIn,   // 4. ì¹¨íˆ¬ìğŸ‘£ (ì†ŒëŸ‰ ì§€ì† ìœ ì…)
  blackHole,   // 5. ë¸”ë™í™€ğŸ•³ï¸ (ê±°ë˜ëŒ€ê¸ˆâ†‘ ê°€ê²©ë³€ë™â†“)
  reboundShot, // 6. ì‡¼íŠ¸í„°ì¹˜âš¡ (ê¸‰ë½ í›„ ë°˜ë“±)
}

extension PatternTypeExtension on PatternType {
  String get displayName {
    switch (this) {
      case PatternType.surge:
        return 'ê¸‰ë“±';
      case PatternType.flashFire:
        return 'ë¶ˆí‹°ğŸ”¥';
      case PatternType.stackUp:
        return 'ìŠ¤íƒì—…ğŸ’°';
      case PatternType.stealthIn:
        return 'ì¹¨íˆ¬ìğŸ‘£';
      case PatternType.blackHole:
        return 'ë¸”ë™í™€ğŸ•³ï¸';
      case PatternType.reboundShot:
        return 'ì‡¼íŠ¸í„°ì¹˜âš¡';
    }
  }

  String get description {
    switch (this) {
      case PatternType.surge:
        return '1ë¶„ ì „ ëŒ€ë¹„ 1.1% ì´ìƒ ìƒìŠ¹';
      case PatternType.flashFire:
        return '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ ê°ì§€';
      case PatternType.stackUp:
        return 'ì—°ì† ë§¤ì§‘ íŒ¨í„´ ê°ì§€';
      case PatternType.stealthIn:
        return 'ì€ë°€í•œ ìœ ì… ê°ì§€';
      case PatternType.blackHole:
        return 'ì´ìƒ ì²´ê²° íŒ¨í„´ ê°ì§€';
      case PatternType.reboundShot:
        return 'ë°˜ë“± íƒ€ì´ë° ê°ì§€';
    }
  }

  /// íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’
  double get defaultThreshold {
    switch (this) {
      case PatternType.surge:
        return 1.1; // 1.1% ìƒìŠ¹
      case PatternType.flashFire:
        return 2.0; // 2ë°° ê¸‰ì¦
      case PatternType.stackUp:
        return 3.0; // 3ì—°ì†
      case PatternType.stealthIn:
        return 5000000.0; // 500ë§Œì› ì´ìƒ ì§€ì†
      case PatternType.blackHole:
        return 0.1; // 0.1% ì´í•˜ ë³€ë™
      case PatternType.reboundShot:
        return 1.5; // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
    }
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  int get timeWindowMinutes {
    switch (this) {
      case PatternType.surge:
        return 1; // 1ë¶„
      case PatternType.flashFire:
        return 3; // 3ë¶„
      case PatternType.stackUp:
        return 3; // 3ë¶„ (1ë¶„ì”© 3ë²ˆ)
      case PatternType.stealthIn:
        return 5; // 5ë¶„
      case PatternType.blackHole:
        return 3; // 3ë¶„
      case PatternType.reboundShot:
        return 2; // 2ë¶„ (ê¸‰ë½ 1ë¶„ + ë°˜ë“± 1ë¶„)
    }
  }
}

/// Signal ê°ì§€ ê²°ê³¼ ì—”í‹°í‹°
class Signal {
  final String market;
  final String name;
  final double currentPrice;
  final double changePercent;
  final double volume;
  final double tradeAmount;
  final DateTime detectedAt;
  final PatternType patternType;
  final Map<String, dynamic> patternDetails;

  const Signal({
    required this.market,
    required this.name,
    required this.currentPrice,
    required this.changePercent,
    required this.volume,
    required this.tradeAmount,
    required this.detectedAt,
    required this.patternType,
    required this.patternDetails,
  });

  /// ê±°ë˜ ì´ì•¡ ê³„ì‚°
  double get total => currentPrice * volume;

  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');

  /// íŒ¨í„´ë³„ íŠ¹í™” ì •ë³´ getterë“¤
  
  /// Surge ì „ìš©: ê¸°ì¤€ê°€ (1ë¶„ ì „ ê°€ê²©)
  double? get basePrice => patternDetails['basePrice'] as double?;
  
  /// FlashFire ì „ìš©: ê¸‰ì¦ ë°°ìœ¨
  double? get surgeMultiplier => patternDetails['surgeMultiplier'] as double?;
  
  /// StackUp ì „ìš©: ì—°ì† ì¦ê°€ íšŸìˆ˜
  int? get consecutiveCount => patternDetails['consecutiveCount'] as int?;
  
  /// StealthIn ì „ìš©: ì§€ì† ì‹œê°„ (ì´ˆ)
  int? get sustainedSeconds => patternDetails['sustainedSeconds'] as int?;
  
  /// BlackHole ì „ìš©: ê°€ê²© ë³€ë™ë¥ 
  double? get priceStability => patternDetails['priceStability'] as double?;
  
  /// ReboundShot ì „ìš©: ë°˜ë“± ê°•ë„
  double? get reboundStrength => patternDetails['reboundStrength'] as double?;

  Signal copyWith({
    String? market,
    String? name,
    double? currentPrice,
    double? changePercent,
    double? volume,
    double? tradeAmount,
    DateTime? detectedAt,
    PatternType? patternType,
    Map<String, dynamic>? patternDetails,
  }) {
    return Signal(
      market: market ?? this.market,
      name: name ?? this.name,
      currentPrice: currentPrice ?? this.currentPrice,
      changePercent: changePercent ?? this.changePercent,
      volume: volume ?? this.volume,
      tradeAmount: tradeAmount ?? this.tradeAmount,
      detectedAt: detectedAt ?? this.detectedAt,
      patternType: patternType ?? this.patternType,
      patternDetails: patternDetails ?? this.patternDetails,
    );
  }

  @override
  String toString() {
    return 'Signal(market: $market, pattern: ${patternType.displayName}, '
        'price: $currentPrice, change: ${changePercent.toStringAsFixed(2)}%, '
        'at: $detectedAt)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Signal &&
        other.market == market &&
        other.detectedAt == detectedAt &&
        other.patternType == patternType;
  }

  @override
  int get hashCode {
    return market.hashCode ^ detectedAt.hashCode ^ patternType.hashCode;
  }
}\n\n// ====== lib/presentation/controllers/signal_controller.dart ======\n
// lib/presentation/controllers/signal_controller.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/signal_provider.dart';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/usecases/signal_usecase.dart';

/// Signal í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class SignalState {
  final List<Signal> signals;
  final bool isLoading;
  final bool isConnected;
  final PatternType currentPattern;
  final int selectedIndex;
  final double threshold;
  final bool isPatternEnabled;
  final String? errorMessage;

  const SignalState({
    this.signals = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.currentPattern = PatternType.surge,
    this.selectedIndex = 0,
    this.threshold = 1.1,
    this.isPatternEnabled = true,
    this.errorMessage,
  });

  SignalState copyWith({
    List<Signal>? signals,
    bool? isLoading,
    bool? isConnected,
    PatternType? currentPattern,
    int? selectedIndex,
    double? threshold,
    bool? isPatternEnabled,
    String? errorMessage,
  }) {
    return SignalState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      currentPattern: currentPattern ?? this.currentPattern,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      threshold: threshold ?? this.threshold,
      isPatternEnabled: isPatternEnabled ?? this.isPatternEnabled,
      errorMessage: errorMessage,
    );
  }
}

/// Signal í™”ë©´ ì „ìš© ViewModel
class SignalController extends StateNotifier<SignalState> {
  final SignalUseCase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Signal>, AppException>>? _subscription;

  SignalController(this._usecase, this._ref) : super(const SignalState());

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™)
  void setPatternIndex(int index, List<String> markets) {
    if (index < 0 || index >= AppConfig.signalPatterns.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index');
      }
      return;
    }

    final patternName = AppConfig.getSignalPatternByIndex(index);
    final patternType = _getPatternTypeFromName(patternName);
    final defaultThreshold = AppConfig.getSignalThreshold(patternName);

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    final controller = _ref.read(signalPatternController);
    controller.updatePatternIndex(index);

    state = state.copyWith(
      currentPattern: patternType,
      selectedIndex: index,
      threshold: defaultThreshold,
      isLoading: true,
      errorMessage: null,
    );

    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _subscribeToPattern(patternType, markets);
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½
  void updateThreshold(double threshold) {
    final controller = _ref.read(signalPatternController);
    controller.updateThreshold(threshold);

    state = state.copyWith(threshold: threshold);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€
  void togglePatternEnabled() {
    final newEnabled = !state.isPatternEnabled;
    final controller = _ref.read(signalPatternController);
    controller.setPatternEnabled(state.currentPattern, newEnabled);

    state = state.copyWith(isPatternEnabled: newEnabled);
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearSignals([PatternType? pattern]) {
    final controller = _ref.read(signalPatternController);
    controller.clearSignals(pattern);

    if (pattern == null || pattern == state.currentPattern) {
      state = state.copyWith(signals: []);
    }
  }

  /// íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  void _subscribeToPattern(PatternType patternType, List<String> markets) {
    _subscription?.cancel();
    _subscription = _usecase
        .watchSignalsByPattern(patternType, markets)
        .map((signals) => Ok<List<Signal>, AppException>(signals))
        .handleError((error) => Err<List<Signal>, AppException>(
            AppException(
              'Signal pattern detection failed: ${error.toString()}',
              code: 'SIGNAL_PATTERN_ERROR',
              originalException: error is Exception ? error : null,
            )))
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Signal>, AppException> result) {
    result.when(
      ok: (signals) {
        state = state.copyWith(
          signals: signals,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨
  void refresh(List<String> markets) {
    setPatternIndex(state.selectedIndex, markets);
  }

  /// í˜„ì¬ íŒ¨í„´ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„±
  String getPatternDisplayText() {
    final patternName = _getPatternNameFromType(state.currentPattern);
    final displayName = AppConfig.getSignalPatternName(patternName);
    final description = AppConfig.getSignalPatternDescription(patternName);
    return '$displayName: $description';
  }

  /// í˜„ì¬ íŒ¨í„´ ì•„ì´ì½˜/ì´ëª¨ì§€
  String getPatternIcon() {
    return state.currentPattern.displayName;
  }

/// ì„ê³„ê°’ í‘œì‹œ í…ìŠ¤íŠ¸
  String getThresholdDisplayText() {
    final threshold = state.threshold;

    switch (state.currentPattern) {
      case PatternType.surge:
        return '${threshold.toStringAsFixed(1)}% ìƒìŠ¹';
      case PatternType.flashFire:
        return '${threshold.toStringAsFixed(1)}ë°° ê¸‰ì¦';
      case PatternType.stackUp:
        return '${threshold.toInt()}ì—°ì† ì¦ê°€';
      case PatternType.stealthIn:
        final amountText = threshold >= 1000000 
            ? '${(threshold / 1000000).toStringAsFixed(0)}ë°±ë§Œì›'
            : '${threshold.toStringAsFixed(0)}ì›';
        return '$amountText ì´ìƒ';
      case PatternType.blackHole:
        return '${threshold.toStringAsFixed(2)}% ì´í•˜ ë³€ë™';
      case PatternType.reboundShot:
        return '${threshold.toStringAsFixed(1)}% ê¸‰ë½ í›„ ë°˜ë“±';
    }
  }

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´
  Map<String, dynamic> getSignalStats() {
    final controller = _ref.read(signalPatternController);
    return controller.getPatternStats();
  }

  /// ì‹œê·¸ë„ í•„í„°ë§ (ë§ˆì¼“ëª…)
  List<Signal> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.signals;
    }
    final upper = marketFilter.toUpperCase();
    return state.signals.where((s) => s.market.contains(upper)).toList();
  }

  /// ì‹œê·¸ë„ ì •ë ¬
  void sortSignals(String field, bool ascending) {
    final list = [...state.signals];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.currentPrice;
          bValue = b.currentPrice;
          break;
        case 'change':
          aValue = a.changePercent;
          bValue = b.changePercent;
          break;
        case 'amount':
          aValue = a.tradeAmount;
          bValue = b.tradeAmount;
          break;
        case 'time':
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
          break;
        default:
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(signals: list);
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì ìš© (ì •ë ¬ ë“±)
  List<Signal> apply(List<Signal> signals) {
    final filtered = [...signals];
    // ìµœì‹  ì‹œê·¸ë„ ìˆœìœ¼ë¡œ ì •ë ¬
    filtered.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
    return filtered;
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ëª©ë¡
  List<String> get availablePatterns => AppConfig.signalPatterns;

  /// íŒ¨í„´ í‘œì‹œëª… ëª©ë¡
  List<String> get patternDisplayNames => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternName(p)).toList();

  /// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê°„ ìœˆë„ìš°
  int get currentTimeWindow {
    final patternName = _getPatternNameFromType(state.currentPattern);
    return AppConfig.getSignalTimeWindow(patternName);
  }

  /// Helper: PatternTypeì„ AppConfig íŒ¨í„´ëª…ìœ¼ë¡œ ë³€í™˜
  String _getPatternNameFromType(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return 'surge';
      case PatternType.flashFire:
        return 'flashFire';
      case PatternType.stackUp:
        return 'stackUp';
      case PatternType.stealthIn:
        return 'stealthIn';
      case PatternType.blackHole:
        return 'blackHole';
      case PatternType.reboundShot:
        return 'reboundShot';
    }
  }

  /// Helper: AppConfig íŒ¨í„´ëª…ì„ PatternTypeìœ¼ë¡œ ë³€í™˜
  PatternType _getPatternTypeFromName(String patternName) {
    switch (patternName) {
      case 'surge':
        return PatternType.surge;
      case 'flashFire':
        return PatternType.flashFire;
      case 'stackUp':
        return PatternType.stackUp;
      case 'stealthIn':
        return PatternType.stealthIn;
      case 'blackHole':
        return PatternType.blackHole;
      case 'reboundShot':
        return PatternType.reboundShot;
      default:
        return PatternType.surge; // ê¸°ë³¸ê°’
    }
  }

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final signalControllerProvider =
    StateNotifierProvider<SignalController, SignalState>((ref) {
  final usecase = ref.read(signalUsecaseProvider);
  return SignalController(usecase, ref);
});\n\n// ====== lib/presentation/pages/signal_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/settings_provider.dart'; // ì„¤ì • provider
import '../../core/di/signal_provider.dart';
import '../../core/di/trade_provider.dart'; // marketsProvider
import '../../domain/entities/app_settings.dart'; // SliderPosition enum
import '../../domain/entities/signal.dart'; // PatternType import
import '../controllers/signal_controller.dart';
import '../widgets/signal_tile.dart';

class SignalPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SignalPage({
    super.key,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Controller ê¸°ë°˜ ì‹œìŠ¤í…œìœ¼ë¡œ ì™„ì „ í†µì¼
    final controller = ref.watch(signalControllerProvider.notifier);
    final state = ref.watch(signalControllerProvider);

    // ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼
    final signalsAsync = ref.watch(signalListProvider);

    // markets ì •ë³´ í•„ìš”
    final marketsAsync = ref.watch(marketsProvider);

    // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(
      controller,
      state,
      marketsAsync,
      ref,
    );

    // ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final signalListWidget = _buildSignalList(
      signalsAsync,
      controller,
      scrollController,
      state,
      context,
      ref,
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,

          // ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: signalListWidget),

          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± - 2ì¤„ë¡œ ê¹”ë”í•˜ê²Œ ì •ë¦¬
  Widget _buildSliderWidget(
    SignalController controller,
    SignalState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
  ) {
    const patterns = AppConfig.signalPatterns;
    final patternNames =
        patterns.map((p) => AppConfig.getSignalPatternName(p)).toList();

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì²« ë²ˆì§¸ ì¤„: ì•„ì´ì½˜ + ì œëª© + ì„¤ëª… + í™œì„±í™” í† ê¸€
          Row(
            children: [
              // ì•„ì´ì½˜ + ì œëª© + ì„¤ëª…
              Expanded(
                child: Row(
                  children: [
                    // íŒ¨í„´ ì•„ì´ì½˜
                    Icon(
                      _getPatternIcon(state.currentPattern),
                      size: 18,
                      color: _getPatternColor(state.currentPattern),
                    ),
                    const SizedBox(width: 8),
                    // ì œëª©: ì„¤ëª… í˜•íƒœ
                    Expanded(
                      child: Text(
                        '${_getPatternName(state.currentPattern)}: ${_getPatternDescription(state.currentPattern)}',
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ),

              // í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€ ë²„íŠ¼
              GestureDetector(
                onTap: () {
                  if (ref.read(appSettingsProvider).isHapticEnabled) {
                    HapticFeedback.lightImpact();
                  }
                  controller.togglePatternEnabled();
                },
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.orange,
                      width: 1.5,
                    ),
                    color: state.isPatternEnabled
                        ? Colors.orange
                        : Colors.transparent,
                  ),
                  child: Text(
                    state.isPatternEnabled ? 'í™œì„±' : 'ë¹„í™œì„±',
                    style: TextStyle(
                      color:
                          state.isPatternEnabled ? Colors.white : Colors.orange,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ),
            ],
          ),

          const SizedBox(height: 2),

          // ğŸ¯ ë‘ ë²ˆì§¸ ì¤„: ì„ê³„ê°’ í‘œì‹œ (ì›ë˜ í˜•íƒœ ìœ ì§€)
          Row(
            children: [
              const SizedBox(width: 26), // ì²« ë²ˆì§¸ "ì„ê³„ê°’:" ìë¦¬ë§Œí¼ ê³µë°±
              Text(
                'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ],
          ),

          const SizedBox(height: 8),

          // íŒ¨í„´ ìŠ¬ë¼ì´ë” (ê¸°ëŠ¥ ì „í™˜)
          Slider(
            value: state.selectedIndex.toDouble(),
            min: 0,
            max: (patterns.length - 1).toDouble(),
            divisions: patterns.length - 1,
            label: patternNames[state.selectedIndex],
            onChanged: (v) {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact();
              }
              final index = v.round();
              // Controllerë¥¼ í†µí•´ íŒ¨í„´ ë³€ê²½
              marketsAsync.whenData((markets) {
                controller.setPatternIndex(index, markets);
              });
            },
          ),
        ],
      ),
    );
  }

  /// íŒ¨í„´ë³„ ì•„ì´ì½˜ ë°˜í™˜
  IconData _getPatternIcon(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// íŒ¨í„´ë³„ ìƒ‰ìƒ ë°˜í™˜
  Color _getPatternColor(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }

  /// íŒ¨í„´ë³„ ì´ë¦„ ë°˜í™˜
  String _getPatternName(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return 'ê¸‰ë“±';
      case PatternType.flashFire:
        return 'ë¶ˆí‹°';
      case PatternType.stackUp:
        return 'ìŠ¤íƒì—…';
      case PatternType.stealthIn:
        return 'ì¹¨íˆ¬ì';
      case PatternType.blackHole:
        return 'ë¸”ë™í™€';
      case PatternType.reboundShot:
        return 'ì‡¼íŠ¸í„°ì¹˜';
    }
  }

  /// íŒ¨í„´ë³„ ì„¤ëª… ë°˜í™˜
  String _getPatternDescription(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return '3ë¶„ ê°€ê²© ê¸‰ë“±ê°ì§€';
      case PatternType.flashFire:
        return '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ê°ì§€';
      case PatternType.stackUp:
        return 'ì—°ì† ë§¤ì§‘ ê°ì§€';
      case PatternType.stealthIn:
        return 'ì€ë°€í•œ ìœ ì… ê°ì§€';
      case PatternType.blackHole:
        return 'ì•ˆì •ì  í¡ìˆ˜ ê°ì§€';
      case PatternType.reboundShot:
        return 'ë‹¨íƒ€ ë°˜ë“± ê°ì§€';
    }
  }

  /// ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ê°œì„  (Tradeì™€ ë™ì¼)
  Widget _buildSignalList(
    AsyncValue<List<Signal>> signalsAsync,
    SignalController controller,
    ScrollController scrollController,
    SignalState state,
    BuildContext context,
    WidgetRef ref,
  ) {
    return signalsAsync.when(
      data: (list) {
        final viewList = controller.apply(list);

        if (viewList.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.radar,
                  size: 64,
                  color: Theme.of(context).hintColor.withAlpha(128),
                ),
                const SizedBox(height: 16),
                Text(
                  state.isPatternEnabled
                      ? '${_getPatternName(state.currentPattern)} íŒ¨í„´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
                      : 'íŒ¨í„´ ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                      color: Theme.of(context).hintColor, fontSize: 16),
                ),
                const SizedBox(height: 8),
                Text(
                  'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color: Theme.of(context).hintColor.withAlpha(179),
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          );
        }

        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: false,
          trackVisibility: false,
          thickness: 6.4,
          radius: const Radius.circular(3.2),
          thumbColor: Colors.orange.withAlpha(128),
          interactive: true,
          minThumbLength: 40,
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding:
                const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
            itemCount: viewList.length,
            itemBuilder: (_, i) => SignalTile(signal: viewList[i]),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 64,
              color: Theme.of(context).colorScheme.error.withAlpha(128),
            ),
            const SizedBox(height: 16),
            Text(
              'ì‹œê·¸ë„ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              '$e',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Theme.of(context).hintColor,
                fontSize: 14,
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: () {
                ref.invalidate(signalListProvider);
              },
              icon: const Icon(Icons.refresh),
              label: const Text('ë‹¤ì‹œ ì‹œë„'),
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.orange,
                foregroundColor: Colors.white,
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/signal_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart'; // appSettingsProvider ì¶”ê°€
import '../../domain/entities/signal.dart';
import '../../shared/widgets/amount_display_widget.dart'; // ê±°ë˜ëŒ€ê¸ˆ í‘œì‹œ
import '../../shared/widgets/coin_logo_provider.dart'; // ì½”ì¸ ë¡œê³  í”„ë¡œë°”ì´ë”
import '../../shared/utils/tile_common.dart'; // ğŸ¯ ê³µí†µ ìœ í‹¸ë¦¬í‹°
import '../../shared/utils/blink_animation_mixin.dart'; // âœ¨ ë°˜ì§ì„ í—¬í¼
import '../../shared/utils/amount_formatter.dart'; // ğŸ’° í¬ë§·í„° ìœ í‹¸ë¦¬í‹°

// ğŸ¯ ì¤‘ë³µ ë°˜ì§ì„ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ Set
final Set<String> _blinkedSignals = {};

class SignalTile extends ConsumerStatefulWidget {
  final Signal signal;

  const SignalTile({super.key, required this.signal});

  @override
  ConsumerState<SignalTile> createState() => _SignalTileState();
}

class _SignalTileState extends ConsumerState<SignalTile>
    with SingleTickerProviderStateMixin {
  
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 800), // Signalì€ ì¡°ê¸ˆ ë” ê¸¸ê²Œ
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.2).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );

    _checkNewSignal();
  }

  /// ğŸ¯ ìƒˆë¡œìš´ ì‹œê·¸ë„ ê°ì§€ ë° ë°˜ì§ì„ ì²˜ë¦¬ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
  void _checkNewSignal() {
    final signalKey = '${widget.signal.market}_${widget.signal.detectedAt.millisecondsSinceEpoch}';
    
    if (BlinkAnimationHelper.checkNewSignal(
      blinkedSignalsSet: _blinkedSignals,
      detectedAt: widget.signal.detectedAt,
      signalKey: signalKey,
      maxAgeSeconds: 10,
    )) {
      _startBlink();
    }
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ¯ íŒ¨í„´ë³„ ìƒì„¸ ì •ë³´ í…ìŠ¤íŠ¸ (ê¸°ì¡´ ìœ ì§€ - ì‹œê·¸ë„ ì „ìš© ë¡œì§)
  String _getPatternDetail() {
    final pattern = widget.signal.patternType;

    switch (pattern) {
      case PatternType.surge:
        final basePrice = widget.signal.basePrice;
        if (basePrice != null) {
          return 'ê¸°ì¤€ê°€: ${AmountFormatter.formatPrice(basePrice)}ì›'; // âœ… ê³µí†µ í¬ë§·í„°
        }
        return 'ê¸‰ë“± ê°ì§€';

      case PatternType.flashFire:
        final multiplier = widget.signal.surgeMultiplier;
        if (multiplier != null) {
          return '${multiplier.toStringAsFixed(1)}ë°° ê¸‰ì¦';
        }
        return 'ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦';

      case PatternType.stackUp:
        final count = widget.signal.consecutiveCount;
        if (count != null) {
          return '$countì—°ì† ì¦ê°€';
        }
        return 'ì—°ì† ë§¤ì§‘';

      case PatternType.stealthIn:
        final seconds = widget.signal.sustainedSeconds;
        if (seconds != null) {
          final minutes = (seconds / 60).toInt();
          return '$minutesë¶„ê°„ ìœ ì…';
        }
        return 'ì€ë°€í•œ ìœ ì…';

      case PatternType.blackHole:
        final stability = widget.signal.priceStability;
        if (stability != null) {
          return 'ë³€ë™: ${stability.toStringAsFixed(2)}%';
        }
        return 'ê°€ê²© ì•ˆì •';

      case PatternType.reboundShot:
        final strength = widget.signal.reboundStrength;
        if (strength != null) {
          return 'ë°˜ë“±: ${strength.toStringAsFixed(1)}%';
        }
        return 'ë°˜ë“± ê°ì§€';
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);

    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 13
          FlexChild.expanded(
            Text(
              _timeFormat.format(widget.signal.detectedAt),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 13,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.signal.market.replaceFirst('KRW-', ''),
              radius: 14,
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸª™ ì½”ì¸ëª… + íŒ¨í„´ ì •ë³´: flex 24
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.signal.market), // âœ… ê³µí†µ í•¨ìˆ˜
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ†• NEW ë±ƒì§€
                    if (TileCommon.buildNewBadge(widget.signal.detectedAt) case final badge?) 
                      badge, // âœ… ê³µí†µ í•¨ìˆ˜
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  _getPatternDetail(), // âœ… ì‹œê·¸ë„ ì „ìš© í•¨ìˆ˜
                  style: TextStyle(
                    color: onSurface70,
                    fontSize: 11,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 24,
          ),

          // ğŸ’µ ê°€ê²© + ë³€í™”ìœ¨: flex 18
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(widget.signal.currentPrice)}ì›', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface, fontSize: 13),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  TileCommon.formatChangePercent(widget.signal.changePercent), // âœ… ê³µí†µ í•¨ìˆ˜
                  style: TextStyle(
                    color: TileCommon.getChangeColor(widget.signal.changePercent), // âœ… ê³µí†µ í•¨ìˆ˜
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 18,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ’° ê±°ë˜ëŒ€ê¸ˆ: flex 18 (AmountDisplayWidget ì‚¬ìš©)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: widget.signal.tradeAmount,
                isBuy: widget.signal.changePercent >= 0, // ìƒìŠ¹ì´ë©´ ë§¤ìˆ˜ ìƒ‰ìƒ
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            flex: 18,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬ ì¶”ê°€)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    return blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: widget.signal.patternType == PatternType.surge
                ? Colors.red
                : Colors.orange, // íŒ¨í„´ì— ë”°ë¥¸ ìƒ‰ìƒ
          )
        : cardWidget;
  }
}