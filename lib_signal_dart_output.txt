\n\n// ====== lib/core/di/signal_provider.dart ======\n
// lib/core/di/signal_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import '../utils/pattern_detector.dart';
import '../utils/pattern_config.dart';
import '../utils/advanced_metrics.dart';
import 'trade_provider.dart'; // ì „ì²´ import (app_providers.dart íŒ¨í„´)
import '../../data/repositories/signal_repository_impl.dart';
import '../../domain/entities/signal.dart';
import '../../domain/repositories/signal_repository.dart';
import '../../domain/usecases/signal_usecase.dart';

// ==========================================================================
// ğŸš€ Clean Architecture V4.1 - ë‹¨ë°©í–¥ ë°ì´í„° íë¦„
// ==========================================================================

/// AdvancedMetrics Provider (ì˜¨ë¼ì¸ ê³„ì‚°ê¸° ê´€ë¦¬)
final advancedMetricsProvider = Provider<AdvancedMetrics>((ref) {
  final metrics = AdvancedMetrics(
    maxGap: const Duration(seconds: 10),
    staleThreshold: const Duration(seconds: 30),
  );
  
  ref.onDispose(() {
    metrics.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ AdvancedMetrics disposed');
    }
  });
  
  return metrics;
});

/// PatternDetector Provider (ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì…)
final patternDetectorProvider = Provider<PatternDetector>((ref) {
  final metrics = ref.watch(advancedMetricsProvider);
  
  // ğŸ”§ PatternConfigë¥¼ Repository ë‚´ë¶€ì—ì„œë§Œ ìƒì„±í•˜ë„ë¡ ë³€ê²½
  final detector = PatternDetector(
    config: PatternConfig(), // ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìƒì„±
    metrics: metrics,
  );
  
  ref.onDispose(() {
    detector.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ PatternDetector disposed');
    }
  });
  
  return detector;
});

/// Signal Repository Provider (ë‹¨ì¼ ì§„ì‹¤ì˜ ì›ì²œ)
final signalRepoProvider = Provider<SignalRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider);
  final patternDetector = ref.watch(patternDetectorProvider);
  
  // ğŸ”§ Repositoryê°€ ìì²´ì ìœ¼ë¡œ PatternConfig ê´€ë¦¬
  final repository = SignalRepositoryImpl(
    remoteDS,
    patternDetector: patternDetector,
    patternConfig: PatternConfig(), // Repositoryê°€ ì§ì ‘ ê´€ë¦¬
  );
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ SignalRepository disposed - Clean Architecture');
    }
  });
  
  return repository;
});

/// Signal UseCase Provider (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê³„ì¸µ)
final signalUsecaseProvider = Provider<SignalUseCase>((ref) {
  final repository = ref.read(signalRepoProvider);
  return SignalUseCase(repository);
});

// ==========================================================================
// ğŸ¯ UI ìƒíƒœ ê´€ë¦¬ Providers (ìµœì†Œí™”)
// ==========================================================================

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ ì¸ë±ìŠ¤ (ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë§Œ)
final signalPatternIndexProvider = StateProvider<int>((_) => 0);

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ íƒ€ì… (UI í‘œì‹œìš©)
final signalPatternTypeProvider = StateProvider<PatternType>((ref) {
  final index = ref.watch(signalPatternIndexProvider);
  final patternName = AppConfig.getSignalPatternByIndex(index);
  
  switch (patternName) {
    case 'surge':
      return PatternType.surge;
    case 'flashFire':
      return PatternType.flashFire;
    case 'stackUp':
      return PatternType.stackUp;
    case 'stealthIn':
      return PatternType.stealthIn;
    case 'blackHole':
      return PatternType.blackHole;
    case 'reboundShot':
      return PatternType.reboundShot;
    default:
      return PatternType.surge;
  }
});

/// íŒ¨í„´ë³„ í™œì„±í™” ìƒíƒœ ê´€ë¦¬ (UI ë™ê¸°í™”ìš©)
final signalPatternEnabledProvider = StateProvider.family<bool, PatternType>((ref, pattern) => false);

/// í†µí•© On/Off ìŠ¤ìœ„ì¹˜ Provider
final isAnyPatternActiveProvider = Provider<bool>((ref) {
  for (final pattern in PatternType.values) {
    if (ref.watch(signalPatternEnabledProvider(pattern))) {
      return true;
    }
  }
  return false;
});

// ==========================================================================
// ğŸ”¥ ìŠ¤íŠ¸ë¦¼ Providers (ë‹¨ìˆœí™”)
// ==========================================================================

/// íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ì„ ë…ë¦½ì ìœ¼ë¡œ ì œê³µ
final signalsByPatternProvider =
    StreamProvider.family.autoDispose<List<Signal>, PatternType>((ref, patternType) async* {

  final isPatternEnabled = ref.watch(signalPatternEnabledProvider(patternType));
  if (!isPatternEnabled) {
    yield [];
    return;
  }

  final repository = ref.read(signalRepoProvider);
  final markets = await ref.watch(marketsProvider.future);

  if (AppConfig.enableTradeLog) {
    log.i('ğŸ¯ Starting stream for pattern: ${patternType.displayName} (Clean)');
  }

  // ğŸ”§ íŒ¨í„´ í™œì„±í™” ìƒíƒœ ë³€ê²½ ê°ì§€ ë° Repository ì§ì ‘ ì—…ë°ì´íŠ¸
  ref.listen<bool>(signalPatternEnabledProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Pattern ${next ? "enabled" : "disabled"}: ${patternType.displayName}');
      }
      repository.setPatternEnabled(patternType, next);
    }
  });

  yield* repository.watchSignalsByPattern(patternType, markets);
});

/// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (í˜¸í™˜ì„±)
final signalListProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  final currentPattern = ref.watch(signalPatternTypeProvider);
  
  await for (final signals in ref.watch(signalsByPatternProvider(currentPattern).stream)) {
    yield signals;
  }
});

/// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ í†µí•© ìŠ¤íŠ¸ë¦¼
final allSignalsProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield [];
    return;
  }

  ref.keepAlive();
  
  final repository = ref.read(signalRepoProvider);
  final markets = await ref.watch(marketsProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.i('ğŸš€ All signals stream initialized (Clean Architecture)');
  }
  
  yield* repository.watchAllSignals(markets);
});

// ==========================================================================
// ğŸ†• ëª¨ë‹ˆí„°ë§ Providers (ê°„ì†Œí™”)
// ==========================================================================

/// ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§
final onlineMetricsHealthProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {'status': 'inactive', 'message': 'ëª¨ë“  íŒ¨í„´ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.'};
    return;
  }
  
  final metrics = ref.watch(advancedMetricsProvider);
  
  yield* Stream.periodic(const Duration(seconds: 5), (_) {
    return metrics.getSystemHealth();
  });
});

/// ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
final systemPerformanceProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {'status': 'inactive', 'message': 'ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.'};
    return;
  }
  
  final repository = ref.watch(signalRepoProvider) as SignalRepositoryImpl;
  
  yield* repository.watchPerformanceMetrics();
});

// ==========================================================================
// ğŸ” ê°œë°œììš© ë””ë²„ê¹… (ê°„ì†Œí™”)
// ==========================================================================

/// Repository dispose ê´€ë¦¬
final signalRepositoryDisposeProvider = Provider.autoDispose<SignalRepository>((ref) {
  final repository = ref.watch(signalRepoProvider);
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal repository disposed - Clean Architecture');
    }
  });
  
  return repository;
});\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ì œë„¤ë¦­)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ í”Œë«í¼ë³„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} â†’ $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} â†’ ${msg.substring(0, 100)}â€¦');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/shared/widgets/signal_widget.dart ======\n
// lib/shared/widgets/signal_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/signal.dart';
import '../../presentation/controllers/signal_controller.dart';

/// ğŸšï¸ ì„ê³„ê°’ ì¡°ì • ëª¨ë‹¬ ìœ„ì ¯ V4.1 - Clean Architecture
class ThresholdAdjustmentModal extends ConsumerStatefulWidget {
  final PatternType pattern;
  final SignalController controller;
  final VoidCallback onClose;

  const ThresholdAdjustmentModal({
    super.key,
    required this.pattern,
    required this.controller,
    required this.onClose,
  });

  @override
  ConsumerState<ThresholdAdjustmentModal> createState() => _ThresholdAdjustmentModalState();
}

class _ThresholdAdjustmentModalState extends ConsumerState<ThresholdAdjustmentModal> {
  late double _currentValue;
  late double _defaultValue;
  late String _thresholdKey;
  late String _unit;
  late double _minValue;
  late double _maxValue;
  late int _divisions;

  @override
  void initState() {
    super.initState();
    _initializeThresholdConfig();
    
    // Controller ë©”ì„œë“œëŠ” keyë§Œ ë°›ìŒ (í˜„ì¬ íŒ¨í„´ì€ Controller ë‚´ë¶€ì—ì„œ ì‚¬ìš©)
    _currentValue = widget.controller.getCurrentThresholdValue(_thresholdKey);
    _defaultValue = widget.controller.getDefaultThresholdValue(_thresholdKey);
  }

  /// ğŸ¯ íŒ¨í„´ë³„ ì„ê³„ê°’ ì„¤ì • ì´ˆê¸°í™”
  void _initializeThresholdConfig() {
    switch (widget.pattern) {
      case PatternType.surge:
        _thresholdKey = 'priceChangePercent';
        _unit = '%';
        _minValue = 0.1;
        _maxValue = 3.0;
        _divisions = ((3.0 - 0.1) / 0.1).round();
        break;
      case PatternType.flashFire:
        _thresholdKey = 'zScoreThreshold';
        _unit = 'ë°°';
        _minValue = 1.0;
        _maxValue = 4.0;
        _divisions = ((4.0 - 1.0) / 0.1).round();
        break;
      case PatternType.stackUp:
        _thresholdKey = 'consecutiveMin';
        _unit = 'ì—°ì†';
        _minValue = 1;
        _maxValue = 8;
        _divisions = (8 - 1);
        break;
      case PatternType.stealthIn:
        _thresholdKey = 'minTradeAmount';
        _unit = 'ë§Œì›';
        _minValue = 100; // 100ë§Œì› (í‘œì‹œìš©)
        _maxValue = 5000; // 5000ë§Œì› (í‘œì‹œìš©)
        _divisions = ((5000 - 100) / 100).round();
        break;
      case PatternType.blackHole:
        _thresholdKey = 'cvThreshold';
        _unit = '%';
        _minValue = 0.5;
        _maxValue = 10.0;
        _divisions = ((10.0 - 0.5) / 0.5).round();
        break;
      case PatternType.reboundShot:
        _thresholdKey = 'priceRangeMin';
        _unit = '%';
        _minValue = 0.1;
        _maxValue = 5.0;
        _divisions = ((5.0 - 0.1) / 0.1).round();
        break;
    }
  }

  /// ğŸ¨ íŒ¨í„´ë³„ ìƒ‰ìƒ ë°˜í™˜
  Color _getPatternColor() {
    switch (widget.pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }

  /// ğŸ¯ íŒ¨í„´ë³„ ì•„ì´ì½˜ ë°˜í™˜
  IconData _getPatternIcon() {
    switch (widget.pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// ğŸ’° ê°’ í¬ë§·íŒ… (íŒ¨í„´ë³„)
  String _formatValue(double value) {
    switch (widget.pattern) {
      case PatternType.surge:
      case PatternType.blackHole:
      case PatternType.reboundShot:
        return '${value.toStringAsFixed(1)}$_unit';
      case PatternType.flashFire:
        return '${value.toStringAsFixed(1)}$_unit';
      case PatternType.stackUp:
        return '${value.toInt()}$_unit';
      case PatternType.stealthIn:
        return '${value.toStringAsFixed(0)}$_unit';
    }
  }

  /// ğŸ”„ ì‹¤ì œ ê°’ ë³€í™˜ (stealthInìš©)
  double _convertToActualValue(double displayValue) {
    if (widget.pattern == PatternType.stealthIn) {
      return displayValue * 10000; // ë§Œì› â†’ ì›
    }
    if (widget.pattern == PatternType.blackHole || widget.pattern == PatternType.reboundShot) {
      return displayValue / 100; // % â†’ ì†Œìˆ˜
    }
    return displayValue;
  }

  /// ğŸšï¸ í‘œì‹œìš© ê°’ ë³€í™˜
  double _convertToDisplayValue(double actualValue) {
    if (widget.pattern == PatternType.stealthIn) {
      return actualValue / 10000; // ì› â†’ ë§Œì›
    }
    if (widget.pattern == PatternType.blackHole || widget.pattern == PatternType.reboundShot) {
      return actualValue * 100; // ì†Œìˆ˜ â†’ %
    }
    return actualValue;
  }

  /// ğŸ“± í–…í‹± í”¼ë“œë°± ì‹¤í–‰
  void _performHaptic() {
    HapticFeedback.selectionClick();
  }

  /// ğŸ’¾ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void _updateThreshold(double displayValue) {
    try {
      final actualValue = _convertToActualValue(displayValue);
      
      // ControllerëŠ” key, valueë§Œ ë°›ìŒ
      widget.controller.updatePatternThresholdDirect(_thresholdKey, actualValue);
      
      setState(() {
        _currentValue = actualValue;
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('ì„ê³„ê°’ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  /// ğŸ”„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  void _resetToDefault() {
    try {
      // ControllerëŠ” keyë§Œ ë°›ìŒ
      widget.controller.resetThresholdToDefault(_thresholdKey);
      
      setState(() {
        _currentValue = _defaultValue;
      });
      _performHaptic();
      
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('ë¦¬ì…‹ ì‹¤íŒ¨: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final patternColor = _getPatternColor();
    final displayValue = _convertToDisplayValue(_currentValue);
    final defaultDisplayValue = _convertToDisplayValue(_defaultValue);

    return Material(
      color: Colors.transparent,
      child: Container(
        width: 280,
        height: 500,
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.3),
              blurRadius: 20,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Column(
          children: [
            // ğŸ¯ í—¤ë”
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: patternColor.withValues(alpha: 0.1),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
                border: Border(
                  bottom: BorderSide(
                    color: patternColor.withValues(alpha: 0.3),
                    width: 1,
                  ),
                ),
              ),
              child: Column(
                children: [
                  Row(
                    children: [
                      Icon(
                        _getPatternIcon(),
                        color: patternColor,
                        size: 24,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          '${widget.pattern.displayName} ì„ê³„ê°’',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: patternColor,
                          ),
                        ),
                      ),
                      GestureDetector(
                        onTap: widget.onClose,
                        child: Icon(
                          Icons.close,
                          color: Colors.grey[600],
                          size: 24,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    widget.pattern.description,
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),

            // ğŸšï¸ ìŠ¬ë¼ì´ë” ì˜ì—­
            Expanded(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    // í˜„ì¬ ê°’ í‘œì‹œ
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                      decoration: BoxDecoration(
                        color: patternColor.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: patternColor.withValues(alpha: 0.3),
                          width: 1,
                        ),
                      ),
                      child: Text(
                        _formatValue(displayValue),
                        style: TextStyle(
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                          color: patternColor,
                        ),
                      ),
                    ),

                    const SizedBox(height: 30),

                    // ì„¸ë¡œ ìŠ¬ë¼ì´ë”
                    Expanded(
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          // ìµœëŒ€ê°’ í‘œì‹œ
                          Text(
                            _formatValue(_maxValue),
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          
                          const SizedBox(width: 20),
                          
                          // ì„¸ë¡œ ìŠ¬ë¼ì´ë”
                          SizedBox(
                            height: 300,
                            child: RotatedBox(
                              quarterTurns: 3, // 90ë„ íšŒì „
                              child: SliderTheme(
                                data: SliderTheme.of(context).copyWith(
                                  activeTrackColor: patternColor,
                                  inactiveTrackColor: patternColor.withValues(alpha: 0.3),
                                  thumbColor: patternColor,
                                  overlayColor: patternColor.withValues(alpha: 0.2),
                                  thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 12),
                                  overlayShape: const RoundSliderOverlayShape(overlayRadius: 20),
                                  trackHeight: 8,
                                ),
                                child: Slider(
                                  value: displayValue.clamp(_minValue, _maxValue),
                                  min: _minValue,
                                  max: _maxValue,
                                  divisions: _divisions,
                                  onChanged: (value) {
                                    _performHaptic();
                                    _updateThreshold(value);
                                  },
                                ),
                              ),
                            ),
                          ),
                          
                          const SizedBox(width: 20),
                          
                          // ìµœì†Œê°’ í‘œì‹œ
                          Text(
                            _formatValue(_minValue),
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ),

                    const SizedBox(height: 20),

                    // ê¸°ë³¸ê°’ í‘œì‹œ
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        'ê¸°ë³¸ê°’: ${_formatValue(defaultDisplayValue)}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // ğŸ”„ ì•¡ì…˜ ë²„íŠ¼ë“¤
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: const BorderRadius.only(
                  bottomLeft: Radius.circular(20),
                  bottomRight: Radius.circular(20),
                ),
              ),
              child: Row(
                children: [
                  // ë¦¬ì…‹ ë²„íŠ¼
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: _resetToDefault,
                      icon: const Icon(Icons.refresh, size: 16),
                      label: const Text('ë¦¬ì…‹'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.grey[300],
                        foregroundColor: Colors.grey[700],
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                    ),
                  ),
                  
                  const SizedBox(width: 12),
                  
                  // ì™„ë£Œ ë²„íŠ¼
                  Expanded(
                    flex: 2,
                    child: ElevatedButton.icon(
                      onPressed: widget.onClose,
                      icon: const Icon(Icons.check, size: 16),
                      label: const Text('ì™„ë£Œ'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: patternColor,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/data/repositories/signal_repository_impl.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/signal_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/pattern_detector.dart';
import '../../core/utils/pattern_config.dart';
import '../../core/utils/market_data_context.dart';
import 'dart:async' show unawaited;


/// ğŸš€ SignalRepositoryImpl V4.1 - ë©”ëª¨ë¦¬ ìµœì í™”
/// 
/// í•µì‹¬ ìµœì í™”:
/// - LRU ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬
/// - í™œì„± íŒ¨í„´ í•„í„°ë§ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ê³„ì‚° ì œê±°
/// - ìŠ¤íŠ¸ë¦¼ ì¬ì‚¬ìš©ìœ¼ë¡œ ì¤‘ë³µ ìƒì„± ë°©ì§€
/// - ì ì‘í˜• ì •ë¦¬ ì£¼ê¸°
class SignalRepositoryImpl implements SignalRepository {
  final TradeRemoteDataSource _remote;
  final TradeAggregator _aggregator;
  final PatternDetector _patternDetector;
  final PatternConfig _patternConfig;

  // ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  final Map<String, MarketDataContext> _marketContexts = {};
  final Map<String, DateTime> _marketLastAccess = {};
  static const int _maxMarketContexts = 50; // ë©”ëª¨ë¦¬ ì œí•œ

  // ğŸ”¥ ìµœì í™”: í™œì„± íŒ¨í„´ë§Œ ì¶”ì 
  final Set<PatternType> _activePatterns = {};
  final Map<PatternType, List<Signal>> _signalLists = {};
  final Map<PatternType, bool> _patternEnabled = {};

  // ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ì¤‘ë³µ ê°ì§€
  final Map<String, DateTime> _seenIdsWithTime = {};
  static const int _maxSeenIds = 1000; // ë©”ëª¨ë¦¬ ì œí•œ

  // ğŸ¯ íŒ¨í„´ë³„ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final Map<PatternType, StreamController<List<Signal>>> _patternControllers = {};
  final StreamController<List<Signal>> _allSignalsController = 
      StreamController<List<Signal>>.broadcast();

  // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _signalStream;
  StreamSubscription<Trade>? _signalSubscription;

  // ğŸš€ ì ì‘í˜• íƒ€ì´ë¨¸ ì‹œìŠ¤í…œ
  Timer? _batchUpdateTimer;
  Timer? _memoryCleanupTimer;
  Timer? _activeCleanupTimer;

  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  final Map<PatternType, int> _signalCounts = {};
  final Map<PatternType, DateTime?> _lastSignalTimes = {};
  int _totalProcessedTrades = 0;
  DateTime? _lastProcessingTime;

  // ğŸ”¥ ìµœì í™”: ë©”ëª¨ë¦¬ ì••ë°• ê°ì§€
  int _memoryPressureLevel = 0; // 0: ë‚®ìŒ, 1: ì¤‘ê°„, 2: ë†’ìŒ

  // ==========================================================================
  // ì´ˆê¸°í™”
  // ==========================================================================

  SignalRepositoryImpl(
    this._remote, {
    PatternDetector? patternDetector,
    PatternConfig? patternConfig,
  }) : _aggregator = TradeAggregator(),
       _patternDetector = patternDetector ?? PatternDetector(),
       _patternConfig = patternConfig ?? PatternConfig() {
    _initializePatterns();
    _startAdaptiveCleanup();
    log.i('ğŸš€ SignalRepository V4.1 ì´ˆê¸°í™” ì™„ë£Œ - ë©”ëª¨ë¦¬ ìµœì í™”');
  }

  void _initializePatterns() {
    for (final pattern in PatternType.values) {
      _signalLists[pattern] = [];
      _patternEnabled[pattern] = false;
      _signalCounts[pattern] = 0;
      _patternControllers[pattern] = StreamController<List<Signal>>.broadcast();
      // _activePatterns.add(pattern); // ì´ ë¼ì¸ì„ ì‚­ì œí•˜ê±°ë‚˜ ì£¼ì„ ì²˜ë¦¬
    }

    if (kDebugMode) {
      log.i('ğŸ¯ íŒ¨í„´ ì´ˆê¸°í™” ì™„ë£Œ: ${_activePatterns.length}ê°œ í™œì„± íŒ¨í„´');
    }
  }

  /// ğŸ”¥ ìµœì í™”: ì ì‘í˜• ì •ë¦¬ ì‹œìŠ¤í…œ
  void _startAdaptiveCleanup() {
    // ë©”ëª¨ë¦¬ ì •ë¦¬: ì••ë°• ìˆ˜ì¤€ì— ë”°ë¼ ì£¼ê¸° ì¡°ì ˆ
    _memoryCleanupTimer = Timer.periodic(const Duration(minutes: 2), (_) {
      _adaptiveMemoryCleanup();
    });

    // í™œì„± ìƒíƒœ ì •ë¦¬: ë” ìì£¼ ìˆ˜í–‰
    _activeCleanupTimer = Timer.periodic(const Duration(minutes: 1), (_) {
      _cleanupActiveStates();
    });
  }

  /// ğŸ”¥ ìµœì í™”: ì ì‘í˜• ë©”ëª¨ë¦¬ ì •ë¦¬
  void _adaptiveMemoryCleanup() {
    final now = DateTime.now();
    
    // ë©”ëª¨ë¦¬ ì••ë°• ìˆ˜ì¤€ ê³„ì‚°
    _memoryPressureLevel = _calculateMemoryPressure();
    
    // ì••ë°• ìˆ˜ì¤€ì— ë”°ë¥¸ ì •ë¦¬ ê°•ë„ ì¡°ì ˆ
    final maxAge = _memoryPressureLevel == 2 ? 10 : // ë†’ìŒ: 10ë¶„
                   _memoryPressureLevel == 1 ? 20 : // ì¤‘ê°„: 20ë¶„  
                   30; // ë‚®ìŒ: 30ë¶„

    _cleanupMarketContextsLRU(maxAge);
    _cleanupSeenIdsLRU(maxAge);

    if (kDebugMode && _memoryPressureLevel > 0) {
      log.d('ğŸ§¹ ì ì‘í˜• ì •ë¦¬ ì™„ë£Œ (ì••ë°•ìˆ˜ì¤€: $_memoryPressureLevel, ìµœëŒ€ì—°ë ¹: ${maxAge}ë¶„)');
    }
  }

  /// ğŸ”¥ ìµœì í™”: ë©”ëª¨ë¦¬ ì••ë°• ìˆ˜ì¤€ ê³„ì‚°
  int _calculateMemoryPressure() {
    final contextCount = _marketContexts.length;
    final seenIdsCount = _seenIdsWithTime.length;
    final totalSignals = _signalLists.values.fold(0, (sum, list) => sum + list.length);

    if (contextCount > _maxMarketContexts * 0.8 || 
        seenIdsCount > _maxSeenIds * 0.8 ||
        totalSignals > 500) {
      return 2; // ë†’ìŒ
    } else if (contextCount > _maxMarketContexts * 0.6 || 
               seenIdsCount > _maxSeenIds * 0.6 ||
               totalSignals > 300) {
      return 1; // ì¤‘ê°„
    }
    return 0; // ë‚®ìŒ
  }

  /// ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬
  void _cleanupMarketContextsLRU(int maxAgeMinutes) {
    final now = DateTime.now();
    final cutoff = now.subtract(Duration(minutes: maxAgeMinutes));
    int removedCount = 0;

    // ì˜¤ë˜ëœ í•­ëª©ë“¤ ì œê±°
    final toRemove = <String>[];
    for (final entry in _marketLastAccess.entries) {
      if (entry.value.isBefore(cutoff)) {
        toRemove.add(entry.key);
      }
    }

    for (final market in toRemove) {
      final context = _marketContexts.remove(market);
      _marketLastAccess.remove(market);
      
      if (context != null) {
        context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        removedCount++;
      }
    }

    // ê°œìˆ˜ ì œí•œ ì´ˆê³¼ì‹œ LRU ì œê±°
    if (_marketContexts.length > _maxMarketContexts) {
      final sortedByAccess = _marketLastAccess.entries.toList()
        ..sort((a, b) => a.value.compareTo(b.value));

      final excessCount = _marketContexts.length - _maxMarketContexts;
      for (int i = 0; i < excessCount; i++) {
        final market = sortedByAccess[i].key;
        final context = _marketContexts.remove(market);
        _marketLastAccess.remove(market);
        
        if (context != null) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
          removedCount++;
        }
      }
    }

    if (kDebugMode && removedCount > 0) {
      log.d('ğŸ§¹ LRU ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬: $removedCountê°œ ì œê±°');
    }
  }

  /// ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ì¤‘ë³µ ê°ì§€ ID ì •ë¦¬
  void _cleanupSeenIdsLRU(int maxAgeMinutes) {
    final now = DateTime.now();
    final cutoff = now.subtract(Duration(minutes: maxAgeMinutes));
    
    _seenIdsWithTime.removeWhere((id, timestamp) => timestamp.isBefore(cutoff));

    // ê°œìˆ˜ ì œí•œ ì´ˆê³¼ì‹œ LRU ì œê±°
    if (_seenIdsWithTime.length > _maxSeenIds) {
      final sortedByTime = _seenIdsWithTime.entries.toList()
        ..sort((a, b) => a.value.compareTo(b.value));

      final excessCount = _seenIdsWithTime.length - _maxSeenIds;
      for (int i = 0; i < excessCount; i++) {
        _seenIdsWithTime.remove(sortedByTime[i].key);
      }
    }
  }

  /// ğŸ”¥ ìµœì í™”: í™œì„± ìƒíƒœ ì •ë¦¬
  void _cleanupActiveStates() {
    // ë¹„í™œì„±í™”ëœ íŒ¨í„´ì„ í™œì„± íŒ¨í„´ ì„¸íŠ¸ì—ì„œ ì œê±°
    _activePatterns.removeWhere((pattern) => !(_patternEnabled[pattern] ?? false));
    
    // í™œì„± íŒ¨í„´ì´ ë³€ê²½ë˜ì—ˆìœ¼ë©´ ë¡œê·¸
    final enabledCount = _patternEnabled.values.where((enabled) => enabled).length;
    if (_activePatterns.length != enabledCount) {
      _activePatterns.clear();
      for (final entry in _patternEnabled.entries) {
        if (entry.value) {
          _activePatterns.add(entry.key);
        }
      }
      
      if (kDebugMode) {
        log.d('ğŸ¯ í™œì„± íŒ¨í„´ ì—…ë°ì´íŠ¸: ${_activePatterns.length}ê°œ');
      }
    }
  }

  // ==========================================================================
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  // ==========================================================================

  void _initializeSignalStream(List<String> markets) {
    if (_signalStream != null) return;

    log.i('SignalRepositoryImpl V4.1: ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” - ${markets.length}ê°œ ì‹œì¥');

    _signalStream = _remote.watch(markets).asBroadcastStream();

    _signalSubscription = _signalStream!.listen(
      _processRawTradeForSignal,
      onError: (error, stackTrace) {
        log.e('Signal stream error: $error', stackTrace);
      },
      onDone: () {
        log.i('Signal stream done');
      },
    );
  }

  // ==========================================================================
  // ğŸ“Š ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬ (LRU ìµœì í™”)
  // ==========================================================================

  /// ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  MarketDataContext _getOrCreateMarketContext(String market) {
    final now = DateTime.now();
    
    // ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸ (LRU)
    _marketLastAccess[market] = now;
    
    return _marketContexts.putIfAbsent(
      market,
      () => MarketDataContext.empty(market),
    );
  }

  /// ëª¨ë“  íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì—…ë°ì´íŠ¸ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
  void _updateMarketContext(Trade trade, DateTime timestamp) {
    final context = _getOrCreateMarketContext(trade.market);
    
    // ê±°ë˜ ê°„ê²© ê³„ì‚°
    final interval = context.intervalWindow != null && 
                    context.intervalWindow!.timestamps.isNotEmpty
        ? timestamp.difference(context.intervalWindow!.timestamps.last).inSeconds.toDouble()
        : 10.0;
    
    // ë§¤ìˆ˜ ë¹„ìœ¨ (ê°„ë‹¨í•œ ì¶”ì •)
    final buyRatio = trade.isBuy ? 1.0 : 0.0;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œì™€ í•¨ê»˜ ëª¨ë“  ìœˆë„ìš° ì—…ë°ì´íŠ¸
    context.updateWithOnlineMetrics(
      price: trade.price,
      volume: trade.total,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: max(interval, 1.0),
      onlineMetrics: _patternDetector.metrics, // ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
    );
  }

  // ==========================================================================
  // ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ì¤‘ë³µ ê°ì§€ ìµœì í™”)
  // ==========================================================================

  void _processRawTradeForSignal(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';
      final now = DateTime.now();

      // ğŸ”¥ ìµœì í™”: LRU ê¸°ë°˜ ì¤‘ë³µ ê°ì§€
      if (_seenIdsWithTime.containsKey(key)) {
        return; // ì´ë¯¸ ì²˜ë¦¬ëœ ê±°ë˜
      }
      
      _seenIdsWithTime[key] = now;

      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleAggregatedTrade,
      );
    } catch (e, stackTrace) {
      log.w('_processRawTradeForSignal error: $e', stackTrace);
    }
  }

  void _handleAggregatedTrade(Map<String, dynamic> aggregatedTrade) {
    if (_activePatterns.isEmpty) return; // í™œì„± íŒ¨í„´ì´ ì—†ìœ¼ë©´ ëª¨ë“  ë¶„ì„ ì¤‘ë‹¨
    try {
      final trade = Trade(
        market: aggregatedTrade['market'] as String,
        price: aggregatedTrade['price'] as double,
        volume: aggregatedTrade['volume'] as double,
        side: (aggregatedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: aggregatedTrade['timestamp'] as int,
        sequentialId: aggregatedTrade['sequential_id'] as String? ?? '',
      );

      final now = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
      _updateMarketContext(trade, now);
      unawaited(_analyzePatterns(trade, now));
    } catch (e, stackTrace) {
      log.w('_handleAggregatedTrade error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸ¯ íŒ¨í„´ ë¶„ì„ (í™œì„± íŒ¨í„´ë§Œ ì²˜ë¦¬)
  // ==========================================================================

  /// ğŸ”¥ ìµœì í™”: í™œì„± íŒ¨í„´ë§Œ ë¶„ì„
  Future<void> _analyzePatterns(Trade trade, DateTime now) async {

    try {
      final context = _getOrCreateMarketContext(trade.market);
      final detectedSignals = <Signal>[];

      // ğŸ”¥ ìµœì í™”: í™œì„±í™”ëœ íŒ¨í„´ë§Œ ì²˜ë¦¬
      for (final pattern in _activePatterns) {
        try {
          // ğŸš€ ê°œì„ ëœ íŒ¨í„´ ê°ì§€ (ë‹¨ì¼ ë©”ì„œë“œ, ëª…í™•í•œ íŒŒë¼ë¯¸í„°)
          final signal = await _patternDetector.detectPattern(
            patternType: pattern,
            trade: trade,
            timestamp: now,
            context: context,
          );

          if (signal != null) {
            detectedSignals.add(signal);
            _signalCounts[pattern] = (_signalCounts[pattern] ?? 0) + 1;
            _lastSignalTimes[pattern] = now;
          }
        } catch (e, stackTrace) {
          log.w('Pattern analysis error: ${pattern.name} - $e', stackTrace);
        }
      }

      // ì‹ í˜¸ ì¶”ê°€
      for (final signal in detectedSignals) {
        _addSignal(signal.patternType, signal);
      }

      if (detectedSignals.isNotEmpty) {
        _scheduleBatchUpdate();
      }

      _totalProcessedTrades++;
      _lastProcessingTime = now;
    } catch (e, stackTrace) {
      log.e('_analyzePatterns error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸš€ ì‹œê·¸ë„ ì¶”ê°€ ë° ê´€ë¦¬
  // ==========================================================================

  void _addSignal(PatternType pattern, Signal signal) {
    final signalList = _signalLists[pattern];
    if (signalList == null) return;

    // ì¤‘ë³µ ì‹ í˜¸ ì²´í¬ (5ë¶„ ì´ë‚´)
    final cutoff = signal.detectedAt.subtract(const Duration(minutes: 5));
    final isDuplicate = signalList.any((existingSignal) =>
        existingSignal.market == signal.market &&
        existingSignal.detectedAt.isAfter(cutoff));

    if (isDuplicate) return;

    signalList.insert(0, signal);

    // ìµœëŒ€ ì‹ í˜¸ ê°œìˆ˜ ì œí•œ
    if (signalList.length > AppConfig.maxSignalsPerPattern) {
      signalList.removeLast();
    }

    if (kDebugMode) {
      final confidence = signal.patternDetails['finalConfidence'] ?? 
                       signal.patternDetails['confidence'] ?? 0.0;
      log.i('ğŸš¨ V4.1 ì‹ í˜¸ ê°ì§€: ${signal.patternType.displayName} - ${signal.market} '
          '(${signal.changePercent.toStringAsFixed(2)}%, ì‹ ë¢°ë„: ${(confidence * 100).toStringAsFixed(1)}%)');
    }
  }

  /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    if (_batchUpdateTimer?.isActive != true) {
      _batchUpdateTimer = Timer(AppConfig.signalBatchInterval, _updateSignalStreams);
    }
  }

  /// ğŸ“Š ëª¨ë“  ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  void _updateSignalStreams() {
    try {
      for (final entry in _signalLists.entries) {
        final pattern = entry.key;
        final signals = List<Signal>.from(entry.value);

        final controller = _patternControllers[pattern];
        if (controller != null && !controller.isClosed) {
          controller.add(signals);
        }
      }

      final allSignals = _signalLists.values.expand((list) => list).toList();
      allSignals.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
      final recentSignals = allSignals.take(50).toList();

      if (!_allSignalsController.isClosed) {
        _allSignalsController.add(recentSignals);
      }

      if (kDebugMode && allSignals.isNotEmpty) {
        log.d('ğŸš€ V4.1 ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì—…ë°ì´íŠ¸: ${allSignals.length}ê°œ ì´ ì‹ í˜¸');
      }
    } catch (e, stackTrace) {
      log.w('_updateSignalStreams error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // SignalRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ (ë³€ê²½ì‚¬í•­ ì—†ìŒ)
  // ==========================================================================

  @override
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    _initializeSignalStream(markets);
    return _patternControllers[patternType]?.stream ?? const Stream.empty();
  }

  @override
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    _initializeSignalStream(markets);
    return _allSignalsController.stream;
  }

  @override
  void updatePatternThreshold(PatternType patternType, double threshold) {
    try {
      _patternConfig.updatePatternConfig(patternType, 'priceChangePercent', threshold);
      log.i('V4.1: íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ - ${patternType.name}: $threshold');
    } catch (e) {
      log.w('íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: $e');
    }
  }

  @override
  double getPatternThreshold(PatternType patternType) {
    return _patternConfig.getConfigValue(patternType, 'priceChangePercent');
  }

  @override
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _patternEnabled[patternType] = enabled;
    
    // ğŸ”¥ ìµœì í™”: í™œì„± íŒ¨í„´ ì„¸íŠ¸ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    if (enabled) {
      _activePatterns.add(patternType);
    } else {
      _activePatterns.remove(patternType);
    }
    
    log.i('íŒ¨í„´ ${patternType.name} ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'} (í™œì„±íŒ¨í„´: ${_activePatterns.length}ê°œ)');
  }

  @override
  bool isPatternEnabled(PatternType patternType) {
    return _patternEnabled[patternType] ?? false;
  }

  @override
  void clearSignals(PatternType? patternType) {
    if (patternType != null) {
      _signalLists[patternType]?.clear();
      _patternControllers[patternType]?.add([]);
      _signalCounts[patternType] = 0;
    } else {
      for (final pattern in PatternType.values) {
        _signalLists[pattern]?.clear();
        _patternControllers[pattern]?.add([]);
        _signalCounts[pattern] = 0;
      }
      _patternDetector.clearAllCooldowns();
    }
    _scheduleBatchUpdate();
  }

  // ==========================================================================
  // ğŸ†• V4.1 í™•ì¥ ê¸°ëŠ¥ë“¤ (ë©”ëª¨ë¦¬ ìƒíƒœ í¬í•¨)
  // ==========================================================================

  @override
  void updatePatternConfig(PatternType pattern, String key, double value) {
    _patternConfig.updatePatternConfig(pattern, key, value);
  }

  @override
  Future<Map<String, dynamic>> getPatternStats(PatternType type) async {
    final signals = _signalLists[type] ?? [];
    final lastSignal = _lastSignalTimes[type];

    return {
      'patternType': type.name,
      'totalSignals': _signalCounts[type] ?? 0,
      'recentSignals': signals.length,
      'lastSignalTime': lastSignal?.toIso8601String(),
      'isEnabled': _patternEnabled[type] ?? false,
      'isActive': _activePatterns.contains(type),
      'cooldownStatus': _patternDetector.getCooldownStatus(),
      'config': _patternConfig.getPatternConfig(type),
    };
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final now = DateTime.now();
    final uptime = _lastProcessingTime != null
        ? now.difference(_lastProcessingTime!).inMinutes
        : 0;

    final patternStats = <String, dynamic>{};
    for (final pattern in PatternType.values) {
      patternStats[pattern.name] = await getPatternStats(pattern);
    }

    final marketStats = <String, dynamic>{};
    for (final entry in _marketContexts.entries) {
      final quality = entry.value.getDataQuality(onlineMetrics: _patternDetector.metrics);
      marketStats[entry.key] = {
        'quality': quality['overall'],
        'score': quality['overallScore'],
        'timeframes': entry.value.availableTimeframes.length,
        'onlineMetrics': quality['onlineMetrics'],
        'lastAccess': _marketLastAccess[entry.key]?.toIso8601String(),
      };
    }

    final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'version': '4.1-Optimized',
      'status': 'healthy',
      'uptime': uptime,
      'totalProcessedTrades': _totalProcessedTrades,
      'lastProcessingTime': _lastProcessingTime?.toIso8601String(),
      'activePatterns': _activePatterns.length,
      'enabledPatterns': _patternEnabled.values.where((enabled) => enabled).length,
      'trackedMarkets': _marketContexts.length,
      'memoryPressure': _memoryPressureLevel,
      'memoryStats': {
        'marketContexts': _marketContexts.length,
        'maxMarketContexts': _maxMarketContexts,
        'seenIds': _seenIdsWithTime.length,
        'maxSeenIds': _maxSeenIds,
        'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
      },
      'patternStats': patternStats,
      'marketStats': marketStats,
      'onlineMetricsSystem': onlineMetricsHealth,
      'optimizations': [
        'LRU Memory Management',
        'Active Pattern Filtering', 
        'Adaptive Cleanup Intervals',
        'Memory Pressure Detection',
        'Stream Reuse Prevention',
        'Online RSI/MACD Integration',
        'O(1) Indicator Calculation',
        'Dependency Injection Architecture',
      ],
    };
  }

  @override
  Map<String, dynamic> getMarketDataQuality() {
    final qualityReport = <String, dynamic>{};

    for (final entry in _marketContexts.entries) {
      qualityReport[entry.key] = entry.value.getDataQuality(
        onlineMetrics: _patternDetector.metrics
      );
    }

    final onlineHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'totalMarkets': _marketContexts.length,
      'maxMarkets': _maxMarketContexts,
      'memoryPressure': _memoryPressureLevel,
      'markets': qualityReport,
      'healthyMarkets': qualityReport.values
          .where((q) => q['overall'] == 'EXCELLENT' || q['overall'] == 'GOOD')
          .length,
      'onlineMetricsSummary': {
        'totalMarkets': onlineHealth['totalMarkets'],
        'healthyMarkets': onlineHealth['healthyMarkets'],
        'staleMarkets': onlineHealth['staleMarkets'],
      },
    };
  }

  @override
  void applyPatternPreset(String presetName) {
    switch (presetName.toLowerCase()) {
      case 'conservative':
        _patternConfig.applyConservativePreset();
        break;
      case 'aggressive':
        _patternConfig.applyAggressivePreset();
        break;
      case 'balanced':
        _patternConfig.applyBalancedPreset();
        break;
      default:
        throw ArgumentError('Unknown preset: $presetName');
    }

    log.i('íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©: $presetName');
  }

  @override
  Map<String, dynamic> exportConfiguration() {
    return {
      'version': '4.1',
      'timestamp': DateTime.now().toIso8601String(),
      'patternConfig': _patternConfig.exportConfig(),
      'patternEnabled': _patternEnabled.map((k, v) => MapEntry(k.name, v)),
      'systemSettings': {
        'maxSignalsPerPattern': AppConfig.maxSignalsPerPattern,
        'signalCacheSize': AppConfig.signalCacheSize,
        'batchInterval': AppConfig.signalBatchInterval.inMilliseconds,
        'maxMarketContexts': _maxMarketContexts,
        'maxSeenIds': _maxSeenIds,
      },
      'memoryOptimizations': {
        'lruEnabled': true,
        'adaptiveCleanup': true,
        'activePatternFiltering': true,
      },
    };
  }

  @override
  void importConfiguration(Map<String, dynamic> config) {
    try {
      // íŒ¨í„´ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
      if (config['patternConfig'] != null) {
        _patternConfig.importConfig(config['patternConfig']);
      }

      // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
      if (config['patternEnabled'] != null) {
        final enabledMap = config['patternEnabled'] as Map<String, dynamic>;
        for (final pattern in PatternType.values) {
          if (enabledMap.containsKey(pattern.name)) {
            final enabled = enabledMap[pattern.name] as bool;
            _patternEnabled[pattern] = enabled;
            
            // ğŸ”¥ ìµœì í™”: í™œì„± íŒ¨í„´ ì„¸íŠ¸ ì—…ë°ì´íŠ¸
            if (enabled) {
              _activePatterns.add(pattern);
            } else {
              _activePatterns.remove(pattern);
            }
          }
        }
      }

      log.i('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ (í™œì„±íŒ¨í„´: ${_activePatterns.length}ê°œ)');
    } catch (e, stackTrace) {
      log.e('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: $e', stackTrace);
      rethrow;
    }
  }

  @override
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    return Stream.periodic(const Duration(seconds: 10), (_) {
      final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Optimized',
        'totalProcessedTrades': _totalProcessedTrades,
        'signalCounts': Map.from(_signalCounts),
        'activeMarkets': _marketContexts.length,
        'activePatterns': _activePatterns.length,
        'memoryPressure': _memoryPressureLevel,
        'cooldownStatus': _patternDetector.getCooldownStatus(),
        'memoryUsage': {
          'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
          'seenIdsCount': _seenIdsWithTime.length,
          'marketContexts': _marketContexts.length,
          'memoryUtilization': {
            'marketContexts': '${(_marketContexts.length / _maxMarketContexts * 100).toStringAsFixed(1)}%',
            'seenIds': '${(_seenIdsWithTime.length / _maxSeenIds * 100).toStringAsFixed(1)}%',
          },
        },
        'performance': {
          'activePatternFiltering': _activePatterns.length < PatternType.values.length,
          'lruCleanupActive': _memoryPressureLevel > 0,
          'adaptiveCleanupLevel': _memoryPressureLevel,
        },
        'onlineMetrics': {
          'totalMarkets': onlineMetricsHealth['totalMarkets'],
          'healthyMarkets': onlineMetricsHealth['healthyMarkets'],
          'staleMarkets': onlineMetricsHealth['staleMarkets'],
        },
        'architecture': 'V4.1 - Memory Optimized + LRU + Active Pattern Filtering',
      };
    });
  }

  // ==========================================================================
  // ğŸ”¥ V4.1 ì¶”ê°€: ë©”ëª¨ë¦¬ ìµœì í™” ì œì–´ ë©”ì„œë“œë“¤
  // ==========================================================================

  /// ë©”ëª¨ë¦¬ ì••ë°• ìˆ˜ì¤€ ê°•ì œ ì„¤ì • (í…ŒìŠ¤íŠ¸/ë””ë²„ê¹…ìš©)
  void setMemoryPressureLevel(int level) {
    _memoryPressureLevel = level.clamp(0, 2);
    log.i('ë©”ëª¨ë¦¬ ì••ë°• ìˆ˜ì¤€ ì„¤ì •: $_memoryPressureLevel');
  }

  /// ì¦‰ì‹œ ë©”ëª¨ë¦¬ ì •ë¦¬ ìˆ˜í–‰
  void forceMemoryCleanup() {
    _adaptiveMemoryCleanup();
    log.i('ê°•ì œ ë©”ëª¨ë¦¬ ì •ë¦¬ ìˆ˜í–‰ ì™„ë£Œ');
  }

  /// LRU ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getLRUStatus() {
    final now = DateTime.now();
    
    // ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ LRU ìƒíƒœ
    final marketLRU = _marketLastAccess.entries
        .map((e) => {
          'market': e.key,
          'lastAccess': e.value.toIso8601String(),
          'ageMinutes': now.difference(e.value).inMinutes,
        })
        .toList()
      ..sort((a, b) => (a['ageMinutes'] as int).compareTo(b['ageMinutes'] as int));

    // Seen IDs LRU ìƒíƒœ (ìµœì‹  10ê°œë§Œ)
    final seenIdsLRU = _seenIdsWithTime.entries
        .map((e) => {
          'id': e.key,
          'timestamp': e.value.toIso8601String(),
          'ageMinutes': now.difference(e.value).inMinutes,
        })
        .toList()
      ..sort((a, b) => (b['ageMinutes'] as int).compareTo(a['ageMinutes'] as int))
      ..take(10);

    return {
      'memoryPressureLevel': _memoryPressureLevel,
      'marketContexts': {
        'total': _marketContexts.length,
        'limit': _maxMarketContexts,
        'utilization': '${(_marketContexts.length / _maxMarketContexts * 100).toStringAsFixed(1)}%',
        'lruList': marketLRU.take(10).toList(),
      },
      'seenIds': {
        'total': _seenIdsWithTime.length,
        'limit': _maxSeenIds,
        'utilization': '${(_seenIdsWithTime.length / _maxSeenIds * 100).toStringAsFixed(1)}%',
        'oldestEntries': seenIdsLRU.toList(),
      },
      'activePatterns': {
        'active': _activePatterns.length,
        'total': PatternType.values.length,
        'patterns': _activePatterns.map((p) => p.name).toList(),
      },
    };
  }

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¼ê´„ ì„¤ì •
  void setBulkPatternEnabled(Map<PatternType, bool> settings) {
    _activePatterns.clear();
    
    for (final entry in settings.entries) {
      _patternEnabled[entry.key] = entry.value;
      if (entry.value) {
        _activePatterns.add(entry.key);
      }
    }
    
    log.i('íŒ¨í„´ ì¼ê´„ ì„¤ì • ì™„ë£Œ: ${_activePatterns.length}ê°œ í™œì„±í™”');
  }

// lib/data/repositories/signal_repository_impl.dart
// ê¸°ì¡´ ì½”ë“œ ëë¶€ë¶„ (dispose() ë©”ì„œë“œ ìœ„)ì— ë‹¤ìŒ ë©”ì„œë“œë“¤ì„ ì¶”ê°€:

  // ==========================================================================
  // ğŸ†• V4.1 ëª¨ë‹¬ìš© ë©”ì„œë“œ êµ¬í˜„ (Repository ì¸í„°í˜ì´ìŠ¤ ì¤€ìˆ˜)
  // ==========================================================================

  @override
  double getCurrentThresholdValue(PatternType pattern, String key) {
    try {
      // PatternConfigì—ì„œ í˜„ì¬ ì„¤ì •ê°’ ì§ì ‘ ì¡°íšŒ
      return _patternConfig.getConfigValue(pattern, key);
    } catch (e) {
      // í•´ë‹¹ í‚¤ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ getCurrentThresholdValue failed for ${pattern.name}.$key: $e');
      }
      
      // íŒ¨í„´ë³„ ê¸°ë³¸ê°’ ë°˜í™˜
      switch (pattern) {
        case PatternType.surge:
          switch (key) {
            case 'priceChangePercent': return 0.4;
            case 'zScoreThreshold': return 2.0;
            case 'buyRatioMin': return 0.6;
            case 'buyRatioMax': return 0.95;
            case 'consecutiveMin': return 3;
            case 'timeWindowSeconds': return 300;
            case 'cooldownSeconds': return 300;
            case 'minVolume': return 100000;
            default: return 0.0;
          }
        case PatternType.flashFire:
          switch (key) {
            case 'priceChangePercent': return 0.8;
            case 'zScoreThreshold': return 3.0;
            case 'buyRatioMin': return 0.7;
            case 'buyRatioMax': return 0.98;
            case 'consecutiveMin': return 5;
            case 'timeWindowSeconds': return 180;
            case 'cooldownSeconds': return 240;
            case 'minVolume': return 200000;
            default: return 0.0;
          }
        case PatternType.stackUp:
          switch (key) {
            case 'priceChangePercent': return 0.2;
            case 'consecutiveMin': return 7;
            case 'buyRatioMin': return 0.65;
            case 'rSquaredMin': return 0.8;
            case 'timeWindowSeconds': return 600;
            case 'cooldownSeconds': return 600;
            case 'minVolume': return 150000;
            default: return 0.0;
          }
        case PatternType.stealthIn:
          switch (key) {
            case 'minTradeAmount': return 5000000.0; // 500ë§Œì›
            case 'priceChangePercent': return 0.15;
            case 'cvThreshold': return 0.05;
            case 'buyRatioMin': return 0.55;
            case 'timeWindowSeconds': return 900;
            case 'cooldownSeconds': return 900;
            case 'minVolume': return 300000;
            default: return 0.0;
          }
        case PatternType.blackHole:
          switch (key) {
            case 'cvThreshold': return 0.02;
            case 'priceChangePercent': return 0.1;
            case 'minTradeAmount': return 10000000.0; // 1000ë§Œì›
            case 'buyRatioMin': return 0.5;
            case 'timeWindowSeconds': return 1200;
            case 'cooldownSeconds': return 1200;
            case 'minVolume': return 500000;
            default: return 0.0;
          }
        case PatternType.reboundShot:
          switch (key) {
            case 'priceRangeMin': return 0.03; // 3% ê¸‰ë½
            case 'priceChangePercent': return 0.25;
            case 'buyRatioMin': return 0.75;
            case 'timeWindowSeconds': return 240;
            case 'cooldownSeconds': return 360;
            case 'reboundStrength': return 1.5;
            case 'minVolume': return 250000;
            default: return 0.0;
          }
      }
    }
  }

  @override
  void setSystemActive(bool active) {
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ¯ System ${active ? "activated" : "deactivated"} - ${active ? "enabling" : "disabling"} all patterns');
    }
    
    // ëª¨ë“  íŒ¨í„´ì„ ì¼ê´„ í™œì„±í™”/ë¹„í™œì„±í™”
    for (final pattern in PatternType.values) {
      setPatternEnabled(pattern, active);
    }
    
    if (AppConfig.enableTradeLog) {
      log.i('âœ… System activation complete: ${_activePatterns.length}/${PatternType.values.length} patterns active');
    }
  }

  @override
  Map<String, dynamic> getSystemStatus() {
    final enabledPatterns = _patternEnabled.values.where((enabled) => enabled).length;
    final enabledPatternsList = PatternType.values
        .where((pattern) => _patternEnabled[pattern] ?? false)
        .map((p) => p.name)
        .toList();
    
    return {
      'isSystemActive': enabledPatterns > 0,
      'activePatterns': _activePatterns.length,
      'enabledPatterns': enabledPatterns,
      'totalPatterns': PatternType.values.length,
      'enabledPatternsList': enabledPatternsList,
      'activePatternsList': _activePatterns.map((p) => p.name).toList(),
      'systemHealth': _memoryPressureLevel == 0 ? 'healthy' : 
                     _memoryPressureLevel == 1 ? 'warning' : 'critical',
      'memoryPressure': _memoryPressureLevel,
      'timestamp': DateTime.now().toIso8601String(),
      'version': '4.1-Repository',
      'totalProcessedTrades': _totalProcessedTrades,
      'trackedMarkets': _marketContexts.length,
    };
  }

  @override
  Map<String, dynamic> getOnlineMetricsHealth() {
    try {
      // PatternDetectorì˜ ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ì¡°íšŒ
      final onlineHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'status': onlineHealth['status'] ?? 'unknown',
        'message': onlineHealth['message'] ?? 'Online metrics system operational',
        'totalMarkets': onlineHealth['totalMarkets'] ?? 0,
        'healthyMarkets': onlineHealth['healthyMarkets'] ?? 0,
        'staleMarkets': onlineHealth['staleMarkets'] ?? 0,
        'lastUpdate': onlineHealth['lastUpdate'],
        'rsiHealth': onlineHealth['rsiHealth'],
        'macdHealth': onlineHealth['macdHealth'],
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Repository',
        'source': 'PatternDetector.metrics',
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ getOnlineMetricsHealth failed: $e');
      }
      
      return {
        'status': 'error',
        'message': 'Failed to retrieve online metrics health: $e',
        'totalMarkets': 0,
        'healthyMarkets': 0,
        'staleMarkets': 0,
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Repository',
        'source': 'Repository-Fallback',
      };
    }
  }

  @override
  void resetOnlineMetrics([String? market]) {
    try {
      if (market != null) {
        // íŠ¹ì • ë§ˆì¼“ì˜ ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
        _patternDetector.metrics.resetMarket(market);
        
        // í•´ë‹¹ ë§ˆì¼“ì˜ ì»¨í…ìŠ¤íŠ¸ë„ ë¦¬ì…‹
        final context = _marketContexts[market];
        if (context != null) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
          _marketContexts.remove(market);
          _marketLastAccess.remove(market);
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('ğŸ”„ Online metrics reset for market: $market');
        }
      } else {
        // ëª¨ë“  ë§ˆì¼“ì˜ ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
        _patternDetector.metrics.resetAll();
        
        // ëª¨ë“  ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ë¦¬ì…‹
        for (final context in _marketContexts.values) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        }
        _marketContexts.clear();
        _marketLastAccess.clear();
        
        if (AppConfig.enableTradeLog) {
          log.i('ğŸ”„ Online metrics reset for all markets');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ resetOnlineMetrics failed: $e');
      }
      // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ìµœì†Œí•œì˜ ì •ë¦¬ ìˆ˜í–‰
      if (market == null) {
        _marketContexts.clear();
        _marketLastAccess.clear();
      } else {
        _marketContexts.remove(market);
        _marketLastAccess.remove(market);
      }
    }
  }
  
  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ê°•í™”ëœ ë©”ëª¨ë¦¬ ì •ë¦¬)
  // ==========================================================================

  @override
  Future<void> dispose() async {
    log.i('SignalRepositoryImpl V4.1: dispose() ì‹œì‘');

    _batchUpdateTimer?.cancel();
    _memoryCleanupTimer?.cancel();
    _activeCleanupTimer?.cancel();

    _aggregator.flushTrades(onTradeProcessed: (_) {});

    await _signalSubscription?.cancel();
    _signalStream = null;

    // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    for (final controller in _patternControllers.values) {
      await controller.close();
    }
    await _allSignalsController.close();

    // ğŸ”¥ ê°•í™”ëœ ë©”ëª¨ë¦¬ ì •ë¦¬
    for (final context in _marketContexts.values) {
      context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
    }
    _marketContexts.clear();
    _marketLastAccess.clear();

    // ì‹ í˜¸ ë° ìºì‹œ ì •ë¦¬
    _signalLists.clear();
    _signalCounts.clear();
    _lastSignalTimes.clear();
    _seenIdsWithTime.clear();
    _activePatterns.clear();

    // PatternDetector ì •ë¦¬
    _patternDetector.dispose();

    log.i('SignalRepositoryImpl V4.1: dispose() ì™„ë£Œ - ë©”ëª¨ë¦¬ ìµœì í™” í¬í•¨');
  }
}

\n\n// ====== lib/data/factories/signal_stream_factory.dart ======\n
\n\n// ====== lib/domain/repositories/signal_repository.dart ======\n
// lib/domain/repositories/signal_repository.dart

import '../entities/signal.dart';

/// ğŸš€ Signal Repository ì¸í„°í˜ì´ìŠ¤ V4.1 - ëª¨ë‹¬ ì§€ì› + ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
///
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ğŸ†• ëª¨ë‹¬ìš© ë©”ì„œë“œ 4ê°œ ì¶”ê°€
/// - ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì§€ì›
/// - ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
/// - ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
/// - ì‹¤ì‹œê°„ ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
abstract class SignalRepository {
  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  );

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets);

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ê¸°ì¡´ + V4.1 í™•ì¥)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updatePatternThreshold(PatternType patternType, double threshold);

  /// í˜„ì¬ ì„¤ì •ëœ íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType);

  /// íŒ¨í„´ë³„ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled);

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType);

  /// ê°ì§€ëœ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearSignals(PatternType? patternType);

  // ==========================================================================
  // ğŸ†• V4.1 ëª¨ë‹¬ìš© ë©”ì„œë“œ 4ê°œ (í•µì‹¬ ì¶”ê°€)
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ íŒ¨í„´ì˜ íŠ¹ì • ì„ê³„ê°’ ì¡°íšŒ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  double getCurrentThresholdValue(PatternType pattern, String key);

  /// ğŸ†• ì‹œìŠ¤í…œ ì „ì²´ í™œì„±í™”/ë¹„í™œì„±í™”
  void setSystemActive(bool active);

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getSystemStatus();

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getOnlineMetricsHealth();

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
  void resetOnlineMetrics([String? market]);

  // ==========================================================================
  // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥ ê¸°ëŠ¥ (ê¸°ì¡´)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì—…ë°ì´íŠ¸ (zScoreThreshold, buyRatioMin ë“±)
  void updatePatternConfig(PatternType pattern, String key, double value);

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (conservative, aggressive, balanced)
  void applyPatternPreset(String presetName);

  /// íŒ¨í„´ë³„ í†µê³„ ì •ë³´ ì¡°íšŒ (ì‹ í˜¸ ê°œìˆ˜, ë§ˆì§€ë§‰ ê°ì§€ ì‹œê°„ ë“±)
  Future<Map<String, dynamic>> getPatternStats(PatternType type);

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<Map<String, dynamic>> getSystemHealth();

  /// ë§ˆì¼“ë³„ ë°ì´í„° í’ˆì§ˆ ì¡°íšŒ (ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± í¬í•¨)
  Map<String, dynamic> getMarketDataQuality();

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  Stream<Map<String, dynamic>> watchPerformanceMetrics();

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬ (ë°±í…ŒìŠ¤íŒ…, A/B í…ŒìŠ¤íŠ¸ ì§€ì›)
  // ==========================================================================

  /// í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸° (JSON í˜•íƒœ)
  Map<String, dynamic> exportConfiguration();

  /// ì„¤ì • ê°€ì ¸ì˜¤ê¸° (ë°±ì—… ë³µì›, í”„ë¦¬ì…‹ ì ìš©)
  void importConfiguration(Map<String, dynamic> config);

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/signal_usecase.dart ======\n
// lib/domain/usecases/signal_usecase.dart

import '../entities/signal.dart';
import '../repositories/signal_repository.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';

/// ğŸš€ Signal UseCase V4.1 - Clean Architecture + ëª¨ë‹¬ ì§€ì›
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ì—°ë™
/// - ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
/// - ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§
/// - ëª¨ë‹¬ìš© ë©”ì„œë“œ 4ê°œ ì¶”ê°€ (ì •ì„ Repository í˜¸ì¶œ)
/// - ë°±í…ŒìŠ¤íŒ… ì§€ì›
/// - ì„±ëŠ¥ ìµœì í™”ëœ í•„í„°ë§
class SignalUseCase {
  final SignalRepository _repository;

  const SignalUseCase(this._repository);

  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    return _repository.watchSignalsByPattern(patternType, markets);
  }

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    return _repository.watchAllSignals(markets);
  }

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ê¸°ë³¸ ê²€ì¦
    if (threshold <= 0) {
      throw ArgumentError('Threshold must be positive: $threshold');
    }

    // V4.1 íŒ¨í„´ë³„ ì„ê³„ê°’ ë²”ìœ„ ê²€ì¦ (ì™„í™”ëœ ê¸°ì¤€ ì ìš©)
    switch (patternType) {
      case PatternType.surge:
        if (threshold < 0.1 || threshold > 50.0) {
          throw ArgumentError('Surge threshold must be between 0.1% and 50%: $threshold');
        }
        break;
      case PatternType.flashFire:
        if (threshold < 1.1 || threshold > 10.0) {
          throw ArgumentError('FlashFire threshold must be between 1.1x and 10x: $threshold');
        }
        break;
      case PatternType.stackUp:
        if (threshold < 2 || threshold > 10) {
          throw ArgumentError('StackUp threshold must be between 2 and 10: $threshold');
        }
        break;
      case PatternType.stealthIn:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 300ë§Œ ~ 1ì–µ
        if (threshold < 3000000 || threshold > 100000000) {
          throw ArgumentError('StealthIn threshold must be between 3M and 100M: $threshold');
        }
        break;
      case PatternType.blackHole:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 0.5% ~ 5%
        if (threshold < 0.5 || threshold > 5.0) {
          throw ArgumentError('BlackHole threshold must be between 0.5% and 5%: $threshold');
        }
        break;
      case PatternType.reboundShot:
        if (threshold < 0.5 || threshold > 20.0) {
          throw ArgumentError('ReboundShot threshold must be between 0.5% and 20%: $threshold');
        }
        break;
    }

    _repository.updatePatternThreshold(patternType, threshold);
  }

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType) {
    return _repository.getPatternThreshold(patternType);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _repository.setPatternEnabled(patternType, enabled);
  }

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType) {
    return _repository.isPatternEnabled(patternType);
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearPatternSignals(PatternType patternType) {
    _repository.clearSignals(patternType);
  }

  /// ëª¨ë“  ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearAllSignals() {
    _repository.clearSignals(null);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì • (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updateAdvancedPatternConfig(PatternType pattern, String key, double value) {
    // ì„¤ì • í‚¤ë³„ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    switch (key) {
      case 'zScoreThreshold':
        if (value < 0.5 || value > 5.0) {
          throw ArgumentError('Z-Score threshold must be between 0.5 and 5.0: $value');
        }
        break;
      case 'buyRatioMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio must be between 0.0 and 1.0: $value');
        }
        break;
      case 'buyRatioMax':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio max must be between 0.0 and 1.0: $value');
        }
        break;
      case 'cvThreshold':
        if (value < 0.001 || value > 0.5) {
          throw ArgumentError('CV threshold must be between 0.001 and 0.5: $value');
        }
        break;
      case 'rSquaredMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('R-squared must be between 0.0 and 1.0: $value');
        }
        break;
      default:
        // ì¼ë°˜ì ì¸ ì–‘ìˆ˜ ê²€ì¦
        if (value < 0) {
          throw ArgumentError('Configuration value must be non-negative: $value');
        }
    }

    _repository.updatePatternConfig(pattern, key, value);
  }

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦)
  void applyPatternPreset(String presetName) {
    final validPresets = ['conservative', 'aggressive', 'balanced'];
    if (!validPresets.contains(presetName.toLowerCase())) {
      throw ArgumentError('Invalid preset name. Valid options: ${validPresets.join(', ')}');
    }

    _repository.applyPatternPreset(presetName);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ëª¨ë‹¬ìš© ë©”ì„œë“œ (Controllerì—ì„œ ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ íŒ¨í„´ì˜ íŠ¹ì • ì„ê³„ê°’ ì¡°íšŒ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  double getCurrentThresholdValue(PatternType pattern, String key) {
    return _repository.getCurrentThresholdValue(pattern, key);
  }

  /// ğŸ†• íŒ¨í„´ì˜ ê¸°ë³¸ ì„ê³„ê°’ ì¡°íšŒ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  double getDefaultThresholdValue(PatternType pattern, String key) {
    // íŒ¨í„´ë³„ ê¸°ë³¸ê°’ ì •ì˜ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
    switch (pattern) {
      case PatternType.surge:
        switch (key) {
          case 'priceChangePercent': return 0.4;
          case 'zScoreThreshold': return 2.0;
          case 'buyRatioMin': return 0.6;
          case 'buyRatioMax': return 0.95;
          case 'consecutiveMin': return 3;
          case 'timeWindowSeconds': return 300;
          case 'cooldownSeconds': return 300;
          case 'minVolume': return 100000;
          default: return 0.0;
        }
      case PatternType.flashFire:
        switch (key) {
          case 'priceChangePercent': return 0.8;
          case 'zScoreThreshold': return 3.0;
          case 'buyRatioMin': return 0.7;
          case 'buyRatioMax': return 0.98;
          case 'consecutiveMin': return 5;
          case 'timeWindowSeconds': return 180;
          case 'cooldownSeconds': return 240;
          case 'minVolume': return 200000;
          default: return 0.0;
        }
      case PatternType.stackUp:
        switch (key) {
          case 'priceChangePercent': return 0.2;
          case 'consecutiveMin': return 7;
          case 'buyRatioMin': return 0.65;
          case 'rSquaredMin': return 0.8;
          case 'timeWindowSeconds': return 600;
          case 'cooldownSeconds': return 600;
          case 'minVolume': return 150000;
          default: return 0.0;
        }
      case PatternType.stealthIn:
        switch (key) {
          case 'minTradeAmount': return 5000000.0; // 500ë§Œì›
          case 'priceChangePercent': return 0.15;
          case 'cvThreshold': return 0.05;
          case 'buyRatioMin': return 0.55;
          case 'timeWindowSeconds': return 900;
          case 'cooldownSeconds': return 900;
          case 'minVolume': return 300000;
          default: return 0.0;
        }
      case PatternType.blackHole:
        switch (key) {
          case 'cvThreshold': return 0.02;
          case 'priceChangePercent': return 0.1;
          case 'minTradeAmount': return 10000000.0; // 1000ë§Œì›
          case 'buyRatioMin': return 0.5;
          case 'timeWindowSeconds': return 1200;
          case 'cooldownSeconds': return 1200;
          case 'minVolume': return 500000;
          default: return 0.0;
        }
      case PatternType.reboundShot:
        switch (key) {
          case 'priceRangeMin': return 0.03; // 3% ê¸‰ë½
          case 'priceChangePercent': return 0.25;
          case 'buyRatioMin': return 0.75;
          case 'timeWindowSeconds': return 240;
          case 'cooldownSeconds': return 360;
          case 'reboundStrength': return 1.5;
          case 'minVolume': return 250000;
          default: return 0.0;
        }
    }
  }

  /// ğŸ†• ì„ê³„ê°’ ì§ì ‘ ì—…ë°ì´íŠ¸ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©) - updateAdvancedPatternConfig ë³„ì¹­
  void updatePatternThresholdDirect(String key, double value, PatternType pattern) {
    updateAdvancedPatternConfig(pattern, key, value);
  }

  /// ğŸ†• ì„ê³„ê°’ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  void resetThresholdToDefault(PatternType pattern, String key) {
    try {
      final defaultValue = getDefaultThresholdValue(pattern, key);
      updateAdvancedPatternConfig(pattern, key, defaultValue);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Threshold reset to default: ${pattern.name}.$key = $defaultValue');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Reset threshold to default failed: $e');
      }
      rethrow;
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ì œì–´ ë©”ì„œë“œ (Fallback ì²˜ë¦¬ í¬í•¨)
  // ==========================================================================

  /// ğŸ†• ì‹œìŠ¤í…œ ì „ì²´ í™œì„±í™”/ë¹„í™œì„±í™” (Controllerì—ì„œ ì‚¬ìš©)
  void setSystemActive(bool active) {
    _repository.setSystemActive(active);
  }

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ (Controllerì—ì„œ ì‚¬ìš©)
  Map<String, dynamic> getSystemStatus() {
    return _repository.getSystemStatus();
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ì¡°íšŒ (Controllerì—ì„œ ì‚¬ìš©)
  Map<String, dynamic> getOnlineMetricsHealth() {
    return _repository.getOnlineMetricsHealth();
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì¡°íšŒ (Controllerì—ì„œ ì‚¬ìš©)
  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹ (Controllerì—ì„œ ì‚¬ìš©)
  void resetOnlineMetrics([String? market]) {
    _repository.resetOnlineMetrics(market);
  }

  /// ğŸ†• ì„¤ì • ë‚´ë³´ë‚´ê¸° (Controllerì—ì„œ ì‚¬ìš©)
  Map<String, dynamic> exportCurrentConfiguration() {
    return _repository.exportConfiguration();
  }

  /// ğŸ†• íŒ¨í„´ì˜ ëª¨ë“  ê¸°ë³¸ê°’ ì¡°íšŒ (ë‚´ë¶€ í—¬í¼)
  Map<String, double> _getAllDefaultValues(PatternType pattern) {
    final commonKeys = [
      'priceChangePercent', 'zScoreThreshold', 'buyRatioMin', 'buyRatioMax',
      'consecutiveMin', 'timeWindowSeconds', 'cooldownSeconds', 'minVolume',
      'cvThreshold', 'rSquaredMin', 'minTradeAmount', 'priceRangeMin', 'reboundStrength'
    ];
    
    final defaults = <String, double>{};
    for (final key in commonKeys) {
      try {
        final value = getDefaultThresholdValue(pattern, key);
        if (value > 0) {
          defaults[key] = value;
        }
      } catch (e) {
        // í•´ë‹¹ í‚¤ê°€ íŒ¨í„´ì— ì—†ìœ¼ë©´ ë¬´ì‹œ
      }
    }
    
    return defaults;
  }

  /// ğŸ†• ì„¤ì • ê°€ì ¸ì˜¤ê¸° (Controllerì—ì„œ ì‚¬ìš©)
  void importSignalConfiguration(Map<String, dynamic> config) {
    _repository.importConfiguration(config);
  }

  /// ğŸ†• ì‹œê·¸ë„ ì´ˆê¸°í™” (ì˜¤ë²„ë¡œë“œëœ ë©”ì„œë“œ)
  void clearSignals([PatternType? pattern]) {
    if (pattern != null) {
      clearPatternSignals(pattern);
    } else {
      clearAllSignals();
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<PatternPerformanceStats> getPatternPerformance(PatternType pattern) async {
    final stats = await _repository.getPatternStats(pattern);
    final systemHealth = await getSystemHealth(); // UseCaseì˜ getSystemHealth ì‚¬ìš©
    
    return PatternPerformanceStats(
      patternType: pattern,
      totalSignals: stats['totalSignals'] ?? 0,
      recentSignals: stats['recentSignals'] ?? 0,
      lastSignalTime: stats['lastSignalTime'] != null 
          ? DateTime.parse(stats['lastSignalTime'])
          : null,
      isEnabled: stats['isEnabled'] ?? false,
      config: Map<String, double>.from(stats['config'] ?? {}),
      cooldownStatus: Map<String, dynamic>.from(stats['cooldownStatus'] ?? {}),
      onlineMetricsHealth: systemHealth['onlineMetricsSystem'],
    );
  }

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Future<SystemHealthReport> getSystemHealthReport() async {
    final health = await getSystemHealth(); // UseCaseì˜ getSystemHealth ì‚¬ìš©
    final dataQuality = _repository.getMarketDataQuality();
    
    return SystemHealthReport(
      version: health['version'] ?? 'Unknown',
      status: health['status'] ?? 'Unknown',
      uptime: health['uptime'] ?? 0,
      totalProcessedTrades: health['totalProcessedTrades'] ?? 0,
      activePatterns: health['activePatterns'] ?? 0,
      trackedMarkets: health['trackedMarkets'] ?? 0,
      onlineMetricsHealth: health['onlineMetricsSystem'],
      marketDataQuality: dataQuality,
      lastProcessingTime: health['lastProcessingTime'] != null 
          ? DateTime.parse(health['lastProcessingTime'])
          : null,
    );
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ìŠ¤íŠ¸ë¦¼ (í•„í„°ë§ í¬í•¨)
  Stream<PerformanceMetrics> watchFilteredPerformanceMetrics() {
    return _repository.watchPerformanceMetrics().map((raw) {
      return PerformanceMetrics(
        timestamp: DateTime.parse(raw['timestamp']),
        version: raw['version'] ?? 'Unknown',
        totalProcessedTrades: raw['totalProcessedTrades'] ?? 0,
        activeMarkets: raw['activeMarkets'] ?? 0,
        signalCounts: Map<String, int>.from(raw['signalCounts'] ?? {}),
        memoryUsage: Map<String, dynamic>.from(raw['memoryUsage'] ?? {}),
        onlineMetrics: Map<String, dynamic>.from(raw['onlineMetrics'] ?? {}),
        architecture: raw['architecture'] ?? 'Unknown',
      );
    });
  }

  // ==========================================================================
  // ì‹œê·¸ë„ ë¶„ì„ ë° í•„í„°ë§ (ê°œì„ ëœ ë¡œì§)
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ ê³„ì‚° (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  SignalStats calculateSignalStats(List<Signal> signals) {
    if (signals.isEmpty) {
      return const SignalStats(
        totalCount: 0,
        patternCounts: {},
        avgChangePercent: 0.0,
        maxChangePercent: 0.0,
        minChangePercent: 0.0,
        totalTradeAmount: 0.0,
        avgConfidence: 0.0,
        onlineMetricsCount: 0,
      );
    }

    final patternCounts = <PatternType, int>{};
    double totalChangePercent = 0.0;
    double maxChangePercent = signals.first.changePercent;
    double minChangePercent = signals.first.changePercent;
    double totalTradeAmount = 0.0;
    double totalConfidence = 0.0;
    int onlineMetricsCount = 0;

    for (final signal in signals) {
      // íŒ¨í„´ë³„ ì¹´ìš´íŠ¸
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;

      // ë³€í™”ìœ¨ í†µê³„
      totalChangePercent += signal.changePercent;
      if (signal.changePercent > maxChangePercent) {
        maxChangePercent = signal.changePercent;
      }
      if (signal.changePercent < minChangePercent) {
        minChangePercent = signal.changePercent;
      }

      // ê±°ë˜ëŒ€ê¸ˆ í•©ê³„
      totalTradeAmount += signal.tradeAmount;
      
      // V4.1 ì‹ ë¢°ë„ í†µê³„
      final confidence = signal.confidence ?? 0.0;
      totalConfidence += confidence;
      
      // V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ ì¹´ìš´íŠ¸
      if (signal.hasOnlineMetrics) {
        onlineMetricsCount++;
      }
    }

    return SignalStats(
      totalCount: signals.length,
      patternCounts: patternCounts,
      avgChangePercent: totalChangePercent / signals.length,
      maxChangePercent: maxChangePercent,
      minChangePercent: minChangePercent,
      totalTradeAmount: totalTradeAmount,
      avgConfidence: totalConfidence / signals.length,
      onlineMetricsCount: onlineMetricsCount,
    );
  }

  /// ê³ ê¸‰ ì‹œê·¸ë„ í•„í„°ë§ (V4.1 í™•ì¥)
  List<Signal> filterSignals(
    List<Signal> signals, {
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<String>? markets,
  }) {
    return signals.where((signal) {
      // ê¸°ì¡´ í•„í„°ë“¤
      if (minChangePercent != null && signal.changePercent < minChangePercent) {
        return false;
      }
      if (maxChangePercent != null && signal.changePercent > maxChangePercent) {
        return false;
      }
      if (minTradeAmount != null && signal.tradeAmount < minTradeAmount) {
        return false;
      }
      if (maxTradeAmount != null && signal.tradeAmount > maxTradeAmount) {
        return false;
      }
      if (patternTypes != null && !patternTypes.contains(signal.patternType)) {
        return false;
      }
      if (timeWindow != null) {
        final cutoff = DateTime.now().subtract(timeWindow);
        if (signal.detectedAt.isBefore(cutoff)) {
          return false;
        }
      }
      
      // V4.1 ìƒˆë¡œìš´ í•„í„°ë“¤
      if (minConfidence != null && (signal.confidence ?? 0.0) < minConfidence) {
        return false;
      }
      if (requireOnlineMetrics == true && !signal.hasOnlineMetrics) {
        return false;
      }
      if (markets != null && !markets.contains(signal.market)) {
        return false;
      }

      return true;
    }).toList();
  }

  // ==========================================================================
  // ğŸ†• V4.1 ë°±í…ŒìŠ¤íŒ… ë° ì„¤ì • ê´€ë¦¬
  // ==========================================================================

  /// í˜„ì¬ ì„¤ì • ë°±ì—…
  SignalConfiguration exportSignalConfiguration() {
    final config = exportCurrentConfiguration();
    return SignalConfiguration.fromJson(config);
  }

  /// ì„¤ì • ë³µì›  
  void importConfiguration(SignalConfiguration configuration) {
    importSignalConfiguration(configuration.toJson());
  }

  /// ì„¤ì • ë¹„êµ (A/B í…ŒìŠ¤íŠ¸ìš©)
  ConfigurationDiff compareConfigurations(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    return ConfigurationDiff.compare(configA, configB);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì¶”ê°€ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ==========================================================================

  /// ğŸ†• íŒ¨í„´ë³„ ì„¤ì • í‚¤ ëª©ë¡ ì¡°íšŒ
  List<String> getPatternConfigKeys(PatternType pattern) {
    final allKeys = _getAllDefaultValues(pattern).keys.toList();
    return allKeys..sort();
  }

  /// ğŸ†• ëª¨ë“  íŒ¨í„´ì˜ í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getAllPatternStatus() {
    final status = <String, dynamic>{};
    
    for (final pattern in PatternType.values) {
      status[pattern.name] = {
        'enabled': isPatternEnabled(pattern),
        'threshold': getPatternThreshold(pattern),
        'displayName': pattern.displayName,
        'description': pattern.description,
        'defaultThreshold': pattern.defaultThreshold,
        'timeWindowMinutes': pattern.timeWindowMinutes,
        'defaultConfidence': pattern.defaultConfidence,
        'defaultCooldownSeconds': pattern.defaultCooldownSeconds,
        'availableKeys': getPatternConfigKeys(pattern),
      };
    }
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'version': 'V4.1-Complete',
      'patterns': status,
      'systemStatus': getSystemStatus(),
    };
  }

  /// ğŸ†• ì„¤ì • ê²€ì¦
  Map<String, dynamic> validateConfiguration(Map<String, dynamic> config) {
    final errors = <String>[];
    final warnings = <String>[];
    
    try {
      // ë²„ì „ í™•ì¸
      final version = config['version'] as String?;
      if (version == null) {
        warnings.add('Configuration version not specified');
      }
      
      // íŒ¨í„´ ì„¤ì • ê²€ì¦
      final patternEnabled = config['patternEnabled'] as Map<String, dynamic>?;
      if (patternEnabled != null) {
        for (final patternName in patternEnabled.keys) {
          final found = PatternType.values.any((p) => p.name == patternName);
          if (!found) {
            warnings.add('Unknown pattern: $patternName');
          }
        }
      }
      
      // ì„ê³„ê°’ ê²€ì¦
      final patternConfig = config['patternConfig'] as Map<String, dynamic>?;
      if (patternConfig != null) {
        for (final entry in patternConfig.entries) {
          final patternName = entry.key;
          final settings = entry.value as Map<String, dynamic>?;
          
          if (settings != null && settings.containsKey('threshold')) {
            try {
              final pattern = PatternType.values.firstWhere(
                (p) => p.name == patternName,
              );
              final threshold = settings['threshold'] as double;
              
              // ì„ê³„ê°’ ë²”ìœ„ ê²€ì¦ (updatePatternThreshold ë¡œì§ ì¬ì‚¬ìš©)
              try {
                updatePatternThreshold(pattern, threshold);
              } catch (e) {
                errors.add('Invalid threshold for $patternName: $e');
              }
            } catch (e) {
              warnings.add('Unknown pattern in config: $patternName');
            }
          }
        }
      }
      
      return {
        'valid': errors.isEmpty,
        'errors': errors,
        'warnings': warnings,
        'timestamp': DateTime.now().toIso8601String(),
      };
    } catch (e) {
      return {
        'valid': false,
        'errors': ['Configuration validation failed: $e'],
        'warnings': warnings,
        'timestamp': DateTime.now().toIso8601String(),
      };
    }
  }

  /// ğŸ†• ì„±ëŠ¥ ìµœì í™”ëœ íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì²´í¬
  bool isAnyPatternEnabled() {
    return PatternType.values.any((pattern) => isPatternEnabled(pattern));
  }

  /// ğŸ†• í™œì„±í™”ëœ íŒ¨í„´ ëª©ë¡ ì¡°íšŒ
  List<PatternType> getEnabledPatterns() {
    return PatternType.values
        .where((pattern) => isPatternEnabled(pattern))
        .toList();
  }

  /// ğŸ†• ë¹„í™œì„±í™”ëœ íŒ¨í„´ ëª©ë¡ ì¡°íšŒ
  List<PatternType> getDisabledPatterns() {
    return PatternType.values
        .where((pattern) => !isPatternEnabled(pattern))
        .toList();
  }

  /// ğŸ†• íŒ¨í„´ë³„ ê¶Œì¥ ì„¤ì • ì¡°íšŒ
  Map<String, dynamic> getRecommendedSettings(PatternType pattern) {
    final defaultValues = _getAllDefaultValues(pattern);
    
    return {
      'pattern': pattern.name,
      'displayName': pattern.displayName,
      'description': pattern.description,
      'defaultValues': defaultValues,
      'currentThreshold': getPatternThreshold(pattern),
      'isEnabled': isPatternEnabled(pattern),
      'recommendations': {
        'conservative': _getConservativeSettings(pattern),
        'balanced': _getBalancedSettings(pattern),
        'aggressive': _getAggressiveSettings(pattern),
      },
    };
  }

  /// ğŸ†• ë³´ìˆ˜ì  ì„¤ì • ì¡°íšŒ
  Map<String, double> _getConservativeSettings(PatternType pattern) {
    final defaults = _getAllDefaultValues(pattern);
    final conservative = <String, double>{};
    
    for (final entry in defaults.entries) {
      final key = entry.key;
      final value = entry.value;
      
      // ë³´ìˆ˜ì  ì„¤ì •: ë” ë†’ì€ ì„ê³„ê°’, ë” ì—„ê²©í•œ ì¡°ê±´
      switch (key) {
        case 'priceChangePercent':
          conservative[key] = value * 1.5; // 50% ë” ë†’ì€ ì„ê³„ê°’
          break;
        case 'zScoreThreshold':
          conservative[key] = value * 1.3; // 30% ë” ë†’ì€ Z-Score
          break;
        case 'buyRatioMin':
          conservative[key] = (value * 1.1).clamp(0.0, 1.0); // 10% ë” ë†’ì€ ë§¤ìˆ˜ë¹„ìœ¨
          break;
        case 'cooldownSeconds':
          conservative[key] = value * 2.0; // 2ë°° ë” ê¸´ ì¿¨ë‹¤ìš´
          break;
        default:
          conservative[key] = value;
      }
    }
    
    return conservative;
  }

  /// ğŸ†• ê· í˜• ì„¤ì • ì¡°íšŒ (ê¸°ë³¸ê°’)
  Map<String, double> _getBalancedSettings(PatternType pattern) {
    return _getAllDefaultValues(pattern);
  }

  /// ğŸ†• ê³µê²©ì  ì„¤ì • ì¡°íšŒ
  Map<String, double> _getAggressiveSettings(PatternType pattern) {
    final defaults = _getAllDefaultValues(pattern);
    final aggressive = <String, double>{};
    
    for (final entry in defaults.entries) {
      final key = entry.key;
      final value = entry.value;
      
      // ê³µê²©ì  ì„¤ì •: ë” ë‚®ì€ ì„ê³„ê°’, ë” ëŠìŠ¨í•œ ì¡°ê±´
      switch (key) {
        case 'priceChangePercent':
          aggressive[key] = value * 0.7; // 30% ë” ë‚®ì€ ì„ê³„ê°’
          break;
        case 'zScoreThreshold':
          aggressive[key] = value * 0.8; // 20% ë” ë‚®ì€ Z-Score
          break;
        case 'buyRatioMin':
          aggressive[key] = (value * 0.9).clamp(0.0, 1.0); // 10% ë” ë‚®ì€ ë§¤ìˆ˜ë¹„ìœ¨
          break;
        case 'cooldownSeconds':
          aggressive[key] = value * 0.5; // ì ˆë°˜ìœ¼ë¡œ ì¤„ì¸ ì¿¨ë‹¤ìš´
          break;
        default:
          aggressive[key] = value;
      }
    }
    
    return aggressive;
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    await _repository.dispose();
  }
}

// ==========================================================================
// ğŸ†• V4.1 í™•ì¥ ë°ì´í„° í´ë˜ìŠ¤ë“¤
// ==========================================================================

/// V4.1 í–¥ìƒëœ Signal í†µê³„ ì •ë³´
class SignalStats {
  final int totalCount;
  final Map<PatternType, int> patternCounts;
  final double avgChangePercent;
  final double maxChangePercent;
  final double minChangePercent;
  final double totalTradeAmount;
  final double avgConfidence;
  final int onlineMetricsCount;

  const SignalStats({
    required this.totalCount,
    required this.patternCounts,
    required this.avgChangePercent,
    required this.maxChangePercent,
    required this.minChangePercent,
    required this.totalTradeAmount,
    required this.avgConfidence,
    required this.onlineMetricsCount,
  });

  double get onlineMetricsRatio => 
      totalCount > 0 ? onlineMetricsCount / totalCount : 0.0;

   /// ğŸ†• V4.1 JSON ì§ë ¬í™”
  Map<String, dynamic> toJson() {
    return {
      'totalCount': totalCount,
      'patternCounts': patternCounts.map((k, v) => MapEntry(k.name, v)),
      'avgChangePercent': avgChangePercent,
      'maxChangePercent': maxChangePercent,
      'minChangePercent': minChangePercent,
      'totalTradeAmount': totalTradeAmount,
      'avgConfidence': avgConfidence,
      'onlineMetricsCount': onlineMetricsCount,
      'onlineMetricsRatio': onlineMetricsRatio,
    };
  }

  @override
  String toString() {
    return 'SignalStats(total: $totalCount, avg: ${avgChangePercent.toStringAsFixed(2)}%, '
        'confidence: ${(avgConfidence * 100).toStringAsFixed(1)}%, '
        'online: ${(onlineMetricsRatio * 100).toStringAsFixed(1)}%)';
  }
}

/// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
class PatternPerformanceStats {
  final PatternType patternType;
  final int totalSignals;
  final int recentSignals;
  final DateTime? lastSignalTime;
  final bool isEnabled;
  final Map<String, double> config;
  final Map<String, dynamic> cooldownStatus;
  final Map<String, dynamic>? onlineMetricsHealth;

  const PatternPerformanceStats({
    required this.patternType,
    required this.totalSignals,
    required this.recentSignals,
    this.lastSignalTime,
    required this.isEnabled,
    required this.config,
    required this.cooldownStatus,
    this.onlineMetricsHealth,
  });
}

/// ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
class SystemHealthReport {
  final String version;
  final String status;
  final int uptime;
  final int totalProcessedTrades;
  final int activePatterns;
  final int trackedMarkets;
  final Map<String, dynamic>? onlineMetricsHealth;
  final Map<String, dynamic> marketDataQuality;
  final DateTime? lastProcessingTime;

  const SystemHealthReport({
    required this.version,
    required this.status,
    required this.uptime,
    required this.totalProcessedTrades,
    required this.activePatterns,
    required this.trackedMarkets,
    this.onlineMetricsHealth,
    required this.marketDataQuality,
    this.lastProcessingTime,
  });

  bool get isHealthy => status == 'healthy';
}

/// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤
class PerformanceMetrics {
  final DateTime timestamp;
  final String version;
  final int totalProcessedTrades;
  final int activeMarkets;
  final Map<String, int> signalCounts;
  final Map<String, dynamic> memoryUsage;
  final Map<String, dynamic> onlineMetrics;
  final String architecture;

  const PerformanceMetrics({
    required this.timestamp,
    required this.version,
    required this.totalProcessedTrades,
    required this.activeMarkets,
    required this.signalCounts,
    required this.memoryUsage,
    required this.onlineMetrics,
    required this.architecture,
  });
}

/// ì„¤ì • ì •ë³´
class SignalConfiguration {
  final String version;
  final DateTime timestamp;
  final Map<String, dynamic> patternConfig;
  final Map<String, bool> patternEnabled;
  final Map<String, dynamic> systemSettings;

  const SignalConfiguration({
    required this.version,
    required this.timestamp,
    required this.patternConfig,
    required this.patternEnabled,
    required this.systemSettings,
  });

  factory SignalConfiguration.fromJson(Map<String, dynamic> json) {
    return SignalConfiguration(
      version: json['version'] ?? 'Unknown',
      timestamp: DateTime.parse(json['timestamp']),
      patternConfig: Map<String, dynamic>.from(json['patternConfig'] ?? {}),
      patternEnabled: Map<String, bool>.from(json['patternEnabled'] ?? {}),
      systemSettings: Map<String, dynamic>.from(json['systemSettings'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'version': version,
      'timestamp': timestamp.toIso8601String(),
      'patternConfig': patternConfig,
      'patternEnabled': patternEnabled,
      'systemSettings': systemSettings,
    };
  }
}

/// ì„¤ì • ë¹„êµ ê²°ê³¼
class ConfigurationDiff {
  final List<String> changedPatterns;
  final List<String> changedSettings;
  final Map<String, dynamic> differences;

  const ConfigurationDiff({
    required this.changedPatterns,
    required this.changedSettings,
    required this.differences,
  });

  static ConfigurationDiff compare(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    final changedPatterns = <String>[];
    final changedSettings = <String>[];
    final differences = <String, dynamic>{};
    
    // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ë¹„êµ
    for (final pattern in configA.patternEnabled.keys) {
      final aEnabled = configA.patternEnabled[pattern] ?? false;
      final bEnabled = configB.patternEnabled[pattern] ?? false;
      
      if (aEnabled != bEnabled) {
        changedPatterns.add(pattern);
        differences['patternEnabled_$pattern'] = {
          'from': aEnabled,
          'to': bEnabled,
        };
      }
    }
    
    // íŒ¨í„´ ì„¤ì • ë¹„êµ
    for (final pattern in configA.patternConfig.keys) {
      final aConfig = configA.patternConfig[pattern] as Map<String, dynamic>?;
      final bConfig = configB.patternConfig[pattern] as Map<String, dynamic>?;
      
      if (aConfig != null && bConfig != null) {
        for (final key in aConfig.keys) {
          final aValue = aConfig[key];
          final bValue = bConfig[key];
          
          if (aValue != bValue) {
            changedSettings.add('${pattern}_$key');
            differences['config_${pattern}_$key'] = {
              'from': aValue,
              'to': bValue,
            };
          }
        }
      }
    }
    
    return ConfigurationDiff(
      changedPatterns: changedPatterns,
      changedSettings: changedSettings,
      differences: differences,
    );
  }

  bool get hasChanges => changedPatterns.isNotEmpty || changedSettings.isNotEmpty;
}\n\n// ====== lib/domain/entities/signal.dart ======\n
// lib/domain/entities/signal.dart

/// ğŸš€ Signal Entity V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ì˜¨ë¼ì¸ RSI/MACD ì •ë³´ í¬í•¨
/// - ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ ê²°ê³¼
/// - ì‹ ë¢°ë„ ë™ì  ì¡°ì •
/// - ìŠ¤íŠ¸ë¦¼ ê±´ê°•ì„± ì •ë³´
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ë©”íƒ€ë°ì´í„°

/// Signal íŒ¨í„´ íƒ€ì… ì •ì˜ (V4.1 í™•ì¥)
enum PatternType {
  surge,       // 1. ê¸‰ë“±ğŸš€ (1ë¶„ ì „ ëŒ€ë¹„ 0.4% ìƒìŠ¹)
  flashFire,   // 2. ë¶ˆí‹°ğŸ”¥ (3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦)
  stackUp,     // 3. ìŠ¤íƒì—…ğŸ’° (1ë¶„ì”© ì—°ì† ì¦ê°€)
  stealthIn,   // 4. ì¹¨íˆ¬ìğŸ‘£ (ì†ŒëŸ‰ ì§€ì† ìœ ì…) - ì™„í™”ë¨
  blackHole,   // 5. ë¸”ë™í™€ğŸ•³ï¸ (ê±°ë˜ëŒ€ê¸ˆâ†‘ ê°€ê²©ë³€ë™â†“) - ì™„í™”ë¨
  reboundShot, // 6. ì‡¼íŠ¸í„°ì¹˜âš¡ (ê¸‰ë½ í›„ ë°˜ë“±)
}

extension PatternTypeExtension on PatternType {
  String get displayName {
    switch (this) {
      case PatternType.surge:
        return 'ê¸‰ë“±ğŸš€';
      case PatternType.flashFire:
        return 'ë¶ˆí‹°ğŸ”¥';
      case PatternType.stackUp:
        return 'ìŠ¤íƒì—…ğŸ’°';
      case PatternType.stealthIn:
        return 'ì¹¨íˆ¬ìğŸ‘£';
      case PatternType.blackHole:
        return 'ë¸”ë™í™€ğŸ•³ï¸';
      case PatternType.reboundShot:
        return 'ì‡¼íŠ¸í„°ì¹˜âš¡';
    }
  }

  String get description {
  switch (this) {
    case PatternType.surge:
      return 'ê°€ê²© ê¸‰ë“± + ì²´ê²°ëŸ‰ í­ë°œ + MACDÂ·RSIÂ·ìœ ë™ì„± ì§€í‘œ ì¶©ì¡±';
    case PatternType.flashFire:
      return 'ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ + ë§¤ìˆ˜ ê°•ë„ + ë¨¸ì‹ ê¸‰ ì²´ê²° ê°€ì†';
    case PatternType.stackUp:
      return 'ì—°ì† ë§¤ì§‘ + MACD ìƒìŠ¹ + ê±°ë˜ëŸ‰ ì¶”ì„¸ ì •ë ¬';
    case PatternType.stealthIn:
      return 'ì €ë³€ë™ ì† ìœ ì… ì§€ì† + ë¶„ì‚° ì²´ê²° + ëˆ„ì  ë§¤ìˆ˜ ê°ì§€';
    case PatternType.blackHole:
      return 'ê°€ê²© ì •ì²´ + ë§¤ìˆ˜Â·ë§¤ë„ ê· í˜• + ì²´ê²° ì™œê³¡ íŒ¨í„´';
    case PatternType.reboundShot:
      return 'ê³¼ë§¤ë„ í›„ ë°˜ë“± + RSIÂ·MACD ë°˜ì‘ + ì í”„ ìŠ¤ì½”ì–´ í™•ì¸';
  }
}


  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ (ì™„í™”ë¨)
  double get defaultThreshold {
    switch (this) {
      case PatternType.surge:
        return 0.4; // 0.4% ìƒìŠ¹ (ê¸°ì¡´ 1.1%ì—ì„œ ì™„í™”)
      case PatternType.flashFire:
        return 2.0; // 2ë°° ê¸‰ì¦
      case PatternType.stackUp:
        return 2.0; // 2ì—°ì† (ê¸°ì¡´ 3ì—ì„œ ì™„í™”)
      case PatternType.stealthIn:
        return 5000000.0; // 500ë§Œì› (ê¸°ì¡´ 2000ë§Œì—ì„œ ëŒ€í­ ì™„í™”)
      case PatternType.blackHole:
        return 2.0; // 2% ì´í•˜ ë³€ë™ (ê¸°ì¡´ 1%ì—ì„œ ì™„í™”)
      case PatternType.reboundShot:
        return 1.5; // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
    }
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  int get timeWindowMinutes {
    switch (this) {
      case PatternType.surge:
        return 1; // 1ë¶„
      case PatternType.flashFire:
        return 1; // 1ë¶„ (V4.1 ë‹¨ì¶•)
      case PatternType.stackUp:
        return 1; // 1ë¶„
      case PatternType.stealthIn:
        return 5; // 5ë¶„
      case PatternType.blackHole:
        return 5; // 5ë¶„ (V4.1 í™•ì¥)
      case PatternType.reboundShot:
        return 1; // 1ë¶„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì‹œê°„ (ì´ˆ)
  int get defaultCooldownSeconds {
    switch (this) {
      case PatternType.surge:
        return 3; // ë¹ ë¥¸ ê°ì§€
      case PatternType.flashFire:
        return 2; // ê°€ì¥ ë¹ ë¦„
      case PatternType.stackUp:
        return 4; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 8; // ëŠë¦¼ (ì€ë°€í•¨ íŠ¹ì„±)
      case PatternType.blackHole:
        return 10; // ê°€ì¥ ëŠë¦¼ (ì•ˆì •ì„± íŠ¹ì„±)
      case PatternType.reboundShot:
        return 5; // ì¤‘ê°„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ì‹ ë¢°ë„ ê¸°ë³¸ê°’
  double get defaultConfidence {
    switch (this) {
      case PatternType.surge:
        return 0.8; // ë†’ìŒ
      case PatternType.flashFire:
        return 0.85; // ë§¤ìš° ë†’ìŒ
      case PatternType.stackUp:
        return 0.75; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 0.7; // ë‚®ìŒ (ì€ë°€í•¨)
      case PatternType.blackHole:
        return 0.8; // ë†’ìŒ (ì•ˆì •ì„±)
      case PatternType.reboundShot:
        return 0.9; // ë§¤ìš° ë†’ìŒ (ëª…í™•í•¨)
    }
  }
}

/// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
class OnlineIndicatorInfo {
  final double? rsi;
  final double? macd;
  final double? macdSignal;
  final double? macdHistogram;
  final bool isStale;
  final DateTime lastUpdate;

  const OnlineIndicatorInfo({
    this.rsi,
    this.macd,
    this.macdSignal,
    this.macdHistogram,
    required this.isStale,
    required this.lastUpdate,
  });

  /// RSI/MACDê°€ ìœ íš¨í•œì§€ ì²´í¬
  bool get hasValidData => !isStale && (rsi != null || macd != null);

  /// RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ ìƒíƒœ
  String get rsiState {
    if (rsi == null) return 'N/A';
    if (rsi! >= 70) return 'Overbought';
    if (rsi! <= 30) return 'Oversold';
    return 'Neutral';
  }

  /// MACD ì‹ í˜¸ ìƒíƒœ
  String get macdState {
    if (macd == null || macdSignal == null) return 'N/A';
    if (macd! > macdSignal!) return 'Bullish';
    if (macd! < macdSignal!) return 'Bearish';
    return 'Neutral';
  }

  Map<String, dynamic> toJson() {
    return {
      'rsi': rsi,
      'macd': macd,
      'macdSignal': macdSignal,
      'macdHistogram': macdHistogram,
      'isStale': isStale,
      'lastUpdate': lastUpdate.toIso8601String(),
      'rsiState': rsiState,
      'macdState': macdState,
    };
  }
}

/// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
class DivergenceInfo {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  final String source; // 'online-rsi', 'online-macd' ë“±

  const DivergenceInfo({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
    required this.source,
  });

  /// ë‹¤ì´ë²„ì „ìŠ¤ íƒ€ì…
  String get type {
    if (isBullish) return 'Bullish';
    if (isBearish) return 'Bearish';
    return 'None';
  }

  /// ì‹ ë¢°ë„ (ê°•ë„ ê¸°ë°˜)
  String get confidenceLevel {
    if (strength >= 0.8) return 'Very High';
    if (strength >= 0.6) return 'High';
    if (strength >= 0.4) return 'Medium';
    if (strength >= 0.2) return 'Low';
    return 'Very Low';
  }

  Map<String, dynamic> toJson() {
    return {
      'isBullish': isBullish,
      'isBearish': isBearish,
      'strength': strength,
      'source': source,
      'type': type,
      'confidenceLevel': confidenceLevel,
    };
  }
}

/// ğŸš€ Signal ê°ì§€ ê²°ê³¼ ì—”í‹°í‹° V4.1
class Signal {
  final String market;
  final String name;
  final double currentPrice;
  final double changePercent;
  final double volume;
  final double tradeAmount;
  final DateTime detectedAt;
  final PatternType patternType;
  final Map<String, dynamic> patternDetails;

  const Signal({
    required this.market,
    required this.name,
    required this.currentPrice,
    required this.changePercent,
    required this.volume,
    required this.tradeAmount,
    required this.detectedAt,
    required this.patternType,
    required this.patternDetails,
  });

  /// ê±°ë˜ ì´ì•¡ ê³„ì‚°
  double get total => currentPrice * volume;

  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ (ë™ì  ì¡°ì •ëœ ìµœì¢… ì‹ ë¢°ë„)
  double? get confidence {
    final finalConf = patternDetails['finalConfidence'] as double?;
    final originalConf = patternDetails['confidence'] as double?;
    return finalConf ?? originalConf;
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ ì¡°íšŒ
  OnlineIndicatorInfo? get onlineIndicators {
    final rsi = patternDetails['rsi'] as double?;
    final macd = patternDetails['macd'] as double?;
    final macdSignal = patternDetails['macdSignal'] as double?;
    final macdHistogram = patternDetails['macdHistogram'] as double?;
    
    if (rsi == null && macd == null) return null;
    
    return OnlineIndicatorInfo(
      rsi: rsi,
      macd: macd,
      macdSignal: macdSignal,
      macdHistogram: macdHistogram,
      isStale: false, // Signal ìƒì„±ì‹œì ì—ëŠ” ìµœì‹ 
      lastUpdate: detectedAt,
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´ ì¡°íšŒ
  DivergenceInfo? get divergence {
    final divData = patternDetails['divergence'] as Map<String, dynamic>?;
    if (divData == null) return null;
    
    return DivergenceInfo(
      isBullish: divData['isBullish'] as bool? ?? false,
      isBearish: divData['isBearish'] as bool? ?? false,
      strength: (divData['strength'] as num?)?.toDouble() ?? 0.0,
      source: divData['source'] as String? ?? 'unknown',
    );
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ì¸ì§€ ì²´í¬
  bool get hasOnlineMetrics {
    return onlineIndicators?.hasValidData ?? false;
  }

  /// ğŸ†• V4.1 ë²„ì „ ì •ë³´
  String? get version => patternDetails['version'] as String?;

  /// íŒ¨í„´ë³„ íŠ¹í™” ì •ë³´ getterë“¤
  
  /// Surge ì „ìš©: ê¸°ì¤€ê°€ (1ë¶„ ì „ ê°€ê²©)
  double? get basePrice => patternDetails['basePrice'] as double?;
  
  /// FlashFire ì „ìš©: ê¸‰ì¦ ë°°ìœ¨
  double? get surgeMultiplier => patternDetails['surgeMultiplier'] as double?;
  
  /// StackUp ì „ìš©: ì—°ì† ì¦ê°€ íšŸìˆ˜
  int? get consecutiveCount => patternDetails['consecutiveCount'] as int?;
  
  /// StealthIn ì „ìš©: ì§€ì† ì‹œê°„ (ì´ˆ)
  int? get sustainedSeconds => patternDetails['sustainedSeconds'] as int?;
  
  /// BlackHole ì „ìš©: ê°€ê²© ë³€ë™ë¥ 
  double? get priceStability => patternDetails['priceStability'] as double?;
  
  /// ReboundShot ì „ìš©: ë°˜ë“± ê°•ë„
  double? get reboundStrength => patternDetails['reboundStrength'] as double?;

  /// ğŸ†• V4.1 ê³ ê¸‰ ì§€í‘œë“¤
  double? get liquidityVortex => patternDetails['liquidityVortex'] as double?;
  double? get flashPulse => patternDetails['flashPulse'] as double?;
  double? get microBurstRadar => patternDetails['microBurstRadar'] as double?;
  double? get machineRush => patternDetails['machineRush'] as double?;
  double? get jumpScore => patternDetails['jumpScore'] as double?;
  double? get zScore => patternDetails['zScore'] as double?;

  /// ğŸ†• ì‹ ë¢°ë„ ë ˆë²¨ (í…ìŠ¤íŠ¸)
  String get confidenceLevel {
    final conf = confidence ?? 0.0;
    if (conf >= 0.9) return 'Excellent';
    if (conf >= 0.8) return 'Very High';
    if (conf >= 0.7) return 'High';
    if (conf >= 0.6) return 'Good';
    if (conf >= 0.5) return 'Medium';
    if (conf >= 0.3) return 'Low';
    return 'Very Low';
  }

  /// ğŸ†• ì‹ í˜¸ ê°•ë„ (ì¢…í•© ì ìˆ˜)
  String get signalStrength {
    double score = 0.0;
    
    // ê¸°ë³¸ ì ìˆ˜ (ë³€í™”ìœ¨ ê¸°ë°˜)
    score += (changePercent.abs() / 10.0).clamp(0.0, 1.0);
    
    // ì‹ ë¢°ë„ ì ìˆ˜
    score += (confidence ?? 0.0);
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ë³´ë„ˆìŠ¤
    if (hasOnlineMetrics) score += 0.3;
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ë³´ë„ˆìŠ¤
    final div = divergence;
    if (div != null && div.strength > 0.5) score += 0.2;
    
    score = score.clamp(0.0, 3.0) / 3.0; // 0-1 ì •ê·œí™”
    
    if (score >= 0.8) return 'Very Strong';
    if (score >= 0.6) return 'Strong';
    if (score >= 0.4) return 'Moderate';
    if (score >= 0.2) return 'Weak';
    return 'Very Weak';
  }

  /// ğŸ†• ìƒì„¸ ì •ë³´ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> get debugInfo {
    return {
      'market': market,
      'pattern': patternType.name,
      'confidence': confidence,
      'hasOnlineMetrics': hasOnlineMetrics,
      'onlineIndicators': onlineIndicators?.toJson(),
      'divergence': divergence?.toJson(),
      'signalStrength': signalStrength,
      'version': version,
      'detectedAt': detectedAt.toIso8601String(),
    };
  }

  Signal copyWith({
    String? market,
    String? name,
    double? currentPrice,
    double? changePercent,
    double? volume,
    double? tradeAmount,
    DateTime? detectedAt,
    PatternType? patternType,
    Map<String, dynamic>? patternDetails,
  }) {
    return Signal(
      market: market ?? this.market,
      name: name ?? this.name,
      currentPrice: currentPrice ?? this.currentPrice,
      changePercent: changePercent ?? this.changePercent,
      volume: volume ?? this.volume,
      tradeAmount: tradeAmount ?? this.tradeAmount,
      detectedAt: detectedAt ?? this.detectedAt,
      patternType: patternType ?? this.patternType,
      patternDetails: patternDetails ?? this.patternDetails,
    );
  }

  @override
  String toString() {
    final confText = confidence != null 
        ? '${(confidence! * 100).toStringAsFixed(1)}%' 
        : 'N/A';
    final onlineText = hasOnlineMetrics ? '[Online]' : '';
    
    return 'Signal(${patternType.displayName} $onlineText: $market '
        '${changePercent.toStringAsFixed(2)}% @ $currentPrice, '
        'Conf: $confText, at: ${detectedAt.toString().substring(11, 19)})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Signal &&
        other.market == market &&
        other.detectedAt == detectedAt &&
        other.patternType == patternType;
  }

  @override
  int get hashCode {
    return market.hashCode ^ detectedAt.hashCode ^ patternType.hashCode;
  }

  /// ğŸ†• V4.1 JSON ì§ë ¬í™” (ì €ì¥/ë¡œë“œìš©)
  Map<String, dynamic> toJson() {
    return {
      'market': market,
      'name': name,
      'currentPrice': currentPrice,
      'changePercent': changePercent,
      'volume': volume,
      'tradeAmount': tradeAmount,
      'detectedAt': detectedAt.toIso8601String(),
      'patternType': patternType.name,
      'patternDetails': patternDetails,
      'version': 'V4.1-Online',
    };
  }

  /// ğŸ†• V4.1 JSON ì—­ì§ë ¬í™”
  factory Signal.fromJson(Map<String, dynamic> json) {
    return Signal(
      market: json['market'] as String,
      name: json['name'] as String,
      currentPrice: (json['currentPrice'] as num).toDouble(),
      changePercent: (json['changePercent'] as num).toDouble(),
      volume: (json['volume'] as num).toDouble(),
      tradeAmount: (json['tradeAmount'] as num).toDouble(),
      detectedAt: DateTime.parse(json['detectedAt'] as String),
      patternType: PatternType.values.firstWhere(
        (e) => e.name == json['patternType'],
        orElse: () => PatternType.surge,
      ),
      patternDetails: Map<String, dynamic>.from(json['patternDetails'] as Map),
    );
  }
}\n\n// ====== lib/presentation/controllers/signal_controller.dart ======\n
// lib/presentation/controllers/signal_controller.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/signal_provider.dart';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/usecases/signal_usecase.dart';

/// ğŸš€ Signal í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸ V4.1
class SignalState {
  final List<Signal> signals;
  final bool isLoading;
  final bool isConnected;
  final PatternType currentPattern;
  final int selectedIndex;
  final double threshold;
  final bool isPatternEnabled;
  final String? errorMessage;
  final Map<String, dynamic>? systemHealth;
  final Map<String, dynamic>? onlineMetricsHealth;
  final String sortField;
  final bool sortAscending;

  const SignalState({
    this.signals = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.currentPattern = PatternType.surge,
    this.selectedIndex = 0,
    this.threshold = 0.4,
    this.isPatternEnabled = false,
    this.errorMessage,
    this.systemHealth,
    this.onlineMetricsHealth,
    this.sortField = 'time',
    this.sortAscending = false,
  });

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ê²° ìƒíƒœ
  bool get hasOnlineMetrics => onlineMetricsHealth != null;
  
  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„±
  bool get isSystemHealthy => 
      systemHealth?['status'] == 'healthy' && 
      (onlineMetricsHealth?['staleMarkets'] ?? 0) == 0;

  /// ğŸ†• V4.1 ì‹ í˜¸ í†µê³„
  Map<String, dynamic> get signalStats {
    final total = signals.length;
    final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
    final avgConfidence = signals.isNotEmpty 
        ? signals.map((s) => s.confidence ?? 0.0).reduce((a, b) => a + b) / total
        : 0.0;
    
    return {
      'total': total,
      'withOnlineMetrics': withOnlineMetrics,
      'onlineMetricsRatio': total > 0 ? withOnlineMetrics / total : 0.0,
      'avgConfidence': avgConfidence,
      'pattern': currentPattern.displayName,
    };
  }

  SignalState copyWith({
    List<Signal>? signals,
    bool? isLoading,
    bool? isConnected,
    PatternType? currentPattern,
    int? selectedIndex,
    double? threshold,
    bool? isPatternEnabled,
    String? errorMessage,
    Map<String, dynamic>? systemHealth,
    Map<String, dynamic>? onlineMetricsHealth,
    String? sortField,
    bool? sortAscending,
  }) {
    return SignalState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      currentPattern: currentPattern ?? this.currentPattern,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      threshold: threshold ?? this.threshold,
      isPatternEnabled: isPatternEnabled ?? this.isPatternEnabled,
      errorMessage: errorMessage,
      systemHealth: systemHealth ?? this.systemHealth,
      onlineMetricsHealth: onlineMetricsHealth ?? this.onlineMetricsHealth,
      sortField: sortField ?? this.sortField,
      sortAscending: sortAscending ?? this.sortAscending,
    );
  }
}

/// ğŸš€ Signal í™”ë©´ ì „ìš© ViewModel V4.1 - Clean Architecture + ë‹¨ë°©í–¥ ë°ì´í„° íë¦„
class SignalController extends StateNotifier<SignalState> {
  final SignalUseCase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Signal>, AppException>>? _subscription;
  StreamSubscription<Map<String, dynamic>>? _healthSubscription;
  Timer? _healthUpdateTimer;

  SignalController(this._usecase, this._ref) : super(const SignalState()) {
    _startSystemHealthMonitoring();
    _initializePatternState();
  }

  // ==========================================================================
  // ğŸ”§ ì´ˆê¸°í™” ë° ìƒíƒœ ë™ê¸°í™” - Clean Architecture
  // ==========================================================================

  /// ğŸ”§ íŒ¨í„´ ìƒíƒœ ì´ˆê¸°í™” (Provider ìƒíƒœì™€ ë™ê¸°í™”)
  void _initializePatternState() {
    try {
      // ğŸ”§ Providerì—ì„œ í˜„ì¬ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
      final currentPatternType = _ref.read(signalPatternTypeProvider);
      final currentIndex = _ref.read(signalPatternIndexProvider);
      final currentEnabled = _ref.read(signalPatternEnabledProvider(currentPatternType));
      
      // ğŸ”§ UseCaseë¥¼ í†µí•´ ì„ê³„ê°’ ê°€ì ¸ì˜¤ê¸° (ë‹¨ë°©í–¥ íë¦„)
      final currentThreshold = _usecase.getPatternThreshold(currentPatternType);
      
      state = state.copyWith(
        isPatternEnabled: currentEnabled,
        threshold: currentThreshold,
        currentPattern: currentPatternType,
        selectedIndex: currentIndex,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('âœ… Pattern state initialized: ${currentPatternType.displayName}, enabled: $currentEnabled, threshold: $currentThreshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ Pattern state initialization failed: $e');
      }
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§ (í†µí•© ìŠ¤ìœ„ì¹˜ ì—°ë™)
  // ==========================================================================

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (í†µí•© ìŠ¤ìœ„ì¹˜ ì—°ë™)
  void _startSystemHealthMonitoring() {
    _healthUpdateTimer = Timer.periodic(const Duration(seconds: 10), (_) {
      final isAnyActive = _ref.read(isAnyPatternActiveProvider);
      if (!isAnyActive) {
        state = state.copyWith(
          systemHealth: {'status': 'inactive', 'message': 'ëª¨ë“  íŒ¨í„´ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.'},
          onlineMetricsHealth: {'status': 'inactive', 'message': 'ì˜¨ë¼ì¸ ì§€í‘œê°€ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.'},
        );
        return;
      }
      
      _updateSystemHealth();
      _updateOnlineMetricsHealth();
    });
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸ (UseCase ì§ì ‘ í˜¸ì¶œ)
  void _updateSystemHealth() async {
    try {
      final health = await _usecase.getSystemHealth();
      
      state = state.copyWith(systemHealth: health);
      
      if (AppConfig.enableTradeLog) {
        final staleMarkets = health['onlineMetricsSystem']?['staleMarkets'] ?? 0;
        if (staleMarkets > 0) {
          log.w('âš ï¸ Signal Controller: $staleMarketsê°œ ë§ˆì¼“ ì˜¨ë¼ì¸ ì§€í‘œ ë§Œë£Œ');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: System health update failed - $e');
      }
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸ (UseCase ì§ì ‘ í˜¸ì¶œ)
  void _updateOnlineMetricsHealth() {
    try {
      final health = _usecase.getOnlineMetricsHealth();
      
      state = state.copyWith(onlineMetricsHealth: health);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: Online metrics health update failed - $e');
      }
    }
  }

  // ==========================================================================
  // ğŸ†• í†µí•© ì‹œìŠ¤í…œ ì œì–´ (Clean Architecture)
  // ==========================================================================

  /// ğŸ†• ì „ì²´ ì‹œìŠ¤í…œ ON/OFF ì œì–´
  void setSystemActive(bool active) {
    try {
      _usecase.setSystemActive(active);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ System ${active ? "activated" : "deactivated"} via Signal Controller');
      }
      
      // í˜„ì¬ íŒ¨í„´ ìƒíƒœ ë™ê¸°í™”
      _initializePatternState();
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ System activation toggle failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'System toggle failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì „ì²´ ì‹œìŠ¤í…œ í™œì„± ìƒíƒœ ì¡°íšŒ
  bool get isSystemActive => _ref.read(isAnyPatternActiveProvider);

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ ìš”ì•½ (UseCase ì§ì ‘ í˜¸ì¶œ)
  Map<String, dynamic> getSystemStatus() {
    try {
      return _usecase.getSystemStatus();
    } catch (e) {
      return {
        'isSystemActive': false,
        'error': e.toString(),
        'timestamp': DateTime.now().toIso8601String(),
      };
    }
  }

  // ==========================================================================
  // ê¸°ë³¸ íŒ¨í„´ ê´€ë¦¬ (Clean Architecture - ë‹¨ë°©í–¥ íë¦„)
  // ==========================================================================

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™)
  void setPatternIndex(int index, List<String> markets) {
    if (index < 0 || index >= PatternType.values.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index');
      }
      return;
    }

    final patternType = PatternType.values[index];

    // ğŸ”§ Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    _ref.read(signalPatternIndexProvider.notifier).state = index;
    _ref.read(signalPatternTypeProvider.notifier).state = patternType;

    // ğŸ”§ UseCaseì—ì„œ í˜„ì¬ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
    final newEnabled = _usecase.isPatternEnabled(patternType);
    final newThreshold = _usecase.getPatternThreshold(patternType);

    state = state.copyWith(
      currentPattern: patternType,
      selectedIndex: index,
      threshold: newThreshold,
      isPatternEnabled: newEnabled,
      isLoading: true,
      errorMessage: null,
    );

    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _subscribeToPattern(patternType, markets);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ¯ Pattern changed to: ${patternType.displayName} (V4.1) - enabled: $newEnabled, threshold: $newThreshold');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½ (UseCase ì§ì ‘ í˜¸ì¶œ)
  void updateThreshold(double threshold) {
    try {
      // ğŸ”§ UseCaseë¥¼ í†µí•œ ì—…ë°ì´íŠ¸ (ë‹¨ë°©í–¥ íë¦„)
      _usecase.updatePatternThreshold(state.currentPattern, threshold);

      // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
      state = state.copyWith(threshold: threshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“Š Threshold updated: ${state.currentPattern.displayName} â†’ $threshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Threshold update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Invalid threshold value: ${e.toString()}'
      );
    }
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€ (Provider + UseCase ë™ê¸°í™”)
  void togglePatternEnabled() {
    final newEnabled = !state.isPatternEnabled;
    
    try {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Toggle requested - Current: ${state.isPatternEnabled}, Pattern: ${state.currentPattern.displayName}');
      }
      
      // ğŸ”§ 1. Provider ìƒíƒœ ì—…ë°ì´íŠ¸
      _ref.read(signalPatternEnabledProvider(state.currentPattern).notifier).state = newEnabled;
      
      // ğŸ”§ 2. UseCase ì—…ë°ì´íŠ¸
      _usecase.setPatternEnabled(state.currentPattern, newEnabled);

      // ğŸ”§ 3. ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
      state = state.copyWith(isPatternEnabled: newEnabled);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Pattern ${newEnabled ? "enabled" : "disabled"}: ${state.currentPattern.displayName} âœ…');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Toggle pattern failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Failed to toggle pattern: ${e.toString()}'
      );
    }
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™” (UseCase ì§ì ‘ í˜¸ì¶œ)
  void clearSignals([PatternType? pattern]) {
    try {
      _usecase.clearSignals(pattern);

      if (pattern == null || pattern == state.currentPattern) {
        state = state.copyWith(signals: []);
      }
      
      if (AppConfig.enableTradeLog) {
        final patternName = pattern?.displayName ?? 'All patterns';
        log.i('ğŸ§¹ Signals cleared: $patternName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Clear signals failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Failed to clear signals: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ëª¨ë‹¬ìš© ë©”ì„œë“œ 4ê°œ (Clean Architecture)
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ ì„ê³„ê°’ ì¡°íšŒ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  double getCurrentThresholdValue(String key) {
    try {
      return _usecase.getCurrentThresholdValue(state.currentPattern, key);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ getCurrentThresholdValue failed for $key: $e');
      }
      return 0.0;
    }
  }

  /// ğŸ†• ê¸°ë³¸ ì„ê³„ê°’ ì¡°íšŒ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  double getDefaultThresholdValue(String key) {
    try {
      return _usecase.getDefaultThresholdValue(state.currentPattern, key);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ getDefaultThresholdValue failed for $key: $e');
      }
      return 0.0;
    }
  }

  /// ğŸ†• ì„ê³„ê°’ ì§ì ‘ ì—…ë°ì´íŠ¸ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  void updatePatternThresholdDirect(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      // ë©”ì¸ thresholdê°€ ë³€ê²½ëœ ê²½ìš° ë¡œì»¬ ìƒíƒœë„ ì—…ë°ì´íŠ¸
      if (key == 'priceChangePercent' || key == 'zScoreThreshold') {
        state = state.copyWith(threshold: value);
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Direct threshold updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Direct threshold update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Threshold update failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì„ê³„ê°’ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ (ëª¨ë‹¬ì—ì„œ ì‚¬ìš©)
  void resetThresholdToDefault(String key) {
    try {
      final defaultValue = getDefaultThresholdValue(key);
      updatePatternThresholdDirect(key, defaultValue);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Threshold reset to default: ${state.currentPattern.name}.$key = $defaultValue');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Reset threshold to default failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Reset to default failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì • (UseCase ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// ğŸ†• ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸
  void updateAdvancedPatternConfig(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Advanced config updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Advanced config update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration update failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (UseCase ì§ì ‘ í˜¸ì¶œ)
  void applyPreset(String presetName) {
    try {
      _usecase.applyPatternPreset(presetName);
      
      // í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ë„ ì—…ë°ì´íŠ¸
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Preset applied: $presetName - threshold: $newThreshold, enabled: $newEnabled');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Preset application failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Preset application failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹ (UseCase ì§ì ‘ í˜¸ì¶œ)
  void resetOnlineMetrics([String? market]) {
    try {
      _usecase.resetOnlineMetrics(market);
      
      // í—¬ìŠ¤ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
      _updateOnlineMetricsHealth();
      
      if (AppConfig.enableTradeLog) {
        final target = market ?? 'all markets';
        log.i('ğŸ”„ Online metrics reset: $target');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Online metrics reset failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Online metrics reset failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ (V4.1 ê°œì„  - UseCase ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  void _subscribeToPattern(PatternType patternType, List<String> markets) {
    _subscription?.cancel();
    
    _subscription = _usecase
        .watchSignalsByPattern(patternType, markets)
        .map((signals) => Ok<List<Signal>, AppException>(signals))
        .handleError((error) => Err<List<Signal>, AppException>(
            AppException(
              'Signal pattern detection failed: ${error.toString()}',
              code: 'SIGNAL_PATTERN_ERROR',
              originalException: error is Exception ? error : null,
            )))
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Signal>, AppException> result) {
    result.when(
      ok: (signals) {
        final sortedSignals = _applySorting(signals);
        
        state = state.copyWith(
          signals: sortedSignals,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
        
        if (AppConfig.enableTradeLog && signals.isNotEmpty) {
          final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
          final ratio = (withOnlineMetrics / signals.length * 100).toStringAsFixed(1);
          log.i('ğŸ“Š Signals received: ${signals.length}, Online metrics: $withOnlineMetrics ($ratio%)');
        }
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
        
        if (AppConfig.enableTradeLog) {
          log.e('âŒ Signal stream error: ${e.message}');
        }
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨
  void refresh(List<String> markets) {
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Signal refresh requested for ${markets.length} markets');
    }
    
    try {
      resetOnlineMetrics();
      setPatternIndex(state.selectedIndex, markets);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Signal refresh failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Refresh failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì •ë ¬ ë° í•„í„°ë§
  // ==========================================================================

  /// ğŸ†• ì •ë ¬ í•„ë“œ ë³€ê²½
  void setSortField(String field, {bool? ascending}) {
    final newAscending = ascending ?? (state.sortField == field ? !state.sortAscending : false);
    
    state = state.copyWith(
      sortField: field,
      sortAscending: newAscending,
      signals: _applySorting(state.signals),
    );
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ“Š Sort changed: $field (${newAscending ? "ASC" : "DESC"})');
    }
  }

  /// ğŸ†• ì •ë ¬ ì ìš©
  List<Signal> _applySorting(List<Signal> signals) {
    final list = List<Signal>.from(signals);
    
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      
      switch (state.sortField) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.currentPrice;
          bValue = b.currentPrice;
          break;
        case 'change':
          aValue = a.changePercent.abs();
          bValue = b.changePercent.abs();
          break;
        case 'amount':
          aValue = a.tradeAmount;
          bValue = b.tradeAmount;
          break;
        case 'confidence':
          aValue = a.confidence ?? 0.0;
          bValue = b.confidence ?? 0.0;
          break;
        case 'time':
        default:
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
      }
      
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      
      return state.sortAscending ? cmp : -cmp;
    });
    
    return list;
  }

  /// ğŸ†• ê³ ê¸‰ í•„í„°ë§ (UseCase ì§ì ‘ í˜¸ì¶œ)
  List<Signal> filterSignals({
    String? marketFilter,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
  }) {
    return _usecase.filterSignals(
      state.signals,
      markets: marketFilter != null ? {marketFilter.toUpperCase()} : null,
      minConfidence: minConfidence,
      requireOnlineMetrics: requireOnlineMetrics,
      patternTypes: patternTypes,
      timeWindow: timeWindow,
    );
  }

  // ==========================================================================
  // í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± (V4.1 ê°œì„  - UseCase ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// í˜„ì¬ íŒ¨í„´ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„±
  String getPatternDisplayText() {
    final pattern = state.currentPattern;
    return '${pattern.displayName}: ${pattern.description}';
  }

  /// í˜„ì¬ íŒ¨í„´ ì•„ì´ì½˜/ì´ëª¨ì§€
  String getPatternIcon() {
    return state.currentPattern.displayName;
  }

  /// ì„ê³„ê°’ í‘œì‹œ í…ìŠ¤íŠ¸ (UseCaseì—ì„œ ì‹¤ì œ ê°’ ì¡°íšŒ)
  String getThresholdDisplayText() {
    final pattern = state.currentPattern;

    try {
      switch (pattern) {
        case PatternType.surge:
          final value = _usecase.getCurrentThresholdValue(pattern, 'priceChangePercent');
          return '${value.toStringAsFixed(1)}% ìƒìŠ¹';
        case PatternType.flashFire:
          final value = _usecase.getCurrentThresholdValue(pattern, 'zScoreThreshold');
          return '${value.toStringAsFixed(1)}ë°° ê¸‰ì¦';
        case PatternType.stackUp:
          final value = _usecase.getCurrentThresholdValue(pattern, 'consecutiveMin');
          return '${value.toInt()}ì—°ì† ì¦ê°€';
        case PatternType.stealthIn:
          final value = _usecase.getCurrentThresholdValue(pattern, 'minTradeAmount');
          final amountText = value >= 1000000 
              ? '${(value / 1000000).toStringAsFixed(0)}ë°±ë§Œì›'
              : '${value.toStringAsFixed(0)}ì›';
          return '$amountText ì´ìƒ';
        case PatternType.blackHole:
          final value = _usecase.getCurrentThresholdValue(pattern, 'cvThreshold');
          return '${(value * 100).toStringAsFixed(1)}% ì´í•˜ ë³€ë™';
        case PatternType.reboundShot:
          final value = _usecase.getCurrentThresholdValue(pattern, 'priceRangeMin');
          return '${(value * 100).toStringAsFixed(1)}% ê¸‰ë½ í›„ ë°˜ë“±';
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ getThresholdDisplayText failed: $e');
      }
      return 'ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨';
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ í…ìŠ¤íŠ¸
  String getSystemStatusText() {
    if (!isSystemActive) return 'System: Inactive (All patterns disabled)';
    if (!state.hasOnlineMetrics) return 'Online metrics: Connecting...';
    
    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    if (staleMarkets > 0) {
      return 'Online metrics: $healthyMarkets/$totalMarkets healthy ($staleMarkets stale)';
    }
    
    return 'Online metrics: $healthyMarkets/$totalMarkets healthy âœ…';
  }

  /// ğŸ†• ì‹ ë¢°ë„ ìƒíƒœ í‘œì‹œ
  String getConfidenceStatusText() {
    final stats = state.signalStats;
    final avgConf = stats['avgConfidence'] as double;
    final onlineRatio = stats['onlineMetricsRatio'] as double;
    
    return 'Avg confidence: ${(avgConf * 100).toStringAsFixed(1)}%, '
           'Online: ${(onlineRatio * 100).toStringAsFixed(1)}%';
  }

  // ==========================================================================
  // ğŸ†• V4.1 í†µê³„ ë° ë¶„ì„ (UseCase ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// ğŸ†• íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<Map<String, dynamic>> getPatternPerformance() async {
    try {
      final performance = await _usecase.getPatternPerformance(state.currentPattern);
      return {
        'pattern': performance.patternType.displayName,
        'totalSignals': performance.totalSignals,
        'recentSignals': performance.recentSignals,
        'lastSignalTime': performance.lastSignalTime?.toIso8601String(),
        'isEnabled': performance.isEnabled,
        'onlineMetricsHealth': performance.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Pattern performance query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
  Future<Map<String, dynamic>> getSystemHealthReport() async {
    try {
      final report = await _usecase.getSystemHealthReport();
      return {
        'version': report.version,
        'status': report.status,
        'uptime': report.uptime,
        'totalProcessedTrades': report.totalProcessedTrades,
        'activePatterns': report.activePatterns,
        'trackedMarkets': report.trackedMarkets,
        'isHealthy': report.isHealthy,
        'onlineMetricsHealth': report.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ System health report query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹ í˜¸ í†µê³„ ê³„ì‚°
  Map<String, dynamic> calculateSignalStats() {
    return _usecase.calculateSignalStats(state.signals).toJson();
  }

  // ==========================================================================
  // ê¸°ì¡´ í˜¸í™˜ì„± ë©”ì„œë“œë“¤ (V4.1 ê°œì„ )
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ (ê¸°ì¡´ í˜¸í™˜ì„±)
  Map<String, dynamic> getSignalStats() {
    return state.signalStats;
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì ìš© (ì •ë ¬ ë“±)
  List<Signal> apply(List<Signal> signals) {
    return _applySorting(signals);
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ëª©ë¡
  List<String> get availablePatterns => 
      PatternType.values.map((p) => p.name).toList();

  /// íŒ¨í„´ í‘œì‹œëª… ëª©ë¡
  List<String> get patternDisplayNames => 
      PatternType.values.map((p) => p.displayName).toList();

  /// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê°„ ìœˆë„ìš°
  int get currentTimeWindow => state.currentPattern.timeWindowMinutes;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ê¸°ë³¸ ì‹ ë¢°ë„
  double get currentPatternDefaultConfidence => state.currentPattern.defaultConfidence;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ì¿¨ë‹¤ìš´ ì‹œê°„
  int get currentPatternCooldownSeconds => state.currentPattern.defaultCooldownSeconds;

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬ (UseCase ì§ì ‘ í˜¸ì¶œ)
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸°
  Map<String, dynamic> exportConfiguration() {
    try {
      return _usecase.exportCurrentConfiguration();
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Export configuration failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  void importConfiguration(Map<String, dynamic> config) {
    try {
      _usecase.importSignalConfiguration(config);
      
      // í˜„ì¬ ìƒíƒœ ìƒˆë¡œê³ ì¹¨
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“¥ Configuration imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Configuration import failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration import failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì—ëŸ¬ ë©”ì‹œì§€ í´ë¦¬ì–´
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (V4.1 í™•ì¥)
  // ==========================================================================

  @override
  void dispose() {
    _subscription?.cancel();
    _healthSubscription?.cancel();
    _healthUpdateTimer?.cancel();
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal Controller V4.1 disposed - Clean Architecture');
    }
    
    super.dispose();
  }
}

/// Provider ì„ ì–¸ - V4.1 Clean Architecture
final signalControllerProvider =
    StateNotifierProvider<SignalController, SignalState>((ref) {
  final usecase = ref.read(signalUsecaseProvider);
  return SignalController(usecase, ref);
});

/// ğŸ†• V4.1 í™•ì¥ - ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ Provider (í†µí•© ìŠ¤ìœ„ì¹˜ ì—°ë™)
final signalSystemMonitorProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {
      'status': 'inactive',
      'message': 'ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.',
      'timestamp': DateTime.now().toIso8601String(),
      'version': 'V4.1-Clean-Architecture-Inactive',
    };
    return;
  }
  
  final controller = ref.watch(signalControllerProvider.notifier);
  
  yield* Stream.periodic(const Duration(seconds: 15), (_) async {
    final performance = await controller.getPatternPerformance();
    final systemHealth = await controller.getSystemHealthReport();
    final signalStats = controller.calculateSignalStats();
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'performance': performance,
      'systemHealth': systemHealth,
      'signalStats': signalStats,
      'version': 'V4.1-Clean-Architecture',
      'isSystemActive': true,
    };
  }).asyncMap((event) => event);
});\n\n// ====== lib/presentation/pages/signal_page.dart ======\n
// lib/presentation/pages/signal_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/settings_provider.dart';
import '../../core/di/signal_provider.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/signal.dart';
import '../controllers/signal_controller.dart';
import '../widgets/signal_tile.dart';
import '../../shared/widgets/signal_widget.dart';  // ğŸ†• ì •êµí•œ ëª¨ë‹¬ ìœ„ì ¯ import

/// ğŸš€ Signal Page V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ + Family Provider
class SignalPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SignalPage({
    super.key,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ğŸ”½ğŸ”½ğŸ”½ ë°±ê·¸ë¼ìš´ë“œ ì›Œë°ì—…: í™œì„±í™”ëœ ëª¨ë“  íŒ¨í„´ì˜ ìŠ¤íŠ¸ë¦¼ì„ ë¯¸ë¦¬ êµ¬ë… ğŸ”½ğŸ”½ğŸ”½
    for (final pattern in PatternType.values) {
      if (ref.watch(signalPatternEnabledProvider(pattern))) {
        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í•´ë‹¹ íŒ¨í„´ì˜ ë…ë¦½ì ì¸ ìŠ¤íŠ¸ë¦¼ì„ ë¯¸ë¦¬ êµ¬ë…í•˜ì—¬ 'ì›Œë°ì—…' ìƒíƒœë¡œ ë‘”ë‹¤.
        // ì´ë ‡ê²Œ í•˜ë©´ ì‚¬ìš©ìê°€ ìŠ¬ë¼ì´ë”ë¥¼ í•´ë‹¹ íŒ¨í„´ìœ¼ë¡œ ì˜®ê²¼ì„ ë•Œ ë°ì´í„°ë¥¼ ì¦‰ì‹œ ë³¼ ìˆ˜ ìˆë‹¤.
        ref.watch(signalsByPatternProvider(pattern));
      }
    }

    // V4.1 Controller ê¸°ë°˜ ì‹œìŠ¤í…œ
    final controller = ref.watch(signalControllerProvider.notifier);
    final state = ref.watch(signalControllerProvider);

    // ğŸ”½ğŸ”½ğŸ”½ ìƒˆë¡œìš´ Family Provider ì‚¬ìš© ğŸ”½ğŸ”½ğŸ”½
    // 1. í˜„ì¬ ì„ íƒëœ íŒ¨í„´ íƒ€ì…ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
    final currentPattern = ref.watch(signalPatternTypeProvider);
    // 2. í•´ë‹¹ íŒ¨í„´ì— ëŒ€í•œ ë…ë¦½ì ì¸ ìŠ¤íŠ¸ë¦¼ í”„ë¡œë°”ì´ë”ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤.
    final signalsAsync = ref.watch(signalsByPatternProvider(currentPattern));

    // markets ì •ë³´
    final marketsAsync = ref.watch(marketsProvider);

    // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
    ref.listen(signalSystemMonitorProvider, (prev, next) {
      if (next.hasError && AppConfig.enableTradeLog) {
        debugPrint('âš ï¸ Signal system monitoring error: ${next.error}');
      }
    });

    // ì—ëŸ¬ ë©”ì‹œì§€ ìë™ í´ë¦¬ì–´
    ref.listen(signalControllerProvider.select((s) => s.errorMessage), (prev, next) {
      if (next != null) {
        Future.delayed(const Duration(seconds: 5), () {
          controller.clearError();
        });
      }
    });

    // ğŸ†• V4.1 ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
    final sliderWidget = _buildEnhancedSliderWidget(
      controller,
      state,
      marketsAsync,
      ref,
      context,
    );

    // ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° í•„í„°ë§ í¬í•¨)
    final signalListWidget = _buildEnhancedSignalList(
      signalsAsync,
      controller,
      scrollController,
      state,
      context,
      ref,
      currentPattern, // í˜„ì¬ íŒ¨í„´ ì •ë³´ ì¶”ê°€
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,

          // ğŸ†• V4.1 ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
          if (state.errorMessage != null) _buildErrorBanner(state.errorMessage!, controller),

          // ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: signalListWidget),

          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ë°°ë„ˆ
  Widget _buildErrorBanner(String errorMessage, SignalController controller) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 16),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              errorMessage,
              style: const TextStyle(color: Colors.red, fontSize: 12),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          GestureDetector(
            onTap: controller.clearError,
            child: const Icon(Icons.close, color: Colors.red, size: 16),
          ),
        ],
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
  Widget _buildEnhancedSliderWidget(
    SignalController controller,
    SignalState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì²« ë²ˆì§¸ ì¤„: ì•„ì´ì½˜ + ì œëª© + ì„¤ëª… + ìƒíƒœ í‘œì‹œ
          Row(
            children: [
              // íŒ¨í„´ ì•„ì´ì½˜ + ì œëª©
              Icon(
                _getPatternIcon(state.currentPattern),
                size: 18,
                color: _getPatternColor(state.currentPattern),
              ),
              const SizedBox(width: 8),
              
              // ì œëª© + ì„¤ëª…
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      state.currentPattern.displayName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      state.currentPattern.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),

              // ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
              _buildSystemStatusChip(state),
              const SizedBox(width: 8),

              // í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€
              _buildPatternToggle(state, controller, ref),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ë‘ ë²ˆì§¸ ì¤„: ì„ê³„ê°’ + ì‹ ë¢°ë„ ì •ë³´
          Row(
            children: [
              // ğŸ”§ ì„ê³„ê°’ì„ íƒ­ ê°€ëŠ¥í•˜ê²Œ ìˆ˜ì • (ì •êµí•œ ëª¨ë‹¬ í˜¸ì¶œ)
              GestureDetector(
                onTap: () => _showThresholdModal(context, controller, state.currentPattern),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(color: Colors.grey.withValues(alpha: 0.3)),
                    color: Colors.grey.withValues(alpha: 0.05),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(Icons.tune, size: 12, color: Colors.grey[600]),
                      const SizedBox(width: 4),
                      Text(
                        'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
                        style: const TextStyle(fontSize: 12, color: Colors.grey),
                      ),
                    ],
                  ),
                ),
              ),
              const Spacer(),
              // ğŸ†• V4.1 ì‹ ë¢°ë„ ì •ë³´
              Text(
                controller.getConfidenceStatusText(),
                style: const TextStyle(fontSize: 10, color: Colors.grey),
              ),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ì„¸ ë²ˆì§¸ ì¤„: íŒ¨í„´ ìŠ¬ë¼ì´ë”
          Row(
            children: [
              // ìŠ¬ë¼ì´ë”
              Expanded(
                child: Slider(
                  value: state.selectedIndex.toDouble(),
                  min: 0,
                  max: (PatternType.values.length - 1).toDouble(),
                  divisions: PatternType.values.length - 1,
                  label: state.currentPattern.displayName,
                  activeColor: _getPatternColor(state.currentPattern),
                  onChanged: (v) {
                    if (ref.read(appSettingsProvider).isHapticEnabled) {
                      HapticFeedback.lightImpact();
                    }
                    final index = v.round();
                    marketsAsync.whenData((markets) {
                      controller.setPatternIndex(index, markets);
                    });
                  },
                ),
              ),

              // ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
              _buildSortButton(state, controller),
            ],
          ),

          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
          _buildOnlineMetricsStatusBar(state),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ ì¹©
  Widget _buildSystemStatusChip(SignalState state) {
    final isHealthy = state.isSystemHealthy;
    final color = isHealthy ? Colors.green : Colors.orange;
    final icon = isHealthy ? Icons.check_circle : Icons.warning;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: color.withValues(alpha: 0.1),
        border: Border.all(color: color.withValues(alpha: 0.3), width: 0.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            isHealthy ? 'OK' : 'WARN',
            style: TextStyle(fontSize: 8, color: color, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ í† ê¸€ ë²„íŠ¼
  Widget _buildPatternToggle(SignalState state, SignalController controller, WidgetRef ref) {
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact();
        }
        controller.togglePatternEnabled();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange,
            width: 1.5,
          ),
          color: state.isPatternEnabled ? Colors.orange : Colors.transparent,
        ),
        child: Text(
          state.isPatternEnabled ? 'í™œì„±' : 'ë¹„í™œì„±',
          style: TextStyle(
            color: state.isPatternEnabled ? Colors.white : Colors.orange,
            fontSize: 11,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
  Widget _buildSortButton(SignalState state, SignalController controller) {
    return PopupMenuButton<String>(
      icon: Icon(
        Icons.sort,
        size: 18,
        color: Colors.grey[600],
      ),
      onSelected: (value) {
        controller.setSortField(value);
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'time', child: Text('ì‹œê°„ ${_getSortIcon(state, 'time')}')),
        PopupMenuItem(value: 'confidence', child: Text('ì‹ ë¢°ë„ ${_getSortIcon(state, 'confidence')}')),
        PopupMenuItem(value: 'change', child: Text('ë³€í™”ìœ¨ ${_getSortIcon(state, 'change')}')),
        PopupMenuItem(value: 'amount', child: Text('ê±°ë˜ì•¡ ${_getSortIcon(state, 'amount')}')),
        PopupMenuItem(value: 'market', child: Text('ë§ˆì¼“ ${_getSortIcon(state, 'market')}')),
      ],
    );
  }

  /// ğŸ†• ì •ë ¬ ì•„ì´ì½˜ í—¬í¼
  String _getSortIcon(SignalState state, String field) {
    if (state.sortField != field) return '';
    return state.sortAscending ? 'â†‘' : 'â†“';
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
  Widget _buildOnlineMetricsStatusBar(SignalState state) {
    if (!state.hasOnlineMetrics) {
      return Container(
        height: 2,
        margin: const EdgeInsets.only(top: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(1),
          color: Colors.grey[300],
        ),
      );
    }

    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    final healthRatio = totalMarkets > 0 ? healthyMarkets / totalMarkets : 0.0;
    final color = staleMarkets > 0 ? Colors.orange : Colors.green;

    return Container(
      height: 2,
      margin: const EdgeInsets.only(top: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(1),
        color: Colors.grey[300],
      ),
      child: FractionallySizedBox(
        widthFactor: healthRatio,
        alignment: Alignment.centerLeft,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(1),
            color: color,
          ),
        ),
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ)
  Widget _buildEnhancedSignalList(
    AsyncValue<List<Signal>> signalsAsync,
    SignalController controller,
    ScrollController scrollController,
    SignalState state,
    BuildContext context,
    WidgetRef ref,
    PatternType currentPattern, // í˜„ì¬ íŒ¨í„´ ì •ë³´ ì¶”ê°€
  ) {
    return signalsAsync.when(
      data: (list) {
        final viewList = controller.apply(list);

        if (viewList.isEmpty) {
          return _buildEmptyState(state, context, controller, currentPattern);
        }

        return _buildSignalListView(viewList, scrollController, state, ref);
      },
      loading: () => _buildLoadingState(context, currentPattern),
      error: (e, _) => _buildErrorState(e, context, ref, currentPattern),
    );
  }

  /// ğŸ†• V4.1 ë¹ˆ ìƒíƒœ (ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ í¬í•¨)
  Widget _buildEmptyState(SignalState state, BuildContext context, SignalController controller, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.radar,
            size: 64,
            color: Theme.of(context).hintColor.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            state.isPatternEnabled
                ? '${currentPattern.displayName} íŒ¨í„´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
                : '${currentPattern.displayName} íŒ¨í„´ ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.',
            textAlign: TextAlign.center,
            style: TextStyle(
                color: Theme.of(context).hintColor, fontSize: 16),
          ),
          const SizedBox(height: 8),
          Text(
            'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 14,
            ),
          ),
          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ
          if (state.hasOnlineMetrics) ...[
            const SizedBox(height: 8),
            Text(
              controller.getSystemStatusText(),
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Theme.of(context).hintColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
          ],
          // ğŸ†• V4.1 ë¹ ë¥¸ ì•¡ì…˜ ë²„íŠ¼ë“¤
          const SizedBox(height: 24),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => controller.resetOnlineMetrics(),
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('ì§€í‘œ ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
              const SizedBox(width: 12),
              // í”„ë¦¬ì…‹ ì ìš© ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showPresetDialog(context, controller),
                icon: const Icon(Icons.tune, size: 16),
                label: const Text('í”„ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          // ğŸ”§ ì •êµí•œ ì„ê³„ê°’ ì¡°ì • ëª¨ë‹¬ í˜¸ì¶œ ë²„íŠ¼
          ElevatedButton.icon(
            onPressed: () => _showThresholdModal(context, controller, currentPattern),
            icon: const Icon(Icons.settings, size: 16),
            label: const Text('ì„ê³„ê°’ ì¡°ì •'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.orange,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              textStyle: const TextStyle(fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ë¡œë”© ìƒíƒœ (íŒ¨í„´ë³„ ë§ì¶¤ ë©”ì‹œì§€)
  Widget _buildLoadingState(BuildContext context, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            '${currentPattern.displayName} íŒ¨í„´ ë¶„ì„ ì¤‘...',
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ ì¤‘...',
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ìƒíƒœ (íŒ¨í„´ë³„ ì—ëŸ¬ ì²˜ë¦¬)
  Widget _buildErrorState(Object error, BuildContext context, WidgetRef ref, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: Theme.of(context).colorScheme.error.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            '${currentPattern.displayName} ì‹œê·¸ë„ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            '$error',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton.icon(
                onPressed: () {
                  ref.invalidate(signalsByPatternProvider(currentPattern));
                },
                icon: const Icon(Icons.refresh),
                label: const Text('ë‹¤ì‹œ ì‹œë„'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                ),
              ),
              const SizedBox(width: 12),
              // ğŸ†• V4.1 ê³ ê¸‰ ì§„ë‹¨ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showDiagnosticsDialog(context, ref),
                icon: const Icon(Icons.info),
                label: const Text('ì§„ë‹¨'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ ë·° (ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ í¬í•¨)
  Widget _buildSignalListView(
    List<Signal> viewList,
    ScrollController scrollController,
    SignalState state,
    WidgetRef ref,
  ) {
    return RawScrollbar(
      controller: scrollController,
      thumbVisibility: false,
      trackVisibility: false,
      thickness: 6.4,
      radius: const Radius.circular(3.2),
      thumbColor: Colors.orange.withValues(alpha: 0.5),
      interactive: true,
      minThumbLength: 40,
      child: ListView.builder(
        controller: scrollController,
        physics: const BouncingScrollPhysics(
          parent: AlwaysScrollableScrollPhysics(),
        ),
        padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
        itemCount: viewList.length,
        itemBuilder: (context, index) {
          final signal = viewList[index];
          
          return Column(
            children: [
              // ğŸ†• V4.1 Signal Tile ì‚¬ìš© (íƒ­ ê¸°ëŠ¥ ì¶”ê°€)
              GestureDetector(
                onTap: () => _showSignalDetails(context, signal, ref),
                child: SignalTile(
                  signal: signal,
                  showOnlineMetrics: true,
                ),
              ),
              
              // êµ¬ë¶„ì„  (ë§ˆì§€ë§‰ ì•„ì´í…œ ì œì™¸)
              if (index < viewList.length - 1)
                Divider(
                  height: 1,
                  thickness: 0.5,
                  color: Colors.grey[300],
                  indent: 16,
                  endIndent: 16,
                ),
            ],
          );
        },
      ),
    );
  }

  // ==========================================================================
  // ğŸ†• V4.1 ëŒ€í™”ìƒìë“¤
  // ==========================================================================

  /// ğŸ”§ ì •êµí•œ ì„ê³„ê°’ ì¡°ì • ëª¨ë‹¬ (ìš°ë¦¬ê°€ ë§Œë“  ëª¨ë‹¬ ì‚¬ìš©)
  void _showThresholdModal(BuildContext context, SignalController controller, PatternType currentPattern) {
    showGeneralDialog(
      context: context,
      barrierDismissible: true,
      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
      barrierColor: Colors.black.withValues(alpha: 0.5),
      transitionDuration: const Duration(milliseconds: 300),
      pageBuilder: (context, animation1, animation2) {
        return Center(
          child: ScaleTransition(
            scale: CurvedAnimation(
              parent: animation1,
              curve: Curves.easeOutBack,
            ),
            child: ThresholdAdjustmentModal(
              pattern: currentPattern,
              controller: controller,
              onClose: () => Navigator.pop(context),
            ),
          ),
        );
      },
    );
  }

  /// ğŸ†• í”„ë¦¬ì…‹ ì„ íƒ ëŒ€í™”ìƒì
  void _showPresetDialog(BuildContext context, SignalController controller) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('íŒ¨í„´ í”„ë¦¬ì…‹ ì„ íƒ'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.security, color: Colors.blue),
              title: const Text('Conservative'),
              subtitle: const Text('False Positive ìµœì†Œí™”'),
              onTap: () {
                controller.applyPreset('conservative');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.balance, color: Colors.green),
              title: const Text('Balanced'),
              subtitle: const Text('ê· í˜•ì¡íŒ ê¸°ë³¸ ì„¤ì •'),
              onTap: () {
                controller.applyPreset('balanced');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.speed, color: Colors.red),
              title: const Text('Aggressive'),
              subtitle: const Text('ê°ì§€ìœ¨ ìµœëŒ€í™”'),
              onTap: () {
                controller.applyPreset('aggressive');
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ†• ì§„ë‹¨ ì •ë³´ ëŒ€í™”ìƒì
  void _showDiagnosticsDialog(BuildContext context, WidgetRef ref) {
    final controller = ref.read(signalControllerProvider.notifier);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ì‹œìŠ¤í…œ ì§„ë‹¨'),
        content: FutureBuilder<Map<String, dynamic>>(
          future: controller.getSystemHealthReport(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('ì§„ë‹¨ ì¤‘...'),
                ],
              );
            }
            
            if (snapshot.hasError) {
              return Text('ì§„ë‹¨ ì‹¤íŒ¨: ${snapshot.error}');
            }
            
            final report = snapshot.data!;
            return SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('ë²„ì „: ${report['version']}'),
                  Text('ìƒíƒœ: ${report['status']}'),
                  Text('ì—…íƒ€ì„: ${report['uptime']}ë¶„'),
                  Text('ì²˜ë¦¬ëœ ê±°ë˜: ${report['totalProcessedTrades']}ê±´'),
                  Text('í™œì„± íŒ¨í„´: ${report['activePatterns']}ê°œ'),
                  Text('ì¶”ì  ë§ˆì¼“: ${report['trackedMarkets']}ê°œ'),
                  const SizedBox(height: 16),
                  const Text('ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ:', style: TextStyle(fontWeight: FontWeight.bold)),
                  if (report['onlineMetricsHealth'] != null) ...[
                    Text('ì´ ë§ˆì¼“: ${report['onlineMetricsHealth']['totalMarkets']}'),
                    Text('ì •ìƒ: ${report['onlineMetricsHealth']['healthyMarkets']}'),
                    Text('ë§Œë£Œ: ${report['onlineMetricsHealth']['staleMarkets']}'),
                  ],
                ],
              ),
            );
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ì‹œê·¸ë„ ìƒì„¸ ì •ë³´ ëŒ€í™”ìƒì
  void _showSignalDetails(BuildContext context, Signal signal, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${signal.patternType.displayName} - ${signal.ticker}'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // ê¸°ë³¸ ì •ë³´
              _buildDetailRow('ë§ˆì¼“', signal.market),
              _buildDetailRow('í˜„ì¬ê°€', '${signal.currentPrice.toStringAsFixed(0)}ì›'),
              _buildDetailRow('ë³€í™”ìœ¨', '${signal.changePercent.toStringAsFixed(2)}%'),
              _buildDetailRow('ê±°ë˜ì•¡', '${(signal.tradeAmount / 1000000).toStringAsFixed(1)}M'),
              _buildDetailRow('ê°ì§€ì‹œê°„', signal.detectedAt.toString().substring(0, 19)),
              
              if (signal.confidence != null)
                _buildDetailRow('ì‹ ë¢°ë„', '${(signal.confidence! * 100).toStringAsFixed(1)}%'),
              
              // ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
              if (signal.hasOnlineMetrics) ...[
                const SizedBox(height: 16),
                const Text('ì˜¨ë¼ì¸ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                
                if (signal.onlineIndicators?.rsi != null)
                  _buildDetailRow('RSI', '${signal.onlineIndicators!.rsi!.toStringAsFixed(1)} (${signal.onlineIndicators!.rsiState})'),
                
                if (signal.onlineIndicators?.macd != null)
                  _buildDetailRow('MACD', '${signal.onlineIndicators!.macd!.toStringAsFixed(2)} (${signal.onlineIndicators!.macdState})'),
              ],
              
              // ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
              if (signal.divergence != null) ...[
                const SizedBox(height: 16),
                const Text('ë‹¤ì´ë²„ì „ìŠ¤', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                _buildDetailRow('íƒ€ì…', signal.divergence!.type),
                _buildDetailRow('ê°•ë„', signal.divergence!.confidenceLevel),
                _buildDetailRow('ì†ŒìŠ¤', signal.divergence!.source),
              ],
              
              // ê³ ê¸‰ ì§€í‘œë“¤
              const SizedBox(height: 16),
              const Text('ê³ ê¸‰ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              
              if (signal.zScore != null)
                _buildDetailRow('Z-Score', signal.zScore!.toStringAsFixed(2)),
              
              if (signal.liquidityVortex != null)
                _buildDetailRow('Liquidity Vortex', signal.liquidityVortex!.toStringAsFixed(3)),
              
              if (signal.flashPulse != null)
                _buildDetailRow('Flash Pulse', signal.flashPulse!.toStringAsFixed(2)),
              
              // ë²„ì „ ì •ë³´
              if (signal.version != null) ...[
                const SizedBox(height: 16),
                _buildDetailRow('ë²„ì „', signal.version!),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ìƒì„¸ ì •ë³´ í–‰
  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  // ==========================================================================
  // í—¬í¼ í•¨ìˆ˜ë“¤
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì•„ì´ì½˜ ë°˜í™˜
  IconData _getPatternIcon(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// íŒ¨í„´ë³„ ìƒ‰ìƒ ë°˜í™˜
  Color _getPatternColor(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }
}\n\n// ====== lib/presentation/widgets/signal_tile.dart ======\n
// lib/presentation/widgets/signal_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/signal.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';

// ğŸ¯ ì¤‘ë³µ ë°˜ì§ì„ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ Set
final Set<String> _blinkedSignals = {};

/// ğŸš€ SignalTile V4.1 - Clean UI (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
class SignalTile extends ConsumerStatefulWidget {
  final Signal signal;
  final bool showOnlineMetrics; // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ ì˜µì…˜

  const SignalTile({
    super.key, 
    required this.signal,
    this.showOnlineMetrics = true, // ê¸°ë³¸ê°’: í‘œì‹œ
  });

  @override
  ConsumerState<SignalTile> createState() => _SignalTileState();
}

class _SignalTileState extends ConsumerState<SignalTile>
    with SingleTickerProviderStateMixin {
  
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 800), // Signalì€ ì¡°ê¸ˆ ë” ê¸¸ê²Œ
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.2).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );

    _checkNewSignal();
  }

  /// ğŸ¯ ìƒˆë¡œìš´ ì‹œê·¸ë„ ê°ì§€ ë° ë°˜ì§ì„ ì²˜ë¦¬ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
  void _checkNewSignal() {
    final signalKey = '${widget.signal.market}_${widget.signal.detectedAt.millisecondsSinceEpoch}';
    
    if (BlinkAnimationHelper.checkNewSignal(
      blinkedSignalsSet: _blinkedSignals,
      detectedAt: widget.signal.detectedAt,
      signalKey: signalKey,
      maxAgeSeconds: 10,
    )) {
      _startBlink();
    }
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ ì¹©
  Widget? _buildConfidenceChip() {
    final confidence = widget.signal.confidence;
    if (confidence == null) return null;

    Color color;
    if (confidence >= 0.8) {
      color = Colors.green;
    } else if (confidence >= 0.6) {
      color = Colors.amber;
    } else {
      color = Colors.orange;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        '${(confidence * 100).toStringAsFixed(0)}%',
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ìƒì„±
  List<Widget> _buildOnlineIndicatorChips() {
    if (!widget.showOnlineMetrics || !widget.signal.hasOnlineMetrics) {
      return [];
    }

    final indicators = widget.signal.onlineIndicators!;
    final chips = <Widget>[];

    // RSI ì¹©
    if (indicators.rsi != null) {
      Color rsiColor;
      String rsiText;
      
      if (indicators.rsi! >= 70) {
        rsiColor = Colors.red;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else if (indicators.rsi! <= 30) {
        rsiColor = Colors.blue;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else {
        rsiColor = Colors.grey[600]!;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      }

      chips.add(_buildIndicatorChip(rsiText, rsiColor));
    }

    // MACD ì¹©
    if (indicators.macd != null && indicators.macdSignal != null) {
      final isBullish = indicators.macd! > indicators.macdSignal!;
      final macdColor = isBullish ? Colors.green : Colors.red;
      final macdText = isBullish ? 'M+' : 'M-';

      chips.add(_buildIndicatorChip(macdText, macdColor));
    }

    return chips;
  }

  /// ğŸ†• V4.1 ì§€í‘œ ì¹© ìœ„ì ¯
  Widget _buildIndicatorChip(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„°
  Widget? _buildDivergenceIndicator() {
    final divergence = widget.signal.divergence;
    if (divergence == null || (!divergence.isBullish && !divergence.isBearish)) {
      return null;
    }

    Color color;
    IconData icon;
    
    if (divergence.isBullish) {
      color = Colors.green;
      icon = Icons.trending_up;
    } else {
      color = Colors.red;
      icon = Icons.trending_down;
    }

    return Container(
      padding: const EdgeInsets.all(3),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Icon(
        icon,
        size: 10,
        color: color,
      ),
    );
  }

  /// ğŸ†• V4.1 ëª¨ë“  ë°°ì§€ë“¤ì„ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€í•˜ë©° ë°°ì¹˜
  Widget _buildBadgeRow() {
    final badges = <Widget>[];
    
    // ì‹ ë¢°ë„ ì¹© ì¶”ê°€
    final confidenceChip = _buildConfidenceChip();
    if (confidenceChip != null) {
      badges.add(confidenceChip);
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ì¶”ê°€
    badges.addAll(_buildOnlineIndicatorChips());
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„° ì¶”ê°€
    final divergenceIndicator = _buildDivergenceIndicator();
    if (divergenceIndicator != null) {
      badges.add(divergenceIndicator);
    }

    if (badges.isEmpty) {
      return const SizedBox.shrink();
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: badges,
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ ìƒ‰ìƒ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ì‹œ ë” ìƒë™ê°ìˆê²Œ)
  Color _getEnhancedPatternColor() {
    Color baseColor;
    
    switch (widget.signal.patternType) {
      case PatternType.surge:
        baseColor = Colors.red;
        break;
      case PatternType.flashFire:
        baseColor = Colors.orange;
        break;
      case PatternType.stackUp:
        baseColor = Colors.amber;
        break;
      case PatternType.stealthIn:
        baseColor = Colors.green;
        break;
      case PatternType.blackHole:
        baseColor = Colors.purple;
        break;
      case PatternType.reboundShot:
        baseColor = Colors.blue;
        break;
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œê°€ ìˆìœ¼ë©´ ë” ì„ ëª…í•˜ê²Œ
    if (widget.signal.hasOnlineMetrics) {
      return baseColor;
    } else {
      return baseColor.withValues(alpha: 0.7);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;

    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„± (V4.1 Clean ë²„ì „)
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 13
          FlexChild.expanded(
            Text(
              _timeFormat.format(widget.signal.detectedAt),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 13,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„: ê³ ì • í¬ê¸° (V4.1 íŒ¨í„´ ìƒ‰ìƒ í…Œë‘ë¦¬ ì¶”ê°€)
          FlexChild.fixed(
            Container(
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: _getEnhancedPatternColor(),
                  width: 1.5,
                ),
              ),
              child: CoinLogoProvider.buildCoinLogo(
                ticker: widget.signal.market.replaceFirst('KRW-', ''),
                radius: 14,
              ),
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸª™ ì½”ì¸ëª… + ë°°ì§€ë“¤: flex 24 (ğŸ†• Clean ë²„ì „)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // ì²« ë²ˆì§¸ ì¤„: ì½”ì¸ëª… + NEW ë±ƒì§€
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.signal.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // NEW ë±ƒì§€ (í•„ìš”í•œ ê²½ìš°)
                    if (TileCommon.buildNewBadge(widget.signal.detectedAt) case final badge?) 
                      badge,
                  ],
                ),
                
                const SizedBox(height: 3),
                
                // ğŸ†• ë‘ ë²ˆì§¸ ì¤„: ëª¨ë“  ë°°ì§€ë“¤ (ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                _buildBadgeRow(),
              ],
            ),
            flex: 24,
          ),

          // ğŸ’µ ê°€ê²© + ë³€í™”ìœ¨: flex 18 (ì‹ ë¢°ë„ ì¹© ì œê±°ë¨)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(widget.signal.currentPrice)}ì›',
                  style: TextStyle(color: onSurface, fontSize: 13),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  TileCommon.formatChangePercent(widget.signal.changePercent),
                  style: TextStyle(
                    color: TileCommon.getChangeColor(widget.signal.changePercent),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 18,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ’° ê±°ë˜ëŒ€ê¸ˆ: flex 18 (AmountDisplayWidget ì‚¬ìš©)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: widget.signal.tradeAmount,
                isBuy: widget.signal.changePercent >= 0,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            flex: 18,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (V4.1 íŒ¨í„´ ìƒ‰ìƒ ì—°ë™)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    return blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: _getEnhancedPatternColor(), // ğŸ†• V4.1 ë™ì  ìƒ‰ìƒ
          )
        : cardWidget;
  }
}

/// ğŸ†• V4.1 í™•ì¥: AmountDisplayWidgetì— highlightColor íŒŒë¼ë¯¸í„° ì¶”ê°€ìš© í™•ì¥
/// (ì‹¤ì œë¡œëŠ” AmountDisplayWidget í´ë˜ìŠ¤ì— ì¶”ê°€í•´ì•¼ í•¨)
extension AmountDisplayWidgetV41 on AmountDisplayWidget {
  /// V4.1 ê°•ì¡° ìƒ‰ìƒì´ ì ìš©ëœ ìœ„ì ¯ ìƒì„±
  static Widget withHighlight({
    required double totalAmount,
    required bool isBuy,
    double fontSize = 14,
    FontWeight fontWeight = FontWeight.w600,
    Color? highlightColor,
  }) {
    return Container(
      padding: highlightColor != null 
          ? const EdgeInsets.symmetric(horizontal: 4, vertical: 1)
          : null,
      decoration: highlightColor != null
          ? BoxDecoration(
              borderRadius: BorderRadius.circular(3),
              color: highlightColor.withValues(alpha: 0.1),
              border: Border.all(color: highlightColor.withValues(alpha: 0.3), width: 0.5),
            )
          : null,
      child: AmountDisplayWidget(
        totalAmount: totalAmount,
        isBuy: isBuy,
        fontSize: fontSize,
        fontWeight: fontWeight,
      ),
    );
  }
}