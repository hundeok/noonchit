\n\n// ====== lib/core/di/signal_provider.dart ======\n
// lib/core/di/signal_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import '../utils/pattern_detector.dart';
import '../utils/pattern_config.dart';
import '../utils/advanced_metrics.dart';
import 'trade_provider.dart'; // 전체 import (app_providers.dart 패턴)
import '../../data/repositories/signal_repository_impl.dart';
import '../../domain/entities/signal.dart';
import '../../domain/repositories/signal_repository.dart';
import '../../domain/usecases/signal_usecase.dart';

// ==========================================================================
// 🚀 Clean Architecture V4.1 - 단방향 데이터 흐름
// ==========================================================================

/// AdvancedMetrics Provider (온라인 계산기 관리)
final advancedMetricsProvider = Provider<AdvancedMetrics>((ref) {
  final metrics = AdvancedMetrics(
    maxGap: const Duration(seconds: 10),
    staleThreshold: const Duration(seconds: 30),
  );
  
  ref.onDispose(() {
    metrics.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('🔥 AdvancedMetrics disposed');
    }
  });
  
  return metrics;
});

/// PatternDetector Provider (온라인 지표 의존성 주입)
final patternDetectorProvider = Provider<PatternDetector>((ref) {
  final metrics = ref.watch(advancedMetricsProvider);
  
  // 🔧 PatternConfig를 Repository 내부에서만 생성하도록 변경
  final detector = PatternDetector(
    config: PatternConfig(), // 기본 설정으로 생성
    metrics: metrics,
  );
  
  ref.onDispose(() {
    detector.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('🔥 PatternDetector disposed');
    }
  });
  
  return detector;
});

/// Signal Repository Provider (단일 진실의 원천)
final signalRepoProvider = Provider<SignalRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider);
  final patternDetector = ref.watch(patternDetectorProvider);
  
  // 🔧 Repository가 자체적으로 PatternConfig 관리
  final repository = SignalRepositoryImpl(
    remoteDS,
    patternDetector: patternDetector,
    patternConfig: PatternConfig(), // Repository가 직접 관리
  );
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('🔥 SignalRepository disposed - Clean Architecture');
    }
  });
  
  return repository;
});

/// Signal UseCase Provider (비즈니스 로직 계층)
final signalUsecaseProvider = Provider<SignalUseCase>((ref) {
  final repository = ref.read(signalRepoProvider);
  return SignalUseCase(repository);
});

// ==========================================================================
// 🎯 UI 상태 관리 Providers (최소화)
// ==========================================================================

/// 현재 선택된 패턴 인덱스 (슬라이더 위치만)
final signalPatternIndexProvider = StateProvider<int>((_) => 0);

/// 현재 선택된 패턴 타입 (UI 표시용)
final signalPatternTypeProvider = StateProvider<PatternType>((ref) {
  final index = ref.watch(signalPatternIndexProvider);
  final patternName = AppConfig.getSignalPatternByIndex(index);
  
  switch (patternName) {
    case 'surge':
      return PatternType.surge;
    case 'flashFire':
      return PatternType.flashFire;
    case 'stackUp':
      return PatternType.stackUp;
    case 'stealthIn':
      return PatternType.stealthIn;
    case 'blackHole':
      return PatternType.blackHole;
    case 'reboundShot':
      return PatternType.reboundShot;
    default:
      return PatternType.surge;
  }
});

/// 패턴별 활성화 상태 관리 (UI 동기화용)
final signalPatternEnabledProvider = StateProvider.family<bool, PatternType>((ref, pattern) => false);

/// 통합 On/Off 스위치 Provider
final isAnyPatternActiveProvider = Provider<bool>((ref) {
  for (final pattern in PatternType.values) {
    if (ref.watch(signalPatternEnabledProvider(pattern))) {
      return true;
    }
  }
  return false;
});

// ==========================================================================
// 🔥 스트림 Providers (단순화)
// ==========================================================================

/// 패턴별 시그널 스트림을 독립적으로 제공
final signalsByPatternProvider =
    StreamProvider.family.autoDispose<List<Signal>, PatternType>((ref, patternType) async* {

  final isPatternEnabled = ref.watch(signalPatternEnabledProvider(patternType));
  if (!isPatternEnabled) {
    yield [];
    return;
  }

  final repository = ref.read(signalRepoProvider);
  final markets = await ref.watch(marketsProvider.future);

  if (AppConfig.enableTradeLog) {
    log.i('🎯 Starting stream for pattern: ${patternType.displayName} (Clean)');
  }

  // 🔧 패턴 활성화 상태 변경 감지 및 Repository 직접 업데이트
  ref.listen<bool>(signalPatternEnabledProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('🔄 Pattern ${next ? "enabled" : "disabled"}: ${patternType.displayName}');
      }
      repository.setPatternEnabled(patternType, next);
    }
  });

  yield* repository.watchSignalsByPattern(patternType, markets);
});

/// 현재 패턴의 시그널 스트림 (호환성)
final signalListProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  final currentPattern = ref.watch(signalPatternTypeProvider);
  
  await for (final signals in ref.watch(signalsByPatternProvider(currentPattern).stream)) {
    yield signals;
  }
});

/// 모든 패턴의 시그널 통합 스트림
final allSignalsProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield [];
    return;
  }

  ref.keepAlive();
  
  final repository = ref.read(signalRepoProvider);
  final markets = await ref.watch(marketsProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.i('🚀 All signals stream initialized (Clean Architecture)');
  }
  
  yield* repository.watchAllSignals(markets);
});

// ==========================================================================
// 🆕 모니터링 Providers (간소화)
// ==========================================================================

/// 온라인 지표 건강성 모니터링
final onlineMetricsHealthProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {'status': 'inactive', 'message': '모든 패턴이 비활성 상태입니다.'};
    return;
  }
  
  final metrics = ref.watch(advancedMetricsProvider);
  
  yield* Stream.periodic(const Duration(seconds: 5), (_) {
    return metrics.getSystemHealth();
  });
});

/// 시스템 성능 모니터링
final systemPerformanceProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {'status': 'inactive', 'message': '시스템 모니터링이 비활성 상태입니다.'};
    return;
  }
  
  final repository = ref.watch(signalRepoProvider) as SignalRepositoryImpl;
  
  yield* repository.watchPerformanceMetrics();
});

// ==========================================================================
// 🔍 개발자용 디버깅 (간소화)
// ==========================================================================

/// Repository dispose 관리
final signalRepositoryDisposeProvider = Provider.autoDispose<SignalRepository>((ref) {
  final repository = ref.watch(signalRepoProvider);
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('🔥 Signal repository disposed - Clean Architecture');
    }
  });
  
  return repository;
});\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// ⚠️ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// 🆕 타입 안전한 이벤트 스트림 (제네릭)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// 🆕 타입 안전한 플랫폼별 이벤트 스트림
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // ───────────────────────────────────────────────────────────────────────
  // Emitters for raw payloads
  // ───────────────────────────────────────────────────────────────────────

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // ───────────────────────────────────────────────────────────────────────
  // Emitters for AppEvent
  // ───────────────────────────────────────────────────────────────────────

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // ───────────────────────────────────────────────────────────────────────
  // Internal dispatch logic
  // ───────────────────────────────────────────────────────────────────────

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} → $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} → ${msg.substring(0, 100)}…');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/shared/widgets/signal_widget.dart ======\n
// lib/shared/widgets/signal_widget.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../domain/entities/signal.dart';
import '../../presentation/controllers/signal_controller.dart';

/// 🎚️ 임계값 조정 모달 위젯 V4.1 - Clean Architecture
class ThresholdAdjustmentModal extends ConsumerStatefulWidget {
  final PatternType pattern;
  final SignalController controller;
  final VoidCallback onClose;

  const ThresholdAdjustmentModal({
    super.key,
    required this.pattern,
    required this.controller,
    required this.onClose,
  });

  @override
  ConsumerState<ThresholdAdjustmentModal> createState() => _ThresholdAdjustmentModalState();
}

class _ThresholdAdjustmentModalState extends ConsumerState<ThresholdAdjustmentModal> {
  late double _currentValue;
  late double _defaultValue;
  late String _thresholdKey;
  late String _unit;
  late double _minValue;
  late double _maxValue;
  late int _divisions;

  @override
  void initState() {
    super.initState();
    _initializeThresholdConfig();
    
    // Controller 메서드는 key만 받음 (현재 패턴은 Controller 내부에서 사용)
    _currentValue = widget.controller.getCurrentThresholdValue(_thresholdKey);
    _defaultValue = widget.controller.getDefaultThresholdValue(_thresholdKey);
  }

  /// 🎯 패턴별 임계값 설정 초기화
  void _initializeThresholdConfig() {
    switch (widget.pattern) {
      case PatternType.surge:
        _thresholdKey = 'priceChangePercent';
        _unit = '%';
        _minValue = 0.1;
        _maxValue = 3.0;
        _divisions = ((3.0 - 0.1) / 0.1).round();
        break;
      case PatternType.flashFire:
        _thresholdKey = 'zScoreThreshold';
        _unit = '배';
        _minValue = 1.0;
        _maxValue = 4.0;
        _divisions = ((4.0 - 1.0) / 0.1).round();
        break;
      case PatternType.stackUp:
        _thresholdKey = 'consecutiveMin';
        _unit = '연속';
        _minValue = 1;
        _maxValue = 8;
        _divisions = (8 - 1);
        break;
      case PatternType.stealthIn:
        _thresholdKey = 'minTradeAmount';
        _unit = '만원';
        _minValue = 100; // 100만원 (표시용)
        _maxValue = 5000; // 5000만원 (표시용)
        _divisions = ((5000 - 100) / 100).round();
        break;
      case PatternType.blackHole:
        _thresholdKey = 'cvThreshold';
        _unit = '%';
        _minValue = 0.5;
        _maxValue = 10.0;
        _divisions = ((10.0 - 0.5) / 0.5).round();
        break;
      case PatternType.reboundShot:
        _thresholdKey = 'priceRangeMin';
        _unit = '%';
        _minValue = 0.1;
        _maxValue = 5.0;
        _divisions = ((5.0 - 0.1) / 0.1).round();
        break;
    }
  }

  /// 🎨 패턴별 색상 반환
  Color _getPatternColor() {
    switch (widget.pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }

  /// 🎯 패턴별 아이콘 반환
  IconData _getPatternIcon() {
    switch (widget.pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// 💰 값 포맷팅 (패턴별)
  String _formatValue(double value) {
    switch (widget.pattern) {
      case PatternType.surge:
      case PatternType.blackHole:
      case PatternType.reboundShot:
        return '${value.toStringAsFixed(1)}$_unit';
      case PatternType.flashFire:
        return '${value.toStringAsFixed(1)}$_unit';
      case PatternType.stackUp:
        return '${value.toInt()}$_unit';
      case PatternType.stealthIn:
        return '${value.toStringAsFixed(0)}$_unit';
    }
  }

  /// 🔄 실제 값 변환 (stealthIn용)
  double _convertToActualValue(double displayValue) {
    if (widget.pattern == PatternType.stealthIn) {
      return displayValue * 10000; // 만원 → 원
    }
    if (widget.pattern == PatternType.blackHole || widget.pattern == PatternType.reboundShot) {
      return displayValue / 100; // % → 소수
    }
    return displayValue;
  }

  /// 🎚️ 표시용 값 변환
  double _convertToDisplayValue(double actualValue) {
    if (widget.pattern == PatternType.stealthIn) {
      return actualValue / 10000; // 원 → 만원
    }
    if (widget.pattern == PatternType.blackHole || widget.pattern == PatternType.reboundShot) {
      return actualValue * 100; // 소수 → %
    }
    return actualValue;
  }

  /// 📱 햅틱 피드백 실행
  void _performHaptic() {
    HapticFeedback.selectionClick();
  }

  /// 💾 임계값 업데이트
  void _updateThreshold(double displayValue) {
    try {
      final actualValue = _convertToActualValue(displayValue);
      
      // Controller는 key, value만 받음
      widget.controller.updatePatternThresholdDirect(_thresholdKey, actualValue);
      
      setState(() {
        _currentValue = actualValue;
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('임계값 업데이트 실패: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  /// 🔄 기본값으로 리셋
  void _resetToDefault() {
    try {
      // Controller는 key만 받음
      widget.controller.resetThresholdToDefault(_thresholdKey);
      
      setState(() {
        _currentValue = _defaultValue;
      });
      _performHaptic();
      
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('기본값으로 리셋되었습니다'),
          backgroundColor: Colors.green,
          duration: Duration(seconds: 2),
        ),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('리셋 실패: ${e.toString()}'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final patternColor = _getPatternColor();
    final displayValue = _convertToDisplayValue(_currentValue);
    final defaultDisplayValue = _convertToDisplayValue(_defaultValue);

    return Material(
      color: Colors.transparent,
      child: Container(
        width: 280,
        height: 500,
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.3),
              blurRadius: 20,
              offset: const Offset(0, 10),
            ),
          ],
        ),
        child: Column(
          children: [
            // 🎯 헤더
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: patternColor.withValues(alpha: 0.1),
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(20),
                  topRight: Radius.circular(20),
                ),
                border: Border(
                  bottom: BorderSide(
                    color: patternColor.withValues(alpha: 0.3),
                    width: 1,
                  ),
                ),
              ),
              child: Column(
                children: [
                  Row(
                    children: [
                      Icon(
                        _getPatternIcon(),
                        color: patternColor,
                        size: 24,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          '${widget.pattern.displayName} 임계값',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: patternColor,
                          ),
                        ),
                      ),
                      GestureDetector(
                        onTap: widget.onClose,
                        child: Icon(
                          Icons.close,
                          color: Colors.grey[600],
                          size: 24,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    widget.pattern.description,
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              ),
            ),

            // 🎚️ 슬라이더 영역
            Expanded(
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    // 현재 값 표시
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                      decoration: BoxDecoration(
                        color: patternColor.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: patternColor.withValues(alpha: 0.3),
                          width: 1,
                        ),
                      ),
                      child: Text(
                        _formatValue(displayValue),
                        style: TextStyle(
                          fontSize: 24,
                          fontWeight: FontWeight.bold,
                          color: patternColor,
                        ),
                      ),
                    ),

                    const SizedBox(height: 30),

                    // 세로 슬라이더
                    Expanded(
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          // 최대값 표시
                          Text(
                            _formatValue(_maxValue),
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          
                          const SizedBox(width: 20),
                          
                          // 세로 슬라이더
                          SizedBox(
                            height: 300,
                            child: RotatedBox(
                              quarterTurns: 3, // 90도 회전
                              child: SliderTheme(
                                data: SliderTheme.of(context).copyWith(
                                  activeTrackColor: patternColor,
                                  inactiveTrackColor: patternColor.withValues(alpha: 0.3),
                                  thumbColor: patternColor,
                                  overlayColor: patternColor.withValues(alpha: 0.2),
                                  thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 12),
                                  overlayShape: const RoundSliderOverlayShape(overlayRadius: 20),
                                  trackHeight: 8,
                                ),
                                child: Slider(
                                  value: displayValue.clamp(_minValue, _maxValue),
                                  min: _minValue,
                                  max: _maxValue,
                                  divisions: _divisions,
                                  onChanged: (value) {
                                    _performHaptic();
                                    _updateThreshold(value);
                                  },
                                ),
                              ),
                            ),
                          ),
                          
                          const SizedBox(width: 20),
                          
                          // 최소값 표시
                          Text(
                            _formatValue(_minValue),
                            style: TextStyle(
                              fontSize: 12,
                              color: Colors.grey[600],
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ],
                      ),
                    ),

                    const SizedBox(height: 20),

                    // 기본값 표시
                    Container(
                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        '기본값: ${_formatValue(defaultDisplayValue)}',
                        style: TextStyle(
                          fontSize: 12,
                          color: Colors.grey[600],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),

            // 🔄 액션 버튼들
            Container(
              padding: const EdgeInsets.all(20),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: const BorderRadius.only(
                  bottomLeft: Radius.circular(20),
                  bottomRight: Radius.circular(20),
                ),
              ),
              child: Row(
                children: [
                  // 리셋 버튼
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: _resetToDefault,
                      icon: const Icon(Icons.refresh, size: 16),
                      label: const Text('리셋'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.grey[300],
                        foregroundColor: Colors.grey[700],
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                    ),
                  ),
                  
                  const SizedBox(width: 12),
                  
                  // 완료 버튼
                  Expanded(
                    flex: 2,
                    child: ElevatedButton.icon(
                      onPressed: widget.onClose,
                      icon: const Icon(Icons.check, size: 16),
                      label: const Text('완료'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: patternColor,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(vertical: 12),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(10),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/data/repositories/signal_repository_impl.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/signal_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/pattern_detector.dart';
import '../../core/utils/pattern_config.dart';
import '../../core/utils/market_data_context.dart';
import 'dart:async' show unawaited;


/// 🚀 SignalRepositoryImpl V4.1 - 메모리 최적화
/// 
/// 핵심 최적화:
/// - LRU 기반 메모리 관리
/// - 활성 패턴 필터링으로 불필요한 계산 제거
/// - 스트림 재사용으로 중복 생성 방지
/// - 적응형 정리 주기
class SignalRepositoryImpl implements SignalRepository {
  final TradeRemoteDataSource _remote;
  final TradeAggregator _aggregator;
  final PatternDetector _patternDetector;
  final PatternConfig _patternConfig;

  // 🔥 최적화: LRU 기반 마켓 컨텍스트 관리
  final Map<String, MarketDataContext> _marketContexts = {};
  final Map<String, DateTime> _marketLastAccess = {};
  static const int _maxMarketContexts = 50; // 메모리 제한

  // 🔥 최적화: 활성 패턴만 추적
  final Set<PatternType> _activePatterns = {};
  final Map<PatternType, List<Signal>> _signalLists = {};
  final Map<PatternType, bool> _patternEnabled = {};

  // 🔥 최적화: LRU 기반 중복 감지
  final Map<String, DateTime> _seenIdsWithTime = {};
  static const int _maxSeenIds = 1000; // 메모리 제한

  // 🎯 패턴별 스트림 컨트롤러
  final Map<PatternType, StreamController<List<Signal>>> _patternControllers = {};
  final StreamController<List<Signal>> _allSignalsController = 
      StreamController<List<Signal>>.broadcast();

  // 🔥 스트림 관리
  Stream<Trade>? _signalStream;
  StreamSubscription<Trade>? _signalSubscription;

  // 🚀 적응형 타이머 시스템
  Timer? _batchUpdateTimer;
  Timer? _memoryCleanupTimer;
  Timer? _activeCleanupTimer;

  // 📊 성능 모니터링
  final Map<PatternType, int> _signalCounts = {};
  final Map<PatternType, DateTime?> _lastSignalTimes = {};
  int _totalProcessedTrades = 0;
  DateTime? _lastProcessingTime;

  // 🔥 최적화: 메모리 압박 감지
  int _memoryPressureLevel = 0; // 0: 낮음, 1: 중간, 2: 높음

  // ==========================================================================
  // 초기화
  // ==========================================================================

  SignalRepositoryImpl(
    this._remote, {
    PatternDetector? patternDetector,
    PatternConfig? patternConfig,
  }) : _aggregator = TradeAggregator(),
       _patternDetector = patternDetector ?? PatternDetector(),
       _patternConfig = patternConfig ?? PatternConfig() {
    _initializePatterns();
    _startAdaptiveCleanup();
    log.i('🚀 SignalRepository V4.1 초기화 완료 - 메모리 최적화');
  }

  void _initializePatterns() {
    for (final pattern in PatternType.values) {
      _signalLists[pattern] = [];
      _patternEnabled[pattern] = false;
      _signalCounts[pattern] = 0;
      _patternControllers[pattern] = StreamController<List<Signal>>.broadcast();
      // _activePatterns.add(pattern); // 이 라인을 삭제하거나 주석 처리
    }

    if (kDebugMode) {
      log.i('🎯 패턴 초기화 완료: ${_activePatterns.length}개 활성 패턴');
    }
  }

  /// 🔥 최적화: 적응형 정리 시스템
  void _startAdaptiveCleanup() {
    // 메모리 정리: 압박 수준에 따라 주기 조절
    _memoryCleanupTimer = Timer.periodic(const Duration(minutes: 2), (_) {
      _adaptiveMemoryCleanup();
    });

    // 활성 상태 정리: 더 자주 수행
    _activeCleanupTimer = Timer.periodic(const Duration(minutes: 1), (_) {
      _cleanupActiveStates();
    });
  }

  /// 🔥 최적화: 적응형 메모리 정리
  void _adaptiveMemoryCleanup() {
    final now = DateTime.now();
    
    // 메모리 압박 수준 계산
    _memoryPressureLevel = _calculateMemoryPressure();
    
    // 압박 수준에 따른 정리 강도 조절
    final maxAge = _memoryPressureLevel == 2 ? 10 : // 높음: 10분
                   _memoryPressureLevel == 1 ? 20 : // 중간: 20분  
                   30; // 낮음: 30분

    _cleanupMarketContextsLRU(maxAge);
    _cleanupSeenIdsLRU(maxAge);

    if (kDebugMode && _memoryPressureLevel > 0) {
      log.d('🧹 적응형 정리 완료 (압박수준: $_memoryPressureLevel, 최대연령: ${maxAge}분)');
    }
  }

  /// 🔥 최적화: 메모리 압박 수준 계산
  int _calculateMemoryPressure() {
    final contextCount = _marketContexts.length;
    final seenIdsCount = _seenIdsWithTime.length;
    final totalSignals = _signalLists.values.fold(0, (sum, list) => sum + list.length);

    if (contextCount > _maxMarketContexts * 0.8 || 
        seenIdsCount > _maxSeenIds * 0.8 ||
        totalSignals > 500) {
      return 2; // 높음
    } else if (contextCount > _maxMarketContexts * 0.6 || 
               seenIdsCount > _maxSeenIds * 0.6 ||
               totalSignals > 300) {
      return 1; // 중간
    }
    return 0; // 낮음
  }

  /// 🔥 최적화: LRU 기반 마켓 컨텍스트 정리
  void _cleanupMarketContextsLRU(int maxAgeMinutes) {
    final now = DateTime.now();
    final cutoff = now.subtract(Duration(minutes: maxAgeMinutes));
    int removedCount = 0;

    // 오래된 항목들 제거
    final toRemove = <String>[];
    for (final entry in _marketLastAccess.entries) {
      if (entry.value.isBefore(cutoff)) {
        toRemove.add(entry.key);
      }
    }

    for (final market in toRemove) {
      final context = _marketContexts.remove(market);
      _marketLastAccess.remove(market);
      
      if (context != null) {
        context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        removedCount++;
      }
    }

    // 개수 제한 초과시 LRU 제거
    if (_marketContexts.length > _maxMarketContexts) {
      final sortedByAccess = _marketLastAccess.entries.toList()
        ..sort((a, b) => a.value.compareTo(b.value));

      final excessCount = _marketContexts.length - _maxMarketContexts;
      for (int i = 0; i < excessCount; i++) {
        final market = sortedByAccess[i].key;
        final context = _marketContexts.remove(market);
        _marketLastAccess.remove(market);
        
        if (context != null) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
          removedCount++;
        }
      }
    }

    if (kDebugMode && removedCount > 0) {
      log.d('🧹 LRU 마켓 컨텍스트 정리: $removedCount개 제거');
    }
  }

  /// 🔥 최적화: LRU 기반 중복 감지 ID 정리
  void _cleanupSeenIdsLRU(int maxAgeMinutes) {
    final now = DateTime.now();
    final cutoff = now.subtract(Duration(minutes: maxAgeMinutes));
    
    _seenIdsWithTime.removeWhere((id, timestamp) => timestamp.isBefore(cutoff));

    // 개수 제한 초과시 LRU 제거
    if (_seenIdsWithTime.length > _maxSeenIds) {
      final sortedByTime = _seenIdsWithTime.entries.toList()
        ..sort((a, b) => a.value.compareTo(b.value));

      final excessCount = _seenIdsWithTime.length - _maxSeenIds;
      for (int i = 0; i < excessCount; i++) {
        _seenIdsWithTime.remove(sortedByTime[i].key);
      }
    }
  }

  /// 🔥 최적화: 활성 상태 정리
  void _cleanupActiveStates() {
    // 비활성화된 패턴을 활성 패턴 세트에서 제거
    _activePatterns.removeWhere((pattern) => !(_patternEnabled[pattern] ?? false));
    
    // 활성 패턴이 변경되었으면 로그
    final enabledCount = _patternEnabled.values.where((enabled) => enabled).length;
    if (_activePatterns.length != enabledCount) {
      _activePatterns.clear();
      for (final entry in _patternEnabled.entries) {
        if (entry.value) {
          _activePatterns.add(entry.key);
        }
      }
      
      if (kDebugMode) {
        log.d('🎯 활성 패턴 업데이트: ${_activePatterns.length}개');
      }
    }
  }

  // ==========================================================================
  // 🔥 핵심: 브로드캐스트 스트림 초기화
  // ==========================================================================

  void _initializeSignalStream(List<String> markets) {
    if (_signalStream != null) return;

    log.i('SignalRepositoryImpl V4.1: 신호 스트림 초기화 - ${markets.length}개 시장');

    _signalStream = _remote.watch(markets).asBroadcastStream();

    _signalSubscription = _signalStream!.listen(
      _processRawTradeForSignal,
      onError: (error, stackTrace) {
        log.e('Signal stream error: $error', stackTrace);
      },
      onDone: () {
        log.i('Signal stream done');
      },
    );
  }

  // ==========================================================================
  // 📊 마켓 데이터 컨텍스트 관리 (LRU 최적화)
  // ==========================================================================

  /// 🔥 최적화: LRU 기반 마켓 데이터 컨텍스트 관리
  MarketDataContext _getOrCreateMarketContext(String market) {
    final now = DateTime.now();
    
    // 접근 시간 업데이트 (LRU)
    _marketLastAccess[market] = now;
    
    return _marketContexts.putIfAbsent(
      market,
      () => MarketDataContext.empty(market),
    );
  }

  /// 모든 타임프레임 윈도우 업데이트 (온라인 지표 연동)
  void _updateMarketContext(Trade trade, DateTime timestamp) {
    final context = _getOrCreateMarketContext(trade.market);
    
    // 거래 간격 계산
    final interval = context.intervalWindow != null && 
                    context.intervalWindow!.timestamps.isNotEmpty
        ? timestamp.difference(context.intervalWindow!.timestamps.last).inSeconds.toDouble()
        : 10.0;
    
    // 매수 비율 (간단한 추정)
    final buyRatio = trade.isBuy ? 1.0 : 0.0;
    
    // 🔥 온라인 지표와 함께 모든 윈도우 업데이트
    context.updateWithOnlineMetrics(
      price: trade.price,
      volume: trade.total,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: max(interval, 1.0),
      onlineMetrics: _patternDetector.metrics, // 온라인 지표 연동
    );
  }

  // ==========================================================================
  // 📥 원시 거래 데이터 처리 (중복 감지 최적화)
  // ==========================================================================

  void _processRawTradeForSignal(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';
      final now = DateTime.now();

      // 🔥 최적화: LRU 기반 중복 감지
      if (_seenIdsWithTime.containsKey(key)) {
        return; // 이미 처리된 거래
      }
      
      _seenIdsWithTime[key] = now;

      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleAggregatedTrade,
      );
    } catch (e, stackTrace) {
      log.w('_processRawTradeForSignal error: $e', stackTrace);
    }
  }

  void _handleAggregatedTrade(Map<String, dynamic> aggregatedTrade) {
    if (_activePatterns.isEmpty) return; // 활성 패턴이 없으면 모든 분석 중단
    try {
      final trade = Trade(
        market: aggregatedTrade['market'] as String,
        price: aggregatedTrade['price'] as double,
        volume: aggregatedTrade['volume'] as double,
        side: (aggregatedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: aggregatedTrade['timestamp'] as int,
        sequentialId: aggregatedTrade['sequential_id'] as String? ?? '',
      );

      final now = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
      _updateMarketContext(trade, now);
      unawaited(_analyzePatterns(trade, now));
    } catch (e, stackTrace) {
      log.w('_handleAggregatedTrade error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // 🎯 패턴 분석 (활성 패턴만 처리)
  // ==========================================================================

  /// 🔥 최적화: 활성 패턴만 분석
  Future<void> _analyzePatterns(Trade trade, DateTime now) async {

    try {
      final context = _getOrCreateMarketContext(trade.market);
      final detectedSignals = <Signal>[];

      // 🔥 최적화: 활성화된 패턴만 처리
      for (final pattern in _activePatterns) {
        try {
          // 🚀 개선된 패턴 감지 (단일 메서드, 명확한 파라미터)
          final signal = await _patternDetector.detectPattern(
            patternType: pattern,
            trade: trade,
            timestamp: now,
            context: context,
          );

          if (signal != null) {
            detectedSignals.add(signal);
            _signalCounts[pattern] = (_signalCounts[pattern] ?? 0) + 1;
            _lastSignalTimes[pattern] = now;
          }
        } catch (e, stackTrace) {
          log.w('Pattern analysis error: ${pattern.name} - $e', stackTrace);
        }
      }

      // 신호 추가
      for (final signal in detectedSignals) {
        _addSignal(signal.patternType, signal);
      }

      if (detectedSignals.isNotEmpty) {
        _scheduleBatchUpdate();
      }

      _totalProcessedTrades++;
      _lastProcessingTime = now;
    } catch (e, stackTrace) {
      log.e('_analyzePatterns error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // 🚀 시그널 추가 및 관리
  // ==========================================================================

  void _addSignal(PatternType pattern, Signal signal) {
    final signalList = _signalLists[pattern];
    if (signalList == null) return;

    // 중복 신호 체크 (5분 이내)
    final cutoff = signal.detectedAt.subtract(const Duration(minutes: 5));
    final isDuplicate = signalList.any((existingSignal) =>
        existingSignal.market == signal.market &&
        existingSignal.detectedAt.isAfter(cutoff));

    if (isDuplicate) return;

    signalList.insert(0, signal);

    // 최대 신호 개수 제한
    if (signalList.length > AppConfig.maxSignalsPerPattern) {
      signalList.removeLast();
    }

    if (kDebugMode) {
      final confidence = signal.patternDetails['finalConfidence'] ?? 
                       signal.patternDetails['confidence'] ?? 0.0;
      log.i('🚨 V4.1 신호 감지: ${signal.patternType.displayName} - ${signal.market} '
          '(${signal.changePercent.toStringAsFixed(2)}%, 신뢰도: ${(confidence * 100).toStringAsFixed(1)}%)');
    }
  }

  /// 🚀 배치 업데이트 스케줄링
  void _scheduleBatchUpdate() {
    if (_batchUpdateTimer?.isActive != true) {
      _batchUpdateTimer = Timer(AppConfig.signalBatchInterval, _updateSignalStreams);
    }
  }

  /// 📊 모든 시그널 스트림 배치 업데이트
  void _updateSignalStreams() {
    try {
      for (final entry in _signalLists.entries) {
        final pattern = entry.key;
        final signals = List<Signal>.from(entry.value);

        final controller = _patternControllers[pattern];
        if (controller != null && !controller.isClosed) {
          controller.add(signals);
        }
      }

      final allSignals = _signalLists.values.expand((list) => list).toList();
      allSignals.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
      final recentSignals = allSignals.take(50).toList();

      if (!_allSignalsController.isClosed) {
        _allSignalsController.add(recentSignals);
      }

      if (kDebugMode && allSignals.isNotEmpty) {
        log.d('🚀 V4.1 신호 스트림 업데이트: ${allSignals.length}개 총 신호');
      }
    } catch (e, stackTrace) {
      log.w('_updateSignalStreams error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // SignalRepository 인터페이스 구현 (변경사항 없음)
  // ==========================================================================

  @override
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    _initializeSignalStream(markets);
    return _patternControllers[patternType]?.stream ?? const Stream.empty();
  }

  @override
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    _initializeSignalStream(markets);
    return _allSignalsController.stream;
  }

  @override
  void updatePatternThreshold(PatternType patternType, double threshold) {
    try {
      _patternConfig.updatePatternConfig(patternType, 'priceChangePercent', threshold);
      log.i('V4.1: 패턴 임계값 업데이트 - ${patternType.name}: $threshold');
    } catch (e) {
      log.w('패턴 임계값 업데이트 실패: $e');
    }
  }

  @override
  double getPatternThreshold(PatternType patternType) {
    return _patternConfig.getConfigValue(patternType, 'priceChangePercent');
  }

  @override
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _patternEnabled[patternType] = enabled;
    
    // 🔥 최적화: 활성 패턴 세트 즉시 업데이트
    if (enabled) {
      _activePatterns.add(patternType);
    } else {
      _activePatterns.remove(patternType);
    }
    
    log.i('패턴 ${patternType.name} ${enabled ? '활성화' : '비활성화'} (활성패턴: ${_activePatterns.length}개)');
  }

  @override
  bool isPatternEnabled(PatternType patternType) {
    return _patternEnabled[patternType] ?? false;
  }

  @override
  void clearSignals(PatternType? patternType) {
    if (patternType != null) {
      _signalLists[patternType]?.clear();
      _patternControllers[patternType]?.add([]);
      _signalCounts[patternType] = 0;
    } else {
      for (final pattern in PatternType.values) {
        _signalLists[pattern]?.clear();
        _patternControllers[pattern]?.add([]);
        _signalCounts[pattern] = 0;
      }
      _patternDetector.clearAllCooldowns();
    }
    _scheduleBatchUpdate();
  }

  // ==========================================================================
  // 🆕 V4.1 확장 기능들 (메모리 상태 포함)
  // ==========================================================================

  @override
  void updatePatternConfig(PatternType pattern, String key, double value) {
    _patternConfig.updatePatternConfig(pattern, key, value);
  }

  @override
  Future<Map<String, dynamic>> getPatternStats(PatternType type) async {
    final signals = _signalLists[type] ?? [];
    final lastSignal = _lastSignalTimes[type];

    return {
      'patternType': type.name,
      'totalSignals': _signalCounts[type] ?? 0,
      'recentSignals': signals.length,
      'lastSignalTime': lastSignal?.toIso8601String(),
      'isEnabled': _patternEnabled[type] ?? false,
      'isActive': _activePatterns.contains(type),
      'cooldownStatus': _patternDetector.getCooldownStatus(),
      'config': _patternConfig.getPatternConfig(type),
    };
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final now = DateTime.now();
    final uptime = _lastProcessingTime != null
        ? now.difference(_lastProcessingTime!).inMinutes
        : 0;

    final patternStats = <String, dynamic>{};
    for (final pattern in PatternType.values) {
      patternStats[pattern.name] = await getPatternStats(pattern);
    }

    final marketStats = <String, dynamic>{};
    for (final entry in _marketContexts.entries) {
      final quality = entry.value.getDataQuality(onlineMetrics: _patternDetector.metrics);
      marketStats[entry.key] = {
        'quality': quality['overall'],
        'score': quality['overallScore'],
        'timeframes': entry.value.availableTimeframes.length,
        'onlineMetrics': quality['onlineMetrics'],
        'lastAccess': _marketLastAccess[entry.key]?.toIso8601String(),
      };
    }

    final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'version': '4.1-Optimized',
      'status': 'healthy',
      'uptime': uptime,
      'totalProcessedTrades': _totalProcessedTrades,
      'lastProcessingTime': _lastProcessingTime?.toIso8601String(),
      'activePatterns': _activePatterns.length,
      'enabledPatterns': _patternEnabled.values.where((enabled) => enabled).length,
      'trackedMarkets': _marketContexts.length,
      'memoryPressure': _memoryPressureLevel,
      'memoryStats': {
        'marketContexts': _marketContexts.length,
        'maxMarketContexts': _maxMarketContexts,
        'seenIds': _seenIdsWithTime.length,
        'maxSeenIds': _maxSeenIds,
        'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
      },
      'patternStats': patternStats,
      'marketStats': marketStats,
      'onlineMetricsSystem': onlineMetricsHealth,
      'optimizations': [
        'LRU Memory Management',
        'Active Pattern Filtering', 
        'Adaptive Cleanup Intervals',
        'Memory Pressure Detection',
        'Stream Reuse Prevention',
        'Online RSI/MACD Integration',
        'O(1) Indicator Calculation',
        'Dependency Injection Architecture',
      ],
    };
  }

  @override
  Map<String, dynamic> getMarketDataQuality() {
    final qualityReport = <String, dynamic>{};

    for (final entry in _marketContexts.entries) {
      qualityReport[entry.key] = entry.value.getDataQuality(
        onlineMetrics: _patternDetector.metrics
      );
    }

    final onlineHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'totalMarkets': _marketContexts.length,
      'maxMarkets': _maxMarketContexts,
      'memoryPressure': _memoryPressureLevel,
      'markets': qualityReport,
      'healthyMarkets': qualityReport.values
          .where((q) => q['overall'] == 'EXCELLENT' || q['overall'] == 'GOOD')
          .length,
      'onlineMetricsSummary': {
        'totalMarkets': onlineHealth['totalMarkets'],
        'healthyMarkets': onlineHealth['healthyMarkets'],
        'staleMarkets': onlineHealth['staleMarkets'],
      },
    };
  }

  @override
  void applyPatternPreset(String presetName) {
    switch (presetName.toLowerCase()) {
      case 'conservative':
        _patternConfig.applyConservativePreset();
        break;
      case 'aggressive':
        _patternConfig.applyAggressivePreset();
        break;
      case 'balanced':
        _patternConfig.applyBalancedPreset();
        break;
      default:
        throw ArgumentError('Unknown preset: $presetName');
    }

    log.i('패턴 프리셋 적용: $presetName');
  }

  @override
  Map<String, dynamic> exportConfiguration() {
    return {
      'version': '4.1',
      'timestamp': DateTime.now().toIso8601String(),
      'patternConfig': _patternConfig.exportConfig(),
      'patternEnabled': _patternEnabled.map((k, v) => MapEntry(k.name, v)),
      'systemSettings': {
        'maxSignalsPerPattern': AppConfig.maxSignalsPerPattern,
        'signalCacheSize': AppConfig.signalCacheSize,
        'batchInterval': AppConfig.signalBatchInterval.inMilliseconds,
        'maxMarketContexts': _maxMarketContexts,
        'maxSeenIds': _maxSeenIds,
      },
      'memoryOptimizations': {
        'lruEnabled': true,
        'adaptiveCleanup': true,
        'activePatternFiltering': true,
      },
    };
  }

  @override
  void importConfiguration(Map<String, dynamic> config) {
    try {
      // 패턴 설정 가져오기
      if (config['patternConfig'] != null) {
        _patternConfig.importConfig(config['patternConfig']);
      }

      // 패턴 활성화 상태 가져오기
      if (config['patternEnabled'] != null) {
        final enabledMap = config['patternEnabled'] as Map<String, dynamic>;
        for (final pattern in PatternType.values) {
          if (enabledMap.containsKey(pattern.name)) {
            final enabled = enabledMap[pattern.name] as bool;
            _patternEnabled[pattern] = enabled;
            
            // 🔥 최적화: 활성 패턴 세트 업데이트
            if (enabled) {
              _activePatterns.add(pattern);
            } else {
              _activePatterns.remove(pattern);
            }
          }
        }
      }

      log.i('설정 가져오기 완료 (활성패턴: ${_activePatterns.length}개)');
    } catch (e, stackTrace) {
      log.e('설정 가져오기 실패: $e', stackTrace);
      rethrow;
    }
  }

  @override
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    return Stream.periodic(const Duration(seconds: 10), (_) {
      final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Optimized',
        'totalProcessedTrades': _totalProcessedTrades,
        'signalCounts': Map.from(_signalCounts),
        'activeMarkets': _marketContexts.length,
        'activePatterns': _activePatterns.length,
        'memoryPressure': _memoryPressureLevel,
        'cooldownStatus': _patternDetector.getCooldownStatus(),
        'memoryUsage': {
          'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
          'seenIdsCount': _seenIdsWithTime.length,
          'marketContexts': _marketContexts.length,
          'memoryUtilization': {
            'marketContexts': '${(_marketContexts.length / _maxMarketContexts * 100).toStringAsFixed(1)}%',
            'seenIds': '${(_seenIdsWithTime.length / _maxSeenIds * 100).toStringAsFixed(1)}%',
          },
        },
        'performance': {
          'activePatternFiltering': _activePatterns.length < PatternType.values.length,
          'lruCleanupActive': _memoryPressureLevel > 0,
          'adaptiveCleanupLevel': _memoryPressureLevel,
        },
        'onlineMetrics': {
          'totalMarkets': onlineMetricsHealth['totalMarkets'],
          'healthyMarkets': onlineMetricsHealth['healthyMarkets'],
          'staleMarkets': onlineMetricsHealth['staleMarkets'],
        },
        'architecture': 'V4.1 - Memory Optimized + LRU + Active Pattern Filtering',
      };
    });
  }

  // ==========================================================================
  // 🔥 V4.1 추가: 메모리 최적화 제어 메서드들
  // ==========================================================================

  /// 메모리 압박 수준 강제 설정 (테스트/디버깅용)
  void setMemoryPressureLevel(int level) {
    _memoryPressureLevel = level.clamp(0, 2);
    log.i('메모리 압박 수준 설정: $_memoryPressureLevel');
  }

  /// 즉시 메모리 정리 수행
  void forceMemoryCleanup() {
    _adaptiveMemoryCleanup();
    log.i('강제 메모리 정리 수행 완료');
  }

  /// LRU 상태 조회
  Map<String, dynamic> getLRUStatus() {
    final now = DateTime.now();
    
    // 마켓 컨텍스트 LRU 상태
    final marketLRU = _marketLastAccess.entries
        .map((e) => {
          'market': e.key,
          'lastAccess': e.value.toIso8601String(),
          'ageMinutes': now.difference(e.value).inMinutes,
        })
        .toList()
      ..sort((a, b) => (a['ageMinutes'] as int).compareTo(b['ageMinutes'] as int));

    // Seen IDs LRU 상태 (최신 10개만)
    final seenIdsLRU = _seenIdsWithTime.entries
        .map((e) => {
          'id': e.key,
          'timestamp': e.value.toIso8601String(),
          'ageMinutes': now.difference(e.value).inMinutes,
        })
        .toList()
      ..sort((a, b) => (b['ageMinutes'] as int).compareTo(a['ageMinutes'] as int))
      ..take(10);

    return {
      'memoryPressureLevel': _memoryPressureLevel,
      'marketContexts': {
        'total': _marketContexts.length,
        'limit': _maxMarketContexts,
        'utilization': '${(_marketContexts.length / _maxMarketContexts * 100).toStringAsFixed(1)}%',
        'lruList': marketLRU.take(10).toList(),
      },
      'seenIds': {
        'total': _seenIdsWithTime.length,
        'limit': _maxSeenIds,
        'utilization': '${(_seenIdsWithTime.length / _maxSeenIds * 100).toStringAsFixed(1)}%',
        'oldestEntries': seenIdsLRU.toList(),
      },
      'activePatterns': {
        'active': _activePatterns.length,
        'total': PatternType.values.length,
        'patterns': _activePatterns.map((p) => p.name).toList(),
      },
    };
  }

  /// 패턴 활성화 상태 일괄 설정
  void setBulkPatternEnabled(Map<PatternType, bool> settings) {
    _activePatterns.clear();
    
    for (final entry in settings.entries) {
      _patternEnabled[entry.key] = entry.value;
      if (entry.value) {
        _activePatterns.add(entry.key);
      }
    }
    
    log.i('패턴 일괄 설정 완료: ${_activePatterns.length}개 활성화');
  }

// lib/data/repositories/signal_repository_impl.dart
// 기존 코드 끝부분 (dispose() 메서드 위)에 다음 메서드들을 추가:

  // ==========================================================================
  // 🆕 V4.1 모달용 메서드 구현 (Repository 인터페이스 준수)
  // ==========================================================================

  @override
  double getCurrentThresholdValue(PatternType pattern, String key) {
    try {
      // PatternConfig에서 현재 설정값 직접 조회
      return _patternConfig.getConfigValue(pattern, key);
    } catch (e) {
      // 해당 키가 없으면 기본값 반환
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ getCurrentThresholdValue failed for ${pattern.name}.$key: $e');
      }
      
      // 패턴별 기본값 반환
      switch (pattern) {
        case PatternType.surge:
          switch (key) {
            case 'priceChangePercent': return 0.4;
            case 'zScoreThreshold': return 2.0;
            case 'buyRatioMin': return 0.6;
            case 'buyRatioMax': return 0.95;
            case 'consecutiveMin': return 3;
            case 'timeWindowSeconds': return 300;
            case 'cooldownSeconds': return 300;
            case 'minVolume': return 100000;
            default: return 0.0;
          }
        case PatternType.flashFire:
          switch (key) {
            case 'priceChangePercent': return 0.8;
            case 'zScoreThreshold': return 3.0;
            case 'buyRatioMin': return 0.7;
            case 'buyRatioMax': return 0.98;
            case 'consecutiveMin': return 5;
            case 'timeWindowSeconds': return 180;
            case 'cooldownSeconds': return 240;
            case 'minVolume': return 200000;
            default: return 0.0;
          }
        case PatternType.stackUp:
          switch (key) {
            case 'priceChangePercent': return 0.2;
            case 'consecutiveMin': return 7;
            case 'buyRatioMin': return 0.65;
            case 'rSquaredMin': return 0.8;
            case 'timeWindowSeconds': return 600;
            case 'cooldownSeconds': return 600;
            case 'minVolume': return 150000;
            default: return 0.0;
          }
        case PatternType.stealthIn:
          switch (key) {
            case 'minTradeAmount': return 5000000.0; // 500만원
            case 'priceChangePercent': return 0.15;
            case 'cvThreshold': return 0.05;
            case 'buyRatioMin': return 0.55;
            case 'timeWindowSeconds': return 900;
            case 'cooldownSeconds': return 900;
            case 'minVolume': return 300000;
            default: return 0.0;
          }
        case PatternType.blackHole:
          switch (key) {
            case 'cvThreshold': return 0.02;
            case 'priceChangePercent': return 0.1;
            case 'minTradeAmount': return 10000000.0; // 1000만원
            case 'buyRatioMin': return 0.5;
            case 'timeWindowSeconds': return 1200;
            case 'cooldownSeconds': return 1200;
            case 'minVolume': return 500000;
            default: return 0.0;
          }
        case PatternType.reboundShot:
          switch (key) {
            case 'priceRangeMin': return 0.03; // 3% 급락
            case 'priceChangePercent': return 0.25;
            case 'buyRatioMin': return 0.75;
            case 'timeWindowSeconds': return 240;
            case 'cooldownSeconds': return 360;
            case 'reboundStrength': return 1.5;
            case 'minVolume': return 250000;
            default: return 0.0;
          }
      }
    }
  }

  @override
  void setSystemActive(bool active) {
    if (AppConfig.enableTradeLog) {
      log.i('🎯 System ${active ? "activated" : "deactivated"} - ${active ? "enabling" : "disabling"} all patterns');
    }
    
    // 모든 패턴을 일괄 활성화/비활성화
    for (final pattern in PatternType.values) {
      setPatternEnabled(pattern, active);
    }
    
    if (AppConfig.enableTradeLog) {
      log.i('✅ System activation complete: ${_activePatterns.length}/${PatternType.values.length} patterns active');
    }
  }

  @override
  Map<String, dynamic> getSystemStatus() {
    final enabledPatterns = _patternEnabled.values.where((enabled) => enabled).length;
    final enabledPatternsList = PatternType.values
        .where((pattern) => _patternEnabled[pattern] ?? false)
        .map((p) => p.name)
        .toList();
    
    return {
      'isSystemActive': enabledPatterns > 0,
      'activePatterns': _activePatterns.length,
      'enabledPatterns': enabledPatterns,
      'totalPatterns': PatternType.values.length,
      'enabledPatternsList': enabledPatternsList,
      'activePatternsList': _activePatterns.map((p) => p.name).toList(),
      'systemHealth': _memoryPressureLevel == 0 ? 'healthy' : 
                     _memoryPressureLevel == 1 ? 'warning' : 'critical',
      'memoryPressure': _memoryPressureLevel,
      'timestamp': DateTime.now().toIso8601String(),
      'version': '4.1-Repository',
      'totalProcessedTrades': _totalProcessedTrades,
      'trackedMarkets': _marketContexts.length,
    };
  }

  @override
  Map<String, dynamic> getOnlineMetricsHealth() {
    try {
      // PatternDetector의 온라인 지표 헬스 조회
      final onlineHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'status': onlineHealth['status'] ?? 'unknown',
        'message': onlineHealth['message'] ?? 'Online metrics system operational',
        'totalMarkets': onlineHealth['totalMarkets'] ?? 0,
        'healthyMarkets': onlineHealth['healthyMarkets'] ?? 0,
        'staleMarkets': onlineHealth['staleMarkets'] ?? 0,
        'lastUpdate': onlineHealth['lastUpdate'],
        'rsiHealth': onlineHealth['rsiHealth'],
        'macdHealth': onlineHealth['macdHealth'],
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Repository',
        'source': 'PatternDetector.metrics',
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ getOnlineMetricsHealth failed: $e');
      }
      
      return {
        'status': 'error',
        'message': 'Failed to retrieve online metrics health: $e',
        'totalMarkets': 0,
        'healthyMarkets': 0,
        'staleMarkets': 0,
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Repository',
        'source': 'Repository-Fallback',
      };
    }
  }

  @override
  void resetOnlineMetrics([String? market]) {
    try {
      if (market != null) {
        // 특정 마켓의 온라인 지표 리셋
        _patternDetector.metrics.resetMarket(market);
        
        // 해당 마켓의 컨텍스트도 리셋
        final context = _marketContexts[market];
        if (context != null) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
          _marketContexts.remove(market);
          _marketLastAccess.remove(market);
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('🔄 Online metrics reset for market: $market');
        }
      } else {
        // 모든 마켓의 온라인 지표 리셋
        _patternDetector.metrics.resetAll();
        
        // 모든 마켓 컨텍스트 리셋
        for (final context in _marketContexts.values) {
          context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        }
        _marketContexts.clear();
        _marketLastAccess.clear();
        
        if (AppConfig.enableTradeLog) {
          log.i('🔄 Online metrics reset for all markets');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ resetOnlineMetrics failed: $e');
      }
      // 에러 발생 시에도 최소한의 정리 수행
      if (market == null) {
        _marketContexts.clear();
        _marketLastAccess.clear();
      } else {
        _marketContexts.remove(market);
        _marketLastAccess.remove(market);
      }
    }
  }
  
  // ==========================================================================
  // 리소스 정리 (강화된 메모리 정리)
  // ==========================================================================

  @override
  Future<void> dispose() async {
    log.i('SignalRepositoryImpl V4.1: dispose() 시작');

    _batchUpdateTimer?.cancel();
    _memoryCleanupTimer?.cancel();
    _activeCleanupTimer?.cancel();

    _aggregator.flushTrades(onTradeProcessed: (_) {});

    await _signalSubscription?.cancel();
    _signalStream = null;

    // 스트림 컨트롤러 정리
    for (final controller in _patternControllers.values) {
      await controller.close();
    }
    await _allSignalsController.close();

    // 🔥 강화된 메모리 정리
    for (final context in _marketContexts.values) {
      context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
    }
    _marketContexts.clear();
    _marketLastAccess.clear();

    // 신호 및 캐시 정리
    _signalLists.clear();
    _signalCounts.clear();
    _lastSignalTimes.clear();
    _seenIdsWithTime.clear();
    _activePatterns.clear();

    // PatternDetector 정리
    _patternDetector.dispose();

    log.i('SignalRepositoryImpl V4.1: dispose() 완료 - 메모리 최적화 포함');
  }
}

\n\n// ====== lib/data/factories/signal_stream_factory.dart ======\n
\n\n// ====== lib/domain/repositories/signal_repository.dart ======\n
// lib/domain/repositories/signal_repository.dart

import '../entities/signal.dart';

/// 🚀 Signal Repository 인터페이스 V4.1 - 모달 지원 + 온라인 지표 연동
///
/// 주요 개선사항:
/// - 🆕 모달용 메서드 4개 추가
/// - 온라인 지표 시스템 헬스 체크
/// - 패턴별 고급 설정 지원
/// - 시스템 성능 모니터링
/// - 설정 내보내기/가져오기
/// - 실시간 다이버전스 감지
abstract class SignalRepository {
  // ==========================================================================
  // 기본 시그널 스트림 (기존 호환성)
  // ==========================================================================

  /// 특정 패턴의 시그널 스트림 감시
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  );

  /// 모든 패턴의 시그널 스트림 감시
  Stream<List<Signal>> watchAllSignals(List<String> markets);

  // ==========================================================================
  // 패턴 설정 관리 (기존 + V4.1 확장)
  // ==========================================================================

  /// 패턴별 임계값 업데이트
  void updatePatternThreshold(PatternType patternType, double threshold);

  /// 현재 설정된 패턴별 임계값 조회
  double getPatternThreshold(PatternType patternType);

  /// 패턴별 활성화/비활성화 설정
  void setPatternEnabled(PatternType patternType, bool enabled);

  /// 패턴 활성화 상태 조회
  bool isPatternEnabled(PatternType patternType);

  /// 감지된 시그널 목록 초기화
  void clearSignals(PatternType? patternType);

  // ==========================================================================
  // 🆕 V4.1 모달용 메서드 4개 (핵심 추가)
  // ==========================================================================

  /// 🆕 현재 패턴의 특정 임계값 조회 (모달에서 사용)
  double getCurrentThresholdValue(PatternType pattern, String key);

  /// 🆕 시스템 전체 활성화/비활성화
  void setSystemActive(bool active);

  /// 🆕 시스템 상태 조회
  Map<String, dynamic> getSystemStatus();

  /// 🆕 온라인 지표 헬스 상태 조회
  Map<String, dynamic> getOnlineMetricsHealth();

  /// 🆕 온라인 지표 리셋
  void resetOnlineMetrics([String? market]);

  // ==========================================================================
  // 🆕 V4.1 온라인 지표 확장 기능 (기존)
  // ==========================================================================

  /// 패턴별 고급 설정 업데이트 (zScoreThreshold, buyRatioMin 등)
  void updatePatternConfig(PatternType pattern, String key, double value);

  /// 패턴 프리셋 적용 (conservative, aggressive, balanced)
  void applyPatternPreset(String presetName);

  /// 패턴별 통계 정보 조회 (신호 개수, 마지막 감지 시간 등)
  Future<Map<String, dynamic>> getPatternStats(PatternType type);

  /// 전체 시스템 헬스 체크 (온라인 지표 포함)
  Future<Map<String, dynamic>> getSystemHealth();

  /// 마켓별 데이터 품질 조회 (온라인 지표 건강성 포함)
  Map<String, dynamic> getMarketDataQuality();

  /// 성능 메트릭스 실시간 모니터링
  Stream<Map<String, dynamic>> watchPerformanceMetrics();

  // ==========================================================================
  // 🆕 V4.1 설정 관리 (백테스팅, A/B 테스트 지원)
  // ==========================================================================

  /// 현재 설정 내보내기 (JSON 형태)
  Map<String, dynamic> exportConfiguration();

  /// 설정 가져오기 (백업 복원, 프리셋 적용)
  void importConfiguration(Map<String, dynamic> config);

  // ==========================================================================
  // 리소스 정리
  // ==========================================================================

  /// 리소스 정리 (온라인 지표 포함)
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/signal_usecase.dart ======\n
// lib/domain/usecases/signal_usecase.dart

import '../entities/signal.dart';
import '../repositories/signal_repository.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';

/// 🚀 Signal UseCase V4.1 - Clean Architecture + 모달 지원
/// 
/// 주요 개선사항:
/// - V4.1 온라인 지표 시스템 연동
/// - 고급 패턴 설정 비즈니스 규칙
/// - 시스템 헬스 모니터링
/// - 모달용 메서드 4개 추가 (정석 Repository 호출)
/// - 백테스팅 지원
/// - 성능 최적화된 필터링
class SignalUseCase {
  final SignalRepository _repository;

  const SignalUseCase(this._repository);

  // ==========================================================================
  // 기본 시그널 스트림 (기존 호환성)
  // ==========================================================================

  /// 특정 패턴의 시그널 스트림 감시
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    return _repository.watchSignalsByPattern(patternType, markets);
  }

  /// 모든 패턴의 시그널 스트림 감시
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    return _repository.watchAllSignals(markets);
  }

  // ==========================================================================
  // 패턴 설정 관리 (비즈니스 규칙 포함)
  // ==========================================================================

  /// 패턴별 임계값 업데이트 (비즈니스 규칙 검증)
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // 기본 검증
    if (threshold <= 0) {
      throw ArgumentError('Threshold must be positive: $threshold');
    }

    // V4.1 패턴별 임계값 범위 검증 (완화된 기준 적용)
    switch (patternType) {
      case PatternType.surge:
        if (threshold < 0.1 || threshold > 50.0) {
          throw ArgumentError('Surge threshold must be between 0.1% and 50%: $threshold');
        }
        break;
      case PatternType.flashFire:
        if (threshold < 1.1 || threshold > 10.0) {
          throw ArgumentError('FlashFire threshold must be between 1.1x and 10x: $threshold');
        }
        break;
      case PatternType.stackUp:
        if (threshold < 2 || threshold > 10) {
          throw ArgumentError('StackUp threshold must be between 2 and 10: $threshold');
        }
        break;
      case PatternType.stealthIn:
        // V4.1 완화된 기준: 300만 ~ 1억
        if (threshold < 3000000 || threshold > 100000000) {
          throw ArgumentError('StealthIn threshold must be between 3M and 100M: $threshold');
        }
        break;
      case PatternType.blackHole:
        // V4.1 완화된 기준: 0.5% ~ 5%
        if (threshold < 0.5 || threshold > 5.0) {
          throw ArgumentError('BlackHole threshold must be between 0.5% and 5%: $threshold');
        }
        break;
      case PatternType.reboundShot:
        if (threshold < 0.5 || threshold > 20.0) {
          throw ArgumentError('ReboundShot threshold must be between 0.5% and 20%: $threshold');
        }
        break;
    }

    _repository.updatePatternThreshold(patternType, threshold);
  }

  /// 패턴별 임계값 조회
  double getPatternThreshold(PatternType patternType) {
    return _repository.getPatternThreshold(patternType);
  }

  /// 패턴 활성화/비활성화 설정
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _repository.setPatternEnabled(patternType, enabled);
  }

  /// 패턴 활성화 상태 조회
  bool isPatternEnabled(PatternType patternType) {
    return _repository.isPatternEnabled(patternType);
  }

  /// 특정 패턴의 시그널 목록 초기화
  void clearPatternSignals(PatternType patternType) {
    _repository.clearSignals(patternType);
  }

  /// 모든 시그널 목록 초기화
  void clearAllSignals() {
    _repository.clearSignals(null);
  }

  // ==========================================================================
  // 🆕 V4.1 고급 패턴 설정 (비즈니스 규칙 포함)
  // ==========================================================================

  /// 고급 패턴 설정 업데이트 (비즈니스 규칙 검증)
  void updateAdvancedPatternConfig(PatternType pattern, String key, double value) {
    // 설정 키별 비즈니스 규칙 검증
    switch (key) {
      case 'zScoreThreshold':
        if (value < 0.5 || value > 5.0) {
          throw ArgumentError('Z-Score threshold must be between 0.5 and 5.0: $value');
        }
        break;
      case 'buyRatioMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio must be between 0.0 and 1.0: $value');
        }
        break;
      case 'buyRatioMax':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio max must be between 0.0 and 1.0: $value');
        }
        break;
      case 'cvThreshold':
        if (value < 0.001 || value > 0.5) {
          throw ArgumentError('CV threshold must be between 0.001 and 0.5: $value');
        }
        break;
      case 'rSquaredMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('R-squared must be between 0.0 and 1.0: $value');
        }
        break;
      default:
        // 일반적인 양수 검증
        if (value < 0) {
          throw ArgumentError('Configuration value must be non-negative: $value');
        }
    }

    _repository.updatePatternConfig(pattern, key, value);
  }

  /// 패턴 프리셋 적용 (비즈니스 로직 검증)
  void applyPatternPreset(String presetName) {
    final validPresets = ['conservative', 'aggressive', 'balanced'];
    if (!validPresets.contains(presetName.toLowerCase())) {
      throw ArgumentError('Invalid preset name. Valid options: ${validPresets.join(', ')}');
    }

    _repository.applyPatternPreset(presetName);
  }

  // ==========================================================================
  // 🆕 V4.1 모달용 메서드 (Controller에서 직접 호출)
  // ==========================================================================

  /// 🆕 현재 패턴의 특정 임계값 조회 (모달에서 사용)
  double getCurrentThresholdValue(PatternType pattern, String key) {
    return _repository.getCurrentThresholdValue(pattern, key);
  }

  /// 🆕 패턴의 기본 임계값 조회 (모달에서 사용)
  double getDefaultThresholdValue(PatternType pattern, String key) {
    // 패턴별 기본값 정의 (비즈니스 로직)
    switch (pattern) {
      case PatternType.surge:
        switch (key) {
          case 'priceChangePercent': return 0.4;
          case 'zScoreThreshold': return 2.0;
          case 'buyRatioMin': return 0.6;
          case 'buyRatioMax': return 0.95;
          case 'consecutiveMin': return 3;
          case 'timeWindowSeconds': return 300;
          case 'cooldownSeconds': return 300;
          case 'minVolume': return 100000;
          default: return 0.0;
        }
      case PatternType.flashFire:
        switch (key) {
          case 'priceChangePercent': return 0.8;
          case 'zScoreThreshold': return 3.0;
          case 'buyRatioMin': return 0.7;
          case 'buyRatioMax': return 0.98;
          case 'consecutiveMin': return 5;
          case 'timeWindowSeconds': return 180;
          case 'cooldownSeconds': return 240;
          case 'minVolume': return 200000;
          default: return 0.0;
        }
      case PatternType.stackUp:
        switch (key) {
          case 'priceChangePercent': return 0.2;
          case 'consecutiveMin': return 7;
          case 'buyRatioMin': return 0.65;
          case 'rSquaredMin': return 0.8;
          case 'timeWindowSeconds': return 600;
          case 'cooldownSeconds': return 600;
          case 'minVolume': return 150000;
          default: return 0.0;
        }
      case PatternType.stealthIn:
        switch (key) {
          case 'minTradeAmount': return 5000000.0; // 500만원
          case 'priceChangePercent': return 0.15;
          case 'cvThreshold': return 0.05;
          case 'buyRatioMin': return 0.55;
          case 'timeWindowSeconds': return 900;
          case 'cooldownSeconds': return 900;
          case 'minVolume': return 300000;
          default: return 0.0;
        }
      case PatternType.blackHole:
        switch (key) {
          case 'cvThreshold': return 0.02;
          case 'priceChangePercent': return 0.1;
          case 'minTradeAmount': return 10000000.0; // 1000만원
          case 'buyRatioMin': return 0.5;
          case 'timeWindowSeconds': return 1200;
          case 'cooldownSeconds': return 1200;
          case 'minVolume': return 500000;
          default: return 0.0;
        }
      case PatternType.reboundShot:
        switch (key) {
          case 'priceRangeMin': return 0.03; // 3% 급락
          case 'priceChangePercent': return 0.25;
          case 'buyRatioMin': return 0.75;
          case 'timeWindowSeconds': return 240;
          case 'cooldownSeconds': return 360;
          case 'reboundStrength': return 1.5;
          case 'minVolume': return 250000;
          default: return 0.0;
        }
    }
  }

  /// 🆕 임계값 직접 업데이트 (모달에서 사용) - updateAdvancedPatternConfig 별칭
  void updatePatternThresholdDirect(String key, double value, PatternType pattern) {
    updateAdvancedPatternConfig(pattern, key, value);
  }

  /// 🆕 임계값 기본값으로 리셋 (모달에서 사용)
  void resetThresholdToDefault(PatternType pattern, String key) {
    try {
      final defaultValue = getDefaultThresholdValue(pattern, key);
      updateAdvancedPatternConfig(pattern, key, defaultValue);
      
      if (AppConfig.enableTradeLog) {
        log.i('🔄 Threshold reset to default: ${pattern.name}.$key = $defaultValue');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Reset threshold to default failed: $e');
      }
      rethrow;
    }
  }

  // ==========================================================================
  // 🆕 V4.1 시스템 제어 메서드 (Fallback 처리 포함)
  // ==========================================================================

  /// 🆕 시스템 전체 활성화/비활성화 (Controller에서 사용)
  void setSystemActive(bool active) {
    _repository.setSystemActive(active);
  }

  /// 🆕 시스템 상태 조회 (Controller에서 사용)
  Map<String, dynamic> getSystemStatus() {
    return _repository.getSystemStatus();
  }

  /// 🆕 온라인 지표 헬스 조회 (Controller에서 사용)
  Map<String, dynamic> getOnlineMetricsHealth() {
    return _repository.getOnlineMetricsHealth();
  }

  /// 🆕 시스템 헬스 조회 (Controller에서 사용)
  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  /// 🆕 온라인 지표 리셋 (Controller에서 사용)
  void resetOnlineMetrics([String? market]) {
    _repository.resetOnlineMetrics(market);
  }

  /// 🆕 설정 내보내기 (Controller에서 사용)
  Map<String, dynamic> exportCurrentConfiguration() {
    return _repository.exportConfiguration();
  }

  /// 🆕 패턴의 모든 기본값 조회 (내부 헬퍼)
  Map<String, double> _getAllDefaultValues(PatternType pattern) {
    final commonKeys = [
      'priceChangePercent', 'zScoreThreshold', 'buyRatioMin', 'buyRatioMax',
      'consecutiveMin', 'timeWindowSeconds', 'cooldownSeconds', 'minVolume',
      'cvThreshold', 'rSquaredMin', 'minTradeAmount', 'priceRangeMin', 'reboundStrength'
    ];
    
    final defaults = <String, double>{};
    for (final key in commonKeys) {
      try {
        final value = getDefaultThresholdValue(pattern, key);
        if (value > 0) {
          defaults[key] = value;
        }
      } catch (e) {
        // 해당 키가 패턴에 없으면 무시
      }
    }
    
    return defaults;
  }

  /// 🆕 설정 가져오기 (Controller에서 사용)
  void importSignalConfiguration(Map<String, dynamic> config) {
    _repository.importConfiguration(config);
  }

  /// 🆕 시그널 초기화 (오버로드된 메서드)
  void clearSignals([PatternType? pattern]) {
    if (pattern != null) {
      clearPatternSignals(pattern);
    } else {
      clearAllSignals();
    }
  }

  // ==========================================================================
  // 🆕 V4.1 시스템 모니터링 및 분석
  // ==========================================================================

  /// 패턴별 성능 통계
  Future<PatternPerformanceStats> getPatternPerformance(PatternType pattern) async {
    final stats = await _repository.getPatternStats(pattern);
    final systemHealth = await getSystemHealth(); // UseCase의 getSystemHealth 사용
    
    return PatternPerformanceStats(
      patternType: pattern,
      totalSignals: stats['totalSignals'] ?? 0,
      recentSignals: stats['recentSignals'] ?? 0,
      lastSignalTime: stats['lastSignalTime'] != null 
          ? DateTime.parse(stats['lastSignalTime'])
          : null,
      isEnabled: stats['isEnabled'] ?? false,
      config: Map<String, double>.from(stats['config'] ?? {}),
      cooldownStatus: Map<String, dynamic>.from(stats['cooldownStatus'] ?? {}),
      onlineMetricsHealth: systemHealth['onlineMetricsSystem'],
    );
  }

  /// 전체 시스템 헬스 체크
  Future<SystemHealthReport> getSystemHealthReport() async {
    final health = await getSystemHealth(); // UseCase의 getSystemHealth 사용
    final dataQuality = _repository.getMarketDataQuality();
    
    return SystemHealthReport(
      version: health['version'] ?? 'Unknown',
      status: health['status'] ?? 'Unknown',
      uptime: health['uptime'] ?? 0,
      totalProcessedTrades: health['totalProcessedTrades'] ?? 0,
      activePatterns: health['activePatterns'] ?? 0,
      trackedMarkets: health['trackedMarkets'] ?? 0,
      onlineMetricsHealth: health['onlineMetricsSystem'],
      marketDataQuality: dataQuality,
      lastProcessingTime: health['lastProcessingTime'] != null 
          ? DateTime.parse(health['lastProcessingTime'])
          : null,
    );
  }

  /// 성능 메트릭스 스트림 (필터링 포함)
  Stream<PerformanceMetrics> watchFilteredPerformanceMetrics() {
    return _repository.watchPerformanceMetrics().map((raw) {
      return PerformanceMetrics(
        timestamp: DateTime.parse(raw['timestamp']),
        version: raw['version'] ?? 'Unknown',
        totalProcessedTrades: raw['totalProcessedTrades'] ?? 0,
        activeMarkets: raw['activeMarkets'] ?? 0,
        signalCounts: Map<String, int>.from(raw['signalCounts'] ?? {}),
        memoryUsage: Map<String, dynamic>.from(raw['memoryUsage'] ?? {}),
        onlineMetrics: Map<String, dynamic>.from(raw['onlineMetrics'] ?? {}),
        architecture: raw['architecture'] ?? 'Unknown',
      );
    });
  }

  // ==========================================================================
  // 시그널 분석 및 필터링 (개선된 로직)
  // ==========================================================================

  /// 시그널 통계 정보 계산 (V4.1 온라인 지표 포함)
  SignalStats calculateSignalStats(List<Signal> signals) {
    if (signals.isEmpty) {
      return const SignalStats(
        totalCount: 0,
        patternCounts: {},
        avgChangePercent: 0.0,
        maxChangePercent: 0.0,
        minChangePercent: 0.0,
        totalTradeAmount: 0.0,
        avgConfidence: 0.0,
        onlineMetricsCount: 0,
      );
    }

    final patternCounts = <PatternType, int>{};
    double totalChangePercent = 0.0;
    double maxChangePercent = signals.first.changePercent;
    double minChangePercent = signals.first.changePercent;
    double totalTradeAmount = 0.0;
    double totalConfidence = 0.0;
    int onlineMetricsCount = 0;

    for (final signal in signals) {
      // 패턴별 카운트
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;

      // 변화율 통계
      totalChangePercent += signal.changePercent;
      if (signal.changePercent > maxChangePercent) {
        maxChangePercent = signal.changePercent;
      }
      if (signal.changePercent < minChangePercent) {
        minChangePercent = signal.changePercent;
      }

      // 거래대금 합계
      totalTradeAmount += signal.tradeAmount;
      
      // V4.1 신뢰도 통계
      final confidence = signal.confidence ?? 0.0;
      totalConfidence += confidence;
      
      // V4.1 온라인 지표 기반 신호 카운트
      if (signal.hasOnlineMetrics) {
        onlineMetricsCount++;
      }
    }

    return SignalStats(
      totalCount: signals.length,
      patternCounts: patternCounts,
      avgChangePercent: totalChangePercent / signals.length,
      maxChangePercent: maxChangePercent,
      minChangePercent: minChangePercent,
      totalTradeAmount: totalTradeAmount,
      avgConfidence: totalConfidence / signals.length,
      onlineMetricsCount: onlineMetricsCount,
    );
  }

  /// 고급 시그널 필터링 (V4.1 확장)
  List<Signal> filterSignals(
    List<Signal> signals, {
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<String>? markets,
  }) {
    return signals.where((signal) {
      // 기존 필터들
      if (minChangePercent != null && signal.changePercent < minChangePercent) {
        return false;
      }
      if (maxChangePercent != null && signal.changePercent > maxChangePercent) {
        return false;
      }
      if (minTradeAmount != null && signal.tradeAmount < minTradeAmount) {
        return false;
      }
      if (maxTradeAmount != null && signal.tradeAmount > maxTradeAmount) {
        return false;
      }
      if (patternTypes != null && !patternTypes.contains(signal.patternType)) {
        return false;
      }
      if (timeWindow != null) {
        final cutoff = DateTime.now().subtract(timeWindow);
        if (signal.detectedAt.isBefore(cutoff)) {
          return false;
        }
      }
      
      // V4.1 새로운 필터들
      if (minConfidence != null && (signal.confidence ?? 0.0) < minConfidence) {
        return false;
      }
      if (requireOnlineMetrics == true && !signal.hasOnlineMetrics) {
        return false;
      }
      if (markets != null && !markets.contains(signal.market)) {
        return false;
      }

      return true;
    }).toList();
  }

  // ==========================================================================
  // 🆕 V4.1 백테스팅 및 설정 관리
  // ==========================================================================

  /// 현재 설정 백업
  SignalConfiguration exportSignalConfiguration() {
    final config = exportCurrentConfiguration();
    return SignalConfiguration.fromJson(config);
  }

  /// 설정 복원  
  void importConfiguration(SignalConfiguration configuration) {
    importSignalConfiguration(configuration.toJson());
  }

  /// 설정 비교 (A/B 테스트용)
  ConfigurationDiff compareConfigurations(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    return ConfigurationDiff.compare(configA, configB);
  }

  // ==========================================================================
  // 🆕 V4.1 추가 유틸리티 메서드들
  // ==========================================================================

  /// 🆕 패턴별 설정 키 목록 조회
  List<String> getPatternConfigKeys(PatternType pattern) {
    final allKeys = _getAllDefaultValues(pattern).keys.toList();
    return allKeys..sort();
  }

  /// 🆕 모든 패턴의 현재 상태 조회
  Map<String, dynamic> getAllPatternStatus() {
    final status = <String, dynamic>{};
    
    for (final pattern in PatternType.values) {
      status[pattern.name] = {
        'enabled': isPatternEnabled(pattern),
        'threshold': getPatternThreshold(pattern),
        'displayName': pattern.displayName,
        'description': pattern.description,
        'defaultThreshold': pattern.defaultThreshold,
        'timeWindowMinutes': pattern.timeWindowMinutes,
        'defaultConfidence': pattern.defaultConfidence,
        'defaultCooldownSeconds': pattern.defaultCooldownSeconds,
        'availableKeys': getPatternConfigKeys(pattern),
      };
    }
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'version': 'V4.1-Complete',
      'patterns': status,
      'systemStatus': getSystemStatus(),
    };
  }

  /// 🆕 설정 검증
  Map<String, dynamic> validateConfiguration(Map<String, dynamic> config) {
    final errors = <String>[];
    final warnings = <String>[];
    
    try {
      // 버전 확인
      final version = config['version'] as String?;
      if (version == null) {
        warnings.add('Configuration version not specified');
      }
      
      // 패턴 설정 검증
      final patternEnabled = config['patternEnabled'] as Map<String, dynamic>?;
      if (patternEnabled != null) {
        for (final patternName in patternEnabled.keys) {
          final found = PatternType.values.any((p) => p.name == patternName);
          if (!found) {
            warnings.add('Unknown pattern: $patternName');
          }
        }
      }
      
      // 임계값 검증
      final patternConfig = config['patternConfig'] as Map<String, dynamic>?;
      if (patternConfig != null) {
        for (final entry in patternConfig.entries) {
          final patternName = entry.key;
          final settings = entry.value as Map<String, dynamic>?;
          
          if (settings != null && settings.containsKey('threshold')) {
            try {
              final pattern = PatternType.values.firstWhere(
                (p) => p.name == patternName,
              );
              final threshold = settings['threshold'] as double;
              
              // 임계값 범위 검증 (updatePatternThreshold 로직 재사용)
              try {
                updatePatternThreshold(pattern, threshold);
              } catch (e) {
                errors.add('Invalid threshold for $patternName: $e');
              }
            } catch (e) {
              warnings.add('Unknown pattern in config: $patternName');
            }
          }
        }
      }
      
      return {
        'valid': errors.isEmpty,
        'errors': errors,
        'warnings': warnings,
        'timestamp': DateTime.now().toIso8601String(),
      };
    } catch (e) {
      return {
        'valid': false,
        'errors': ['Configuration validation failed: $e'],
        'warnings': warnings,
        'timestamp': DateTime.now().toIso8601String(),
      };
    }
  }

  /// 🆕 성능 최적화된 패턴 활성화 상태 체크
  bool isAnyPatternEnabled() {
    return PatternType.values.any((pattern) => isPatternEnabled(pattern));
  }

  /// 🆕 활성화된 패턴 목록 조회
  List<PatternType> getEnabledPatterns() {
    return PatternType.values
        .where((pattern) => isPatternEnabled(pattern))
        .toList();
  }

  /// 🆕 비활성화된 패턴 목록 조회
  List<PatternType> getDisabledPatterns() {
    return PatternType.values
        .where((pattern) => !isPatternEnabled(pattern))
        .toList();
  }

  /// 🆕 패턴별 권장 설정 조회
  Map<String, dynamic> getRecommendedSettings(PatternType pattern) {
    final defaultValues = _getAllDefaultValues(pattern);
    
    return {
      'pattern': pattern.name,
      'displayName': pattern.displayName,
      'description': pattern.description,
      'defaultValues': defaultValues,
      'currentThreshold': getPatternThreshold(pattern),
      'isEnabled': isPatternEnabled(pattern),
      'recommendations': {
        'conservative': _getConservativeSettings(pattern),
        'balanced': _getBalancedSettings(pattern),
        'aggressive': _getAggressiveSettings(pattern),
      },
    };
  }

  /// 🆕 보수적 설정 조회
  Map<String, double> _getConservativeSettings(PatternType pattern) {
    final defaults = _getAllDefaultValues(pattern);
    final conservative = <String, double>{};
    
    for (final entry in defaults.entries) {
      final key = entry.key;
      final value = entry.value;
      
      // 보수적 설정: 더 높은 임계값, 더 엄격한 조건
      switch (key) {
        case 'priceChangePercent':
          conservative[key] = value * 1.5; // 50% 더 높은 임계값
          break;
        case 'zScoreThreshold':
          conservative[key] = value * 1.3; // 30% 더 높은 Z-Score
          break;
        case 'buyRatioMin':
          conservative[key] = (value * 1.1).clamp(0.0, 1.0); // 10% 더 높은 매수비율
          break;
        case 'cooldownSeconds':
          conservative[key] = value * 2.0; // 2배 더 긴 쿨다운
          break;
        default:
          conservative[key] = value;
      }
    }
    
    return conservative;
  }

  /// 🆕 균형 설정 조회 (기본값)
  Map<String, double> _getBalancedSettings(PatternType pattern) {
    return _getAllDefaultValues(pattern);
  }

  /// 🆕 공격적 설정 조회
  Map<String, double> _getAggressiveSettings(PatternType pattern) {
    final defaults = _getAllDefaultValues(pattern);
    final aggressive = <String, double>{};
    
    for (final entry in defaults.entries) {
      final key = entry.key;
      final value = entry.value;
      
      // 공격적 설정: 더 낮은 임계값, 더 느슨한 조건
      switch (key) {
        case 'priceChangePercent':
          aggressive[key] = value * 0.7; // 30% 더 낮은 임계값
          break;
        case 'zScoreThreshold':
          aggressive[key] = value * 0.8; // 20% 더 낮은 Z-Score
          break;
        case 'buyRatioMin':
          aggressive[key] = (value * 0.9).clamp(0.0, 1.0); // 10% 더 낮은 매수비율
          break;
        case 'cooldownSeconds':
          aggressive[key] = value * 0.5; // 절반으로 줄인 쿨다운
          break;
        default:
          aggressive[key] = value;
      }
    }
    
    return aggressive;
  }

  // ==========================================================================
  // 리소스 정리
  // ==========================================================================

  /// 리소스 정리
  Future<void> dispose() async {
    await _repository.dispose();
  }
}

// ==========================================================================
// 🆕 V4.1 확장 데이터 클래스들
// ==========================================================================

/// V4.1 향상된 Signal 통계 정보
class SignalStats {
  final int totalCount;
  final Map<PatternType, int> patternCounts;
  final double avgChangePercent;
  final double maxChangePercent;
  final double minChangePercent;
  final double totalTradeAmount;
  final double avgConfidence;
  final int onlineMetricsCount;

  const SignalStats({
    required this.totalCount,
    required this.patternCounts,
    required this.avgChangePercent,
    required this.maxChangePercent,
    required this.minChangePercent,
    required this.totalTradeAmount,
    required this.avgConfidence,
    required this.onlineMetricsCount,
  });

  double get onlineMetricsRatio => 
      totalCount > 0 ? onlineMetricsCount / totalCount : 0.0;

   /// 🆕 V4.1 JSON 직렬화
  Map<String, dynamic> toJson() {
    return {
      'totalCount': totalCount,
      'patternCounts': patternCounts.map((k, v) => MapEntry(k.name, v)),
      'avgChangePercent': avgChangePercent,
      'maxChangePercent': maxChangePercent,
      'minChangePercent': minChangePercent,
      'totalTradeAmount': totalTradeAmount,
      'avgConfidence': avgConfidence,
      'onlineMetricsCount': onlineMetricsCount,
      'onlineMetricsRatio': onlineMetricsRatio,
    };
  }

  @override
  String toString() {
    return 'SignalStats(total: $totalCount, avg: ${avgChangePercent.toStringAsFixed(2)}%, '
        'confidence: ${(avgConfidence * 100).toStringAsFixed(1)}%, '
        'online: ${(onlineMetricsRatio * 100).toStringAsFixed(1)}%)';
  }
}

/// 패턴별 성능 통계
class PatternPerformanceStats {
  final PatternType patternType;
  final int totalSignals;
  final int recentSignals;
  final DateTime? lastSignalTime;
  final bool isEnabled;
  final Map<String, double> config;
  final Map<String, dynamic> cooldownStatus;
  final Map<String, dynamic>? onlineMetricsHealth;

  const PatternPerformanceStats({
    required this.patternType,
    required this.totalSignals,
    required this.recentSignals,
    this.lastSignalTime,
    required this.isEnabled,
    required this.config,
    required this.cooldownStatus,
    this.onlineMetricsHealth,
  });
}

/// 시스템 헬스 리포트
class SystemHealthReport {
  final String version;
  final String status;
  final int uptime;
  final int totalProcessedTrades;
  final int activePatterns;
  final int trackedMarkets;
  final Map<String, dynamic>? onlineMetricsHealth;
  final Map<String, dynamic> marketDataQuality;
  final DateTime? lastProcessingTime;

  const SystemHealthReport({
    required this.version,
    required this.status,
    required this.uptime,
    required this.totalProcessedTrades,
    required this.activePatterns,
    required this.trackedMarkets,
    this.onlineMetricsHealth,
    required this.marketDataQuality,
    this.lastProcessingTime,
  });

  bool get isHealthy => status == 'healthy';
}

/// 성능 메트릭스
class PerformanceMetrics {
  final DateTime timestamp;
  final String version;
  final int totalProcessedTrades;
  final int activeMarkets;
  final Map<String, int> signalCounts;
  final Map<String, dynamic> memoryUsage;
  final Map<String, dynamic> onlineMetrics;
  final String architecture;

  const PerformanceMetrics({
    required this.timestamp,
    required this.version,
    required this.totalProcessedTrades,
    required this.activeMarkets,
    required this.signalCounts,
    required this.memoryUsage,
    required this.onlineMetrics,
    required this.architecture,
  });
}

/// 설정 정보
class SignalConfiguration {
  final String version;
  final DateTime timestamp;
  final Map<String, dynamic> patternConfig;
  final Map<String, bool> patternEnabled;
  final Map<String, dynamic> systemSettings;

  const SignalConfiguration({
    required this.version,
    required this.timestamp,
    required this.patternConfig,
    required this.patternEnabled,
    required this.systemSettings,
  });

  factory SignalConfiguration.fromJson(Map<String, dynamic> json) {
    return SignalConfiguration(
      version: json['version'] ?? 'Unknown',
      timestamp: DateTime.parse(json['timestamp']),
      patternConfig: Map<String, dynamic>.from(json['patternConfig'] ?? {}),
      patternEnabled: Map<String, bool>.from(json['patternEnabled'] ?? {}),
      systemSettings: Map<String, dynamic>.from(json['systemSettings'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'version': version,
      'timestamp': timestamp.toIso8601String(),
      'patternConfig': patternConfig,
      'patternEnabled': patternEnabled,
      'systemSettings': systemSettings,
    };
  }
}

/// 설정 비교 결과
class ConfigurationDiff {
  final List<String> changedPatterns;
  final List<String> changedSettings;
  final Map<String, dynamic> differences;

  const ConfigurationDiff({
    required this.changedPatterns,
    required this.changedSettings,
    required this.differences,
  });

  static ConfigurationDiff compare(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    final changedPatterns = <String>[];
    final changedSettings = <String>[];
    final differences = <String, dynamic>{};
    
    // 패턴 활성화 상태 비교
    for (final pattern in configA.patternEnabled.keys) {
      final aEnabled = configA.patternEnabled[pattern] ?? false;
      final bEnabled = configB.patternEnabled[pattern] ?? false;
      
      if (aEnabled != bEnabled) {
        changedPatterns.add(pattern);
        differences['patternEnabled_$pattern'] = {
          'from': aEnabled,
          'to': bEnabled,
        };
      }
    }
    
    // 패턴 설정 비교
    for (final pattern in configA.patternConfig.keys) {
      final aConfig = configA.patternConfig[pattern] as Map<String, dynamic>?;
      final bConfig = configB.patternConfig[pattern] as Map<String, dynamic>?;
      
      if (aConfig != null && bConfig != null) {
        for (final key in aConfig.keys) {
          final aValue = aConfig[key];
          final bValue = bConfig[key];
          
          if (aValue != bValue) {
            changedSettings.add('${pattern}_$key');
            differences['config_${pattern}_$key'] = {
              'from': aValue,
              'to': bValue,
            };
          }
        }
      }
    }
    
    return ConfigurationDiff(
      changedPatterns: changedPatterns,
      changedSettings: changedSettings,
      differences: differences,
    );
  }

  bool get hasChanges => changedPatterns.isNotEmpty || changedSettings.isNotEmpty;
}\n\n// ====== lib/domain/entities/signal.dart ======\n
// lib/domain/entities/signal.dart

/// 🚀 Signal Entity V4.1 - 온라인 지표 연동
/// 
/// 주요 개선사항:
/// - 온라인 RSI/MACD 정보 포함
/// - 다이버전스 감지 결과
/// - 신뢰도 동적 조정
/// - 스트림 건강성 정보
/// - 패턴별 고급 메타데이터

/// Signal 패턴 타입 정의 (V4.1 확장)
enum PatternType {
  surge,       // 1. 급등🚀 (1분 전 대비 0.4% 상승)
  flashFire,   // 2. 불티🔥 (3분 거래대금 급증)
  stackUp,     // 3. 스택업💰 (1분씩 연속 증가)
  stealthIn,   // 4. 침투자👣 (소량 지속 유입) - 완화됨
  blackHole,   // 5. 블랙홀🕳️ (거래대금↑ 가격변동↓) - 완화됨
  reboundShot, // 6. 쇼트터치⚡ (급락 후 반등)
}

extension PatternTypeExtension on PatternType {
  String get displayName {
    switch (this) {
      case PatternType.surge:
        return '급등🚀';
      case PatternType.flashFire:
        return '불티🔥';
      case PatternType.stackUp:
        return '스택업💰';
      case PatternType.stealthIn:
        return '침투자👣';
      case PatternType.blackHole:
        return '블랙홀🕳️';
      case PatternType.reboundShot:
        return '쇼트터치⚡';
    }
  }

  String get description {
  switch (this) {
    case PatternType.surge:
      return '가격 급등 + 체결량 폭발 + MACD·RSI·유동성 지표 충족';
    case PatternType.flashFire:
      return '거래대금 급증 + 매수 강도 + 머신급 체결 가속';
    case PatternType.stackUp:
      return '연속 매집 + MACD 상승 + 거래량 추세 정렬';
    case PatternType.stealthIn:
      return '저변동 속 유입 지속 + 분산 체결 + 누적 매수 감지';
    case PatternType.blackHole:
      return '가격 정체 + 매수·매도 균형 + 체결 왜곡 패턴';
    case PatternType.reboundShot:
      return '과매도 후 반등 + RSI·MACD 반응 + 점프 스코어 확인';
  }
}


  /// V4.1 패턴별 기본 임계값 (완화됨)
  double get defaultThreshold {
    switch (this) {
      case PatternType.surge:
        return 0.4; // 0.4% 상승 (기존 1.1%에서 완화)
      case PatternType.flashFire:
        return 2.0; // 2배 급증
      case PatternType.stackUp:
        return 2.0; // 2연속 (기존 3에서 완화)
      case PatternType.stealthIn:
        return 5000000.0; // 500만원 (기존 2000만에서 대폭 완화)
      case PatternType.blackHole:
        return 2.0; // 2% 이하 변동 (기존 1%에서 완화)
      case PatternType.reboundShot:
        return 1.5; // 1.5% 급락 후 반등
    }
  }

  /// 패턴별 시간 윈도우 (분)
  int get timeWindowMinutes {
    switch (this) {
      case PatternType.surge:
        return 1; // 1분
      case PatternType.flashFire:
        return 1; // 1분 (V4.1 단축)
      case PatternType.stackUp:
        return 1; // 1분
      case PatternType.stealthIn:
        return 5; // 5분
      case PatternType.blackHole:
        return 5; // 5분 (V4.1 확장)
      case PatternType.reboundShot:
        return 1; // 1분
    }
  }

  /// V4.1 패턴별 기본 쿨다운 시간 (초)
  int get defaultCooldownSeconds {
    switch (this) {
      case PatternType.surge:
        return 3; // 빠른 감지
      case PatternType.flashFire:
        return 2; // 가장 빠름
      case PatternType.stackUp:
        return 4; // 중간
      case PatternType.stealthIn:
        return 8; // 느림 (은밀함 특성)
      case PatternType.blackHole:
        return 10; // 가장 느림 (안정성 특성)
      case PatternType.reboundShot:
        return 5; // 중간
    }
  }

  /// V4.1 패턴별 신뢰도 기본값
  double get defaultConfidence {
    switch (this) {
      case PatternType.surge:
        return 0.8; // 높음
      case PatternType.flashFire:
        return 0.85; // 매우 높음
      case PatternType.stackUp:
        return 0.75; // 중간
      case PatternType.stealthIn:
        return 0.7; // 낮음 (은밀함)
      case PatternType.blackHole:
        return 0.8; // 높음 (안정성)
      case PatternType.reboundShot:
        return 0.9; // 매우 높음 (명확함)
    }
  }
}

/// 🆕 V4.1 온라인 지표 정보
class OnlineIndicatorInfo {
  final double? rsi;
  final double? macd;
  final double? macdSignal;
  final double? macdHistogram;
  final bool isStale;
  final DateTime lastUpdate;

  const OnlineIndicatorInfo({
    this.rsi,
    this.macd,
    this.macdSignal,
    this.macdHistogram,
    required this.isStale,
    required this.lastUpdate,
  });

  /// RSI/MACD가 유효한지 체크
  bool get hasValidData => !isStale && (rsi != null || macd != null);

  /// RSI 과매수/과매도 상태
  String get rsiState {
    if (rsi == null) return 'N/A';
    if (rsi! >= 70) return 'Overbought';
    if (rsi! <= 30) return 'Oversold';
    return 'Neutral';
  }

  /// MACD 신호 상태
  String get macdState {
    if (macd == null || macdSignal == null) return 'N/A';
    if (macd! > macdSignal!) return 'Bullish';
    if (macd! < macdSignal!) return 'Bearish';
    return 'Neutral';
  }

  Map<String, dynamic> toJson() {
    return {
      'rsi': rsi,
      'macd': macd,
      'macdSignal': macdSignal,
      'macdHistogram': macdHistogram,
      'isStale': isStale,
      'lastUpdate': lastUpdate.toIso8601String(),
      'rsiState': rsiState,
      'macdState': macdState,
    };
  }
}

/// 🆕 V4.1 다이버전스 정보
class DivergenceInfo {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  final String source; // 'online-rsi', 'online-macd' 등

  const DivergenceInfo({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
    required this.source,
  });

  /// 다이버전스 타입
  String get type {
    if (isBullish) return 'Bullish';
    if (isBearish) return 'Bearish';
    return 'None';
  }

  /// 신뢰도 (강도 기반)
  String get confidenceLevel {
    if (strength >= 0.8) return 'Very High';
    if (strength >= 0.6) return 'High';
    if (strength >= 0.4) return 'Medium';
    if (strength >= 0.2) return 'Low';
    return 'Very Low';
  }

  Map<String, dynamic> toJson() {
    return {
      'isBullish': isBullish,
      'isBearish': isBearish,
      'strength': strength,
      'source': source,
      'type': type,
      'confidenceLevel': confidenceLevel,
    };
  }
}

/// 🚀 Signal 감지 결과 엔티티 V4.1
class Signal {
  final String market;
  final String name;
  final double currentPrice;
  final double changePercent;
  final double volume;
  final double tradeAmount;
  final DateTime detectedAt;
  final PatternType patternType;
  final Map<String, dynamic> patternDetails;

  const Signal({
    required this.market,
    required this.name,
    required this.currentPrice,
    required this.changePercent,
    required this.volume,
    required this.tradeAmount,
    required this.detectedAt,
    required this.patternType,
    required this.patternDetails,
  });

  /// 거래 총액 계산
  double get total => currentPrice * volume;

  /// 코인 티커만 추출 (KRW- 제거)
  String get ticker => market.replaceFirst('KRW-', '');

  /// 🆕 V4.1 신뢰도 (동적 조정된 최종 신뢰도)
  double? get confidence {
    final finalConf = patternDetails['finalConfidence'] as double?;
    final originalConf = patternDetails['confidence'] as double?;
    return finalConf ?? originalConf;
  }

  /// 🆕 V4.1 온라인 지표 정보 조회
  OnlineIndicatorInfo? get onlineIndicators {
    final rsi = patternDetails['rsi'] as double?;
    final macd = patternDetails['macd'] as double?;
    final macdSignal = patternDetails['macdSignal'] as double?;
    final macdHistogram = patternDetails['macdHistogram'] as double?;
    
    if (rsi == null && macd == null) return null;
    
    return OnlineIndicatorInfo(
      rsi: rsi,
      macd: macd,
      macdSignal: macdSignal,
      macdHistogram: macdHistogram,
      isStale: false, // Signal 생성시점에는 최신
      lastUpdate: detectedAt,
    );
  }

  /// 🆕 V4.1 다이버전스 정보 조회
  DivergenceInfo? get divergence {
    final divData = patternDetails['divergence'] as Map<String, dynamic>?;
    if (divData == null) return null;
    
    return DivergenceInfo(
      isBullish: divData['isBullish'] as bool? ?? false,
      isBearish: divData['isBearish'] as bool? ?? false,
      strength: (divData['strength'] as num?)?.toDouble() ?? 0.0,
      source: divData['source'] as String? ?? 'unknown',
    );
  }

  /// 🆕 온라인 지표 기반 신호인지 체크
  bool get hasOnlineMetrics {
    return onlineIndicators?.hasValidData ?? false;
  }

  /// 🆕 V4.1 버전 정보
  String? get version => patternDetails['version'] as String?;

  /// 패턴별 특화 정보 getter들
  
  /// Surge 전용: 기준가 (1분 전 가격)
  double? get basePrice => patternDetails['basePrice'] as double?;
  
  /// FlashFire 전용: 급증 배율
  double? get surgeMultiplier => patternDetails['surgeMultiplier'] as double?;
  
  /// StackUp 전용: 연속 증가 횟수
  int? get consecutiveCount => patternDetails['consecutiveCount'] as int?;
  
  /// StealthIn 전용: 지속 시간 (초)
  int? get sustainedSeconds => patternDetails['sustainedSeconds'] as int?;
  
  /// BlackHole 전용: 가격 변동률
  double? get priceStability => patternDetails['priceStability'] as double?;
  
  /// ReboundShot 전용: 반등 강도
  double? get reboundStrength => patternDetails['reboundStrength'] as double?;

  /// 🆕 V4.1 고급 지표들
  double? get liquidityVortex => patternDetails['liquidityVortex'] as double?;
  double? get flashPulse => patternDetails['flashPulse'] as double?;
  double? get microBurstRadar => patternDetails['microBurstRadar'] as double?;
  double? get machineRush => patternDetails['machineRush'] as double?;
  double? get jumpScore => patternDetails['jumpScore'] as double?;
  double? get zScore => patternDetails['zScore'] as double?;

  /// 🆕 신뢰도 레벨 (텍스트)
  String get confidenceLevel {
    final conf = confidence ?? 0.0;
    if (conf >= 0.9) return 'Excellent';
    if (conf >= 0.8) return 'Very High';
    if (conf >= 0.7) return 'High';
    if (conf >= 0.6) return 'Good';
    if (conf >= 0.5) return 'Medium';
    if (conf >= 0.3) return 'Low';
    return 'Very Low';
  }

  /// 🆕 신호 강도 (종합 점수)
  String get signalStrength {
    double score = 0.0;
    
    // 기본 점수 (변화율 기반)
    score += (changePercent.abs() / 10.0).clamp(0.0, 1.0);
    
    // 신뢰도 점수
    score += (confidence ?? 0.0);
    
    // 온라인 지표 보너스
    if (hasOnlineMetrics) score += 0.3;
    
    // 다이버전스 보너스
    final div = divergence;
    if (div != null && div.strength > 0.5) score += 0.2;
    
    score = score.clamp(0.0, 3.0) / 3.0; // 0-1 정규화
    
    if (score >= 0.8) return 'Very Strong';
    if (score >= 0.6) return 'Strong';
    if (score >= 0.4) return 'Moderate';
    if (score >= 0.2) return 'Weak';
    return 'Very Weak';
  }

  /// 🆕 상세 정보 (디버깅용)
  Map<String, dynamic> get debugInfo {
    return {
      'market': market,
      'pattern': patternType.name,
      'confidence': confidence,
      'hasOnlineMetrics': hasOnlineMetrics,
      'onlineIndicators': onlineIndicators?.toJson(),
      'divergence': divergence?.toJson(),
      'signalStrength': signalStrength,
      'version': version,
      'detectedAt': detectedAt.toIso8601String(),
    };
  }

  Signal copyWith({
    String? market,
    String? name,
    double? currentPrice,
    double? changePercent,
    double? volume,
    double? tradeAmount,
    DateTime? detectedAt,
    PatternType? patternType,
    Map<String, dynamic>? patternDetails,
  }) {
    return Signal(
      market: market ?? this.market,
      name: name ?? this.name,
      currentPrice: currentPrice ?? this.currentPrice,
      changePercent: changePercent ?? this.changePercent,
      volume: volume ?? this.volume,
      tradeAmount: tradeAmount ?? this.tradeAmount,
      detectedAt: detectedAt ?? this.detectedAt,
      patternType: patternType ?? this.patternType,
      patternDetails: patternDetails ?? this.patternDetails,
    );
  }

  @override
  String toString() {
    final confText = confidence != null 
        ? '${(confidence! * 100).toStringAsFixed(1)}%' 
        : 'N/A';
    final onlineText = hasOnlineMetrics ? '[Online]' : '';
    
    return 'Signal(${patternType.displayName} $onlineText: $market '
        '${changePercent.toStringAsFixed(2)}% @ $currentPrice, '
        'Conf: $confText, at: ${detectedAt.toString().substring(11, 19)})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Signal &&
        other.market == market &&
        other.detectedAt == detectedAt &&
        other.patternType == patternType;
  }

  @override
  int get hashCode {
    return market.hashCode ^ detectedAt.hashCode ^ patternType.hashCode;
  }

  /// 🆕 V4.1 JSON 직렬화 (저장/로드용)
  Map<String, dynamic> toJson() {
    return {
      'market': market,
      'name': name,
      'currentPrice': currentPrice,
      'changePercent': changePercent,
      'volume': volume,
      'tradeAmount': tradeAmount,
      'detectedAt': detectedAt.toIso8601String(),
      'patternType': patternType.name,
      'patternDetails': patternDetails,
      'version': 'V4.1-Online',
    };
  }

  /// 🆕 V4.1 JSON 역직렬화
  factory Signal.fromJson(Map<String, dynamic> json) {
    return Signal(
      market: json['market'] as String,
      name: json['name'] as String,
      currentPrice: (json['currentPrice'] as num).toDouble(),
      changePercent: (json['changePercent'] as num).toDouble(),
      volume: (json['volume'] as num).toDouble(),
      tradeAmount: (json['tradeAmount'] as num).toDouble(),
      detectedAt: DateTime.parse(json['detectedAt'] as String),
      patternType: PatternType.values.firstWhere(
        (e) => e.name == json['patternType'],
        orElse: () => PatternType.surge,
      ),
      patternDetails: Map<String, dynamic>.from(json['patternDetails'] as Map),
    );
  }
}\n\n// ====== lib/presentation/controllers/signal_controller.dart ======\n
// lib/presentation/controllers/signal_controller.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/signal_provider.dart';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/usecases/signal_usecase.dart';

/// 🚀 Signal 화면 상태를 캡슐화하는 immutable 모델 V4.1
class SignalState {
  final List<Signal> signals;
  final bool isLoading;
  final bool isConnected;
  final PatternType currentPattern;
  final int selectedIndex;
  final double threshold;
  final bool isPatternEnabled;
  final String? errorMessage;
  final Map<String, dynamic>? systemHealth;
  final Map<String, dynamic>? onlineMetricsHealth;
  final String sortField;
  final bool sortAscending;

  const SignalState({
    this.signals = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.currentPattern = PatternType.surge,
    this.selectedIndex = 0,
    this.threshold = 0.4,
    this.isPatternEnabled = false,
    this.errorMessage,
    this.systemHealth,
    this.onlineMetricsHealth,
    this.sortField = 'time',
    this.sortAscending = false,
  });

  /// 🆕 V4.1 온라인 지표 연결 상태
  bool get hasOnlineMetrics => onlineMetricsHealth != null;
  
  /// 🆕 V4.1 시스템 건강성
  bool get isSystemHealthy => 
      systemHealth?['status'] == 'healthy' && 
      (onlineMetricsHealth?['staleMarkets'] ?? 0) == 0;

  /// 🆕 V4.1 신호 통계
  Map<String, dynamic> get signalStats {
    final total = signals.length;
    final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
    final avgConfidence = signals.isNotEmpty 
        ? signals.map((s) => s.confidence ?? 0.0).reduce((a, b) => a + b) / total
        : 0.0;
    
    return {
      'total': total,
      'withOnlineMetrics': withOnlineMetrics,
      'onlineMetricsRatio': total > 0 ? withOnlineMetrics / total : 0.0,
      'avgConfidence': avgConfidence,
      'pattern': currentPattern.displayName,
    };
  }

  SignalState copyWith({
    List<Signal>? signals,
    bool? isLoading,
    bool? isConnected,
    PatternType? currentPattern,
    int? selectedIndex,
    double? threshold,
    bool? isPatternEnabled,
    String? errorMessage,
    Map<String, dynamic>? systemHealth,
    Map<String, dynamic>? onlineMetricsHealth,
    String? sortField,
    bool? sortAscending,
  }) {
    return SignalState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      currentPattern: currentPattern ?? this.currentPattern,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      threshold: threshold ?? this.threshold,
      isPatternEnabled: isPatternEnabled ?? this.isPatternEnabled,
      errorMessage: errorMessage,
      systemHealth: systemHealth ?? this.systemHealth,
      onlineMetricsHealth: onlineMetricsHealth ?? this.onlineMetricsHealth,
      sortField: sortField ?? this.sortField,
      sortAscending: sortAscending ?? this.sortAscending,
    );
  }
}

/// 🚀 Signal 화면 전용 ViewModel V4.1 - Clean Architecture + 단방향 데이터 흐름
class SignalController extends StateNotifier<SignalState> {
  final SignalUseCase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Signal>, AppException>>? _subscription;
  StreamSubscription<Map<String, dynamic>>? _healthSubscription;
  Timer? _healthUpdateTimer;

  SignalController(this._usecase, this._ref) : super(const SignalState()) {
    _startSystemHealthMonitoring();
    _initializePatternState();
  }

  // ==========================================================================
  // 🔧 초기화 및 상태 동기화 - Clean Architecture
  // ==========================================================================

  /// 🔧 패턴 상태 초기화 (Provider 상태와 동기화)
  void _initializePatternState() {
    try {
      // 🔧 Provider에서 현재 상태 가져오기
      final currentPatternType = _ref.read(signalPatternTypeProvider);
      final currentIndex = _ref.read(signalPatternIndexProvider);
      final currentEnabled = _ref.read(signalPatternEnabledProvider(currentPatternType));
      
      // 🔧 UseCase를 통해 임계값 가져오기 (단방향 흐름)
      final currentThreshold = _usecase.getPatternThreshold(currentPatternType);
      
      state = state.copyWith(
        isPatternEnabled: currentEnabled,
        threshold: currentThreshold,
        currentPattern: currentPatternType,
        selectedIndex: currentIndex,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('✅ Pattern state initialized: ${currentPatternType.displayName}, enabled: $currentEnabled, threshold: $currentThreshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ Pattern state initialization failed: $e');
      }
    }
  }

  // ==========================================================================
  // 🆕 V4.1 시스템 건강성 모니터링 (통합 스위치 연동)
  // ==========================================================================

  /// 🆕 시스템 헬스 모니터링 시작 (통합 스위치 연동)
  void _startSystemHealthMonitoring() {
    _healthUpdateTimer = Timer.periodic(const Duration(seconds: 10), (_) {
      final isAnyActive = _ref.read(isAnyPatternActiveProvider);
      if (!isAnyActive) {
        state = state.copyWith(
          systemHealth: {'status': 'inactive', 'message': '모든 패턴이 비활성 상태입니다.'},
          onlineMetricsHealth: {'status': 'inactive', 'message': '온라인 지표가 비활성 상태입니다.'},
        );
        return;
      }
      
      _updateSystemHealth();
      _updateOnlineMetricsHealth();
    });
  }

  /// 🆕 시스템 헬스 업데이트 (UseCase 직접 호출)
  void _updateSystemHealth() async {
    try {
      final health = await _usecase.getSystemHealth();
      
      state = state.copyWith(systemHealth: health);
      
      if (AppConfig.enableTradeLog) {
        final staleMarkets = health['onlineMetricsSystem']?['staleMarkets'] ?? 0;
        if (staleMarkets > 0) {
          log.w('⚠️ Signal Controller: $staleMarkets개 마켓 온라인 지표 만료');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: System health update failed - $e');
      }
    }
  }

  /// 🆕 온라인 지표 헬스 업데이트 (UseCase 직접 호출)
  void _updateOnlineMetricsHealth() {
    try {
      final health = _usecase.getOnlineMetricsHealth();
      
      state = state.copyWith(onlineMetricsHealth: health);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: Online metrics health update failed - $e');
      }
    }
  }

  // ==========================================================================
  // 🆕 통합 시스템 제어 (Clean Architecture)
  // ==========================================================================

  /// 🆕 전체 시스템 ON/OFF 제어
  void setSystemActive(bool active) {
    try {
      _usecase.setSystemActive(active);
      
      if (AppConfig.enableTradeLog) {
        log.i('🎯 System ${active ? "activated" : "deactivated"} via Signal Controller');
      }
      
      // 현재 패턴 상태 동기화
      _initializePatternState();
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ System activation toggle failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'System toggle failed: ${e.toString()}'
      );
    }
  }

  /// 🆕 전체 시스템 활성 상태 조회
  bool get isSystemActive => _ref.read(isAnyPatternActiveProvider);

  /// 🆕 시스템 상태 요약 (UseCase 직접 호출)
  Map<String, dynamic> getSystemStatus() {
    try {
      return _usecase.getSystemStatus();
    } catch (e) {
      return {
        'isSystemActive': false,
        'error': e.toString(),
        'timestamp': DateTime.now().toIso8601String(),
      };
    }
  }

  // ==========================================================================
  // 기본 패턴 관리 (Clean Architecture - 단방향 흐름)
  // ==========================================================================

  /// 패턴 인덱스 변경 (슬라이더 이동)
  void setPatternIndex(int index, List<String> markets) {
    if (index < 0 || index >= PatternType.values.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index');
      }
      return;
    }

    final patternType = PatternType.values[index];

    // 🔧 Provider 상태 업데이트
    _ref.read(signalPatternIndexProvider.notifier).state = index;
    _ref.read(signalPatternTypeProvider.notifier).state = patternType;

    // 🔧 UseCase에서 현재 상태 가져오기
    final newEnabled = _usecase.isPatternEnabled(patternType);
    final newThreshold = _usecase.getPatternThreshold(patternType);

    state = state.copyWith(
      currentPattern: patternType,
      selectedIndex: index,
      threshold: newThreshold,
      isPatternEnabled: newEnabled,
      isLoading: true,
      errorMessage: null,
    );

    // 스트림 재구독
    _subscribeToPattern(patternType, markets);
    
    if (AppConfig.enableTradeLog) {
      log.i('🎯 Pattern changed to: ${patternType.displayName} (V4.1) - enabled: $newEnabled, threshold: $newThreshold');
    }
  }

  /// 현재 패턴의 임계값 변경 (UseCase 직접 호출)
  void updateThreshold(double threshold) {
    try {
      // 🔧 UseCase를 통한 업데이트 (단방향 흐름)
      _usecase.updatePatternThreshold(state.currentPattern, threshold);

      // 로컬 상태 업데이트
      state = state.copyWith(threshold: threshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('📊 Threshold updated: ${state.currentPattern.displayName} → $threshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Threshold update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Invalid threshold value: ${e.toString()}'
      );
    }
  }

  /// 패턴 활성화/비활성화 토글 (Provider + UseCase 동기화)
  void togglePatternEnabled() {
    final newEnabled = !state.isPatternEnabled;
    
    try {
      if (AppConfig.enableTradeLog) {
        log.i('🎯 Toggle requested - Current: ${state.isPatternEnabled}, Pattern: ${state.currentPattern.displayName}');
      }
      
      // 🔧 1. Provider 상태 업데이트
      _ref.read(signalPatternEnabledProvider(state.currentPattern).notifier).state = newEnabled;
      
      // 🔧 2. UseCase 업데이트
      _usecase.setPatternEnabled(state.currentPattern, newEnabled);

      // 🔧 3. 로컬 상태 업데이트
      state = state.copyWith(isPatternEnabled: newEnabled);
      
      if (AppConfig.enableTradeLog) {
        log.i('🔄 Pattern ${newEnabled ? "enabled" : "disabled"}: ${state.currentPattern.displayName} ✅');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Toggle pattern failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Failed to toggle pattern: ${e.toString()}'
      );
    }
  }

  /// 시그널 목록 초기화 (UseCase 직접 호출)
  void clearSignals([PatternType? pattern]) {
    try {
      _usecase.clearSignals(pattern);

      if (pattern == null || pattern == state.currentPattern) {
        state = state.copyWith(signals: []);
      }
      
      if (AppConfig.enableTradeLog) {
        final patternName = pattern?.displayName ?? 'All patterns';
        log.i('🧹 Signals cleared: $patternName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Clear signals failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Failed to clear signals: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // 🆕 V4.1 모달용 메서드 4개 (Clean Architecture)
  // ==========================================================================

  /// 🆕 현재 임계값 조회 (모달에서 사용)
  double getCurrentThresholdValue(String key) {
    try {
      return _usecase.getCurrentThresholdValue(state.currentPattern, key);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ getCurrentThresholdValue failed for $key: $e');
      }
      return 0.0;
    }
  }

  /// 🆕 기본 임계값 조회 (모달에서 사용)
  double getDefaultThresholdValue(String key) {
    try {
      return _usecase.getDefaultThresholdValue(state.currentPattern, key);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ getDefaultThresholdValue failed for $key: $e');
      }
      return 0.0;
    }
  }

  /// 🆕 임계값 직접 업데이트 (모달에서 사용)
  void updatePatternThresholdDirect(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      // 메인 threshold가 변경된 경우 로컬 상태도 업데이트
      if (key == 'priceChangePercent' || key == 'zScoreThreshold') {
        state = state.copyWith(threshold: value);
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('⚙️ Direct threshold updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Direct threshold update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Threshold update failed: ${e.toString()}'
      );
    }
  }

  /// 🆕 임계값 기본값으로 리셋 (모달에서 사용)
  void resetThresholdToDefault(String key) {
    try {
      final defaultValue = getDefaultThresholdValue(key);
      updatePatternThresholdDirect(key, defaultValue);
      
      if (AppConfig.enableTradeLog) {
        log.i('🔄 Threshold reset to default: ${state.currentPattern.name}.$key = $defaultValue');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Reset threshold to default failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Reset to default failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // 🆕 V4.1 고급 패턴 설정 (UseCase 직접 호출)
  // ==========================================================================

  /// 🆕 고급 패턴 설정 업데이트
  void updateAdvancedPatternConfig(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      if (AppConfig.enableTradeLog) {
        log.i('⚙️ Advanced config updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Advanced config update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration update failed: ${e.toString()}'
      );
    }
  }

  /// 🆕 패턴 프리셋 적용 (UseCase 직접 호출)
  void applyPreset(String presetName) {
    try {
      _usecase.applyPatternPreset(presetName);
      
      // 현재 패턴의 임계값도 업데이트
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('🎯 Preset applied: $presetName - threshold: $newThreshold, enabled: $newEnabled');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Preset application failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Preset application failed: ${e.toString()}'
      );
    }
  }

  /// 🆕 온라인 지표 리셋 (UseCase 직접 호출)
  void resetOnlineMetrics([String? market]) {
    try {
      _usecase.resetOnlineMetrics(market);
      
      // 헬스 상태 즉시 업데이트
      _updateOnlineMetricsHealth();
      
      if (AppConfig.enableTradeLog) {
        final target = market ?? 'all markets';
        log.i('🔄 Online metrics reset: $target');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Online metrics reset failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Online metrics reset failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // 스트림 관리 (V4.1 개선 - UseCase 직접 호출)
  // ==========================================================================

  /// 패턴별 시그널 스트림 구독
  void _subscribeToPattern(PatternType patternType, List<String> markets) {
    _subscription?.cancel();
    
    _subscription = _usecase
        .watchSignalsByPattern(patternType, markets)
        .map((signals) => Ok<List<Signal>, AppException>(signals))
        .handleError((error) => Err<List<Signal>, AppException>(
            AppException(
              'Signal pattern detection failed: ${error.toString()}',
              code: 'SIGNAL_PATTERN_ERROR',
              originalException: error is Exception ? error : null,
            )))
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Signal>, AppException> result) {
    result.when(
      ok: (signals) {
        final sortedSignals = _applySorting(signals);
        
        state = state.copyWith(
          signals: sortedSignals,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
        
        if (AppConfig.enableTradeLog && signals.isNotEmpty) {
          final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
          final ratio = (withOnlineMetrics / signals.length * 100).toStringAsFixed(1);
          log.i('📊 Signals received: ${signals.length}, Online metrics: $withOnlineMetrics ($ratio%)');
        }
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
        
        if (AppConfig.enableTradeLog) {
          log.e('❌ Signal stream error: ${e.message}');
        }
      },
    );
  }

  /// 재연결/새로고침
  void refresh(List<String> markets) {
    if (AppConfig.enableTradeLog) {
      log.i('🔄 Signal refresh requested for ${markets.length} markets');
    }
    
    try {
      resetOnlineMetrics();
      setPatternIndex(state.selectedIndex, markets);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Signal refresh failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Refresh failed: ${e.toString()}'
      );
    }
  }

  // ==========================================================================
  // 🆕 V4.1 정렬 및 필터링
  // ==========================================================================

  /// 🆕 정렬 필드 변경
  void setSortField(String field, {bool? ascending}) {
    final newAscending = ascending ?? (state.sortField == field ? !state.sortAscending : false);
    
    state = state.copyWith(
      sortField: field,
      sortAscending: newAscending,
      signals: _applySorting(state.signals),
    );
    
    if (AppConfig.enableTradeLog) {
      log.i('📊 Sort changed: $field (${newAscending ? "ASC" : "DESC"})');
    }
  }

  /// 🆕 정렬 적용
  List<Signal> _applySorting(List<Signal> signals) {
    final list = List<Signal>.from(signals);
    
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      
      switch (state.sortField) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.currentPrice;
          bValue = b.currentPrice;
          break;
        case 'change':
          aValue = a.changePercent.abs();
          bValue = b.changePercent.abs();
          break;
        case 'amount':
          aValue = a.tradeAmount;
          bValue = b.tradeAmount;
          break;
        case 'confidence':
          aValue = a.confidence ?? 0.0;
          bValue = b.confidence ?? 0.0;
          break;
        case 'time':
        default:
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
      }
      
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      
      return state.sortAscending ? cmp : -cmp;
    });
    
    return list;
  }

  /// 🆕 고급 필터링 (UseCase 직접 호출)
  List<Signal> filterSignals({
    String? marketFilter,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
  }) {
    return _usecase.filterSignals(
      state.signals,
      markets: marketFilter != null ? {marketFilter.toUpperCase()} : null,
      minConfidence: minConfidence,
      requireOnlineMetrics: requireOnlineMetrics,
      patternTypes: patternTypes,
      timeWindow: timeWindow,
    );
  }

  // ==========================================================================
  // 표시 텍스트 생성 (V4.1 개선 - UseCase 직접 호출)
  // ==========================================================================

  /// 현재 패턴 표시 텍스트 생성
  String getPatternDisplayText() {
    final pattern = state.currentPattern;
    return '${pattern.displayName}: ${pattern.description}';
  }

  /// 현재 패턴 아이콘/이모지
  String getPatternIcon() {
    return state.currentPattern.displayName;
  }

  /// 임계값 표시 텍스트 (UseCase에서 실제 값 조회)
  String getThresholdDisplayText() {
    final pattern = state.currentPattern;

    try {
      switch (pattern) {
        case PatternType.surge:
          final value = _usecase.getCurrentThresholdValue(pattern, 'priceChangePercent');
          return '${value.toStringAsFixed(1)}% 상승';
        case PatternType.flashFire:
          final value = _usecase.getCurrentThresholdValue(pattern, 'zScoreThreshold');
          return '${value.toStringAsFixed(1)}배 급증';
        case PatternType.stackUp:
          final value = _usecase.getCurrentThresholdValue(pattern, 'consecutiveMin');
          return '${value.toInt()}연속 증가';
        case PatternType.stealthIn:
          final value = _usecase.getCurrentThresholdValue(pattern, 'minTradeAmount');
          final amountText = value >= 1000000 
              ? '${(value / 1000000).toStringAsFixed(0)}백만원'
              : '${value.toStringAsFixed(0)}원';
          return '$amountText 이상';
        case PatternType.blackHole:
          final value = _usecase.getCurrentThresholdValue(pattern, 'cvThreshold');
          return '${(value * 100).toStringAsFixed(1)}% 이하 변동';
        case PatternType.reboundShot:
          final value = _usecase.getCurrentThresholdValue(pattern, 'priceRangeMin');
          return '${(value * 100).toStringAsFixed(1)}% 급락 후 반등';
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('⚠️ getThresholdDisplayText failed: $e');
      }
      return '설정 불러오기 실패';
    }
  }

  /// 🆕 시스템 상태 표시 텍스트
  String getSystemStatusText() {
    if (!isSystemActive) return 'System: Inactive (All patterns disabled)';
    if (!state.hasOnlineMetrics) return 'Online metrics: Connecting...';
    
    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    if (staleMarkets > 0) {
      return 'Online metrics: $healthyMarkets/$totalMarkets healthy ($staleMarkets stale)';
    }
    
    return 'Online metrics: $healthyMarkets/$totalMarkets healthy ✅';
  }

  /// 🆕 신뢰도 상태 표시
  String getConfidenceStatusText() {
    final stats = state.signalStats;
    final avgConf = stats['avgConfidence'] as double;
    final onlineRatio = stats['onlineMetricsRatio'] as double;
    
    return 'Avg confidence: ${(avgConf * 100).toStringAsFixed(1)}%, '
           'Online: ${(onlineRatio * 100).toStringAsFixed(1)}%';
  }

  // ==========================================================================
  // 🆕 V4.1 통계 및 분석 (UseCase 직접 호출)
  // ==========================================================================

  /// 🆕 패턴별 성능 통계
  Future<Map<String, dynamic>> getPatternPerformance() async {
    try {
      final performance = await _usecase.getPatternPerformance(state.currentPattern);
      return {
        'pattern': performance.patternType.displayName,
        'totalSignals': performance.totalSignals,
        'recentSignals': performance.recentSignals,
        'lastSignalTime': performance.lastSignalTime?.toIso8601String(),
        'isEnabled': performance.isEnabled,
        'onlineMetricsHealth': performance.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Pattern performance query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// 🆕 시스템 헬스 리포트
  Future<Map<String, dynamic>> getSystemHealthReport() async {
    try {
      final report = await _usecase.getSystemHealthReport();
      return {
        'version': report.version,
        'status': report.status,
        'uptime': report.uptime,
        'totalProcessedTrades': report.totalProcessedTrades,
        'activePatterns': report.activePatterns,
        'trackedMarkets': report.trackedMarkets,
        'isHealthy': report.isHealthy,
        'onlineMetricsHealth': report.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ System health report query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// 🆕 신호 통계 계산
  Map<String, dynamic> calculateSignalStats() {
    return _usecase.calculateSignalStats(state.signals).toJson();
  }

  // ==========================================================================
  // 기존 호환성 메서드들 (V4.1 개선)
  // ==========================================================================

  /// 시그널 통계 정보 (기존 호환성)
  Map<String, dynamic> getSignalStats() {
    return state.signalStats;
  }

  /// 시그널 목록 적용 (정렬 등)
  List<Signal> apply(List<Signal> signals) {
    return _applySorting(signals);
  }

  /// 사용 가능한 패턴 목록
  List<String> get availablePatterns => 
      PatternType.values.map((p) => p.name).toList();

  /// 패턴 표시명 목록
  List<String> get patternDisplayNames => 
      PatternType.values.map((p) => p.displayName).toList();

  /// 현재 패턴의 시간 윈도우
  int get currentTimeWindow => state.currentPattern.timeWindowMinutes;

  /// 🆕 V4.1 현재 패턴의 기본 신뢰도
  double get currentPatternDefaultConfidence => state.currentPattern.defaultConfidence;

  /// 🆕 V4.1 현재 패턴의 쿨다운 시간
  int get currentPatternCooldownSeconds => state.currentPattern.defaultCooldownSeconds;

  // ==========================================================================
  // 🆕 V4.1 설정 관리 (UseCase 직접 호출)
  // ==========================================================================

  /// 🆕 현재 설정 내보내기
  Map<String, dynamic> exportConfiguration() {
    try {
      return _usecase.exportCurrentConfiguration();
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Export configuration failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// 🆕 설정 가져오기
  void importConfiguration(Map<String, dynamic> config) {
    try {
      _usecase.importSignalConfiguration(config);
      
      // 현재 상태 새로고침
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('📥 Configuration imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('❌ Configuration import failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration import failed: ${e.toString()}'
      );
    }
  }

  /// 🆕 에러 메시지 클리어
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }

  // ==========================================================================
  // 리소스 정리 (V4.1 확장)
  // ==========================================================================

  @override
  void dispose() {
    _subscription?.cancel();
    _healthSubscription?.cancel();
    _healthUpdateTimer?.cancel();
    
    if (AppConfig.enableTradeLog) {
      log.i('🔥 Signal Controller V4.1 disposed - Clean Architecture');
    }
    
    super.dispose();
  }
}

/// Provider 선언 - V4.1 Clean Architecture
final signalControllerProvider =
    StateNotifierProvider<SignalController, SignalState>((ref) {
  final usecase = ref.read(signalUsecaseProvider);
  return SignalController(usecase, ref);
});

/// 🆕 V4.1 확장 - 시스템 모니터링 Provider (통합 스위치 연동)
final signalSystemMonitorProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final isAnyActive = ref.watch(isAnyPatternActiveProvider);
  if (!isAnyActive) {
    yield {
      'status': 'inactive',
      'message': '시스템 모니터링이 비활성 상태입니다.',
      'timestamp': DateTime.now().toIso8601String(),
      'version': 'V4.1-Clean-Architecture-Inactive',
    };
    return;
  }
  
  final controller = ref.watch(signalControllerProvider.notifier);
  
  yield* Stream.periodic(const Duration(seconds: 15), (_) async {
    final performance = await controller.getPatternPerformance();
    final systemHealth = await controller.getSystemHealthReport();
    final signalStats = controller.calculateSignalStats();
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'performance': performance,
      'systemHealth': systemHealth,
      'signalStats': signalStats,
      'version': 'V4.1-Clean-Architecture',
      'isSystemActive': true,
    };
  }).asyncMap((event) => event);
});\n\n// ====== lib/presentation/pages/signal_page.dart ======\n
// lib/presentation/pages/signal_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/settings_provider.dart';
import '../../core/di/signal_provider.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/signal.dart';
import '../controllers/signal_controller.dart';
import '../widgets/signal_tile.dart';
import '../../shared/widgets/signal_widget.dart';  // 🆕 정교한 모달 위젯 import

/// 🚀 Signal Page V4.1 - 온라인 지표 연동 + Family Provider
class SignalPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SignalPage({
    super.key,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 🔽🔽🔽 백그라운드 워밍업: 활성화된 모든 패턴의 스트림을 미리 구독 🔽🔽🔽
    for (final pattern in PatternType.values) {
      if (ref.watch(signalPatternEnabledProvider(pattern))) {
        // 백그라운드에서 해당 패턴의 독립적인 스트림을 미리 구독하여 '워밍업' 상태로 둔다.
        // 이렇게 하면 사용자가 슬라이더를 해당 패턴으로 옮겼을 때 데이터를 즉시 볼 수 있다.
        ref.watch(signalsByPatternProvider(pattern));
      }
    }

    // V4.1 Controller 기반 시스템
    final controller = ref.watch(signalControllerProvider.notifier);
    final state = ref.watch(signalControllerProvider);

    // 🔽🔽🔽 새로운 Family Provider 사용 🔽🔽🔽
    // 1. 현재 선택된 패턴 타입을 가져옵니다.
    final currentPattern = ref.watch(signalPatternTypeProvider);
    // 2. 해당 패턴에 대한 독립적인 스트림 프로바이더를 구독합니다.
    final signalsAsync = ref.watch(signalsByPatternProvider(currentPattern));

    // markets 정보
    final marketsAsync = ref.watch(marketsProvider);

    // 슬라이더 위치 설정
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // 🆕 V4.1 시스템 모니터링
    ref.listen(signalSystemMonitorProvider, (prev, next) {
      if (next.hasError && AppConfig.enableTradeLog) {
        debugPrint('⚠️ Signal system monitoring error: ${next.error}');
      }
    });

    // 에러 메시지 자동 클리어
    ref.listen(signalControllerProvider.select((s) => s.errorMessage), (prev, next) {
      if (next != null) {
        Future.delayed(const Duration(seconds: 5), () {
          controller.clearError();
        });
      }
    });

    // 🆕 V4.1 슬라이더 위젯 (온라인 지표 상태 포함)
    final sliderWidget = _buildEnhancedSliderWidget(
      controller,
      state,
      marketsAsync,
      ref,
      context,
    );

    // 🆕 V4.1 시그널 리스트 (정렬 및 필터링 포함)
    final signalListWidget = _buildEnhancedSignalList(
      signalsAsync,
      controller,
      scrollController,
      state,
      context,
      ref,
      currentPattern, // 현재 패턴 정보 추가
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // 슬라이더 위치에 따른 조건부 배치
          if (sliderPosition == SliderPosition.top) sliderWidget,

          // 🆕 V4.1 에러 메시지 표시
          if (state.errorMessage != null) _buildErrorBanner(state.errorMessage!, controller),

          // 시그널 리스트 (항상 중간)
          Expanded(child: signalListWidget),

          // 슬라이더가 하단일 때
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// 🆕 V4.1 에러 배너
  Widget _buildErrorBanner(String errorMessage, SignalController controller) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 16),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              errorMessage,
              style: const TextStyle(color: Colors.red, fontSize: 12),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          GestureDetector(
            onTap: controller.clearError,
            child: const Icon(Icons.close, color: Colors.red, size: 16),
          ),
        ],
      ),
    );
  }

  /// 🚀 V4.1 강화된 슬라이더 위젯 (온라인 지표 상태 포함)
  Widget _buildEnhancedSliderWidget(
    SignalController controller,
    SignalState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 🎯 첫 번째 줄: 아이콘 + 제목 + 설명 + 상태 표시
          Row(
            children: [
              // 패턴 아이콘 + 제목
              Icon(
                _getPatternIcon(state.currentPattern),
                size: 18,
                color: _getPatternColor(state.currentPattern),
              ),
              const SizedBox(width: 8),
              
              // 제목 + 설명
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      state.currentPattern.displayName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      state.currentPattern.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),

              // 🆕 V4.1 시스템 상태 표시
              _buildSystemStatusChip(state),
              const SizedBox(width: 8),

              // 활성화/비활성화 토글
              _buildPatternToggle(state, controller, ref),
            ],
          ),

          const SizedBox(height: 8),

          // 🎯 두 번째 줄: 임계값 + 신뢰도 정보
          Row(
            children: [
              // 🔧 임계값을 탭 가능하게 수정 (정교한 모달 호출)
              GestureDetector(
                onTap: () => _showThresholdModal(context, controller, state.currentPattern),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(6),
                    border: Border.all(color: Colors.grey.withValues(alpha: 0.3)),
                    color: Colors.grey.withValues(alpha: 0.05),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(Icons.tune, size: 12, color: Colors.grey[600]),
                      const SizedBox(width: 4),
                      Text(
                        '임계값: ${controller.getThresholdDisplayText()}',
                        style: const TextStyle(fontSize: 12, color: Colors.grey),
                      ),
                    ],
                  ),
                ),
              ),
              const Spacer(),
              // 🆕 V4.1 신뢰도 정보
              Text(
                controller.getConfidenceStatusText(),
                style: const TextStyle(fontSize: 10, color: Colors.grey),
              ),
            ],
          ),

          const SizedBox(height: 8),

          // 🎯 세 번째 줄: 패턴 슬라이더
          Row(
            children: [
              // 슬라이더
              Expanded(
                child: Slider(
                  value: state.selectedIndex.toDouble(),
                  min: 0,
                  max: (PatternType.values.length - 1).toDouble(),
                  divisions: PatternType.values.length - 1,
                  label: state.currentPattern.displayName,
                  activeColor: _getPatternColor(state.currentPattern),
                  onChanged: (v) {
                    if (ref.read(appSettingsProvider).isHapticEnabled) {
                      HapticFeedback.lightImpact();
                    }
                    final index = v.round();
                    marketsAsync.whenData((markets) {
                      controller.setPatternIndex(index, markets);
                    });
                  },
                ),
              ),

              // 🆕 V4.1 정렬 버튼
              _buildSortButton(state, controller),
            ],
          ),

          // 🆕 V4.1 온라인 지표 상태 바
          _buildOnlineMetricsStatusBar(state),
        ],
      ),
    );
  }

  /// 🆕 V4.1 시스템 상태 칩
  Widget _buildSystemStatusChip(SignalState state) {
    final isHealthy = state.isSystemHealthy;
    final color = isHealthy ? Colors.green : Colors.orange;
    final icon = isHealthy ? Icons.check_circle : Icons.warning;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: color.withValues(alpha: 0.1),
        border: Border.all(color: color.withValues(alpha: 0.3), width: 0.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            isHealthy ? 'OK' : 'WARN',
            style: TextStyle(fontSize: 8, color: color, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  /// 🆕 V4.1 패턴 토글 버튼
  Widget _buildPatternToggle(SignalState state, SignalController controller, WidgetRef ref) {
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact();
        }
        controller.togglePatternEnabled();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange,
            width: 1.5,
          ),
          color: state.isPatternEnabled ? Colors.orange : Colors.transparent,
        ),
        child: Text(
          state.isPatternEnabled ? '활성' : '비활성',
          style: TextStyle(
            color: state.isPatternEnabled ? Colors.white : Colors.orange,
            fontSize: 11,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  /// 🆕 V4.1 정렬 버튼
  Widget _buildSortButton(SignalState state, SignalController controller) {
    return PopupMenuButton<String>(
      icon: Icon(
        Icons.sort,
        size: 18,
        color: Colors.grey[600],
      ),
      onSelected: (value) {
        controller.setSortField(value);
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'time', child: Text('시간 ${_getSortIcon(state, 'time')}')),
        PopupMenuItem(value: 'confidence', child: Text('신뢰도 ${_getSortIcon(state, 'confidence')}')),
        PopupMenuItem(value: 'change', child: Text('변화율 ${_getSortIcon(state, 'change')}')),
        PopupMenuItem(value: 'amount', child: Text('거래액 ${_getSortIcon(state, 'amount')}')),
        PopupMenuItem(value: 'market', child: Text('마켓 ${_getSortIcon(state, 'market')}')),
      ],
    );
  }

  /// 🆕 정렬 아이콘 헬퍼
  String _getSortIcon(SignalState state, String field) {
    if (state.sortField != field) return '';
    return state.sortAscending ? '↑' : '↓';
  }

  /// 🆕 V4.1 온라인 지표 상태 바
  Widget _buildOnlineMetricsStatusBar(SignalState state) {
    if (!state.hasOnlineMetrics) {
      return Container(
        height: 2,
        margin: const EdgeInsets.only(top: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(1),
          color: Colors.grey[300],
        ),
      );
    }

    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    final healthRatio = totalMarkets > 0 ? healthyMarkets / totalMarkets : 0.0;
    final color = staleMarkets > 0 ? Colors.orange : Colors.green;

    return Container(
      height: 2,
      margin: const EdgeInsets.only(top: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(1),
        color: Colors.grey[300],
      ),
      child: FractionallySizedBox(
        widthFactor: healthRatio,
        alignment: Alignment.centerLeft,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(1),
            color: color,
          ),
        ),
      ),
    );
  }

  /// 🚀 V4.1 강화된 시그널 리스트 (정렬 및 온라인 지표 표시)
  Widget _buildEnhancedSignalList(
    AsyncValue<List<Signal>> signalsAsync,
    SignalController controller,
    ScrollController scrollController,
    SignalState state,
    BuildContext context,
    WidgetRef ref,
    PatternType currentPattern, // 현재 패턴 정보 추가
  ) {
    return signalsAsync.when(
      data: (list) {
        final viewList = controller.apply(list);

        if (viewList.isEmpty) {
          return _buildEmptyState(state, context, controller, currentPattern);
        }

        return _buildSignalListView(viewList, scrollController, state, ref);
      },
      loading: () => _buildLoadingState(context, currentPattern),
      error: (e, _) => _buildErrorState(e, context, ref, currentPattern),
    );
  }

  /// 🆕 V4.1 빈 상태 (온라인 지표 정보 포함)
  Widget _buildEmptyState(SignalState state, BuildContext context, SignalController controller, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.radar,
            size: 64,
            color: Theme.of(context).hintColor.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            state.isPatternEnabled
                ? '${currentPattern.displayName} 패턴이 감지되지 않았습니다.'
                : '${currentPattern.displayName} 패턴 감지가 비활성화되어 있습니다.',
            textAlign: TextAlign.center,
            style: TextStyle(
                color: Theme.of(context).hintColor, fontSize: 16),
          ),
          const SizedBox(height: 8),
          Text(
            '임계값: ${controller.getThresholdDisplayText()}',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 14,
            ),
          ),
          // 🆕 V4.1 온라인 지표 상태
          if (state.hasOnlineMetrics) ...[
            const SizedBox(height: 8),
            Text(
              controller.getSystemStatusText(),
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Theme.of(context).hintColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
          ],
          // 🆕 V4.1 빠른 액션 버튼들
          const SizedBox(height: 24),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // 온라인 지표 리셋 버튼
              ElevatedButton.icon(
                onPressed: () => controller.resetOnlineMetrics(),
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('지표 리셋'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
              const SizedBox(width: 12),
              // 프리셋 적용 버튼
              ElevatedButton.icon(
                onPressed: () => _showPresetDialog(context, controller),
                icon: const Icon(Icons.tune, size: 16),
                label: const Text('프리셋'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          // 🔧 정교한 임계값 조정 모달 호출 버튼
          ElevatedButton.icon(
            onPressed: () => _showThresholdModal(context, controller, currentPattern),
            icon: const Icon(Icons.settings, size: 16),
            label: const Text('임계값 조정'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.orange,
              foregroundColor: Colors.white,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              textStyle: const TextStyle(fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }

  /// 🆕 V4.1 로딩 상태 (패턴별 맞춤 메시지)
  Widget _buildLoadingState(BuildContext context, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            '${currentPattern.displayName} 패턴 분석 중...',
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            '온라인 지표 연동 중...',
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  /// 🆕 V4.1 에러 상태 (패턴별 에러 처리)
  Widget _buildErrorState(Object error, BuildContext context, WidgetRef ref, PatternType currentPattern) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: Theme.of(context).colorScheme.error.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            '${currentPattern.displayName} 시그널 로드 중 오류가 발생했습니다.',
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            '$error',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton.icon(
                onPressed: () {
                  ref.invalidate(signalsByPatternProvider(currentPattern));
                },
                icon: const Icon(Icons.refresh),
                label: const Text('다시 시도'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                ),
              ),
              const SizedBox(width: 12),
              // 🆕 V4.1 고급 진단 버튼
              ElevatedButton.icon(
                onPressed: () => _showDiagnosticsDialog(context, ref),
                icon: const Icon(Icons.info),
                label: const Text('진단'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// 🆕 V4.1 시그널 리스트 뷰 (온라인 지표 표시 포함)
  Widget _buildSignalListView(
    List<Signal> viewList,
    ScrollController scrollController,
    SignalState state,
    WidgetRef ref,
  ) {
    return RawScrollbar(
      controller: scrollController,
      thumbVisibility: false,
      trackVisibility: false,
      thickness: 6.4,
      radius: const Radius.circular(3.2),
      thumbColor: Colors.orange.withValues(alpha: 0.5),
      interactive: true,
      minThumbLength: 40,
      child: ListView.builder(
        controller: scrollController,
        physics: const BouncingScrollPhysics(
          parent: AlwaysScrollableScrollPhysics(),
        ),
        padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
        itemCount: viewList.length,
        itemBuilder: (context, index) {
          final signal = viewList[index];
          
          return Column(
            children: [
              // 🆕 V4.1 Signal Tile 사용 (탭 기능 추가)
              GestureDetector(
                onTap: () => _showSignalDetails(context, signal, ref),
                child: SignalTile(
                  signal: signal,
                  showOnlineMetrics: true,
                ),
              ),
              
              // 구분선 (마지막 아이템 제외)
              if (index < viewList.length - 1)
                Divider(
                  height: 1,
                  thickness: 0.5,
                  color: Colors.grey[300],
                  indent: 16,
                  endIndent: 16,
                ),
            ],
          );
        },
      ),
    );
  }

  // ==========================================================================
  // 🆕 V4.1 대화상자들
  // ==========================================================================

  /// 🔧 정교한 임계값 조정 모달 (우리가 만든 모달 사용)
  void _showThresholdModal(BuildContext context, SignalController controller, PatternType currentPattern) {
    showGeneralDialog(
      context: context,
      barrierDismissible: true,
      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
      barrierColor: Colors.black.withValues(alpha: 0.5),
      transitionDuration: const Duration(milliseconds: 300),
      pageBuilder: (context, animation1, animation2) {
        return Center(
          child: ScaleTransition(
            scale: CurvedAnimation(
              parent: animation1,
              curve: Curves.easeOutBack,
            ),
            child: ThresholdAdjustmentModal(
              pattern: currentPattern,
              controller: controller,
              onClose: () => Navigator.pop(context),
            ),
          ),
        );
      },
    );
  }

  /// 🆕 프리셋 선택 대화상자
  void _showPresetDialog(BuildContext context, SignalController controller) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('패턴 프리셋 선택'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.security, color: Colors.blue),
              title: const Text('Conservative'),
              subtitle: const Text('False Positive 최소화'),
              onTap: () {
                controller.applyPreset('conservative');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.balance, color: Colors.green),
              title: const Text('Balanced'),
              subtitle: const Text('균형잡힌 기본 설정'),
              onTap: () {
                controller.applyPreset('balanced');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.speed, color: Colors.red),
              title: const Text('Aggressive'),
              subtitle: const Text('감지율 최대화'),
              onTap: () {
                controller.applyPreset('aggressive');
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  /// 🆕 진단 정보 대화상자
  void _showDiagnosticsDialog(BuildContext context, WidgetRef ref) {
    final controller = ref.read(signalControllerProvider.notifier);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('시스템 진단'),
        content: FutureBuilder<Map<String, dynamic>>(
          future: controller.getSystemHealthReport(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('진단 중...'),
                ],
              );
            }
            
            if (snapshot.hasError) {
              return Text('진단 실패: ${snapshot.error}');
            }
            
            final report = snapshot.data!;
            return SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('버전: ${report['version']}'),
                  Text('상태: ${report['status']}'),
                  Text('업타임: ${report['uptime']}분'),
                  Text('처리된 거래: ${report['totalProcessedTrades']}건'),
                  Text('활성 패턴: ${report['activePatterns']}개'),
                  Text('추적 마켓: ${report['trackedMarkets']}개'),
                  const SizedBox(height: 16),
                  const Text('온라인 지표 상태:', style: TextStyle(fontWeight: FontWeight.bold)),
                  if (report['onlineMetricsHealth'] != null) ...[
                    Text('총 마켓: ${report['onlineMetricsHealth']['totalMarkets']}'),
                    Text('정상: ${report['onlineMetricsHealth']['healthyMarkets']}'),
                    Text('만료: ${report['onlineMetricsHealth']['staleMarkets']}'),
                  ],
                ],
              ),
            );
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('닫기'),
          ),
        ],
      ),
    );
  }

  /// 🆕 시그널 상세 정보 대화상자
  void _showSignalDetails(BuildContext context, Signal signal, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${signal.patternType.displayName} - ${signal.ticker}'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // 기본 정보
              _buildDetailRow('마켓', signal.market),
              _buildDetailRow('현재가', '${signal.currentPrice.toStringAsFixed(0)}원'),
              _buildDetailRow('변화율', '${signal.changePercent.toStringAsFixed(2)}%'),
              _buildDetailRow('거래액', '${(signal.tradeAmount / 1000000).toStringAsFixed(1)}M'),
              _buildDetailRow('감지시간', signal.detectedAt.toString().substring(0, 19)),
              
              if (signal.confidence != null)
                _buildDetailRow('신뢰도', '${(signal.confidence! * 100).toStringAsFixed(1)}%'),
              
              // 온라인 지표 정보
              if (signal.hasOnlineMetrics) ...[
                const SizedBox(height: 16),
                const Text('온라인 지표', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                
                if (signal.onlineIndicators?.rsi != null)
                  _buildDetailRow('RSI', '${signal.onlineIndicators!.rsi!.toStringAsFixed(1)} (${signal.onlineIndicators!.rsiState})'),
                
                if (signal.onlineIndicators?.macd != null)
                  _buildDetailRow('MACD', '${signal.onlineIndicators!.macd!.toStringAsFixed(2)} (${signal.onlineIndicators!.macdState})'),
              ],
              
              // 다이버전스 정보
              if (signal.divergence != null) ...[
                const SizedBox(height: 16),
                const Text('다이버전스', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                _buildDetailRow('타입', signal.divergence!.type),
                _buildDetailRow('강도', signal.divergence!.confidenceLevel),
                _buildDetailRow('소스', signal.divergence!.source),
              ],
              
              // 고급 지표들
              const SizedBox(height: 16),
              const Text('고급 지표', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              
              if (signal.zScore != null)
                _buildDetailRow('Z-Score', signal.zScore!.toStringAsFixed(2)),
              
              if (signal.liquidityVortex != null)
                _buildDetailRow('Liquidity Vortex', signal.liquidityVortex!.toStringAsFixed(3)),
              
              if (signal.flashPulse != null)
                _buildDetailRow('Flash Pulse', signal.flashPulse!.toStringAsFixed(2)),
              
              // 버전 정보
              if (signal.version != null) ...[
                const SizedBox(height: 16),
                _buildDetailRow('버전', signal.version!),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('닫기'),
          ),
        ],
      ),
    );
  }

  /// 상세 정보 행
  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  // ==========================================================================
  // 헬퍼 함수들
  // ==========================================================================

  /// 패턴별 아이콘 반환
  IconData _getPatternIcon(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// 패턴별 색상 반환
  Color _getPatternColor(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }
}\n\n// ====== lib/presentation/widgets/signal_tile.dart ======\n
// lib/presentation/widgets/signal_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/signal.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';

// 🎯 중복 반짝임 방지를 위한 전역 Set
final Set<String> _blinkedSignals = {};

/// 🚀 SignalTile V4.1 - Clean UI (온라인 지표 연동)
class SignalTile extends ConsumerStatefulWidget {
  final Signal signal;
  final bool showOnlineMetrics; // 🆕 V4.1 온라인 지표 표시 옵션

  const SignalTile({
    super.key, 
    required this.signal,
    this.showOnlineMetrics = true, // 기본값: 표시
  });

  @override
  ConsumerState<SignalTile> createState() => _SignalTileState();
}

class _SignalTileState extends ConsumerState<SignalTile>
    with SingleTickerProviderStateMixin {
  
  // 🕒 시간 포맷터만 유지 (고유 기능)
  static final _timeFormat = DateFormat('HH:mm:ss');

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // ✨ 반짝임 애니메이션 초기화 (기존 방식)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 800), // Signal은 조금 더 길게
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.2).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );

    _checkNewSignal();
  }

  /// 🎯 새로운 시그널 감지 및 반짝임 처리 (헬퍼 클래스 사용)
  void _checkNewSignal() {
    final signalKey = '${widget.signal.market}_${widget.signal.detectedAt.millisecondsSinceEpoch}';
    
    if (BlinkAnimationHelper.checkNewSignal(
      blinkedSignalsSet: _blinkedSignals,
      detectedAt: widget.signal.detectedAt,
      signalKey: signalKey,
      maxAgeSeconds: 10,
    )) {
      _startBlink();
    }
  }

  /// 반짝임 시작 (설정 연동 추가)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // 🎯 설정 체크 추가!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// 🆕 V4.1 신뢰도 칩
  Widget? _buildConfidenceChip() {
    final confidence = widget.signal.confidence;
    if (confidence == null) return null;

    Color color;
    if (confidence >= 0.8) {
      color = Colors.green;
    } else if (confidence >= 0.6) {
      color = Colors.amber;
    } else {
      color = Colors.orange;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        '${(confidence * 100).toStringAsFixed(0)}%',
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// 🆕 V4.1 온라인 지표 칩들 생성
  List<Widget> _buildOnlineIndicatorChips() {
    if (!widget.showOnlineMetrics || !widget.signal.hasOnlineMetrics) {
      return [];
    }

    final indicators = widget.signal.onlineIndicators!;
    final chips = <Widget>[];

    // RSI 칩
    if (indicators.rsi != null) {
      Color rsiColor;
      String rsiText;
      
      if (indicators.rsi! >= 70) {
        rsiColor = Colors.red;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else if (indicators.rsi! <= 30) {
        rsiColor = Colors.blue;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else {
        rsiColor = Colors.grey[600]!;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      }

      chips.add(_buildIndicatorChip(rsiText, rsiColor));
    }

    // MACD 칩
    if (indicators.macd != null && indicators.macdSignal != null) {
      final isBullish = indicators.macd! > indicators.macdSignal!;
      final macdColor = isBullish ? Colors.green : Colors.red;
      final macdText = isBullish ? 'M+' : 'M-';

      chips.add(_buildIndicatorChip(macdText, macdColor));
    }

    return chips;
  }

  /// 🆕 V4.1 지표 칩 위젯
  Widget _buildIndicatorChip(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// 🆕 V4.1 다이버전스 인디케이터
  Widget? _buildDivergenceIndicator() {
    final divergence = widget.signal.divergence;
    if (divergence == null || (!divergence.isBullish && !divergence.isBearish)) {
      return null;
    }

    Color color;
    IconData icon;
    
    if (divergence.isBullish) {
      color = Colors.green;
      icon = Icons.trending_up;
    } else {
      color = Colors.red;
      icon = Icons.trending_down;
    }

    return Container(
      padding: const EdgeInsets.all(3),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Icon(
        icon,
        size: 10,
        color: color,
      ),
    );
  }

  /// 🆕 V4.1 모든 배지들을 오버플로우 방지하며 배치
  Widget _buildBadgeRow() {
    final badges = <Widget>[];
    
    // 신뢰도 칩 추가
    final confidenceChip = _buildConfidenceChip();
    if (confidenceChip != null) {
      badges.add(confidenceChip);
    }
    
    // 온라인 지표 칩들 추가
    badges.addAll(_buildOnlineIndicatorChips());
    
    // 다이버전스 인디케이터 추가
    final divergenceIndicator = _buildDivergenceIndicator();
    if (divergenceIndicator != null) {
      badges.add(divergenceIndicator);
    }

    if (badges.isEmpty) {
      return const SizedBox.shrink();
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: badges,
      ),
    );
  }

  /// 🆕 V4.1 패턴 색상 (온라인 지표 연동시 더 생동감있게)
  Color _getEnhancedPatternColor() {
    Color baseColor;
    
    switch (widget.signal.patternType) {
      case PatternType.surge:
        baseColor = Colors.red;
        break;
      case PatternType.flashFire:
        baseColor = Colors.orange;
        break;
      case PatternType.stackUp:
        baseColor = Colors.amber;
        break;
      case PatternType.stealthIn:
        baseColor = Colors.green;
        break;
      case PatternType.blackHole:
        baseColor = Colors.purple;
        break;
      case PatternType.reboundShot:
        baseColor = Colors.blue;
        break;
    }

    // 🆕 온라인 지표가 있으면 더 선명하게
    if (widget.signal.hasOnlineMetrics) {
      return baseColor;
    } else {
      return baseColor.withValues(alpha: 0.7);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;

    // 🎯 표준 카드 위젯 생성 (V4.1 Clean 버전)
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // 🕒 시간 부분: flex 13
          FlexChild.expanded(
            Text(
              _timeFormat.format(widget.signal.detectedAt),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 13,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // 🎨 코인 로고 부분: 고정 크기 (V4.1 패턴 색상 테두리 추가)
          FlexChild.fixed(
            Container(
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: _getEnhancedPatternColor(),
                  width: 1.5,
                ),
              ),
              child: CoinLogoProvider.buildCoinLogo(
                ticker: widget.signal.market.replaceFirst('KRW-', ''),
                radius: 14,
              ),
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // 🪙 코인명 + 배지들: flex 24 (🆕 Clean 버전)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // 첫 번째 줄: 코인명 + NEW 뱃지
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.signal.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // NEW 뱃지 (필요한 경우)
                    if (TileCommon.buildNewBadge(widget.signal.detectedAt) case final badge?) 
                      badge,
                  ],
                ),
                
                const SizedBox(height: 3),
                
                // 🆕 두 번째 줄: 모든 배지들 (오버플로우 방지)
                _buildBadgeRow(),
              ],
            ),
            flex: 24,
          ),

          // 💵 가격 + 변화율: flex 18 (신뢰도 칩 제거됨)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(widget.signal.currentPrice)}원',
                  style: TextStyle(color: onSurface, fontSize: 13),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  TileCommon.formatChangePercent(widget.signal.changePercent),
                  style: TextStyle(
                    color: TileCommon.getChangeColor(widget.signal.changePercent),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 18,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // 💰 거래대금: flex 18 (AmountDisplayWidget 사용)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: widget.signal.tradeAmount,
                isBuy: widget.signal.changePercent >= 0,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            flex: 18,
          ),
        ],
      ),
    );

    // 🎯 반짝임 애니메이션 적용 (V4.1 패턴 색상 연동)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    return blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: _getEnhancedPatternColor(), // 🆕 V4.1 동적 색상
          )
        : cardWidget;
  }
}

/// 🆕 V4.1 확장: AmountDisplayWidget에 highlightColor 파라미터 추가용 확장
/// (실제로는 AmountDisplayWidget 클래스에 추가해야 함)
extension AmountDisplayWidgetV41 on AmountDisplayWidget {
  /// V4.1 강조 색상이 적용된 위젯 생성
  static Widget withHighlight({
    required double totalAmount,
    required bool isBuy,
    double fontSize = 14,
    FontWeight fontWeight = FontWeight.w600,
    Color? highlightColor,
  }) {
    return Container(
      padding: highlightColor != null 
          ? const EdgeInsets.symmetric(horizontal: 4, vertical: 1)
          : null,
      decoration: highlightColor != null
          ? BoxDecoration(
              borderRadius: BorderRadius.circular(3),
              color: highlightColor.withValues(alpha: 0.1),
              border: Border.all(color: highlightColor.withValues(alpha: 0.3), width: 0.5),
            )
          : null,
      child: AmountDisplayWidget(
        totalAmount: totalAmount,
        isBuy: isBuy,
        fontSize: fontSize,
        fontWeight: fontWeight,
      ),
    );
  }
}