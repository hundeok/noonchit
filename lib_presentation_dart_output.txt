\n\n// ====== lib/presentation/controllers/surge_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/surge_provider.dart';
import '../../domain/entities/surge.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ê¹”ë”í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ SurgeController
class SurgeController extends StateNotifier<SurgeControllerState> with RankHotMixin {
  final Ref _ref;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ ì €ì¥
  final Map<String, bool> _blinkStates = {};
  final Map<String, bool> _hotStates = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  SurgeController(this._ref) : super(const SurgeControllerState()) {
    // âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStates.clear();
    _hotStates.clear();
  }

  /// âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      surgeDataProvider,
      (previous, next) {
        next.when(
          data: (surges) => _processSurgeData(surges),
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ì²˜ë¦¬ - ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
  void _processSurgeData(List<Surge> surges) {
    // 1. ë°ì´í„° ì •ë ¬/í•„í„°ë§
    final processedSurges = _applyProcessing(surges);
    
    // 2. ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° (build ë°–ì—ì„œ!)
    _calculateAllStates(processedSurges);
    
    // 3. ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      surges: processedSurges,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - ì‹œê°„ëŒ€ë³„ ë…ë¦½
  void _calculateAllStates(List<Surge> processedSurges) {
    final currentTimeFrame = this.currentTimeFrame;
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™”
    initializeTimeFrame(currentTimeFrame);
    _rankTracker.initializeTimeFrame(currentTimeFrame);
    
    // ê¸°ì¡´ ìƒíƒœ ì´ˆê¸°í™”
    _blinkStates.clear();
    _hotStates.clear();
    
    for (int i = 0; i < processedSurges.length; i++) {
      final surge = processedSurges[i];
      final market = surge.market;
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœ ê³„ì‚° (RankHotMixin ì‚¬ìš©)
      _hotStates[market] = checkIfHot(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (RankTracker ì‚¬ìš©)
      _blinkStates[market] = _rankTracker.checkRankChange(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
    }
  }

  /// âœ… ë°ì´í„° ì²˜ë¦¬ (ì •ë ¬/í•„í„°ë§)
  List<Surge> _applyProcessing(List<Surge> surgeData) {
    // 1) í•„í„° íƒ€ì…ì— ë”°ë¥¸ í•„í„°ë§
    List<Surge> filteredData = _applyFilter(surgeData, state.filterType);
    
    // 2) í•„í„° íƒ€ì…ì— ë”°ë¥¸ ì •ë ¬
    if (state.filterType == SurgeFilterType.fallingOnly) {
      // í•˜ë½ë§Œ: í•˜ë½ í° ìˆœì„œ (ì˜¤ë¦„ì°¨ìˆœ)
      filteredData.sort((a, b) => a.changePercent.compareTo(b.changePercent));
    } else {
      // ì „ì²´/ìƒìŠ¹: ë³€ë™ë¥  ë‚´ë¦¼ì°¨ìˆœ (í° í”ŒëŸ¬ìŠ¤ë¶€í„°)
      filteredData.sort((a, b) => b.changePercent.compareTo(a.changePercent));
    }
    
    // 3) í˜„ì¬ ì„¤ì •ì— ë”°ë¼ 50ê°œ ë˜ëŠ” 100ê°œë¡œ ì œí•œ
    final int limit = state.isTop100 ? 100 : 50;
    return filteredData.take(limit).toList();
  }

  /// âœ… í•„í„° íƒ€ì… ì ìš©
  List<Surge> _applyFilter(List<Surge> surgeData, SurgeFilterType filterType) {
    switch (filterType) {
      case SurgeFilterType.all:
        return surgeData.where((s) => s.hasChange).toList();
      case SurgeFilterType.risingOnly:
        return surgeData.where((s) => s.isRising).toList();
      case SurgeFilterType.fallingOnly:
        return surgeData.where((s) => s.isFalling).toList();
    }
  }

  /// âœ… Top 50/100 í† ê¸€
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
    _reprocessData();
  }

  /// âœ… í•„í„° íƒ€ì… ë³€ê²½
  void setFilterType(SurgeFilterType filterType) {
    state = state.copyWith(filterType: filterType);
    _reprocessData();
  }

  /// âœ… ê¸°ì¡´ ë°ì´í„° ì¬ì²˜ë¦¬
  void _reprocessData() {
    if (state.surges.isNotEmpty) {
      final surgesAsync = _ref.read(surgeDataProvider);
      surgesAsync.whenData((surges) => _processSurgeData(surges));
    }
  }

  /// âœ… ì‹œê°„ëŒ€ ë³€ê²½ - ìƒíƒœ ì´ˆê¸°í™”ë¡œ ë…ë¦½ì„± ë³´ì¥
  void setTimeFrame(String timeFrame, int index) {
    final oldTimeFrame = currentTimeFrame;
    
    // âœ… ì´ì „ ì‹œê°„ëŒ€ ìƒíƒœ ì´ˆê¸°í™” (ë…ë¦½ì„± ë³´ì¥)
    if (oldTimeFrame != timeFrame) {
      clearTimeFrameHot(oldTimeFrame);
      _rankTracker.clearTimeFrame(oldTimeFrame);
    }
    
    final controller = _ref.read(surgeTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
  }

  /// âœ… í˜„ì¬ í‘œì‹œ ê°œìˆ˜
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// âœ… í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// âœ… í˜„ì¬ í•„í„° íƒ€ì… ì´ë¦„
  String get currentFilterName {
    switch (state.filterType) {
      case SurgeFilterType.all:
        return 'ì „ì²´';
      case SurgeFilterType.risingOnly:
        return 'ìƒìŠ¹';
      case SurgeFilterType.fallingOnly:
        return 'í•˜ë½';
    }
  }

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool isHot(String market) {
    return _hotStates[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool shouldBlink(String market) {
    return _blinkStates[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í˜¸ì¶œ)
  void clearBlinkState(String market) {
    _blinkStates[market] = false;
    state = state.copyWith();
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´íŠ¸ ê³„ì‚°
  Map<String, int> getSurgeCount() {
    final risingCount = state.surges.where((s) => s.isRising).length;
    final fallingCount = state.surges.where((s) => s.isFalling).length;
    
    return {
      'rising': risingCount,
      'falling': fallingCount,
    };
  }

  /// âœ… TimeFrame ê´€ë ¨ ë©”ì„œë“œë“¤
  String get currentTimeFrame => _ref.read(surgeTimeFrameController).currentTimeFrame;
  int get currentIndex => _ref.read(surgeTimeFrameController).currentIndex;
  List<String> get availableTimeFrames => _ref.read(surgeTimeFrameController).availableTimeFrames;

  String getTimeFrameName(String timeFrame) {
    return _ref.read(surgeTimeFrameController).getTimeFrameName(timeFrame);
  }

  void resetCurrentTimeFrame() {
    _ref.read(surgeTimeFrameController).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    _ref.read(surgeTimeFrameController).resetAllTimeFrames();
  }

  DateTime? getNextResetTime() {
    return _ref.read(surgeTimeFrameController).getNextResetTime();
  }

  /// âœ… ë””ë²„ê¹…ìš© ë©”ì„œë“œë“¤
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬ (ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œ ê¶Œì¥)
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStates.clear();
    _hotStates.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class SurgeControllerState {
  final List<Surge> surges;           // ì •ë ¬/í•„í„°ë§ëœ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°
  final bool isTop100;               // Top 50/100 ëª¨ë“œ
  final SurgeFilterType filterType;  // í•„í„° íƒ€ì…
  final bool isLoading;              // ë¡œë”© ìƒíƒœ
  final String? errorMessage;        // ì—ëŸ¬ ë©”ì‹œì§€

  const SurgeControllerState({
    this.surges = const [],
    this.isTop100 = false,
    this.filterType = SurgeFilterType.all,
    this.isLoading = false,
    this.errorMessage,
  });

  SurgeControllerState copyWith({
    List<Surge>? surges,
    bool? isTop100,
    SurgeFilterType? filterType,
    bool? isLoading,
    String? errorMessage,
  }) {
    return SurgeControllerState(
      surges: surges ?? this.surges,
      isTop100: isTop100 ?? this.isTop100,
      filterType: filterType ?? this.filterType,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// Surge í•„í„° íƒ€ì… enum
enum SurgeFilterType {
  all,        // ì „ì²´
  risingOnly, // ìƒìŠ¹ë§Œ
  fallingOnly // í•˜ë½ë§Œ
}

/// Provider ì„ ì–¸
final surgeControllerProvider = StateNotifierProvider<SurgeController, SurgeControllerState>(
  (ref) => SurgeController(ref),
);\n\n// ====== lib/presentation/controllers/main_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/settings_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/sector_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/sector_provider.dart';
import '../../domain/entities/volume.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ê¹”ë”í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ SectorController
class SectorController extends StateNotifier<SectorControllerState> with RankHotMixin {
  final Ref _ref;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ ì €ì¥
  final Map<String, bool> _blinkStates = {};
  final Map<String, bool> _hotStates = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  SectorController(this._ref) : super(const SectorControllerState()) {
    // âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStates.clear();
    _hotStates.clear();
  }

  /// âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
  void _initializeDataSubscription() {
    // ê¸°ì¡´ êµ¬ë… ì •ë¦¬
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // ë¶„ë¥˜ ìƒíƒœ ë™ê¸°í™”
    final controller = _ref.read(sectorTimeFrameController);
    state = state.copyWith(
      isDetailedClassification: controller.isDetailedClassification,
      timeFrame: controller.currentTimeFrame,
      selectedTimeFrameIndex: controller.currentIndex,
    );

    final subscription = _ref.listen(
      sectorVolumeDataProvider,
      (previous, next) {
        next.when(
          data: (volumes) => _processSectorData(volumes),
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ì„¹í„° ë°ì´í„° ì²˜ë¦¬ - ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
  void _processSectorData(List<Volume> volumes) {
    // 1. ë°ì´í„° ì •ë ¬
    final sortedVolumes = _applySorting(volumes);
    
    // 2. ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° (build ë°–ì—ì„œ!)
    _calculateAllStates(sortedVolumes);
    
    // 3. ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      sectorVolumes: sortedVolumes,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - ì‹œê°„ëŒ€ë³„ ë…ë¦½
  void _calculateAllStates(List<Volume> sortedVolumes) {
    final currentTimeFrame = state.timeFrame;
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™”
    initializeTimeFrame(currentTimeFrame);
    _rankTracker.initializeTimeFrame(currentTimeFrame);
    
    // ê¸°ì¡´ ìƒíƒœ ì´ˆê¸°í™”
    _blinkStates.clear();
    _hotStates.clear();
    
    for (int i = 0; i < sortedVolumes.length; i++) {
      final volume = sortedVolumes[i];
      final sectorName = volume.market.replaceFirst('SECTOR-', '');
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœ ê³„ì‚° (RankHotMixin ì‚¬ìš©)
      _hotStates[sectorName] = checkIfHot(
        key: sectorName,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (RankTracker ì‚¬ìš©)
      _blinkStates[sectorName] = _rankTracker.checkRankChange(
        key: sectorName,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
    }
  }

  /// âœ… ë°ì´í„° ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> _applySorting(List<Volume> volumes) {
    final sorted = [...volumes];
    sorted.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    return sorted;
  }

  /// âœ… ì‹œê°„ëŒ€ ë³€ê²½ - ìƒíƒœ ì´ˆê¸°í™”ë¡œ ë…ë¦½ì„± ë³´ì¥
  void setTimeFrame(String timeFrame, int index) {
    final oldTimeFrame = state.timeFrame;
    
    // âœ… ì´ì „ ì‹œê°„ëŒ€ ìƒíƒœ ì´ˆê¸°í™” (ë…ë¦½ì„± ë³´ì¥)
    if (oldTimeFrame != timeFrame) {
      clearTimeFrameHot(oldTimeFrame);
      _rankTracker.clearTimeFrame(oldTimeFrame);
    }
    
    final controller = _ref.read(sectorTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
    
    state = state.copyWith(
      timeFrame: timeFrame,
      selectedTimeFrameIndex: index,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _initializeDataSubscription();
  }

  /// âœ… ì„¹í„° ë¶„ë¥˜ í† ê¸€ (ìƒì„¸ â†” ê¸°ë³¸) - ìƒíƒœ ì´ˆê¸°í™” ì¶”ê°€!
  void toggleSectorClassification() {
    final currentTimeFrame = state.timeFrame;
    
    // âœ… ë¶„ë¥˜ ë³€ê²½ì‹œì—ë„ ìƒíƒœ ì´ˆê¸°í™” (ì™„ì „íˆ ë‹¤ë¥¸ ë°ì´í„°ì…‹)
    clearTimeFrameHot(currentTimeFrame);
    _rankTracker.clearTimeFrame(currentTimeFrame);
    
    final controller = _ref.read(sectorTimeFrameController);
    controller.toggleSectorClassification();
    
    final newClassification = !state.isDetailedClassification;
    state = state.copyWith(
      isDetailedClassification: newClassification,
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _initializeDataSubscription();
  }

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool isHot(String sectorName) {
    return _hotStates[sectorName] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool shouldBlink(String sectorName) {
    return _blinkStates[sectorName] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í˜¸ì¶œ)
  void clearBlinkState(String sectorName) {
    _blinkStates[sectorName] = false;
    state = state.copyWith();
  }

  /// âœ… ìƒˆë¡œê³ ì¹¨
  void refresh() {
    _initializeDataSubscription();
  }

  /// âœ… ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetCurrentTimeFrame();
    refresh();
  }

  void resetAllTimeFrames() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetAllTimeFrames();
    refresh();
  }

  /// âœ… ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getNextResetTime();
  }

  /// âœ… Sector ê³ ìœ  ê¸°ëŠ¥ë“¤
  List<String> get availableTimeFrames {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.availableTimeFrames;
  }

  String getTimeFrameName(String timeFrame) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getTimeFrameName(timeFrame);
  }

  String get currentSectorClassificationName {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.currentSectorClassificationName;
  }

  int get totalSectors {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.totalSectors;
  }

  /// âœ… íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ì¡°íšŒ
  List<String> getCoinsInSector(String sectorName) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getCoinsInSector(sectorName);
  }

  /// âœ… íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì¡°íšŒ
  List<String> getSectorsForCoin(String ticker) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getSectorsForCoin(ticker);
  }

  /// âœ… ë””ë²„ê¹…ìš© ë©”ì„œë“œë“¤
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  Map<String, Map<String, dynamic>> getHotDebugInfo() {
    return getHotDebugInfo();
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬ (ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œ ê¶Œì¥)
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStates.clear();
    _hotStates.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class SectorControllerState {
  final List<Volume> sectorVolumes;        // ì •ë ¬ëœ ì„¹í„° ë³¼ë¥¨ ë°ì´í„°
  final bool isLoading;                   // ë¡œë”© ìƒíƒœ
  final bool isDetailedClassification;    // ë¶„ë¥˜ ë°©ì‹
  final String timeFrame;                 // ì‹œê°„ëŒ€
  final int selectedTimeFrameIndex;       // ì‹œê°„ëŒ€ ì¸ë±ìŠ¤
  final String? errorMessage;             // ì—ëŸ¬ ë©”ì‹œì§€

  const SectorControllerState({
    this.sectorVolumes = const [],
    this.isLoading = false,
    this.isDetailedClassification = true,
    this.timeFrame = '1m',
    this.selectedTimeFrameIndex = 0,
    this.errorMessage,
  });

  SectorControllerState copyWith({
    List<Volume>? sectorVolumes,
    bool? isLoading,
    bool? isDetailedClassification,
    String? timeFrame,
    int? selectedTimeFrameIndex,
    String? errorMessage,
  }) {
    return SectorControllerState(
      sectorVolumes: sectorVolumes ?? this.sectorVolumes,
      isLoading: isLoading ?? this.isLoading,
      isDetailedClassification: isDetailedClassification ?? this.isDetailedClassification,
      timeFrame: timeFrame ?? this.timeFrame,
      selectedTimeFrameIndex: selectedTimeFrameIndex ?? this.selectedTimeFrameIndex,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// Provider ì„ ì–¸
final sectorControllerProvider = StateNotifierProvider<SectorController, SectorControllerState>(
  (ref) => SectorController(ref),
);\n\n// ====== lib/presentation/controllers/signal_controller.dart ======\n
// lib/presentation/controllers/signal_controller.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/signal_provider.dart';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/usecases/signal_usecase.dart';

/// ğŸš€ Signal í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸ V4.1
class SignalState {
  final List<Signal> signals;
  final bool isLoading;
  final bool isConnected;
  final PatternType currentPattern;
  final int selectedIndex;
  final double threshold;
  final bool isPatternEnabled;
  final String? errorMessage;
  final Map<String, dynamic>? systemHealth; // ğŸ†• V4.1
  final Map<String, dynamic>? onlineMetricsHealth; // ğŸ†• V4.1
  final String sortField; // ğŸ†• V4.1
  final bool sortAscending; // ğŸ†• V4.1

  const SignalState({
    this.signals = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.currentPattern = PatternType.surge,
    this.selectedIndex = 0,
    this.threshold = 0.4,
    this.isPatternEnabled = true,
    this.errorMessage,
    this.systemHealth,
    this.onlineMetricsHealth,
    this.sortField = 'time',
    this.sortAscending = false,
  });

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ê²° ìƒíƒœ
  bool get hasOnlineMetrics => onlineMetricsHealth != null;
  
  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„±
  bool get isSystemHealthy => 
      systemHealth?['status'] == 'healthy' && 
      (onlineMetricsHealth?['staleMarkets'] ?? 0) == 0;

  /// ğŸ†• V4.1 ì‹ í˜¸ í†µê³„
  Map<String, dynamic> get signalStats {
    final total = signals.length;
    final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
    final avgConfidence = signals.isNotEmpty 
        ? signals.map((s) => s.confidence ?? 0.0).reduce((a, b) => a + b) / total
        : 0.0;
    
    return {
      'total': total,
      'withOnlineMetrics': withOnlineMetrics,
      'onlineMetricsRatio': total > 0 ? withOnlineMetrics / total : 0.0,
      'avgConfidence': avgConfidence,
      'pattern': currentPattern.displayName,
    };
  }

  SignalState copyWith({
    List<Signal>? signals,
    bool? isLoading,
    bool? isConnected,
    PatternType? currentPattern,
    int? selectedIndex,
    double? threshold,
    bool? isPatternEnabled,
    String? errorMessage,
    Map<String, dynamic>? systemHealth,
    Map<String, dynamic>? onlineMetricsHealth,
    String? sortField,
    bool? sortAscending,
  }) {
    return SignalState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      currentPattern: currentPattern ?? this.currentPattern,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      threshold: threshold ?? this.threshold,
      isPatternEnabled: isPatternEnabled ?? this.isPatternEnabled,
      errorMessage: errorMessage,
      systemHealth: systemHealth ?? this.systemHealth,
      onlineMetricsHealth: onlineMetricsHealth ?? this.onlineMetricsHealth,
      sortField: sortField ?? this.sortField,
      sortAscending: sortAscending ?? this.sortAscending,
    );
  }
}

/// ğŸš€ Signal í™”ë©´ ì „ìš© ViewModel V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
class SignalController extends StateNotifier<SignalState> {
  final SignalUseCase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Signal>, AppException>>? _subscription;
  StreamSubscription<Map<String, dynamic>>? _healthSubscription; // ğŸ†• V4.1
  Timer? _healthUpdateTimer; // ğŸ†• V4.1

  SignalController(this._usecase, this._ref) : super(const SignalState()) {
    _startSystemHealthMonitoring(); // ğŸ†• V4.1
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§
  // ==========================================================================

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
  void _startSystemHealthMonitoring() {
    _healthUpdateTimer = Timer.periodic(const Duration(seconds: 10), (_) {
      _updateSystemHealth();
      _updateOnlineMetricsHealth();
    });
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸
  void _updateSystemHealth() async {
    try {
      final controller = _ref.read(signalPatternController);
      final health = await controller.getSystemHealth();
      
      state = state.copyWith(systemHealth: health);
      
      if (AppConfig.enableTradeLog) {
        final staleMarkets = health['onlineMetricsSystem']?['staleMarkets'] ?? 0;
        if (staleMarkets > 0) {
          log.w('âš ï¸ Signal Controller: $staleMarketsê°œ ë§ˆì¼“ ì˜¨ë¼ì¸ ì§€í‘œ ë§Œë£Œ');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: System health update failed - $e');
      }
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸
  void _updateOnlineMetricsHealth() {
    try {
      final controller = _ref.read(signalPatternController);
      final health = controller.getOnlineMetricsHealth();
      
      state = state.copyWith(onlineMetricsHealth: health);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: Online metrics health update failed - $e');
      }
    }
  }

  // ==========================================================================
  // ê¸°ë³¸ íŒ¨í„´ ê´€ë¦¬ (ê¸°ì¡´ + V4.1 ê°œì„ )
  // ==========================================================================

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™) - V4.1 ê°œì„ 
  void setPatternIndex(int index, List<String> markets) {
    if (index < 0 || index >= PatternType.values.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index');
      }
      return;
    }

    final patternType = PatternType.values[index];
    final defaultThreshold = patternType.defaultThreshold; // V4.1 ê¸°ë³¸ê°’

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    final controller = _ref.read(signalPatternController);
    controller.updatePatternIndex(index);

    state = state.copyWith(
      currentPattern: patternType,
      selectedIndex: index,
      threshold: defaultThreshold,
      isLoading: true,
      errorMessage: null,
    );

    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _subscribeToPattern(patternType, markets);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ¯ Pattern changed to: ${patternType.displayName} (V4.1)');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½ - V4.1 ê°œì„ 
  void updateThreshold(double threshold) {
    try {
      // UseCaseë¥¼ í†µí•œ ê²€ì¦ëœ ì—…ë°ì´íŠ¸
      _usecase.updatePatternThreshold(state.currentPattern, threshold);
      
      final controller = _ref.read(signalPatternController);
      controller.updateThreshold(threshold);

      state = state.copyWith(threshold: threshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“Š Threshold updated: ${state.currentPattern.displayName} â†’ $threshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Threshold update failed: $e');
      }
      
      // ì—ëŸ¬ë¥¼ ì‚¬ìš©ìì—ê²Œ í‘œì‹œ
      state = state.copyWith(
        errorMessage: 'Invalid threshold value: ${e.toString()}'
      );
    }
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€ - V4.1 ê°œì„ 
  void togglePatternEnabled() {
    final newEnabled = !state.isPatternEnabled;
    
    _usecase.setPatternEnabled(state.currentPattern, newEnabled);
    
    final controller = _ref.read(signalPatternController);
    controller.setPatternEnabled(state.currentPattern, newEnabled);

    state = state.copyWith(isPatternEnabled: newEnabled);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Pattern ${newEnabled ? "enabled" : "disabled"}: ${state.currentPattern.displayName}');
    }
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™” - V4.1 ê°œì„ 
  void clearSignals([PatternType? pattern]) {
    final controller = _ref.read(signalPatternController);
    controller.clearSignals(pattern);

    if (pattern == null || pattern == state.currentPattern) {
      state = state.copyWith(signals: []);
    }
    
    if (AppConfig.enableTradeLog) {
      final patternName = pattern?.displayName ?? 'All patterns';
      log.i('ğŸ§¹ Signals cleared: $patternName');
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì •
  // ==========================================================================

  /// ğŸ†• ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸
  void updateAdvancedPatternConfig(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Advanced config updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Advanced config update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration update failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    try {
      _usecase.applyPatternPreset(presetName);
      
      // í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ë„ ì—…ë°ì´íŠ¸
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      state = state.copyWith(threshold: newThreshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Preset applied: $presetName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Preset application failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Preset application failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
  void resetOnlineMetrics([String? market]) {
    final controller = _ref.read(signalPatternController);
    controller.resetOnlineMetrics(market);
    
    // í—¬ìŠ¤ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    _updateOnlineMetricsHealth();
    
    if (AppConfig.enableTradeLog) {
      final target = market ?? 'all markets';
      log.i('ğŸ”„ Online metrics reset: $target');
    }
  }

  // ==========================================================================
  // ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ (V4.1 ê°œì„ )
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ êµ¬ë… - V4.1 ê°œì„ 
  void _subscribeToPattern(PatternType patternType, List<String> markets) {
    _subscription?.cancel();
    
    _subscription = _usecase
        .watchSignalsByPattern(patternType, markets)
        .map((signals) => Ok<List<Signal>, AppException>(signals))
        .handleError((error) => Err<List<Signal>, AppException>(
            AppException(
              'Signal pattern detection failed: ${error.toString()}',
              code: 'SIGNAL_PATTERN_ERROR',
              originalException: error is Exception ? error : null,
            )))
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Signal>, AppException> result) {
    result.when(
      ok: (signals) {
        // V4.1 ì •ë ¬ ì ìš©
        final sortedSignals = _applySorting(signals);
        
        state = state.copyWith(
          signals: sortedSignals,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
        
        // ì˜¨ë¼ì¸ ì§€í‘œ í†µê³„ ë¡œê¹…
        if (AppConfig.enableTradeLog && signals.isNotEmpty) {
          final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
          final ratio = (withOnlineMetrics / signals.length * 100).toStringAsFixed(1);
          log.i('ğŸ“Š Signals received: ${signals.length}, Online metrics: $withOnlineMetrics ($ratio%)');
        }
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
        
        if (AppConfig.enableTradeLog) {
          log.e('âŒ Signal stream error: ${e.message}');
        }
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨ - V4.1 ê°œì„ 
  void refresh(List<String> markets) {
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Signal refresh requested for ${markets.length} markets');
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœë„ ë¦¬ì…‹
    resetOnlineMetrics();
    
    // íŒ¨í„´ ì¬êµ¬ë…
    setPatternIndex(state.selectedIndex, markets);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì •ë ¬ ë° í•„í„°ë§
  // ==========================================================================

  /// ğŸ†• ì •ë ¬ í•„ë“œ ë³€ê²½
  void setSortField(String field, {bool? ascending}) {
    final newAscending = ascending ?? (state.sortField == field ? !state.sortAscending : false);
    
    state = state.copyWith(
      sortField: field,
      sortAscending: newAscending,
      signals: _applySorting(state.signals),
    );
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ“Š Sort changed: $field (${newAscending ? "ASC" : "DESC"})');
    }
  }

  /// ğŸ†• ì •ë ¬ ì ìš©
  List<Signal> _applySorting(List<Signal> signals) {
    final list = List<Signal>.from(signals);
    
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      
      switch (state.sortField) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.currentPrice;
          bValue = b.currentPrice;
          break;
        case 'change':
          aValue = a.changePercent.abs();
          bValue = b.changePercent.abs();
          break;
        case 'amount':
          aValue = a.tradeAmount;
          bValue = b.tradeAmount;
          break;
        case 'confidence':
          aValue = a.confidence ?? 0.0;
          bValue = b.confidence ?? 0.0;
          break;
        case 'time':
        default:
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
      }
      
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      
      return state.sortAscending ? cmp : -cmp;
    });
    
    return list;
  }

  /// ğŸ†• ê³ ê¸‰ í•„í„°ë§ (V4.1)
  List<Signal> filterSignals({
    String? marketFilter,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
  }) {
    return _usecase.filterSignals(
      state.signals,
      markets: marketFilter != null ? {marketFilter.toUpperCase()} : null,
      minConfidence: minConfidence,
      requireOnlineMetrics: requireOnlineMetrics,
      patternTypes: patternTypes,
      timeWindow: timeWindow,
    );
  }

  // ==========================================================================
  // í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± (V4.1 ê°œì„ )
  // ==========================================================================

  /// í˜„ì¬ íŒ¨í„´ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± - V4.1 ê°œì„ 
  String getPatternDisplayText() {
    final pattern = state.currentPattern;
    return '${pattern.displayName}: ${pattern.description}';
  }

  /// í˜„ì¬ íŒ¨í„´ ì•„ì´ì½˜/ì´ëª¨ì§€
  String getPatternIcon() {
    return state.currentPattern.displayName;
  }

  /// ì„ê³„ê°’ í‘œì‹œ í…ìŠ¤íŠ¸ - V4.1 ê°œì„ 
  String getThresholdDisplayText() {
    final threshold = state.threshold;
    final pattern = state.currentPattern;

    switch (pattern) {
      case PatternType.surge:
        return '${threshold.toStringAsFixed(1)}% ìƒìŠ¹';
      case PatternType.flashFire:
        return '${threshold.toStringAsFixed(1)}ë°° ê¸‰ì¦';
      case PatternType.stackUp:
        return '${threshold.toInt()}ì—°ì† ì¦ê°€';
      case PatternType.stealthIn:
        final amountText = threshold >= 1000000 
            ? '${(threshold / 1000000).toStringAsFixed(0)}ë°±ë§Œì›'
            : '${threshold.toStringAsFixed(0)}ì›';
        return '$amountText ì´ìƒ';
      case PatternType.blackHole:
        return '${threshold.toStringAsFixed(1)}% ì´í•˜ ë³€ë™';
      case PatternType.reboundShot:
        return '${threshold.toStringAsFixed(1)}% ê¸‰ë½ í›„ ë°˜ë“±';
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ í…ìŠ¤íŠ¸
  String getSystemStatusText() {
    if (!state.hasOnlineMetrics) return 'Online metrics: Connecting...';
    
    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    if (staleMarkets > 0) {
      return 'Online metrics: $healthyMarkets/$totalMarkets healthy ($staleMarkets stale)';
    }
    
    return 'Online metrics: $healthyMarkets/$totalMarkets healthy âœ…';
  }

  /// ğŸ†• ì‹ ë¢°ë„ ìƒíƒœ í‘œì‹œ
  String getConfidenceStatusText() {
    final stats = state.signalStats;
    final avgConf = stats['avgConfidence'] as double;
    final onlineRatio = stats['onlineMetricsRatio'] as double;
    
    return 'Avg confidence: ${(avgConf * 100).toStringAsFixed(1)}%, '
           'Online: ${(onlineRatio * 100).toStringAsFixed(1)}%';
  }

  // ==========================================================================
  // ğŸ†• V4.1 í†µê³„ ë° ë¶„ì„
  // ==========================================================================

  /// ğŸ†• íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<Map<String, dynamic>> getPatternPerformance() async {
    try {
      final performance = await _usecase.getPatternPerformance(state.currentPattern);
      return {
        'pattern': performance.patternType.displayName,
        'totalSignals': performance.totalSignals,
        'recentSignals': performance.recentSignals,
        'lastSignalTime': performance.lastSignalTime?.toIso8601String(),
        'isEnabled': performance.isEnabled,
        'onlineMetricsHealth': performance.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Pattern performance query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
  Future<Map<String, dynamic>> getSystemHealthReport() async {
    try {
      final report = await _usecase.getSystemHealthReport();
      return {
        'version': report.version,
        'status': report.status,
        'uptime': report.uptime,
        'totalProcessedTrades': report.totalProcessedTrades,
        'activePatterns': report.activePatterns,
        'trackedMarkets': report.trackedMarkets,
        'isHealthy': report.isHealthy,
        'onlineMetricsHealth': report.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ System health report query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹ í˜¸ í†µê³„ ê³„ì‚°
  Map<String, dynamic> calculateSignalStats() {
    return _usecase.calculateSignalStats(state.signals).toJson();
  }

  // ==========================================================================
  // ê¸°ì¡´ í˜¸í™˜ì„± ë©”ì„œë“œë“¤ (V4.1 ê°œì„ )
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ (ê¸°ì¡´ í˜¸í™˜ì„±)
  Map<String, dynamic> getSignalStats() {
    return state.signalStats;
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì ìš© (ì •ë ¬ ë“±) - V4.1 ê°œì„ 
  List<Signal> apply(List<Signal> signals) {
    return _applySorting(signals);
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ëª©ë¡ - V4.1 ê°œì„ 
  List<String> get availablePatterns => 
      PatternType.values.map((p) => p.name).toList();

  /// íŒ¨í„´ í‘œì‹œëª… ëª©ë¡ - V4.1 ê°œì„ 
  List<String> get patternDisplayNames => 
      PatternType.values.map((p) => p.displayName).toList();

  /// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê°„ ìœˆë„ìš° - V4.1 ê°œì„ 
  int get currentTimeWindow => state.currentPattern.timeWindowMinutes;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ê¸°ë³¸ ì‹ ë¢°ë„
  double get currentPatternDefaultConfidence => state.currentPattern.defaultConfidence;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ì¿¨ë‹¤ìš´ ì‹œê°„
  int get currentPatternCooldownSeconds => state.currentPattern.defaultCooldownSeconds;

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸°
  Map<String, dynamic> exportConfiguration() {
    final controller = _ref.read(signalPatternController);
    return controller.exportConfiguration();
  }

  /// ğŸ†• ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  void importConfiguration(Map<String, dynamic> config) {
    try {
      final controller = _ref.read(signalPatternController);
      controller.importConfiguration(config);
      
      // í˜„ì¬ ìƒíƒœ ìƒˆë¡œê³ ì¹¨
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“¥ Configuration imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Configuration import failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration import failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì—ëŸ¬ ë©”ì‹œì§€ í´ë¦¬ì–´
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (V4.1 í™•ì¥)
  // ==========================================================================

  @override
  void dispose() {
    _subscription?.cancel();
    _healthSubscription?.cancel();
    _healthUpdateTimer?.cancel();
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal Controller V4.1 disposed');
    }
    
    super.dispose();
  }
}

/// Provider ì„ ì–¸ - V4.1
final signalControllerProvider =
    StateNotifierProvider<SignalController, SignalState>((ref) {
  final usecase = ref.read(signalUsecaseProvider);
  return SignalController(usecase, ref);
});

/// ğŸ†• V4.1 í™•ì¥ - ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ Provider
final signalSystemMonitorProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final controller = ref.watch(signalControllerProvider.notifier);
  
  yield* Stream.periodic(const Duration(seconds: 15), (_) async {
    final performance = await controller.getPatternPerformance();
    final systemHealth = await controller.getSystemHealthReport();
    final signalStats = controller.calculateSignalStats();
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'performance': performance,
      'systemHealth': systemHealth,
      'signalStats': signalStats,
      'version': 'V4.1-Online',
    };
  }).asyncMap((event) => event);
});\n\n// ====== lib/presentation/controllers/market_mood_controller.dart ======\n
// lib/presentation/controllers/market_mood_controller.dart
// ğŸ® Presentation Layer: Market Mood ì»¨íŠ¸ë¡¤ëŸ¬ (ë¦¬íŒ©í† ë§ëœ Providerì— ë§ì¶° ìˆ˜ì •)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/utils/date_time.dart';
import '../pages/market_mood_page.dart';

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬
class MarketMoodPageController extends StateNotifier<MarketMoodPageState> {
  final Ref _ref;

  MarketMoodPageController(this._ref) : super(MarketMoodPageState.initial()) {
    // [ìˆ˜ì •] ì´ˆê¸°í™” ë¡œì§ì„ ìƒì„±ìì—ì„œ ë¶„ë¦¬í•˜ì—¬ ëª…í™•í•˜ê²Œ ê´€ë¦¬
    _initialize();
  }

  /// [ìˆ˜ì •] ì´ˆê¸°í™” ë° ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë‹ ì‹œì‘
  void _initialize() {
    // 1. ì´ˆê¸° ìƒíƒœ ì„¤ì •
    final initialState = _ref.read(marketMoodSystemProvider);
    state = state.copyWith(
      isLoading: initialState.isLoading,
      error: initialState.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
      systemState: initialState,
    );

    // 2. ì‹¤ì‹œê°„ ìƒíƒœ ë³€í™” ê°ì§€ ë° ë™ê¸°í™”
    //    ì´ì œ ìµœì¢… ìƒíƒœì¸ marketMoodSystemProviderë§Œ listení•˜ë©´ ë©ë‹ˆë‹¤.
    _ref.listen<MarketMoodSystemState>(
      marketMoodSystemProvider,
      (previous, next) {
        state = state.copyWith(
          isLoading: next.isLoading,
          error: next.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
          systemState: next,
        );
      },
    );
  }

  /// [ìˆ˜ì •] ë°ì´í„° ë¡œë“œ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // Future<void> loadData() async { ... }

  /// ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  void refresh() {
    // [ìˆ˜ì •] controllerë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë‘ì§€ ì•Šê³  í•„ìš” ì‹œ read
    final controller = _ref.read(marketMoodControllerProvider);
    controller.refresh();
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  MarketMood getCurrentMood() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(currentMarketMoodProvider);
  }

  /// í™˜ìœ¨ ì¡°íšŒ (Future ëŒ€ì‘ - ì´ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ)
  Future<double> getExchangeRate() async {
    final exchangeAsync = _ref.read(exchangeRateProvider);
    return exchangeAsync.when(
      data: (rate) => rate,
      loading: () => 1400.0,
      error: (_, __) => 1400.0,
    );
  }

  /// [ìˆ˜ì •] ë³¼ë¥¨ ë¹„êµ ë°ì´í„° ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  ComparisonData getVolumeComparisons() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(volumeComparisonProvider);
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<void> checkSystemHealth() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      final health = await controller.getSystemHealth();

      state = state.copyWith(
        systemHealth: health,
        lastHealthCheck: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.refreshExchangeRate();
      // loadData() ëŒ€ì‹  systemProviderê°€ ìë™ìœ¼ë¡œ ê°±ì‹ í•˜ë¯€ë¡œ ë³„ë„ í˜¸ì¶œ ë¶ˆí•„ìš”
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ë¡œê¹…
  Future<void> logSystemStatus() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.logSystemStatus();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ë¶„ìœ„ê¸° ì´ëª¨ì§€ ì¡°íšŒ
  String getMoodEmoji(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ğŸš€',
      MarketMood.weakBull => 'ğŸ”¥',
      MarketMood.sideways => 'âš–ï¸',
      MarketMood.bear => 'ğŸ’§',
      MarketMood.deepBear => 'ğŸ§Š',
    };
  }

  /// ë¶„ìœ„ê¸° ì´ë¦„ ì¡°íšŒ
  String getMoodName(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ë¶ˆì¥',
      MarketMood.weakBull => 'ì•½ë¶ˆì¥',
      MarketMood.sideways => 'ì¤‘ê°„ì¥',
      MarketMood.bear => 'ë¬¼ì¥',
      MarketMood.deepBear => 'ì–¼ìŒì¥',
    };
  }

  /// [ìˆ˜ì •] ë¶„ìœ„ê¸° ìš”ì•½ í…ìŠ¤íŠ¸ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  String getMoodSummary() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(marketMoodSummaryProvider);
  }

  /// ë³¼ë¥¨ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatVolume(double volumeUsd) async {
    final rate = await getExchangeRate();
    final volumeKrw = volumeUsd * rate;

    if (volumeKrw >= 1e12) {
      final trillions = (volumeKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    if (volumeKrw >= 1e8) {
      final hundreds = (volumeKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    return '${(volumeKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì‹œê°€ì´ì•¡ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatMarketCap(double marketCapUsd) async {
    final rate = await getExchangeRate();
    // [ìˆ˜ì •] marketCapKrw ë³€ìˆ˜ ì„ ì–¸
    final marketCapKrw = marketCapUsd * rate; 

    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e12) { 
      final trillions = (marketCapKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e8) {
      final hundreds = (marketCapKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    return '${(marketCapKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì—…ë°ì´íŠ¸ ì‹œê°„ í¬ë§·íŒ…
  String formatUpdateTime(DateTime updatedAt) {
    return updatedAt.hhmmss(); // DateTime extension ì‚¬ìš©
  }

  /// ë¹„êµ ê²°ê³¼ ê°’ í¬ë§·íŒ…
  String formatComparisonValue(ComparisonResult result) {
    if (result.isReady && result.changePercent != null) {
      final value = result.changePercent!;
      final arrow = value > 5 ? 'â†—ï¸' : value < -5 ? 'â†˜ï¸' : 'â¡ï¸';
      return '${value >= 0 ? '+' : ''}${value.toStringAsFixed(1)}% $arrow';
    }
    return '${(result.progressPercent * 100).round()}% (${result.status})';
  }

  /// ì§„í–‰ë¥  ê³„ì‚°
  int getProgressPercent(ComparisonResult result) {
    return (result.progressPercent * 100).round();
  }

  /// í•˜ì´ë¼ì´íŠ¸ ìƒ‰ìƒ íŒë‹¨
  bool isHighlight(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) > 5;
  }

  /// ê²½ê³  ìƒ‰ìƒ íŒë‹¨
  bool isWarning(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) < -5;
  }

  /// [ìˆ˜ì •] ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë‹ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // void startListening() { ... }

  /// ìˆ«ìì— ì½¤ë§ˆ ì¶”ê°€
  String _addCommas(String numberStr) {
    final parts = numberStr.split('.');
    final integerPart = parts[0];
    final reversedInteger = integerPart.split('').reversed.join('');
    final withCommas = reversedInteger
        .replaceAllMapped(RegExp(r'.{3}'), (match) => '${match.group(0)},')
        .split('')
        .reversed
        .join('');
    final result =
        withCommas.startsWith(',') ? withCommas.substring(1) : withCommas;
    return parts.length > 1 ? '$result.${parts[1]}' : result;
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ìƒíƒœ
class MarketMoodPageState {
  final bool isLoading;
  final String? error;
  final MarketMoodSystemState? systemState;
  final Map<String, dynamic>? systemHealth;
  final DateTime? lastHealthCheck;

  const MarketMoodPageState({
    required this.isLoading,
    this.error,
    this.systemState,
    this.systemHealth,
    this.lastHealthCheck,
  });

  factory MarketMoodPageState.initial() {
    return const MarketMoodPageState(isLoading: true); // [ìˆ˜ì •] ì´ˆê¸° ìƒíƒœëŠ” ë¡œë”©ì¤‘
  }

  MarketMoodPageState copyWith({
    bool? isLoading,
    String? error,
    MarketMoodSystemState? systemState,
    Map<String, dynamic>? systemHealth,
    DateTime? lastHealthCheck,
  }) {
    return MarketMoodPageState(
      isLoading: isLoading ?? this.isLoading,
      error: error, // [ìˆ˜ì •] nullë¡œ ë®ì–´ì“°ê¸° ê°€ëŠ¥í•˜ë„ë¡ ?? this.error ì œê±°
      systemState: systemState ?? this.systemState,
      systemHealth: systemHealth ?? this.systemHealth,
      lastHealthCheck: lastHealthCheck ?? this.lastHealthCheck,
    );
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬ Provider
final marketMoodPageControllerProvider = StateNotifierProvider.autoDispose<
    MarketMoodPageController, MarketMoodPageState>((ref) {
  // [ìˆ˜ì •] ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± ì‹œ ë°”ë¡œ _initialize()ê°€ í˜¸ì¶œë˜ë¯€ë¡œ ë³„ë„ ë¡œì§ ë¶ˆí•„ìš”
  return MarketMoodPageController(ref);
});

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ ê´€ë¦¬ì (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalManager {
  static OverlayEntry? _overlayEntry;

  /// ëª¨ë‹¬ í‘œì‹œ
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
    required MarketMoodData data,
  }) {
    hide(); // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°

    _overlayEntry = OverlayEntry(
      builder: (context) => MarketMoodModalOverlay(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
        data: data,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalOverlay extends StatelessWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;
  final MarketMoodData data;

  const MarketMoodModalOverlay({
    super.key,
    required this.position,
    required this.statusIconSize,
    required this.ref,
    required this.data,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => MarketMoodModalManager.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ MarketMoodPage ìœ„ì ¯
            Positioned(
              left: position.dx,
              top: position.dy,
              child: Consumer(
                builder: (context, ref, child) {
                  return MarketMoodPage(
                    statusIconSize: statusIconSize,
                    data: data,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ê¹”ë”í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ VolumeController
class VolumeController extends StateNotifier<VolumeControllerState> with RankHotMixin {
  final Ref _ref;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ ì €ì¥
  final Map<String, bool> _blinkStates = {};
  final Map<String, bool> _hotStates = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  VolumeController(this._ref) : super(const VolumeControllerState()) {
    // âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStates.clear();
    _hotStates.clear();
  }

  /// âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      volumeDataProvider,
      (previous, next) {
        next.when(
          data: (volumes) => _processVolumeData(volumes),
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ë³¼ë¥¨ ë°ì´í„° ì²˜ë¦¬ - ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
  void _processVolumeData(List<Volume> volumes) {
    // 1. ë°ì´í„° ì •ë ¬
    final sortedVolumes = _applySorting(volumes);
    
    // 2. ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° (build ë°–ì—ì„œ!)
    _calculateAllStates(sortedVolumes);
    
    // 3. ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      volumes: sortedVolumes,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - ì‹œê°„ëŒ€ë³„ ë…ë¦½
  void _calculateAllStates(List<Volume> sortedVolumes) {
    final currentTimeFrame = this.currentTimeFrame;
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™”
    initializeTimeFrame(currentTimeFrame);
    _rankTracker.initializeTimeFrame(currentTimeFrame);
    
    // ê¸°ì¡´ ìƒíƒœ ì´ˆê¸°í™”
    _blinkStates.clear();
    _hotStates.clear();
    
    for (int i = 0; i < sortedVolumes.length; i++) {
      final volume = sortedVolumes[i];
      final market = volume.market;
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœ ê³„ì‚° (RankHotMixin ì‚¬ìš©)
      _hotStates[market] = checkIfHot(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (RankTracker ì‚¬ìš©)
      _blinkStates[market] = _rankTracker.checkRankChange(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
    }
  }

  /// âœ… ë°ì´í„° ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> _applySorting(List<Volume> volumeData) {
    final filteredData = volumeData.where((v) => v.totalVolume > 0).toList();
    filteredData.sort((a, b) => b.totalVolume.compareTo(a.totalVolume)); // ë‚´ë¦¼ì°¨ìˆœ
    
    // í˜„ì¬ ì„¤ì •ì— ë”°ë¼ 50ê°œ ë˜ëŠ” 100ê°œë¡œ ì œí•œ
    final int limit = state.isTop100 ? 100 : 50;
    return filteredData.take(limit).toList();
  }

  /// âœ… Top 50/100 í† ê¸€
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
    
    // ê¸°ì¡´ ë°ì´í„°ë¡œ ì¬ì²˜ë¦¬
    if (state.volumes.isNotEmpty) {
      final volumesAsync = _ref.read(volumeDataProvider);
      volumesAsync.whenData((volumes) => _processVolumeData(volumes));
    }
  }

  /// âœ… ì‹œê°„ëŒ€ ë³€ê²½ - ìƒíƒœ ì´ˆê¸°í™”ë¡œ ë…ë¦½ì„± ë³´ì¥
  void setTimeFrame(String timeFrame, int index) {
    final oldTimeFrame = currentTimeFrame;
    
    // âœ… ì´ì „ ì‹œê°„ëŒ€ ìƒíƒœ ì´ˆê¸°í™” (ë…ë¦½ì„± ë³´ì¥)
    if (oldTimeFrame != timeFrame) {
      clearTimeFrameHot(oldTimeFrame);
      _rankTracker.clearTimeFrame(oldTimeFrame);
    }
    
    final controller = _ref.read(volumeTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
  }

  /// âœ… í˜„ì¬ í‘œì‹œ ê°œìˆ˜
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// âœ… í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool isHot(String market) {
    return _hotStates[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool shouldBlink(String market) {
    return _blinkStates[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í˜¸ì¶œ)
  void clearBlinkState(String market) {
    _blinkStates[market] = false;
    // ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ notify
    state = state.copyWith();
  }

  /// âœ… TimeFrame ê´€ë ¨ ë©”ì„œë“œë“¤
  String get currentTimeFrame => _ref.read(volumeTimeFrameController).currentTimeFrame;
  int get currentIndex => _ref.read(volumeTimeFrameController).currentIndex;
  List<String> get availableTimeFrames => _ref.read(volumeTimeFrameController).availableTimeFrames;

  String getTimeFrameName(String timeFrame) {
    return _ref.read(volumeTimeFrameController).getTimeFrameName(timeFrame);
  }

  void resetCurrentTimeFrame() {
    _ref.read(volumeTimeFrameController).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    _ref.read(volumeTimeFrameController).resetAllTimeFrames();
  }

  DateTime? getNextResetTime() {
    return _ref.read(volumeTimeFrameController).getNextResetTime();
  }

  /// âœ… ë””ë²„ê¹…ìš© ë©”ì„œë“œë“¤
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬ (ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œ ê¶Œì¥)
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStates.clear();
    _hotStates.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class VolumeControllerState {
  final List<Volume> volumes;      // ì •ë ¬ëœ ë³¼ë¥¨ ë°ì´í„°
  final bool isTop100;            // Top 50/100 ëª¨ë“œ
  final bool isLoading;           // ë¡œë”© ìƒíƒœ
  final String? errorMessage;     // ì—ëŸ¬ ë©”ì‹œì§€

  const VolumeControllerState({
    this.volumes = const [],
    this.isTop100 = false,
    this.isLoading = false,
    this.errorMessage,
  });

  VolumeControllerState copyWith({
    List<Volume>? volumes,
    bool? isTop100,
    bool? isLoading,
    String? errorMessage,
  }) {
    return VolumeControllerState(
      volumes: volumes ?? this.volumes,
      isTop100: isTop100 ?? this.isTop100,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// Provider ì„ ì–¸
final volumeControllerProvider = StateNotifierProvider<VolumeController, VolumeControllerState>(
  (ref) => VolumeController(ref),
);\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// lib/presentation/controllers/trade_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// ğŸ¯ ê¹”ë”í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ TradeController (Volume/Surge íŒ¨í„´ + ê¸°ì¡´ Provider í˜¸í™˜)
class TradeController extends StateNotifier<TradeControllerState> {
  final Ref _ref;
  final TradeUsecase _usecase;
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  TradeController(this._usecase, this._ref) : super(const TradeControllerState()) {
    // âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
    _initializeDataSubscription();
  }

  /// âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™” (ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©)
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      tradeListProvider,  // âœ… ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©
      (previous, next) {
        next?.when(  // âœ… null safety ì²˜ë¦¬
          data: (trades) => _processTradeData(trades),
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
  void _processTradeData(List<Trade> trades) {
    // 1. ë°ì´í„° ì •ë ¬
    final sortedTrades = _applySorting(trades);
    
    // 2. ìƒíƒœ ì—…ë°ì´íŠ¸ (TradeëŠ” HOT/Blink ì—†ìœ¼ë¯€ë¡œ ë‹¨ìˆœ)
    state = state.copyWith(
      trades: sortedTrades,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ë°ì´í„° ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Trade> _applySorting(List<Trade> tradeData) {
    final sorted = [...tradeData];
    // ìµœì‹  ìˆœìœ¼ë¡œ ì •ë ¬
    sorted.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return sorted;
  }

  /// âœ… ì„ê³„ê°’ ì„¤ì • - Usecaseë¡œ ìœ„ì„ (Volume/Surge íŒ¨í„´)
  void setThreshold(double threshold, int index) {
    // âœ… Usecaseë¡œ ìœ„ì„ (Repository ì§ì ‘ ì ‘ê·¼ ì œê±°)
    _usecase.updateThreshold(threshold);
    
    // âœ… UI ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      threshold: threshold,
      selectedIndex: index,
    );
  }

  /// âœ… êµ¬ê°„/ëˆ„ì  ëª¨ë“œ í† ê¸€ - Usecaseë¡œ ìœ„ì„ (Volume/Surge íŒ¨í„´)
  void toggleRangeMode() {
    final newMode = !state.isRangeMode;
    
    // âœ… Usecaseë¡œ ìœ„ì„ (Repository ì§ì ‘ ì ‘ê·¼ ì œê±°)
    _usecase.updateRangeMode(newMode);
    
    // âœ… UI ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(isRangeMode: newMode);
  }

  /// âœ… í˜„ì¬ ì„¤ì •ì— ë”°ë¥¸ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„±
  String getThresholdDisplayText() {
    final threshold = state.threshold;
    final thresholds = availableThresholds;
    final currentIndex = thresholds.indexOf(threshold);
    
    if (state.isRangeMode) {
      // êµ¬ê°„ ëª¨ë“œ
      if (currentIndex >= 0 && currentIndex < thresholds.length - 1) {
        final nextThreshold = thresholds[currentIndex + 1];
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        final nextLabel = AppConfig.filterNames[nextThreshold] ?? nextThreshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabel ~ $nextLabelì›';
      } else {
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabelì› ì´ìƒ';
      }
    } else {
      // ëˆ„ì  ëª¨ë“œ
      final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
      return 'ìµœì†Œ ê±°ë˜ê¸ˆì•¡: $currentLabelì›';
    }
  }

  /// âœ… í† ê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸
  String get toggleButtonText => state.isRangeMode ? 'êµ¬ê°„' : 'ëˆ„ì ';

  /// âœ… ì‚¬ìš© ê°€ëŠ¥í•œ ì„ê³„ê°’ ì˜µì…˜ë“¤
  List<double> get availableThresholds =>
    AppConfig.tradeFilters.where((f) => f >= 20000000).toList();

  /// âœ… ê±°ë˜ ëª©ë¡ ì¶”ê°€ í•„í„° (ì‹œì¥ëª…)
  List<Trade> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.trades;
    }
    final upper = marketFilter.toUpperCase();
    return state.trades.where((t) => t.market.contains(upper)).toList();
  }

  /// âœ… ê±°ë˜ ëª©ë¡ ì •ë ¬
  void sortTrades(String field, bool ascending) {
    final list = [...state.trades];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'volume':
          aValue = a.volume;
          bValue = b.volume;
          break;
        case 'total':
          aValue = a.total;
          bValue = b.total;
          break;
        case 'timestamp':
          aValue = a.timestampMs;
          bValue = b.timestampMs;
          break;
        default:
          aValue = a.timestampMs;
          bValue = b.timestampMs;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(trades: list);
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (Volume/Surge ìŠ¤íƒ€ì¼ë¡œ ë‹¨ìˆœí™”)
class TradeControllerState {
  final List<Trade> trades;           // í‘œì‹œìš© ê±°ë˜ ë°ì´í„°
  final bool isLoading;              // ë¡œë”© ìƒíƒœ
  final double threshold;            // í˜„ì¬ ì„ê³„ê°’
  final int selectedIndex;           // ìŠ¬ë¼ì´ë” ì¸ë±ìŠ¤
  final bool isRangeMode;           // êµ¬ê°„/ëˆ„ì  ëª¨ë“œ
  final String? errorMessage;        // ì—ëŸ¬ ë©”ì‹œì§€

  const TradeControllerState({
    this.trades = const [],
    this.isLoading = false,
    this.threshold = 20000000.0,
    this.selectedIndex = 0,
    this.isRangeMode = false,          // ê¸°ë³¸ê°’: ëˆ„ì  ëª¨ë“œ
    this.errorMessage,
  });

  TradeControllerState copyWith({
    List<Trade>? trades,
    bool? isLoading,
    double? threshold,
    int? selectedIndex,
    bool? isRangeMode,
    String? errorMessage,
  }) {
    return TradeControllerState(
      trades: trades ?? this.trades,
      isLoading: isLoading ?? this.isLoading,
      threshold: threshold ?? this.threshold,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      isRangeMode: isRangeMode ?? this.isRangeMode,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// âœ… Provider ì„ ì–¸ (UIì—ì„œ TradeController ì‚¬ìš©í•˜ê¸° ìœ„í•´ í•„ìˆ˜)
final tradeControllerProvider = StateNotifierProvider<TradeController, TradeControllerState>(
  (ref) {
    final usecase = ref.read(usecaseProvider);  // âœ… ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©
    return TradeController(usecase, ref);
  },
);\n\n// ====== lib/presentation/pages/main_page.dart ======\n
// lib/presentation/pages/main_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/common_app_bar.dart';
import 'trade_page.dart';
import 'volume_page.dart';
import 'sector_page.dart';
import 'surge_page.dart';
// ğŸ”¥ Controller Providerë“¤ import ì¶”ê°€
import '../controllers/volume_controller.dart';
import '../controllers/surge_controller.dart';
import '../controllers/trade_controller.dart';
import '../controllers/sector_controller.dart';

/// ğŸ¯ ë©”ì¸ í˜ì´ì§€ - PageViewë¡œ 4ê°œ í™”ë©´ ê´€ë¦¬
class MainPage extends ConsumerStatefulWidget {
  const MainPage({Key? key}) : super(key: key);

  @override
  ConsumerState<MainPage> createState() => _MainPageState();
}

class _MainPageState extends ConsumerState<MainPage> with TickerProviderStateMixin {
  late PageController _pageController;
  late AnimationController _animationController;
  
  // âœ… TradePageì˜ ScrollControllerë¥¼ ìœ„í•œ ê° í˜ì´ì§€ë³„ ê´€ë¦¬
  final Map<int, ScrollController> _pageScrollControllers = {};
  
  // 4ê°œ í˜ì´ì§€ ì •ë³´
  final List<PageInfo> _pages = [
    PageInfo(
      index: 0,
      title: 'ê¸‰ë“±ë½',
      icon: Icons.trending_up,
      builder: (scrollController) => SurgePage(scrollController: scrollController),
    ),
    PageInfo(
      index: 1,
      title: 'ì²´ê²°',
      icon: Icons.monetization_on,
      builder: (scrollController) => TradePage(scrollController: scrollController),
    ),
    PageInfo(
      index: 2,
      title: 'ë³¼ë¥¨',
      icon: Icons.bar_chart,
      builder: (scrollController) => VolumePage(scrollController: scrollController),
    ),
    PageInfo(
      index: 3,
      title: 'ì„¹í„°',
      icon: Icons.pie_chart,
      builder: (scrollController) => SectorPage(scrollController: scrollController),
    ),
  ];

  @override
  void initState() {
    super.initState();
    
    // PageController ì´ˆê¸°í™” (ì²´ê²° í˜ì´ì§€ë¥¼ ê¸°ë³¸ìœ¼ë¡œ)
    _pageController = PageController(initialPage: 1);
    
    // ì• ë‹ˆë©”ì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™” 
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    // âœ… ê° í˜ì´ì§€ë³„ ScrollController ì´ˆê¸°í™”
    for (int i = 0; i < _pages.length; i++) {
      _pageScrollControllers[i] = ScrollController();
    }
    
    // ì´ˆê¸° í˜ì´ì§€ ì¸ë±ìŠ¤ ì„¤ì •
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(selectedTabProvider.notifier).state = 1; // ì²´ê²° í˜ì´ì§€
      
      // ğŸ”¥ ëª¨ë“  Controllerë¥¼ ë¯¸ë¦¬ ì´ˆê¸°í™”í•´ì„œ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì‹œì‘
      _initializeAllControllers();
    });
  }

  /// ğŸ”¥ ëª¨ë“  Controller ë¯¸ë¦¬ ì´ˆê¸°í™” - ì•± ì‹œì‘ê³¼ ë™ì‹œì— ëª¨ë“  ë©”ë‰´ ì‹¤í–‰
  void _initializeAllControllers() {
    try {
      // 1. VolumeController ì´ˆê¸°í™” (ë³¼ë¥¨ ë©”ë‰´)
      ref.read(volumeControllerProvider);
      debugPrint('ğŸ”¥ VolumeController ì´ˆê¸°í™” ì™„ë£Œ');
      
      // 2. SurgeController ì´ˆê¸°í™” (ê¸‰ë“±ë½ ë©”ë‰´)  
      ref.read(surgeControllerProvider);
      debugPrint('ğŸ”¥ SurgeController ì´ˆê¸°í™” ì™„ë£Œ');
      
      // 3. TradeController ì´ˆê¸°í™” (ì²´ê²° ë©”ë‰´ - ì´ë¯¸ ì‹¤í–‰ì¤‘ì´ì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ)
      ref.read(tradeControllerProvider);
      debugPrint('ğŸ”¥ TradeController ì´ˆê¸°í™” ì™„ë£Œ');
      
      // 4. SectorController ì´ˆê¸°í™” (ì„¹í„° ë©”ë‰´)
      ref.read(sectorControllerProvider);
      debugPrint('ğŸ”¥ SectorController ì´ˆê¸°í™” ì™„ë£Œ');
      
      debugPrint('âœ… ëª¨ë“  Controller ì´ˆê¸°í™” ì™„ë£Œ - 4ê°œ ë©”ë‰´ ëª¨ë‘ ì‹¤í–‰ ì‹œì‘!');
      
    } catch (e) {
      debugPrint('âŒ Controller ì´ˆê¸°í™” ì˜¤ë¥˜: $e');
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    _animationController.dispose();
    // âœ… ëª¨ë“  ScrollController í•´ì œ
    for (final controller in _pageScrollControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: CommonAppBar(
        title: '', // ë¹ˆ ì œëª© (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°ê°€ ë“¤ì–´ê°ˆ ìë¦¬)
        pages: _pages,
        pageController: _pageController,
        animationController: _animationController,
      ),
      body: SafeArea(
        child: PageView.builder(
          controller: _pageController,
          onPageChanged: _onPageChanged,
          itemCount: _pages.length,
          // âœ… iOS ìŠ¤íƒ€ì¼ physics + ìŠ¤í¬ë¡¤ ì¶©ëŒ ë°©ì§€
          physics: const BouncingScrollPhysics(
            parent: AlwaysScrollableScrollPhysics(),
          ),
          // âœ… ìŠ¤í¬ë¡¤ ë°©í–¥ ëª…ì‹œ (ìˆ˜í‰ ìŠ¤ì™€ì´í”„)
          scrollDirection: Axis.horizontal,
          itemBuilder: (context, index) {
            // âœ… ê° í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ScrollController ì „ë‹¬
            final scrollController = _pageScrollControllers[index]!;
            return _pages[index].builder(scrollController);
          },
        ),
      ),
    );
  }

  /// ğŸ”¥ í˜ì´ì§€ ë³€ê²½ ì²˜ë¦¬ - í–…í‹± ì„¤ì • ì²´í¬ ì¶”ê°€
  void _onPageChanged(int index) {
    // ğŸ”¥ ì„¤ì • ì²´í¬ í›„ í–…í‹± (ë‹¤ë¥¸ ìœ„ì ¯ë“¤ê³¼ ë™ì¼í•œ íŒ¨í„´)
    if (ref.read(appSettingsProvider).isHapticEnabled) {
      HapticFeedback.lightImpact();
    }

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(selectedTabProvider.notifier).state = index;
    
    // ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±°
    _animationController.forward().then((_) {
      _animationController.reset();
    });
    
    debugPrint('ğŸ“± í˜ì´ì§€ ë³€ê²½: ${_pages[index].title} (index: $index)');
  }

  /// ğŸ¯ ì™¸ë¶€ì—ì„œ í˜ì´ì§€ ì´ë™ (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° í´ë¦­ ì‹œ)
  void goToPage(int index) {
    if (index >= 0 && index < _pages.length) {
      _pageController.animateToPage(
        index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }
}

/// ğŸ“„ í˜ì´ì§€ ì •ë³´ í´ë˜ìŠ¤
class PageInfo {
  final int index;
  final String title;
  final IconData icon;
  final Widget Function(ScrollController scrollController) builder;

  const PageInfo({
    required this.index,
    required this.title,
    required this.icon,
    required this.builder,
  });
}\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
// lib/presentation/pages/trade_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  final ScrollController scrollController;

  const TradePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ) - Volume/Surge íŒ¨í„´
    final state = ref.watch(tradeControllerProvider);
    final controller = ref.read(tradeControllerProvider.notifier);
    
    // âœ… ì„ê³„ê°’ ê´€ë ¨
    final thresholds = controller.availableThresholds;
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
    final sliderWidget = CommonSliderWidget(
      leftText: controller.getThresholdDisplayText(),
      sliderValue: state.selectedIndex.toDouble(),
      sliderMin: 0.0,
      sliderMax: (thresholds.length - 1).toDouble(),
      sliderDivisions: thresholds.length - 1,
      sliderLabel: AppConfig.filterNames[thresholds[state.selectedIndex]] ?? 
                   thresholds[state.selectedIndex].toStringAsFixed(0),
      onSliderChanged: (value) {
        final index = value.round();
        final threshold = thresholds[index];
        controller.setThreshold(threshold, index);  // âœ… Controller ë©”ì„œë“œ í˜¸ì¶œ (Volume/Surge íŒ¨í„´)
      },
      rightWidget: CommonToggleButton(  // âœ… rightWidgetìœ¼ë¡œ ë³µêµ¬ (ìš°ì¸¡ ìœ„ì¹˜)
        text: controller.toggleButtonText,
        isActive: !state.isRangeMode, // ëˆ„ì ì¼ ë•Œ active
        onTap: () => controller.toggleRangeMode(),  // âœ… Controller ë©”ì„œë“œ í˜¸ì¶œ
        // âœ… Sectorì™€ ë™ì¼í•œ ê¸°ë³¸ í¬ê¸° (fontSize, padding ì œê±°)
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildTradeList(state, controller, thresholds, context, displayMode)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜) - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
  Widget _buildTradeList(
    TradeControllerState state,
    TradeController controller,
    List<double> thresholds,
    BuildContext context,
    DisplayMode displayMode,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ì²´ê²° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.trades.isEmpty) {
      return Center(
        child: Text(
          'í¬ì°©ëœ ì²´ê²°ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì„ê³„ê°’: ${AppConfig.filterNames[thresholds[state.selectedIndex]] ?? thresholds[state.selectedIndex].toStringAsFixed(0)})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì‚¬ìš©) - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.trades.length,
      addAutomaticKeepAlives: true,   // ğŸ”¥ ë©”ëª¨ë¦¬ ìµœì í™”
      addRepaintBoundaries: true,     // ğŸ”¥ ë¦¬í˜ì¸íŠ¸ ìµœì í™”
      itemBuilder: (_, i) {
        final trade = state.trades[i];
        
        return TradeTile(
          trade: trade,
          displayMode: displayMode,
        );
      },
    );
  }
}\n\n// ====== lib/presentation/pages/splash_page.dart ======\n
// lib/presentation/pages/splash_page.dart

import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';
import 'main_page.dart';

class SplashPage extends StatefulWidget {
  const SplashPage({Key? key}) : super(key: key);

  @override
  State<SplashPage> createState() => _SplashPageState();
}

class _SplashPageState extends State<SplashPage> {
  VideoPlayerController? _controller;
  bool _isVideoInitialized = false;
  bool _hasNavigated = false;

  @override
  void initState() {
    super.initState();
    _initializeVideo();
    
    // ì•ˆì „ë§: 5ì´ˆ í›„ ê°•ì œ ì´ë™ (ë¹„ë””ì˜¤ ë¬¸ì œ ì‹œ)
    Future.delayed(const Duration(seconds: 5), () {
      if (!_hasNavigated && mounted) {
        _navigateToMain();
      }
    });
  }

  Future<void> _initializeVideo() async {
    try {
      _controller = VideoPlayerController.asset('assets/noonchit_intro_84frames.mp4');
      
      await _controller!.initialize();
      
      if (mounted) {
        setState(() {
          _isVideoInitialized = true;
        });
        
        // ë¹„ë””ì˜¤ ì„¤ì •
        _controller!.setVolume(0.0); // ìŒì†Œê±°
        _controller!.setLooping(false);
        
        // ì¬ìƒ ì™„ë£Œ ë¦¬ìŠ¤ë„ˆ
        _controller!.addListener(_videoListener);
        
        // ì¬ìƒ ì‹œì‘
        _controller!.play();
      }
    } catch (e) {
      // ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ë©”ì¸ìœ¼ë¡œ ì´ë™
      debugPrint('Video initialization failed: $e');
      if (mounted) {
        _navigateToMain();
      }
    }
  }

  void _videoListener() {
    if (_controller != null && _controller!.value.position >= _controller!.value.duration) {
      // ë¹„ë””ì˜¤ ì¬ìƒ ì™„ë£Œ
      _navigateToMain();
    }
  }

  void _navigateToMain() {
    if (_hasNavigated) return;
    _hasNavigated = true;
    
    if (mounted) {
      Navigator.of(context).pushReplacement(
        PageRouteBuilder(
          pageBuilder: (context, animation, secondaryAnimation) => const MainPage(),
          transitionDuration: const Duration(milliseconds: 300),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(
              opacity: animation,
              child: child,
            );
          },
        ),
      );
    }
  }

  @override
  void dispose() {
    _controller?.removeListener(_videoListener);
    _controller?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF121212), // ì–´ë‘ìš´ ë°°ê²½
      body: Center(
        child: _isVideoInitialized && _controller != null
            ? AspectRatio(
                aspectRatio: _controller!.value.aspectRatio,
                child: VideoPlayer(_controller!),
              )
            : _buildLoadingFallback(),
      ),
    );
  }

  Widget _buildLoadingFallback() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // ë¡œë”© ì¤‘ì´ê±°ë‚˜ ë¹„ë””ì˜¤ ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ UI
        Icon(
          Icons.currency_bitcoin,
          size: 64,
          color: Colors.orange.withValues(alpha: 0.8),
        ),
        const SizedBox(height: 16),
        Text(
          'NOONCHIT',
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: Colors.white.withValues(alpha: 0.9),
            letterSpacing: 2.0,
          ),
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: 32,
          height: 32,
          child: CircularProgressIndicator(
            strokeWidth: 3,
            valueColor: AlwaysStoppedAnimation<Color>(
              Colors.orange.withValues(alpha: 0.8),
            ),
          ),
        ),
      ],
    );
  }
}\n\n// ====== lib/presentation/pages/market_mood_page.dart ======\n
// lib/presentation/pages/market_mood_page.dart
// ğŸ“± Presentation Layer: Market Mood í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ, í´ë¦° ì•„í‚¤í…ì²˜)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../controllers/market_mood_controller.dart';

/// ğŸ“± ë§ˆì¼“ë¬´ë“œ ìƒì„¸ í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ)
class MarketMoodPage extends ConsumerStatefulWidget {
  final double statusIconSize;
  final MarketMoodData data;

  const MarketMoodPage({
    super.key,
    required this.statusIconSize,
    required this.data,
  });

  @override
  ConsumerState<MarketMoodPage> createState() => _MarketMoodPageState();
}

class _MarketMoodPageState extends ConsumerState<MarketMoodPage>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _animationController.forward();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.5),
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          alignment: Alignment.center,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildPageContent(),
          ),
        );
      },
    );
  }

  Widget _buildPageContent() {
    // í™”ë©´ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final maxWidth = screenSize.width * 0.9;

    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: widget.statusIconSize * 4.2,
          maxWidth: maxWidth,
        ),
        decoration: _buildContainerDecoration(),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              const SizedBox(height: 8),
              _buildCoreMetrics(),
              const SizedBox(height: 8),
              _buildIntradayAnalysis(),
              const SizedBox(height: 8),
              _buildLongTermAnalysis(),
            ],
          ),
        ),
      ),
    );
  }

  BoxDecoration _buildContainerDecoration() {
    return BoxDecoration(
      color: Theme.of(context).colorScheme.surface,
      borderRadius: BorderRadius.circular(16),
      boxShadow: [
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.08),
          blurRadius: 16,
          offset: const Offset(0, 6),
          spreadRadius: 2,
        ),
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.04),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        // [ìˆ˜ì •] withOpacity -> withValues
        color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
        width: 0.8,
      ),
    );
  }

  Widget _buildHeader() {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final updateTime = controller.formatUpdateTime(widget.data.updatedAt);

    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final currentMood = ref.watch(currentMarketMoodProvider);
            final moodEmoji = controller.getMoodEmoji(currentMood);
            final moodName = controller.getMoodName(currentMood);

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      moodEmoji,
                      style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '$moodName - á–¾ á–½',
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w700,
                          color: Theme.of(context).colorScheme.onSurface,
                          letterSpacing: 0.3,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      'ì‹¤ì‹œê°„ ê¸°ì¤€ â€¢ ',
                      style: TextStyle(
                        fontSize: 8,
                        fontWeight: FontWeight.w500,
                        // [ìˆ˜ì •] withOpacity -> withValues
                        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                      ),
                    ),
                    Icon(
                      Icons.access_time,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                    const SizedBox(width: 3),
                    Flexible(
                      child: Text(
                        '$updateTime ì—…ë°ì´íŠ¸',
                        style: TextStyle(
                          fontSize: 8,
                          // [ìˆ˜ì •] withOpacity -> withValues
                          color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
          loading: () => _buildLoadingHeader(),
          error: (_, __) => _buildErrorHeader(),
        );
      },
    );
  }

  Widget _buildLoadingHeader() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 16, height: 16,
              child: CircularProgressIndicator(strokeWidth: 2)
            ),
            SizedBox(width: 8),
            Text(
              'ë¡œë”©ì¤‘...',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildErrorHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 12,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 4),
            Text(
              'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCoreMetrics() {
    return Consumer(
      builder: (context, ref, child) {
        final exchangeAsync = ref.watch(exchangeRateProvider);

        return exchangeAsync.when(
          data: (exchangeRate) => _buildCoreMetricsContent(exchangeRate),
          loading: () => _buildLoadingMetrics(),
          error: (_, __) => _buildCoreMetricsContent(1400.0),
        );
      },
    );
  }

  Widget _buildCoreMetricsContent(double exchangeRate) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    return FutureBuilder<List<String>>(
      future: Future.wait([
        controller.formatVolume(widget.data.totalVolumeUsd),
        controller.formatMarketCap(widget.data.totalMarketCapUsd),
      ]),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingMetrics();
        }
        if (snapshot.hasData) {
          final values = snapshot.data!;
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
              const SizedBox(height: 4),
              _buildStatRow(
                icon: Icons.monetization_on,
                label: '24ì‹œê°„ ê±°ë˜ëŒ€ê¸ˆ',
                value: values[0],
                isHighlight: true,
              ),
              _buildStatRow(
                icon: Icons.pie_chart,
                label: 'ì´ ì‹œê°€ì´ì•¡',
                value: values[1],
              ),
              _buildStatRow(
                icon: Icons.trending_up,
                label: 'ì‹œì´ 24ì‹œê°„ ë³€í™”',
                value: '${widget.data.marketCapChange24h >= 0 ? '+' : ''}${widget.data.marketCapChange24h.toStringAsFixed(2)}%',
                isHighlight: widget.data.marketCapChange24h > 0,
                isWarning: widget.data.marketCapChange24h < -2,
              ),
              _buildStatRow(
                icon: Icons.flash_on,
                label: 'BTC ë„ë¯¸ë„ŒìŠ¤',
                value: '${widget.data.btcDominance.toStringAsFixed(1)}%',
              ),
            ],
          );
        }
        return _buildLoadingMetrics();
      },
    );
  }

  Widget _buildLoadingMetrics() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildIntradayAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
                const SizedBox(height: 4),
                _buildComparisonRow('30ë¶„ ëŒ€ë¹„', comparisonData.thirtyMin, Icons.hourglass_empty),
                _buildComparisonRow('1ì‹œê°„ ëŒ€ë¹„', comparisonData.oneHour, Icons.hourglass_full),
                _buildComparisonRow('2ì‹œê°„ ëŒ€ë¹„', comparisonData.twoHour, Icons.access_time),
                _buildComparisonRow('4ì‹œê°„ ëŒ€ë¹„', comparisonData.fourHour, Icons.timer),
                _buildComparisonRow('8ì‹œê°„ ëŒ€ë¹„', comparisonData.eightHour, Icons.timer_outlined),
                _buildComparisonRow('12ì‹œê°„ ëŒ€ë¹„', comparisonData.twelveHour, Icons.update),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
          error: (_, __) => _buildErrorSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
        );
      },
    );
  }

  Widget _buildLongTermAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
                const SizedBox(height: 4),
                _buildComparisonRow('24ì‹œê°„ ëŒ€ë¹„', comparisonData.twentyFourHour, Icons.calendar_today),
                _buildComparisonRow('3ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.threeDayAverage, Icons.view_day),
                _buildComparisonRow('ì¼ì£¼ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.weeklyAverage, Icons.date_range),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
          error: (_, __) => _buildErrorSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
        );
      },
    );
  }

  Widget _buildLoadingSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildErrorSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        Text(
          'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
          style: TextStyle(
            fontSize: 9,
            color: Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  Widget _buildComparisonRow(String label, ComparisonResult result, IconData icon) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    if (result.isReady && result.changePercent != null) {
      return _buildStatRow(
        icon: icon,
        label: label,
        value: controller.formatComparisonValue(result),
        isHighlight: controller.isHighlight(result),
        isWarning: controller.isWarning(result),
      );
    } else {
      return _buildProgressRow(icon, label, result);
    }
  }

  Widget _buildProgressRow(IconData icon, String label, ComparisonResult result) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final progressPercent = controller.getProgressPercent(result);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
          ),
          const SizedBox(width: 5),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '$label: $progressPercent% (${result.status})',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.w500,
                    // [ìˆ˜ì •] withOpacity -> withValues
                    color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: result.progressPercent.clamp(0.0, 1.0),
                  // [ìˆ˜ì •] withOpacity -> withValues
                  backgroundColor: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                  valueColor: AlwaysStoppedAnimation(
                    result.progressPercent >= 1.0
                      ? Colors.green
                      // [ìˆ˜ì •] withOpacity -> withValues
                      : Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
                  ),
                  minHeight: 3,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Colors.green;
      if (isWarning) return Colors.red;
      // [ìˆ˜ì •] withOpacity -> withValues
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.green.withValues(alpha: 0.08)
            : isWarning
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.red.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              // [ìˆ˜ì •] withOpacity -> withValues
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/sector_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/sector_provider.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/sector_controller.dart';
import '../widgets/sector_tile.dart';

class SectorPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SectorPage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ)
    final state = ref.watch(sectorControllerProvider);
    final controller = ref.read(sectorControllerProvider.notifier);
    
    // âœ… TimeFrame ê´€ë ¨
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(sectorTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(sectorTimeFrameController);
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
      sliderValue: index.toDouble(),
      sliderMin: 0.0,
      sliderMax: (timeFrames.length - 1).toDouble(),
      sliderDivisions: timeFrames.length - 1,
      sliderLabel: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
      onSliderChanged: (value) {
        final i = value.round();
        controller.setTimeFrame(timeFrames[i], i); 
      },
      centerWidget: CommonToggleButton(
        text: timeFrameCtrl.currentSectorClassificationName,
        isActive: state.isDetailedClassification, // ìƒì„¸ì¼ ë•Œ active
        onTap: () => controller.toggleSectorClassification(),
        icon: state.isDetailedClassification ? Icons.view_module : Icons.view_list,
      ),
      rightWidget: CommonCountdownWidget(
        nextResetTime: timeFrameCtrl.getNextResetTime(),
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildSectorList(state, controller, timeFrames, index, context)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ì„¹í„° ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜)
  Widget _buildSectorList(
    SectorControllerState state,
    SectorController controller,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ì„¹í„° ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.sectorVolumes.isEmpty) {
      return Center(
        child: Text(
          'ì„¹í„° ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ì„¹í„° ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì‚¬ìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.sectorVolumes.length,
      itemBuilder: (_, i) {
        final volume = state.sectorVolumes[i];
        final sectorName = volume.market.replaceFirst('SECTOR-', '');
        final rank = i + 1;
        
        return SectorTile(
          sectorName: sectorName,
          totalVolume: volume.totalVolume,
          rank: rank,
          timeFrame: volume.timeFrame,
          lastUpdated: volume.lastUpdated,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ
          isHot: controller.isHot(sectorName),
          shouldBlink: controller.shouldBlink(sectorName),
          // âœ… ë¶„ë¥˜ ìƒíƒœ ì „ë‹¬
          isDetailedClassification: state.isDetailedClassification,
        );
      },
    );
  }
}\n\n// ====== lib/presentation/pages/notification_page.dart ======\n
// lib/presentation/pages/notification_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// ì„ì‹œ ì•Œë¦¼ í˜ì´ì§€ (ì—ëŸ¬ í•´ê²°ìš©)
class NotificationPage extends ConsumerWidget {
  const NotificationPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ì•Œë¦¼'),
        centerTitle: true,
        elevation: 0,
      ),
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.notifications_outlined,
              size: 80,
              color: Colors.orange,
            ),
            SizedBox(height: 24),
            Text(
              'ì•Œë¦¼ í˜ì´ì§€',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.orange,
              ),
            ),
            SizedBox(height: 12),
            Text(
              'ì„ì‹œ í˜ì´ì§€ì…ë‹ˆë‹¤',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/volume_provider.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';

class VolumePage extends ConsumerWidget {
  final ScrollController scrollController;

  const VolumePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ)
    final state = ref.watch(volumeControllerProvider);
    final controller = ref.read(volumeControllerProvider.notifier);
    
    // âœ… TimeFrame ê´€ë ¨
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(volumeTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(volumeTimeFrameController);
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
      sliderValue: index.toDouble(),
      sliderMin: 0.0,
      sliderMax: (timeFrames.length - 1).toDouble(),
      sliderDivisions: timeFrames.length - 1,
      sliderLabel: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
      onSliderChanged: (value) {
        final i = value.round();
        controller.setTimeFrame(timeFrames[i], i); 
      },
      centerWidget: CommonToggleButton(
        text: controller.currentLimitName,
        isActive: state.isTop100,
        onTap: () => controller.toggleTopLimit(),
      ),
      rightWidget: CommonCountdownWidget(
        nextResetTime: timeFrameCtrl.getNextResetTime(),
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildVolumeList(state, controller, timeFrames, index, context)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜)
  Widget _buildVolumeList(
    VolumeControllerState state,
    VolumeController controller,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ë³¼ë¥¨ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.volumes.isEmpty) {
      return Center(
        child: Text(
          'ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì‚¬ìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.volumes.length,
      itemBuilder: (_, i) {
        final volume = state.volumes[i];
        final rank = i + 1;
        
        return VolumeTile(
          market: volume.market,
          totalVolume: volume.totalVolume,
          rank: rank,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ (rank íŒŒë¼ë¯¸í„° ë¶ˆí•„ìš”)
          isHot: controller.isHot(volume.market),
          shouldBlink: controller.shouldBlink(volume.market),
        );
      },
    );
  }
}\n\n// ====== lib/presentation/pages/surge_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/surge_provider.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/surge_controller.dart';
import '../widgets/surge_tile.dart';

class SurgePage extends ConsumerWidget {
  final ScrollController scrollController;

  const SurgePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ)
    final state = ref.watch(surgeControllerProvider);
    final controller = ref.read(surgeControllerProvider.notifier);
    
    // âœ… TimeFrame ê´€ë ¨
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(surgeTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(surgeTimeFrameController);
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ - Surge ê³ ìœ ì˜ ë³µì¡í•œ 5ë¶„í•  êµ¬ì¡°
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
      sliderValue: index.toDouble(),
      sliderMin: 0.0,
      sliderMax: (timeFrames.length - 1).toDouble(),
      sliderDivisions: timeFrames.length - 1,
      sliderLabel: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
      onSliderChanged: (value) {
        final i = value.round();
        controller.setTimeFrame(timeFrames[i], i);
      },
      // ğŸ”¥ Surge ê³ ìœ : ë³µì¡í•œ 5ë¶„í•  ë ˆì´ì•„ì›ƒ (12-6-10-10-11)
      extraWidgets: [
        // í•„í„° í† ê¸€ ë²„íŠ¼ (6/49)
        Expanded(
          flex: 6,
          child: Center(
            child: CommonToggleButton(
              text: controller.currentFilterName,
              isActive: state.filterType != SurgeFilterType.all,
              onTap: () {
                // í•„í„° ìˆœí™˜: ì „ì²´ â†’ ê¸‰ë“±ë§Œ â†’ ê¸‰ë½ë§Œ â†’ ì „ì²´
                SurgeFilterType nextFilter;
                switch (state.filterType) {
                  case SurgeFilterType.all:
                    nextFilter = SurgeFilterType.risingOnly;
                    break;
                  case SurgeFilterType.risingOnly:
                    nextFilter = SurgeFilterType.fallingOnly;
                    break;
                  case SurgeFilterType.fallingOnly:
                    nextFilter = SurgeFilterType.all;
                    break;
                }
                controller.setFilterType(nextFilter);
              },
              activeColor: Colors.blue,
              borderColor: Colors.blue,
              fontSize: 10,
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
            ),
          ),
        ),
        
        // Top 50/100 í† ê¸€ ë²„íŠ¼ (10/49)
        Expanded(
          flex: 10,
          child: Center(
            child: CommonToggleButton(
              text: controller.currentLimitName,
              isActive: state.isTop100,
              onTap: () => controller.toggleTopLimit(),
              fontSize: 10,
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
            ),
          ),
        ),
        
        // ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° (10/49)
        Expanded(
          flex: 10,
          child: Center(
            child: _buildSurgeCounter(controller, state),
          ),
        ),
      ],
      rightWidget: CommonCountdownWidget(
        nextResetTime: timeFrameCtrl.getNextResetTime(),
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildSurgeList(state, controller, timeFrames, index, context)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° ìœ„ì ¯
  Widget _buildSurgeCounter(SurgeController controller, SurgeControllerState state) {
    if (state.surges.isEmpty) {
      return Container(
        height: 29,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: Colors.grey.withValues(alpha: 0.1),
        ),
        child: const Center(
          child: Text(
            'ë¡œë”©ì¤‘',
            style: TextStyle(fontSize: 8, color: Colors.grey),
          ),
        ),
      );
    }

    final count = controller.getSurgeCount();
    final risingCount = count['rising'] ?? 0;
    final fallingCount = count['falling'] ?? 0;
    
    return Container(
      height: 29,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.withValues(alpha: 0.3), width: 1),
      ),
      child: Row(
        children: [
          // ì¢Œì¸¡: ê¸‰ë“± ì¹´ìš´í„° (ì´ˆë¡ ë°°ê²½)
          Expanded(
            child: Container(
              decoration: const BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(11),
                  bottomLeft: Radius.circular(11),
                ),
              ),
              child: Center(
                child: Text(
                  '$risingCount',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
          // ìš°ì¸¡: ê¸‰ë½ ì¹´ìš´í„° (ë¹¨ê°„ ë°°ê²½)
          Expanded(
            child: Container(
              decoration: const BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.only(
                  topRight: Radius.circular(11),
                  bottomRight: Radius.circular(11),
                ),
              ),
              child: Center(
                child: Text(
                  '$fallingCount',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜)
  Widget _buildSurgeList(
    SurgeControllerState state,
    SurgeController controller,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ê¸‰ë“±/ê¸‰ë½ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.surges.isEmpty) {
      return Center(
        child: Text(
          'ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬/í•„í„°ëœ ë°ì´í„° ì‚¬ìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.surges.length,
      itemBuilder: (_, i) {
        final surge = state.surges[i];
        final rank = i + 1;
        
        return SurgeTile(
          market: surge.market,
          changePercent: surge.changePercent,
          basePrice: surge.basePrice,
          currentPrice: surge.currentPrice,
          rank: rank,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ
          isHot: controller.isHot(surge.market),
          shouldBlink: controller.shouldBlink(surge.market),
        );
      },
    );
  }
}\n\n// ====== lib/presentation/pages/signal_page.dart ======\n
// lib/presentation/pages/signal_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/settings_provider.dart';
import '../../core/di/signal_provider.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/signal.dart';
import '../controllers/signal_controller.dart';
import '../widgets/signal_tile.dart';

/// ğŸš€ Signal Page V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
class SignalPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SignalPage({
    super.key,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // V4.1 Controller ê¸°ë°˜ ì‹œìŠ¤í…œ
    final controller = ref.watch(signalControllerProvider.notifier);
    final state = ref.watch(signalControllerProvider);

    // ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
    final signalsAsync = ref.watch(signalListProvider);

    // markets ì •ë³´
    final marketsAsync = ref.watch(marketsProvider);

    // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
    ref.listen(signalSystemMonitorProvider, (prev, next) {
      if (next.hasError && AppConfig.enableTradeLog) {
        debugPrint('âš ï¸ Signal system monitoring error: ${next.error}');
      }
    });

    // ì—ëŸ¬ ë©”ì‹œì§€ ìë™ í´ë¦¬ì–´
    ref.listen(signalControllerProvider.select((s) => s.errorMessage), (prev, next) {
      if (next != null) {
        Future.delayed(const Duration(seconds: 5), () {
          controller.clearError();
        });
      }
    });

    // ğŸ†• V4.1 ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
    final sliderWidget = _buildEnhancedSliderWidget(
      controller,
      state,
      marketsAsync,
      ref,
      context,
    );

    // ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° í•„í„°ë§ í¬í•¨)
    final signalListWidget = _buildEnhancedSignalList(
      signalsAsync,
      controller,
      scrollController,
      state,
      context,
      ref,
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,

          // ğŸ†• V4.1 ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
          if (state.errorMessage != null) _buildErrorBanner(state.errorMessage!, controller),

          // ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: signalListWidget),

          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ë°°ë„ˆ
  Widget _buildErrorBanner(String errorMessage, SignalController controller) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 16),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              errorMessage,
              style: const TextStyle(color: Colors.red, fontSize: 12),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          GestureDetector(
            onTap: controller.clearError,
            child: const Icon(Icons.close, color: Colors.red, size: 16),
          ),
        ],
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
  Widget _buildEnhancedSliderWidget(
    SignalController controller,
    SignalState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì²« ë²ˆì§¸ ì¤„: ì•„ì´ì½˜ + ì œëª© + ì„¤ëª… + ìƒíƒœ í‘œì‹œ
          Row(
            children: [
              // íŒ¨í„´ ì•„ì´ì½˜ + ì œëª©
              Icon(
                _getPatternIcon(state.currentPattern),
                size: 18,
                color: _getPatternColor(state.currentPattern),
              ),
              const SizedBox(width: 8),
              
              // ì œëª© + ì„¤ëª…
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      state.currentPattern.displayName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      state.currentPattern.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),

              // ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
              _buildSystemStatusChip(state),
              const SizedBox(width: 8),

              // í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€
              _buildPatternToggle(state, controller, ref),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ë‘ ë²ˆì§¸ ì¤„: ì„ê³„ê°’ + ì‹ ë¢°ë„ ì •ë³´
          Row(
            children: [
              Text(
                'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
              const Spacer(),
              // ğŸ†• V4.1 ì‹ ë¢°ë„ ì •ë³´
              Text(
                controller.getConfidenceStatusText(),
                style: const TextStyle(fontSize: 10, color: Colors.grey),
              ),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ì„¸ ë²ˆì§¸ ì¤„: íŒ¨í„´ ìŠ¬ë¼ì´ë”
          Row(
            children: [
              // ìŠ¬ë¼ì´ë”
              Expanded(
                child: Slider(
                  value: state.selectedIndex.toDouble(),
                  min: 0,
                  max: (PatternType.values.length - 1).toDouble(),
                  divisions: PatternType.values.length - 1,
                  label: state.currentPattern.displayName,
                  activeColor: _getPatternColor(state.currentPattern),
                  onChanged: (v) {
                    if (ref.read(appSettingsProvider).isHapticEnabled) {
                      HapticFeedback.lightImpact();
                    }
                    final index = v.round();
                    marketsAsync.whenData((markets) {
                      controller.setPatternIndex(index, markets);
                    });
                  },
                ),
              ),

              // ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
              _buildSortButton(state, controller),
            ],
          ),

          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
          _buildOnlineMetricsStatusBar(state),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ ì¹©
  Widget _buildSystemStatusChip(SignalState state) {
    final isHealthy = state.isSystemHealthy;
    final color = isHealthy ? Colors.green : Colors.orange;
    final icon = isHealthy ? Icons.check_circle : Icons.warning;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: color.withValues(alpha: 0.1),
        border: Border.all(color: color.withValues(alpha: 0.3), width: 0.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            isHealthy ? 'OK' : 'WARN',
            style: TextStyle(fontSize: 8, color: color, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ í† ê¸€ ë²„íŠ¼
  Widget _buildPatternToggle(SignalState state, SignalController controller, WidgetRef ref) {
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact();
        }
        controller.togglePatternEnabled();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange,
            width: 1.5,
          ),
          color: state.isPatternEnabled ? Colors.orange : Colors.transparent,
        ),
        child: Text(
          state.isPatternEnabled ? 'í™œì„±' : 'ë¹„í™œì„±',
          style: TextStyle(
            color: state.isPatternEnabled ? Colors.white : Colors.orange,
            fontSize: 11,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
  Widget _buildSortButton(SignalState state, SignalController controller) {
    return PopupMenuButton<String>(
      icon: Icon(
        Icons.sort,
        size: 18,
        color: Colors.grey[600],
      ),
      onSelected: (value) {
        controller.setSortField(value);
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'time', child: Text('ì‹œê°„ ${_getSortIcon(state, 'time')}')),
        PopupMenuItem(value: 'confidence', child: Text('ì‹ ë¢°ë„ ${_getSortIcon(state, 'confidence')}')),
        PopupMenuItem(value: 'change', child: Text('ë³€í™”ìœ¨ ${_getSortIcon(state, 'change')}')),
        PopupMenuItem(value: 'amount', child: Text('ê±°ë˜ì•¡ ${_getSortIcon(state, 'amount')}')),
        PopupMenuItem(value: 'market', child: Text('ë§ˆì¼“ ${_getSortIcon(state, 'market')}')),
      ],
    );
  }

  /// ğŸ†• ì •ë ¬ ì•„ì´ì½˜ í—¬í¼
  String _getSortIcon(SignalState state, String field) {
    if (state.sortField != field) return '';
    return state.sortAscending ? 'â†‘' : 'â†“';
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
  Widget _buildOnlineMetricsStatusBar(SignalState state) {
    if (!state.hasOnlineMetrics) {
      return Container(
        height: 2,
        margin: const EdgeInsets.only(top: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(1),
          color: Colors.grey[300],
        ),
      );
    }

    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    final healthRatio = totalMarkets > 0 ? healthyMarkets / totalMarkets : 0.0;
    final color = staleMarkets > 0 ? Colors.orange : Colors.green;

    return Container(
      height: 2,
      margin: const EdgeInsets.only(top: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(1),
        color: Colors.grey[300],
      ),
      child: FractionallySizedBox(
        widthFactor: healthRatio,
        alignment: Alignment.centerLeft,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(1),
            color: color,
          ),
        ),
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ)
  Widget _buildEnhancedSignalList(
    AsyncValue<List<Signal>> signalsAsync,
    SignalController controller,
    ScrollController scrollController,
    SignalState state,
    BuildContext context,
    WidgetRef ref,
  ) {
    return signalsAsync.when(
      data: (list) {
        final viewList = controller.apply(list);

        if (viewList.isEmpty) {
          return _buildEmptyState(state, context, controller);
        }

        return _buildSignalListView(viewList, scrollController, state, ref);
      },
      loading: () => _buildLoadingState(context),
      error: (e, _) => _buildErrorState(e, context, ref),
    );
  }

  /// ğŸ†• V4.1 ë¹ˆ ìƒíƒœ (ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ í¬í•¨)
  Widget _buildEmptyState(SignalState state, BuildContext context, SignalController controller) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.radar,
            size: 64,
            color: Theme.of(context).hintColor.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            state.isPatternEnabled
                ? '${state.currentPattern.displayName} íŒ¨í„´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
                : 'íŒ¨í„´ ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.',
            textAlign: TextAlign.center,
            style: TextStyle(
                color: Theme.of(context).hintColor, fontSize: 16),
          ),
          const SizedBox(height: 8),
          Text(
            'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 14,
            ),
          ),
          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ
          if (state.hasOnlineMetrics) ...[
            const SizedBox(height: 8),
            Text(
              controller.getSystemStatusText(),
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Theme.of(context).hintColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
          ],
          // ğŸ†• V4.1 ë¹ ë¥¸ ì•¡ì…˜ ë²„íŠ¼ë“¤
          const SizedBox(height: 24),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => controller.resetOnlineMetrics(),
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('ì§€í‘œ ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
              const SizedBox(width: 12),
              // í”„ë¦¬ì…‹ ì ìš© ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showPresetDialog(context, controller),
                icon: const Icon(Icons.tune, size: 16),
                label: const Text('í”„ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ë¡œë”© ìƒíƒœ (ê°œì„ ëœ ë””ìì¸)
  Widget _buildLoadingState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            'ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ ì¤‘...',
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ìƒíƒœ (ê°œì„ ëœ ì—ëŸ¬ ì²˜ë¦¬)
  Widget _buildErrorState(Object error, BuildContext context, WidgetRef ref) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: Theme.of(context).colorScheme.error.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            'ì‹œê·¸ë„ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            '$error',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton.icon(
                onPressed: () {
                  ref.invalidate(signalListProvider);
                },
                icon: const Icon(Icons.refresh),
                label: const Text('ë‹¤ì‹œ ì‹œë„'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                ),
              ),
              const SizedBox(width: 12),
              // ğŸ†• V4.1 ê³ ê¸‰ ì§„ë‹¨ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showDiagnosticsDialog(context, ref),
                icon: const Icon(Icons.info),
                label: const Text('ì§„ë‹¨'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ ë·° (ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ í¬í•¨)
  Widget _buildSignalListView(
    List<Signal> viewList,
    ScrollController scrollController,
    SignalState state,
    WidgetRef ref,
  ) {
    return RawScrollbar(
      controller: scrollController,
      thumbVisibility: false,
      trackVisibility: false,
      thickness: 6.4,
      radius: const Radius.circular(3.2),
      thumbColor: Colors.orange.withValues(alpha: 0.5),
      interactive: true,
      minThumbLength: 40,
      child: ListView.builder(
        controller: scrollController,
        physics: const BouncingScrollPhysics(
          parent: AlwaysScrollableScrollPhysics(),
        ),
        padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
        itemCount: viewList.length,
        itemBuilder: (context, index) {
          final signal = viewList[index];
          
          return Column(
            children: [
              // ğŸ†• V4.1 Signal Tile ì‚¬ìš© (íƒ­ ê¸°ëŠ¥ ì¶”ê°€)
              GestureDetector(
                onTap: () => _showSignalDetails(context, signal, ref),
                child: SignalTile(
                  signal: signal,
                  showOnlineMetrics: true,
                ),
              ),
              
              // êµ¬ë¶„ì„  (ë§ˆì§€ë§‰ ì•„ì´í…œ ì œì™¸)
              if (index < viewList.length - 1)
                Divider(
                  height: 1,
                  thickness: 0.5,
                  color: Colors.grey[300],
                  indent: 16,
                  endIndent: 16,
                ),
            ],
          );
        },
      ),
    );
  }

  // ==========================================================================
  // ğŸ†• V4.1 ëŒ€í™”ìƒìë“¤
  // ==========================================================================

  /// ğŸ†• í”„ë¦¬ì…‹ ì„ íƒ ëŒ€í™”ìƒì
  void _showPresetDialog(BuildContext context, SignalController controller) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('íŒ¨í„´ í”„ë¦¬ì…‹ ì„ íƒ'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.security, color: Colors.blue),
              title: const Text('Conservative'),
              subtitle: const Text('False Positive ìµœì†Œí™”'),
              onTap: () {
                controller.applyPreset('conservative');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.balance, color: Colors.green),
              title: const Text('Balanced'),
              subtitle: const Text('ê· í˜•ì¡íŒ ê¸°ë³¸ ì„¤ì •'),
              onTap: () {
                controller.applyPreset('balanced');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.speed, color: Colors.red),
              title: const Text('Aggressive'),
              subtitle: const Text('ê°ì§€ìœ¨ ìµœëŒ€í™”'),
              onTap: () {
                controller.applyPreset('aggressive');
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ†• ì§„ë‹¨ ì •ë³´ ëŒ€í™”ìƒì
  void _showDiagnosticsDialog(BuildContext context, WidgetRef ref) {
    final controller = ref.read(signalControllerProvider.notifier);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ì‹œìŠ¤í…œ ì§„ë‹¨'),
        content: FutureBuilder<Map<String, dynamic>>(
          future: controller.getSystemHealthReport(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('ì§„ë‹¨ ì¤‘...'),
                ],
              );
            }
            
            if (snapshot.hasError) {
              return Text('ì§„ë‹¨ ì‹¤íŒ¨: ${snapshot.error}');
            }
            
            final report = snapshot.data!;
            return SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('ë²„ì „: ${report['version']}'),
                  Text('ìƒíƒœ: ${report['status']}'),
                  Text('ì—…íƒ€ì„: ${report['uptime']}ë¶„'),
                  Text('ì²˜ë¦¬ëœ ê±°ë˜: ${report['totalProcessedTrades']}ê±´'),
                  Text('í™œì„± íŒ¨í„´: ${report['activePatterns']}ê°œ'),
                  Text('ì¶”ì  ë§ˆì¼“: ${report['trackedMarkets']}ê°œ'),
                  const SizedBox(height: 16),
                  const Text('ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ:', style: TextStyle(fontWeight: FontWeight.bold)),
                  if (report['onlineMetricsHealth'] != null) ...[
                    Text('ì´ ë§ˆì¼“: ${report['onlineMetricsHealth']['totalMarkets']}'),
                    Text('ì •ìƒ: ${report['onlineMetricsHealth']['healthyMarkets']}'),
                    Text('ë§Œë£Œ: ${report['onlineMetricsHealth']['staleMarkets']}'),
                  ],
                ],
              ),
            );
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ì‹œê·¸ë„ ìƒì„¸ ì •ë³´ ëŒ€í™”ìƒì
  void _showSignalDetails(BuildContext context, Signal signal, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${signal.patternType.displayName} - ${signal.ticker}'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // ê¸°ë³¸ ì •ë³´
              _buildDetailRow('ë§ˆì¼“', signal.market),
              _buildDetailRow('í˜„ì¬ê°€', '${signal.currentPrice.toStringAsFixed(0)}ì›'),
              _buildDetailRow('ë³€í™”ìœ¨', '${signal.changePercent.toStringAsFixed(2)}%'),
              _buildDetailRow('ê±°ë˜ì•¡', '${(signal.tradeAmount / 1000000).toStringAsFixed(1)}M'),
              _buildDetailRow('ê°ì§€ì‹œê°„', signal.detectedAt.toString().substring(0, 19)),
              
              if (signal.confidence != null)
                _buildDetailRow('ì‹ ë¢°ë„', '${(signal.confidence! * 100).toStringAsFixed(1)}%'),
              
              // ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
              if (signal.hasOnlineMetrics) ...[
                const SizedBox(height: 16),
                const Text('ì˜¨ë¼ì¸ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                
                if (signal.onlineIndicators?.rsi != null)
                  _buildDetailRow('RSI', '${signal.onlineIndicators!.rsi!.toStringAsFixed(1)} (${signal.onlineIndicators!.rsiState})'),
                
                if (signal.onlineIndicators?.macd != null)
                  _buildDetailRow('MACD', '${signal.onlineIndicators!.macd!.toStringAsFixed(2)} (${signal.onlineIndicators!.macdState})'),
              ],
              
              // ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
              if (signal.divergence != null) ...[
                const SizedBox(height: 16),
                const Text('ë‹¤ì´ë²„ì „ìŠ¤', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                _buildDetailRow('íƒ€ì…', signal.divergence!.type),
                _buildDetailRow('ê°•ë„', signal.divergence!.confidenceLevel),
                _buildDetailRow('ì†ŒìŠ¤', signal.divergence!.source),
              ],
              
              // ê³ ê¸‰ ì§€í‘œë“¤
              const SizedBox(height: 16),
              const Text('ê³ ê¸‰ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              
              if (signal.zScore != null)
                _buildDetailRow('Z-Score', signal.zScore!.toStringAsFixed(2)),
              
              if (signal.liquidityVortex != null)
                _buildDetailRow('Liquidity Vortex', signal.liquidityVortex!.toStringAsFixed(3)),
              
              if (signal.flashPulse != null)
                _buildDetailRow('Flash Pulse', signal.flashPulse!.toStringAsFixed(2)),
              
              // ë²„ì „ ì •ë³´
              if (signal.version != null) ...[
                const SizedBox(height: 16),
                _buildDetailRow('ë²„ì „', signal.version!),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ìƒì„¸ ì •ë³´ í–‰
  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  // ==========================================================================
  // í—¬í¼ í•¨ìˆ˜ë“¤
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì•„ì´ì½˜ ë°˜í™˜
  IconData _getPatternIcon(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// íŒ¨í„´ë³„ ìƒ‰ìƒ ë°˜í™˜
  Color _getPatternColor(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }
}\n\n// ====== lib/presentation/widgets/sector_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/sector_names.dart';
import '../../shared/widgets/sector_logo_provider.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/sector_controller.dart';

class SectorTile extends ConsumerStatefulWidget {
  final String sectorName;
  final double totalVolume;
  final int rank;
  final String timeFrame;
  final DateTime lastUpdated;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool isDetailedClassification; // âœ… ë¶„ë¥˜ ìƒíƒœ

  const SectorTile({
    Key? key,
    required this.sectorName,
    required this.totalVolume,
    required this.rank,
    required this.timeFrame,
    required this.lastUpdated,
    required this.isHot,
    required this.shouldBlink,
    required this.isDetailedClassification,
  }) : super(key: key);

  @override
  ConsumerState<SectorTile> createState() => _SectorTileState();
}

class _SectorTileState extends ConsumerState<SectorTile>
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SectorTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (ì„¤ì • ì²´í¬ + Controller ìƒíƒœ ì´ˆê¸°í™”)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­
            ref.read(sectorControllerProvider.notifier).clearBlinkState(widget.sectorName);
          }
        });
      }
    });
  }

  /// âœ… ì„¹í„° ë²ˆí˜¸ ë§¤í•‘ (ê¸°ì¡´ ìœ ì§€ - ì„¹í„° ì „ìš© ë¡œì§)
  int _getSectorNumber(String sectorName) {
    const sectorNumberMap = {
      // ìƒì„¸ ë¶„ë¥˜ (1-28ë²ˆ)
      'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': 1, 'ì´ë”ë¦¬ì›€ ê·¸ë£¹': 2, 'ìŠ¤í…Œì´í‚¹': 3, 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': 4,
      'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': 5, 'ìŠ¤í…Œì´ë¸” ì½”ì¸': 6, 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': 7, 'ëœë”©': 8,
      'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': 9, 'RWA': 10, 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': 11, 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': 12,
      'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': 13, 'ì˜¤ë¼í´': 14, 'ë°ì´í„° ì¸í”„ë¼': 15, 'ìŠ¤í† ë¦¬ì§€': 16,
      'AI': 17, 'ë©”íƒ€ë²„ìŠ¤': 18, 'NFT/ê²Œì„': 19, 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': 20,
      'ê´‘ê³ ': 21, 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': 22, 'ì†Œì…œ/DAO': 23, 'íŒ¬í† í°': 24,
      'ë°ˆ': 25, 'DID': 26, 'ì˜ë£Œ': 27, 'ì›”ë ›/ë©”ì„¸ì§•': 28,
      // ê¸°ë³¸ ë¶„ë¥˜ (29-46ë²ˆ)
      'ë©”ì´ì € ì½”ì¸': 29, 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': 30, 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': 31, 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': 32,
      'ê³  ì‹œì´': 33, 'ì¤‘ ì‹œì´': 34, 'ì € ì‹œì´': 35, 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': 36,
      'DeFi í† í°': 37, 'ìŠ¤í…Œì´ë¸”ì½”ì¸': 38, 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': 39, 'í•œêµ­ í”„ë¡œì íŠ¸': 40,
      'ì†”ë¼ë‚˜ ìƒíƒœê³„': 41, 'AI/ê¸°ìˆ  í† í°': 42, '2023ë…„ ì‹ ê·œìƒì¥': 43, '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 44,
      '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': 45, '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 46,
    };
    return sectorNumberMap[sectorName] ?? 1;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);

    // âœ… ì„¹í„°ëª… í‘œì‹œ (ë‚´ë¶€ì—ì„œ DisplayMode ì²˜ë¦¬)
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final displaySectorName = SectorNames.getDisplayName(
      widget.sectorName, 
      displayMode, 
      isDetailed: widget.isDetailedClassification
    );

    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),

          const FlexChild.fixed(SizedBox(width: 12)),

          // ğŸ¨ ì„¹í„° ì•„ì´ì½˜ ë¶€ë¶„
          FlexChild.fixed(
            SectorLogoProvider.buildSectorIcon(
              sectorNumber: _getSectorNumber(widget.sectorName),
              size: 40.0,
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 12)),

          // ğŸ“± ì„¹í„°ëª… ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        displaySectorName,
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // âœ… HOT ì•„ì´ì½˜ (ë°›ì€ props ì‚¬ìš©)
                    if (TileCommon.buildHotIcon(widget.isHot) case final hotIcon?)
                      hotIcon,
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  SectorNames.getDisplayName(
                    widget.sectorName, 
                    DisplayMode.ticker, 
                    isDetailed: widget.isDetailedClassification
                  ),
                  style: TextStyle(
                    color: onSurface70,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),

          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;

                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget(
                          totalAmount: widget.totalVolume,
                          isBuy: true, // Sectorë„ ì¤‘ë¦½ì  ìƒ‰ìƒ
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text(
                          AmountFormatter.formatVolume(widget.totalVolume),
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;

    // âœ… ë¸”ë§í¬ ìƒíƒœì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: Colors.amber, // Sectorë„ ì•°ë²„ ìƒ‰ìƒ
      );
    }

    return cardWidget;
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
// lib/presentation/widgets/trade_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/amount_formatter.dart';

class TradeTile extends ConsumerWidget {
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');
  
  final Trade trade;
  final DisplayMode displayMode;  // âœ… ìƒìœ„ì—ì„œ ë°›ì•„ì˜´ (Volume/Surge íŒ¨í„´)

  const TradeTile({
    Key? key,
    required this.trade,
    required this.displayMode,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // âœ… ìµœì í™”ëœ ì½”ì¸ëª… í‘œì‹œ (TileCommon ì‚¬ìš©)
    final displayName = TileCommon.getDisplayNameOptimized(
      ref,
      trade.market,
      displayMode, // ìƒìœ„ì—ì„œ ë°›ì€ DisplayMode ì‚¬ìš©
    );
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ì‚¬ìš© (Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´)
    return TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 12
          FlexChild.expanded(
            Text(
              _timeFormat.format(trade.timestamp),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 12,
          ),
          
          // ğŸª™ ì½”ì¸ëª… ë¶€ë¶„: flex 18 - ìµœì í™”ëœ ë²„ì „ ì‚¬ìš©
          FlexChild.expanded(
            Text(
              displayName, // âœ… ìµœì í™”ëœ ë°©ì‹
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
                fontSize: 16,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
            flex: 18,
          ),
          
          // ğŸ’µ ê°€ê²©/ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 20
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(trade.price)}ì›', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface, fontSize: 14),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatTradeVolume(trade.volume)}ê°œ', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface70, fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 20,
          ),
          
          // ğŸ’° ì´ì•¡ ë¶€ë¶„: flex 20 - AmountDisplayWidget ì‚¬ìš©
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: trade.total,
                isBuy: trade.isBuy,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            flex: 20,
          ),
          
          // ğŸ“ˆ ë°©í–¥ ì•„ì´ì½˜: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            Icon(
              trade.isBuy ? Icons.arrow_upward : Icons.arrow_downward,
              color: trade.isBuy ? Colors.green : Colors.red,
              size: 16,
            ),
          ),
        ],
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/surge_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/surge_controller.dart';

class SurgeTile extends ConsumerStatefulWidget {
  final String market;
  final double changePercent;
  final double basePrice;
  final double currentPrice;
  final int rank;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  
  const SurgeTile({
    Key? key, 
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.rank,
    required this.isHot,
    required this.shouldBlink,
  }) : super(key: key);

  @override
  ConsumerState<SurgeTile> createState() => _SurgeTileState();
}

class _SurgeTileState extends ConsumerState<SurgeTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SurgeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (ì„¤ì • ì²´í¬ + Controller ìƒíƒœ ì´ˆê¸°í™”)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­
            ref.read(surgeControllerProvider.notifier).clearBlinkState(widget.market);
          }
        });
      }
    });
  }

  // âœ… ë³€ë™ë¥  í¬ë§·íŒ… (ìƒ‰ìƒ í¬í•¨)
  String _formatChangePercent(double changePercent) {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }

  // âœ… ë³€ë™ë¥ ì— ë”°ë¥¸ ìƒ‰ìƒ
  Color _getChangeColor() {
    if (widget.changePercent > 0) {
      return Colors.green; // ğŸŸ¢ ê¸‰ë“± - ì´ˆë¡
    } else if (widget.changePercent < 0) {
      return Colors.red; // ğŸ”´ ê¸‰ë½ - ë¹¨ê°•
    } else {
      return Colors.grey; // âšª ë³€ë™ ì—†ìŒ - íšŒìƒ‰
    }
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final changeColor = _getChangeColor();
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        // âœ… ë°±ì—…ì²˜ëŸ¼ ì‹¬í”Œí•˜ê²Œ (DisplayMode props ì—†ì´)
                        TileCommon.getDisplayName(ref, widget.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // âœ… HOT ì•„ì´ì½˜ (ë°›ì€ props ì‚¬ìš©)
                    if (TileCommon.buildHotIcon(widget.isHot) case final hotIcon?) 
                      hotIcon,
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''),
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸš€ ë³€ë™ë¥  ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  _formatChangePercent(widget.changePercent),
                  style: TextStyle(
                    color: changeColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatPrice(widget.currentPrice)}ì›',
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    // âœ… ë¸”ë§í¬ ìƒíƒœì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: changeColor, // SurgeëŠ” ë³€ë™ë¥  ìƒ‰ìƒìœ¼ë¡œ
      );
    }
    
    return cardWidget;
  }
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/volume_controller.dart';

class VolumeTile extends ConsumerStatefulWidget {
  final String market;
  final double totalVolume;
  final int rank;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  
  const VolumeTile({
    Key? key, 
    required this.market,
    required this.totalVolume,
    required this.rank,
    required this.isHot,
    required this.shouldBlink,
  }) : super(key: key);

  @override
  ConsumerState<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends ConsumerState<VolumeTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (ì„¤ì • ì²´í¬ + Controller ìƒíƒœ ì´ˆê¸°í™”)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­
            ref.read(volumeControllerProvider.notifier).clearBlinkState(widget.market);
          }
        });
      }
    });
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        // âœ… ë°±ì—…ì²˜ëŸ¼ ì‹¬í”Œí•˜ê²Œ (DisplayMode props ì—†ì´)
                        TileCommon.getDisplayName(ref, widget.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // âœ… HOT ì•„ì´ì½˜ (ë°›ì€ props ì‚¬ìš©)
                    if (TileCommon.buildHotIcon(widget.isHot) case final hotIcon?) 
                      hotIcon,
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''),
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
                  
                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget(
                          totalAmount: widget.totalVolume,
                          isBuy: true,
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text(
                          AmountFormatter.formatVolume(widget.totalVolume),
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    // âœ… ë¸”ë§í¬ ìƒíƒœì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: Colors.amber,
      );
    }
    
    return cardWidget;
  }
}\n\n// ====== lib/presentation/widgets/signal_tile.dart ======\n
// lib/presentation/widgets/signal_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/signal.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';

// ğŸ¯ ì¤‘ë³µ ë°˜ì§ì„ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ Set
final Set<String> _blinkedSignals = {};

/// ğŸš€ SignalTile V4.1 - Clean UI (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
class SignalTile extends ConsumerStatefulWidget {
  final Signal signal;
  final bool showOnlineMetrics; // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ ì˜µì…˜

  const SignalTile({
    super.key, 
    required this.signal,
    this.showOnlineMetrics = true, // ê¸°ë³¸ê°’: í‘œì‹œ
  });

  @override
  ConsumerState<SignalTile> createState() => _SignalTileState();
}

class _SignalTileState extends ConsumerState<SignalTile>
    with SingleTickerProviderStateMixin {
  
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 800), // Signalì€ ì¡°ê¸ˆ ë” ê¸¸ê²Œ
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.2).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );

    _checkNewSignal();
  }

  /// ğŸ¯ ìƒˆë¡œìš´ ì‹œê·¸ë„ ê°ì§€ ë° ë°˜ì§ì„ ì²˜ë¦¬ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
  void _checkNewSignal() {
    final signalKey = '${widget.signal.market}_${widget.signal.detectedAt.millisecondsSinceEpoch}';
    
    if (BlinkAnimationHelper.checkNewSignal(
      blinkedSignalsSet: _blinkedSignals,
      detectedAt: widget.signal.detectedAt,
      signalKey: signalKey,
      maxAgeSeconds: 10,
    )) {
      _startBlink();
    }
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ ì¹©
  Widget? _buildConfidenceChip() {
    final confidence = widget.signal.confidence;
    if (confidence == null) return null;

    Color color;
    if (confidence >= 0.8) {
      color = Colors.green;
    } else if (confidence >= 0.6) {
      color = Colors.amber;
    } else {
      color = Colors.orange;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        '${(confidence * 100).toStringAsFixed(0)}%',
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ìƒì„±
  List<Widget> _buildOnlineIndicatorChips() {
    if (!widget.showOnlineMetrics || !widget.signal.hasOnlineMetrics) {
      return [];
    }

    final indicators = widget.signal.onlineIndicators!;
    final chips = <Widget>[];

    // RSI ì¹©
    if (indicators.rsi != null) {
      Color rsiColor;
      String rsiText;
      
      if (indicators.rsi! >= 70) {
        rsiColor = Colors.red;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else if (indicators.rsi! <= 30) {
        rsiColor = Colors.blue;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else {
        rsiColor = Colors.grey[600]!;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      }

      chips.add(_buildIndicatorChip(rsiText, rsiColor));
    }

    // MACD ì¹©
    if (indicators.macd != null && indicators.macdSignal != null) {
      final isBullish = indicators.macd! > indicators.macdSignal!;
      final macdColor = isBullish ? Colors.green : Colors.red;
      final macdText = isBullish ? 'M+' : 'M-';

      chips.add(_buildIndicatorChip(macdText, macdColor));
    }

    return chips;
  }

  /// ğŸ†• V4.1 ì§€í‘œ ì¹© ìœ„ì ¯
  Widget _buildIndicatorChip(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„°
  Widget? _buildDivergenceIndicator() {
    final divergence = widget.signal.divergence;
    if (divergence == null || (!divergence.isBullish && !divergence.isBearish)) {
      return null;
    }

    Color color;
    IconData icon;
    
    if (divergence.isBullish) {
      color = Colors.green;
      icon = Icons.trending_up;
    } else {
      color = Colors.red;
      icon = Icons.trending_down;
    }

    return Container(
      padding: const EdgeInsets.all(3),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Icon(
        icon,
        size: 10,
        color: color,
      ),
    );
  }

  /// ğŸ†• V4.1 ëª¨ë“  ë°°ì§€ë“¤ì„ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€í•˜ë©° ë°°ì¹˜
  Widget _buildBadgeRow() {
    final badges = <Widget>[];
    
    // ì‹ ë¢°ë„ ì¹© ì¶”ê°€
    final confidenceChip = _buildConfidenceChip();
    if (confidenceChip != null) {
      badges.add(confidenceChip);
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ì¶”ê°€
    badges.addAll(_buildOnlineIndicatorChips());
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„° ì¶”ê°€
    final divergenceIndicator = _buildDivergenceIndicator();
    if (divergenceIndicator != null) {
      badges.add(divergenceIndicator);
    }

    if (badges.isEmpty) {
      return const SizedBox.shrink();
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: badges,
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ ìƒ‰ìƒ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ì‹œ ë” ìƒë™ê°ìˆê²Œ)
  Color _getEnhancedPatternColor() {
    Color baseColor;
    
    switch (widget.signal.patternType) {
      case PatternType.surge:
        baseColor = Colors.red;
        break;
      case PatternType.flashFire:
        baseColor = Colors.orange;
        break;
      case PatternType.stackUp:
        baseColor = Colors.amber;
        break;
      case PatternType.stealthIn:
        baseColor = Colors.green;
        break;
      case PatternType.blackHole:
        baseColor = Colors.purple;
        break;
      case PatternType.reboundShot:
        baseColor = Colors.blue;
        break;
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œê°€ ìˆìœ¼ë©´ ë” ì„ ëª…í•˜ê²Œ
    if (widget.signal.hasOnlineMetrics) {
      return baseColor;
    } else {
      return baseColor.withValues(alpha: 0.7);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;

    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„± (V4.1 Clean ë²„ì „)
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 13
          FlexChild.expanded(
            Text(
              _timeFormat.format(widget.signal.detectedAt),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 13,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„: ê³ ì • í¬ê¸° (V4.1 íŒ¨í„´ ìƒ‰ìƒ í…Œë‘ë¦¬ ì¶”ê°€)
          FlexChild.fixed(
            Container(
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: _getEnhancedPatternColor(),
                  width: 1.5,
                ),
              ),
              child: CoinLogoProvider.buildCoinLogo(
                ticker: widget.signal.market.replaceFirst('KRW-', ''),
                radius: 14,
              ),
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸª™ ì½”ì¸ëª… + ë°°ì§€ë“¤: flex 24 (ğŸ†• Clean ë²„ì „)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // ì²« ë²ˆì§¸ ì¤„: ì½”ì¸ëª… + NEW ë±ƒì§€
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.signal.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // NEW ë±ƒì§€ (í•„ìš”í•œ ê²½ìš°)
                    if (TileCommon.buildNewBadge(widget.signal.detectedAt) case final badge?) 
                      badge,
                  ],
                ),
                
                const SizedBox(height: 3),
                
                // ğŸ†• ë‘ ë²ˆì§¸ ì¤„: ëª¨ë“  ë°°ì§€ë“¤ (ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                _buildBadgeRow(),
              ],
            ),
            flex: 24,
          ),

          // ğŸ’µ ê°€ê²© + ë³€í™”ìœ¨: flex 18 (ì‹ ë¢°ë„ ì¹© ì œê±°ë¨)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(widget.signal.currentPrice)}ì›',
                  style: TextStyle(color: onSurface, fontSize: 13),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  TileCommon.formatChangePercent(widget.signal.changePercent),
                  style: TextStyle(
                    color: TileCommon.getChangeColor(widget.signal.changePercent),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 18,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ’° ê±°ë˜ëŒ€ê¸ˆ: flex 18 (AmountDisplayWidget ì‚¬ìš©)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: widget.signal.tradeAmount,
                isBuy: widget.signal.changePercent >= 0,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            flex: 18,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (V4.1 íŒ¨í„´ ìƒ‰ìƒ ì—°ë™)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    return blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: _getEnhancedPatternColor(), // ğŸ†• V4.1 ë™ì  ìƒ‰ìƒ
          )
        : cardWidget;
  }
}

/// ğŸ†• V4.1 í™•ì¥: AmountDisplayWidgetì— highlightColor íŒŒë¼ë¯¸í„° ì¶”ê°€ìš© í™•ì¥
/// (ì‹¤ì œë¡œëŠ” AmountDisplayWidget í´ë˜ìŠ¤ì— ì¶”ê°€í•´ì•¼ í•¨)
extension AmountDisplayWidgetV41 on AmountDisplayWidget {
  /// V4.1 ê°•ì¡° ìƒ‰ìƒì´ ì ìš©ëœ ìœ„ì ¯ ìƒì„±
  static Widget withHighlight({
    required double totalAmount,
    required bool isBuy,
    double fontSize = 14,
    FontWeight fontWeight = FontWeight.w600,
    Color? highlightColor,
  }) {
    return Container(
      padding: highlightColor != null 
          ? const EdgeInsets.symmetric(horizontal: 4, vertical: 1)
          : null,
      decoration: highlightColor != null
          ? BoxDecoration(
              borderRadius: BorderRadius.circular(3),
              color: highlightColor.withValues(alpha: 0.1),
              border: Border.all(color: highlightColor.withValues(alpha: 0.3), width: 0.5),
            )
          : null,
      child: AmountDisplayWidget(
        totalAmount: totalAmount,
        isBuy: isBuy,
        fontSize: fontSize,
        fontWeight: fontWeight,
      ),
    );
  }
}