\n\n// ====== lib/core/di/volume_provider.dart ======\n
import 'dart:async';
import 'dart:collection';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show marketsProvider, repoProvider;
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart';
import '../../domain/entities/volume.dart';
import '../../domain/entities/trade.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ í•µì‹¬ íƒ€ì… ì •ì˜ (Trade íŒ¨í„´ ì ìš©)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì‹œê°„ëŒ€ Enum (íƒ€ì… ì•ˆì „ì„±)
enum TimeFrame {
  min1(1, '1ë¶„'),
  min5(5, '5ë¶„'),
  min15(15, '15ë¶„'),
  min30(30, '30ë¶„'),
  min60(60, '1ì‹œê°„'),
  hour4(240, '4ì‹œê°„'),
  day1(1440, '1ì¼');

  const TimeFrame(this.minutes, this.displayName);
  final int minutes;
  final String displayName;

  /// String í‚¤ (í˜¸í™˜ì„±ìš©)
  String get key => '${minutes}m';

  /// ë¶„ìœ¼ë¡œ TimeFrame ì°¾ê¸°
  static TimeFrame fromMinutes(int minutes) {
    return values.firstWhere(
      (tf) => tf.minutes == minutes,
      orElse: () => TimeFrame.min1,
    );
  }

  /// String í‚¤ë¡œ TimeFrame ì°¾ê¸°
  static TimeFrame fromKey(String key) {
    return values.firstWhere(
      (tf) => tf.key == key,
      orElse: () => TimeFrame.min1,
    );
  }

  static List<TimeFrame> get available => values;
}

/// ë³¼ë¥¨ ì„¤ì • (Trade íŒ¨í„´ ì ìš©)
class VolumeConfig {
  static const int maxVolumesPerTimeFrame = 200;  // Tradeì™€ ë™ì¼
  static const int maxCacheSize = 250;             // Tradeì™€ ë™ì¼ (LRU)
  // âœ… ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¸í„°ë²Œ
  static const Duration batchInterval = Duration(milliseconds: 100);

  /// AppConfigì™€ ì—°ë™í•˜ì—¬ ì§€ì› ì‹œê°„ëŒ€ ê²°ì •
  static List<TimeFrame> get supportedTimeFrames =>
    AppConfig.timeFrames.map(TimeFrame.fromMinutes).toList();
}

/// ë³¼ë¥¨ ì´ë²¤íŠ¸ í´ë˜ìŠ¤ (ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€)
class VolumeEvent {
  final List<Volume> volumes;
  final TimeFrame? resetTimeFrame;

  const VolumeEvent(this.volumes, {this.resetTimeFrame});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ Extension (ìµœì†Œí•œë§Œ - Trade ìˆ˜ì¤€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// TimeFrame ë¦¬ìŠ¤íŠ¸ í—¬í¼ (ê¼­ í•„ìš”í•œ ê²ƒë§Œ)
extension TimeFrameList on List<TimeFrame> {
  List<String> get keys => map((tf) => tf.key).toList();
  List<String> get displayNames => map((tf) => tf.displayName).toList();
  List<int> get minutes => map((tf) => tf.minutes).toList();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ—ï¸ Infrastructure Layer (ê¸°ì¡´ ìœ ì§€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  return VolumeRepositoryImpl(ref.read(repoProvider));
});

final volumeUsecaseProvider = Provider<VolumeUsecase>((ref) {
  return VolumeUsecase(ref.read(repoProvider));
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ Settings Layer (Trade íŒ¨í„´)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// íƒ€ì… ì•ˆì „ ì‹œê°„ëŒ€ ì¸ë±ìŠ¤
final volumeTimeFrameIndexProvider = StateProvider<int>((_) => 0);

/// íƒ€ì… ì•ˆì „ í˜„ì¬ ì‹œê°„ëŒ€
final volumeTimeFrameProvider = StateProvider<TimeFrame>((ref) {
  final index = ref.watch(volumeTimeFrameIndexProvider);
  final timeFrames = VolumeConfig.supportedTimeFrames;
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return TimeFrame.min1;
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ State Management Layer (Trade LRU íŒ¨í„´ ì ìš©)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë³¼ë¥¨ ë°ì´í„° ìºì‹œ (Trade íŒ¨í„´ ì ìš©)
final volumeDataCacheProvider = StateNotifierProvider<VolumeDataNotifier, Map<TimeFrame, Map<String, double>>>((ref) {
  return VolumeDataNotifier();
});

class VolumeDataNotifier extends StateNotifier<Map<TimeFrame, Map<String, double>>> {
  VolumeDataNotifier() : super({}) {
    final initialState = <TimeFrame, Map<String, double>>{};
    for (final timeFrame in VolumeConfig.supportedTimeFrames) {
      initialState[timeFrame] = <String, double>{};
    }
    state = initialState;
  }

  // âœ… 1ë‹¨ê³„: ë°°ì¹˜ ë°ì´í„°ë¥¼ ë°›ì•„ ì²˜ë¦¬í•˜ëŠ” ë©”ì„œë“œ ì¶”ê°€
  void addBatch(Map<TimeFrame, Map<String, double>> batchData) {
    if (batchData.values.every((map) => map.isEmpty)) return;

    final newState = Map<TimeFrame, Map<String, double>>.from(state);

    batchData.forEach((timeFrame, batchMap) {
      if (batchMap.isNotEmpty) {
        final volumeMap = Map<String, double>.from(newState[timeFrame] ?? {});
        batchMap.forEach((market, volume) {
          volumeMap[market] = (volumeMap[market] ?? 0.0) + volume;
        });

        // í¬ê¸° ì œí•œ ë¡œì§ ì ìš©
        if (volumeMap.length > VolumeConfig.maxVolumesPerTimeFrame) {
          final sorted = volumeMap.entries.toList()
            ..sort((a, b) => b.value.compareTo(a.value));
          newState[timeFrame] = Map.fromEntries(sorted.take(VolumeConfig.maxVolumesPerTimeFrame));
        } else {
          newState[timeFrame] = volumeMap;
        }
      }
    });

    state = newState;
  }

  void resetTimeFrame(TimeFrame timeFrame) {
    final newState = Map<TimeFrame, Map<String, double>>.from(state);
    newState[timeFrame] = <String, double>{};
    state = newState;
  }

  void resetAll() {
    final newState = <TimeFrame, Map<String, double>>{};
    for (final timeFrame in VolumeConfig.supportedTimeFrames) {
      newState[timeFrame] = <String, double>{};
    }
    state = newState;
  }
}

/// ì¤‘ë³µ ID ê´€ë¦¬ (Trade LRU íŒ¨í„´ ì™„ì „ ì ìš©)
final volumeSeenIdsProvider = StateNotifierProvider<VolumeSeenIdsNotifier, Set<String>>((ref) {
  return VolumeSeenIdsNotifier();
});

class VolumeSeenIdsNotifier extends StateNotifier<Set<String>> {
  final LinkedHashSet<String> _orderedIds = LinkedHashSet<String>();

  VolumeSeenIdsNotifier() : super(<String>{});

  bool addId(String id) {
    if (_orderedIds.contains(id)) return false;

    _orderedIds.add(id);

    if (_orderedIds.length > VolumeConfig.maxCacheSize) {
      final removeCount = (_orderedIds.length / 4).ceil();
      final oldestIds = _orderedIds.take(removeCount).toList();
      for (final oldId in oldestIds) {
        _orderedIds.remove(oldId);
      }
    }

    state = Set<String>.from(_orderedIds);
    return true;
  }

  void clear() {
    _orderedIds.clear();
    state = <String>{};
  }
}

/// ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ê´€ë¦¬
final volumeTimeFrameStartTimesProvider = StateNotifierProvider<VolumeTimeFrameStartNotifier, Map<TimeFrame, DateTime>>((ref) {
  return VolumeTimeFrameStartNotifier();
});

class VolumeTimeFrameStartNotifier extends StateNotifier<Map<TimeFrame, DateTime>> {
  VolumeTimeFrameStartNotifier() : super({}) {
    final now = DateTime.now();
    final newState = <TimeFrame, DateTime>{};

    for (final timeFrame in VolumeConfig.supportedTimeFrames) {
      newState[timeFrame] = now;
    }

    state = newState;
  }

  void updateStartTime(TimeFrame timeFrame, DateTime startTime) {
    state = {...state, timeFrame: startTime};
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ Processing Layer (Trade íŒ¨í„´)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì£¼ê¸°ì  ë¦¬ì…‹ íƒ€ì´ë¨¸
final volumeProcessingTimerProvider = StreamProvider((ref) {
  return Stream.periodic(AppConfig.globalResetInterval, (i) => i);
});

/// ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ íƒ€ì´ë¨¸ë“¤ (Trade êµ¬ì¡° ì ìš©)
final volumeResetTimersProvider = Provider<Map<TimeFrame, Timer>>((ref) {
  final timers = <TimeFrame, Timer>{};
  final startTimesNotifier = ref.read(volumeTimeFrameStartTimesProvider.notifier);
  final dataCacheNotifier = ref.read(volumeDataCacheProvider.notifier);

  void scheduleReset(TimeFrame timeFrame) {
    final now = DateTime.now();
    final startTime = ref.read(volumeTimeFrameStartTimesProvider)[timeFrame] ?? now;
    final nextReset = startTime.add(Duration(minutes: timeFrame.minutes));
    final delay = nextReset.difference(now);

    if (delay.isNegative) {
      dataCacheNotifier.resetTimeFrame(timeFrame);
      startTimesNotifier.updateStartTime(timeFrame, now);
      scheduleReset(timeFrame);
    } else {
      timers[timeFrame] = Timer(delay, () {
        dataCacheNotifier.resetTimeFrame(timeFrame);
        startTimesNotifier.updateStartTime(timeFrame, DateTime.now());
        scheduleReset(timeFrame);
      });
    }
  }

  for (final timeFrame in VolumeConfig.supportedTimeFrames) {
    scheduleReset(timeFrame);
  }

  ref.onDispose(() {
    for (final timer in timers.values) {
      timer.cancel();
    }
    timers.clear();
  });

  return timers;
});

// âœ… 2ë‹¨ê³„: ë°°ì¹˜ ì²˜ë¦¬ ë¡œì§ì„ ë‹¤ì‹œ êµ¬í˜„í•œ Provider
final rawVolumeProcessingProvider = StreamProvider<Trade>((ref) async* {
  log.i('ğŸš€ Volume processing with BATCHING started');

  final markets = await ref.read(marketsProvider.future);
  final repo = ref.read(repoProvider);
  final seenIdsNotifier = ref.read(volumeSeenIdsProvider.notifier);
  final dataCacheNotifier = ref.read(volumeDataCacheProvider.notifier);

  // ë°ì´í„°ë¥¼ ì„ì‹œë¡œ ëª¨ì•„ë‘˜ ë²„í¼
  final batchBuffer = <TimeFrame, Map<String, double>>{};
  for (final timeFrame in VolumeConfig.supportedTimeFrames) {
    batchBuffer[timeFrame] = <String, double>{};
  }

  // ì£¼ê¸°ì ìœ¼ë¡œ ë²„í¼ë¥¼ ë¹„ìš°ëŠ” íƒ€ì´ë¨¸
  final batchTimer = Timer.periodic(VolumeConfig.batchInterval, (timer) {
    dataCacheNotifier.addBatch(batchBuffer);
    // ë²„í¼ ë¹„ìš°ê¸°
    for (final map in batchBuffer.values) {
      map.clear();
    }
  });

  // ë¦¬ì…‹ íƒ€ì´ë¨¸ í™œì„±í™”
  ref.read(volumeResetTimersProvider);

  // Provider ì¢…ë£Œ ì‹œ íƒ€ì´ë¨¸ ì·¨ì†Œ
  ref.onDispose(() {
    batchTimer.cancel();
  });

  // Repository ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
  yield* repo.watchTrades(markets).where((trade) {
    final key = '${trade.market}/${trade.sequentialId}';
    if (!seenIdsNotifier.addId(key)) return false;

    // ëª¨ë“  ì§€ì› ì‹œê°„ëŒ€ì— ëŒ€í•´ ì§ì ‘ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ëŒ€ì‹ , ë²„í¼ì— ì¶”ê°€
    for (final timeFrame in VolumeConfig.supportedTimeFrames) {
      final bufferMap = batchBuffer[timeFrame]!;
      bufferMap[trade.market] = (bufferMap[trade.market] ?? 0.0) + trade.total;
    }

    return true; // ì´ where ì¡°ê±´ì€ ìŠ¤íŠ¸ë¦¼ í•„í„°ë§ì´ ì•„ë‹Œ ë²„í¼ ì¶”ê°€ìš©ì´ë¯€ë¡œ í•­ìƒ true
  });
});


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ AsyncNotifier ê¸°ë°˜ Public API Layer (Trade íŒ¨í„´ ì™„ì „ ì ìš©)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ“‹ AsyncNotifier ê¸°ë°˜ ë³¼ë¥¨ ëª©ë¡ Provider (StreamController ì™„ì „ ì œê±°)
class VolumeListNotifier extends AsyncNotifier<List<Volume>> {
  @override
  FutureOr<List<Volume>> build() async {
    log.i('ğŸš€ VolumeListNotifier build() started');

    // ì´ˆê¸° ìƒíƒœ
    final initialVolumes = _calculateVolumes();

    // ëª¨ë“  ìƒíƒœ ë³€í™” êµ¬ë… (Trade íŒ¨í„´)
    _setupStateListeners();

    return initialVolumes;
  }

  void _setupStateListeners() {
    // ì›ì‹œ ì²˜ë¦¬ ìŠ¤íŠ¸ë¦¼ í™œì„±í™” (Trade íŒ¨í„´)
    ref.listen(rawVolumeProcessingProvider, (previous, next) {
      next.when(
        data: (trade) => {}, // ë°ì´í„°ëŠ” ë²„í¼ì—ì„œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì—¬ê¸°ì„  ì•„ë¬´ê²ƒë„ ì•ˆ í•¨
        loading: () => {},
        error: (error, stack) => log.e('ğŸ’¥ Volume error: $error'),
      );
    });

    // ìƒíƒœ ë³€í™” ê°ì§€ (Trade íŒ¨í„´)
    ref.listen(volumeDataCacheProvider, (previous, next) {
      _updateVolumes();
    });

    ref.listen<TimeFrame>(volumeTimeFrameProvider, (prev, next) {
      if (prev != null && prev != next) {
        log.i('ğŸ• TimeFrame: ${prev.displayName} â†’ ${next.displayName}');
        _updateVolumes();
      }
    });
  }

  void _updateVolumes() {
    final newVolumes = _calculateVolumes();
    log.i('âœ… Filtered volumes: ${newVolumes.length}');

    // ğŸ”§ í•µì‹¬ ë³€í™”: StreamController ëŒ€ì‹  ì§ì ‘ state ì—…ë°ì´íŠ¸ (Trade íŒ¨í„´)
    state = AsyncValue.data(newVolumes);
  }

  List<Volume> _calculateVolumes() {
    final currentTimeFrame = ref.read(volumeTimeFrameProvider);
    final dataCache = ref.read(volumeDataCacheProvider);
    final startTimes = ref.read(volumeTimeFrameStartTimesProvider);
    final usecase = ref.read(volumeUsecaseProvider);

    final volumeMap = dataCache[currentTimeFrame] ?? <String, double>{};
    final startTime = startTimes[currentTimeFrame] ?? DateTime.now();

    // UseCase í˜¸ì¶œ ì‹œ String ë³€í™˜ (ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜)
    return usecase.calculateVolumeList(volumeMap, currentTimeFrame.key, startTime);
  }
}

/// ğŸ“‹ AsyncNotifier ê¸°ë°˜ Provider (ë‹¤ì¤‘ StreamController ì™„ì „ ì œê±°)
final volumeListProvider = AsyncNotifierProvider<VolumeListNotifier, List<Volume>>(() {
  return VolumeListNotifier();
});

/// í˜¸í™˜ì„±ì„ ìœ„í•œ VolumeEvent ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€)
final volumeDataProvider = StreamProvider<VolumeEvent>((ref) {
  // ìŠ¤íŠ¸ë¦¼ì„ ìˆ˜ë™ìœ¼ë¡œ ì œì–´í•  ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
  final controller = StreamController<VolumeEvent>();

  ref.keepAlive();

  // volumeListProviderì˜ ìƒíƒœ ë³€í™”ë¥¼ ê°ì§€(listen)í•©ë‹ˆë‹¤.
  ref.listen<AsyncValue<List<Volume>>>(
    volumeListProvider,
    (previous, next) {
      // ë°ì´í„°ê°€ ìˆì„ ë•Œë§Œ (ë¡œë”©, ì—ëŸ¬ ì œì™¸)
      if (next.hasValue && !next.isLoading) {
        // VolumeEventë¡œ ë³€í™˜í•˜ì—¬ ì»¨íŠ¸ë¡¤ëŸ¬ì— ì¶”ê°€í•©ë‹ˆë‹¤.
        controller.add(VolumeEvent(next.value!));
      }
      // ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
      else if (next.hasError) {
        controller.addError(next.error!, next.stackTrace);
      }
    },
    // ì¦‰ì‹œ ì‹¤í–‰ ì˜µì…˜ìœ¼ë¡œ ì´ˆê¸° ë°ì´í„°ë„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³´ëƒ…ë‹ˆë‹¤.
    fireImmediately: true,
  );

  // Providerê°€ íŒŒê´´ë  ë•Œ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ë‹«ì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
  ref.onDispose(() {
    controller.close();
  });

  // ìƒì„±ëœ ì»¨íŠ¸ë¡¤ëŸ¬ì˜ ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
  return controller.stream;
});


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›ï¸ Controller Helper (Trade íŒ¨í„´)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

final volumeTimeFrameController = Provider((ref) => VolumeTimeFrameController(ref));

class VolumeTimeFrameController {
  final Ref ref;
  VolumeTimeFrameController(this.ref);

  /// íƒ€ì… ì•ˆì „ ì‹œê°„ëŒ€ ì„¤ì • (Trade íŒ¨í„´)
  void setTimeFrame(TimeFrame timeFrame, int index) {
    final timeFrames = VolumeConfig.supportedTimeFrames;
    if (index < 0 || index >= timeFrames.length) {
      log.w('Invalid timeFrame index: $index');
      return;
    }

    ref.read(volumeTimeFrameProvider.notifier).state = timeFrame;
    ref.read(volumeTimeFrameIndexProvider.notifier).state = index;

    log.i('ğŸ• Volume TimeFrame: ${timeFrame.displayName}');
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€ ë¦¬ì…‹
  void resetCurrentTimeFrame() {
    final timeFrame = ref.read(volumeTimeFrameProvider);
    final dataCacheNotifier = ref.read(volumeDataCacheProvider.notifier);

    dataCacheNotifier.resetTimeFrame(timeFrame);
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ë¦¬ì…‹
  void resetAllTimeFrames() {
    final dataCacheNotifier = ref.read(volumeDataCacheProvider.notifier);

    dataCacheNotifier.resetAll();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ê³„ì‚°
  DateTime? getNextResetTime() {
    final timeFrame = ref.read(volumeTimeFrameProvider);
    final startTimes = ref.read(volumeTimeFrameStartTimesProvider);
    final startTime = startTimes[timeFrame];

    return startTime?.add(Duration(minutes: timeFrame.minutes));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ íƒ€ì… ì•ˆì „ Getterë“¤ (Trade íŒ¨í„´)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  TimeFrame get currentTimeFrame => ref.read(volumeTimeFrameProvider);
  int get currentIndex => ref.read(volumeTimeFrameIndexProvider);
  List<TimeFrame> get availableTimeFrames => VolumeConfig.supportedTimeFrames;

  String getTimeFrameName(TimeFrame timeFrame) => timeFrame.displayName;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”„ í˜¸í™˜ì„± ë©”ì„œë“œë“¤ (ê¸°ì¡´ ì½”ë“œ ì§€ì›)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í˜¸í™˜ì„±: String í‚¤ë¡œ ì‹œê°„ëŒ€ ì„¤ì •
  void setTimeFrameByKey(String timeFrameKey, int index) {
    final timeFrame = TimeFrame.fromKey(timeFrameKey);
    setTimeFrame(timeFrame, index);
  }

  /// í˜¸í™˜ì„±: ë¶„ìœ¼ë¡œ ì‹œê°„ëŒ€ ì„¤ì •
  void setTimeFrameByMinutes(int minutes, int index) {
    final timeFrame = TimeFrame.fromMinutes(minutes);
    setTimeFrame(timeFrame, index);
  }

  /// í˜¸í™˜ì„±: String í‚¤ ë°˜í™˜
  String get currentTimeFrameKey => currentTimeFrame.key;

  /// í˜¸í™˜ì„±: String í‚¤ ëª©ë¡
  List<String> get availableTimeFrameKeys => availableTimeFrames.keys;
}\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../domain/entities/volume.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/repositories/trade_repository.dart';

/// VolumeRepository - TradeRepository êµ¬ë…í•˜ëŠ” ë°ì´í„° ê³„ì¸µ
class VolumeRepositoryImpl implements VolumeRepository {
  final TradeRepository _tradeRepository;

  bool _disposed = false;

  VolumeRepositoryImpl(this._tradeRepository);

  @override
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets) {
    if (_disposed) {
      return const Stream.empty();
    }

    debugPrint('VolumeRepository: watchVolumeByTimeFrame() - $timeFrame, ${markets.length} markets');
    
    return _tradeRepository.watchTrades(markets)
        .map((trade) => <Volume>[])
        .asBroadcastStream();
  }

  @override
  void resetTimeFrame(String timeFrame) {
  }

  @override
  void resetAllTimeFrames() {
  }

  @override
  DateTime? getNextResetTime(String timeFrame) {
    return null;
  }

  @override
  List<String> getActiveTimeFrames() {
    return [];
  }

  @override
  bool isTimeFrameActive(String timeFrame) {
    return true;
  }

  @override
  Future<void> dispose() async {
    if (_disposed) return;
    
    debugPrint('VolumeRepository: dispose() called');
    _disposed = true;
    
    debugPrint('VolumeRepository: dispose completed');
  }
}\n\n// ====== lib/data/models/volume_dto.dart ======\n
\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
// lib/domain/repositories/volume_repository.dart

import '../entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import

/// ë³¼ë¥¨ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ëˆ„ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class VolumeRepository {
  /// ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ìŠ¤íŠ¸ë¦¼ ì œê³µ (Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³¼ë¥¨ìˆœ ì •ë ¬)
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import '../../core/config/app_config.dart';
import '../entities/volume.dart';
import '../repositories/trade_repository.dart';

/// ğŸ”¥ VolumeUsecase - ìˆœìˆ˜ ê³„ì‚° í•¨ìˆ˜ë“¤ë§Œ ë‹´ë‹¹ (ë¦¬íŒ©í† ë§ë¨)
/// - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
/// - ë³¼ë¥¨ ë°ì´í„° ë³€í™˜ ë° ê³„ì‚°
/// - ìƒíƒœ ê´€ë¦¬ëŠ” ëª¨ë‘ Providerë¡œ ì´ì „ë¨
class VolumeUsecase {
  final TradeRepository _volumeRepo;

  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int maxVolumes = 200;
  static const int maxCacheSize = 1000;

  VolumeUsecase(this._volumeRepo);

  /// ğŸ¯ ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ê³„ì‚° (ìˆœìˆ˜ í•¨ìˆ˜)
  /// Providerì—ì„œ í˜¸ì¶œ: usecase.calculateVolumeList(volumeMap, timeFrame, startTime)
  List<Volume> calculateVolumeList(
    Map<String, double> volumeMap,
    String timeFrame,
    DateTime startTime,
  ) {
    if (!isValidTimeFrame(timeFrame)) {
      return <Volume>[];
    }

    final now = DateTime.now();
    
    // Volume ê°ì²´ ìƒì„±
    final volumeList = volumeMap.entries
        .where((entry) => entry.value > 0) // ë³¼ë¥¨ì´ 0ë³´ë‹¤ í° ê²ƒë§Œ
        .map((entry) => Volume(
              market: entry.key,
              totalVolume: entry.value,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame,
              timeFrameStartMs: startTime.millisecondsSinceEpoch,
            ))
        .toList();

    // ë³¼ë¥¨ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ìˆœ)
    volumeList.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    
    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    return volumeList.take(maxVolumes).toList();
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isValidTimeFrame(String timeFrame) {
    final activeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    return activeFrames.contains(timeFrame);
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ (ìˆœìˆ˜ í•¨ìˆ˜)
  int? parseTimeFrameMinutes(String timeFrame) {
    return int.tryParse(timeFrame.replaceAll('m', ''));
  }

  /// ğŸ¯ ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ê³„ì‚° (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  DateTime? calculateNextResetTime(String timeFrame, DateTime startTime) {
    final minutes = parseTimeFrameMinutes(timeFrame);
    if (minutes == null) return null;
    
    return startTime.add(Duration(minutes: minutes));
  }

  /// ğŸ¯ ë³¼ë¥¨ ë°ì´í„° í•„í„°ë§ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> filterVolumesByMinimum(List<Volume> volumes, double minimumVolume) {
    return volumes.where((v) => v.totalVolume >= minimumVolume).toList();
  }

  /// ğŸ¯ ë³¼ë¥¨ ëª©ë¡ì„ ë³¼ë¥¨ ìˆœìœ¼ë¡œ ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> sortVolumesByAmount(List<Volume> volumes, {bool descending = true}) {
    final sorted = List<Volume>.from(volumes);
    if (descending) {
      sorted.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    } else {
      sorted.sort((a, b) => a.totalVolume.compareTo(b.totalVolume));
    }
    return sorted;
  }

  /// ğŸ¯ ë³¼ë¥¨ ëª©ë¡ í¬ê¸° ì œí•œ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> limitVolumeCount(List<Volume> volumes, [int? maxCount]) {
    final limit = maxCount ?? maxVolumes;
    return volumes.length > limit ? volumes.take(limit).toList() : volumes;
  }

  /// ğŸ¯ ìœ íš¨í•œ ë³¼ë¥¨ì¸ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isValidVolume(Volume volume) {
    return volume.market.isNotEmpty &&
           volume.totalVolume > 0 &&
           volume.lastUpdatedMs > 0 &&
           volume.timeFrame.isNotEmpty;
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë§µì—ì„œ ì´ ë³¼ë¥¨ ê³„ì‚° (ìˆœìˆ˜ í•¨ìˆ˜)
  double calculateTotalVolume(Map<String, double> volumeMap) {
    return volumeMap.values.fold(0.0, (sum, volume) => sum + volume);
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë§µì—ì„œ ë§ˆì¼“ ìˆ˜ ê³„ì‚° (ìˆœìˆ˜ í•¨ìˆ˜)
  int getActiveMarketCount(Map<String, double> volumeMap) {
    return volumeMap.entries.where((entry) => entry.value > 0).length;
  }

  /// ğŸ¯ ë³¼ë¥¨ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í–ˆëŠ”ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isVolumeAboveThreshold(double volume, double threshold) {
    return volume > threshold;
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isTimeFrameActive(String timeFrame) {
    final activeFrames = getActiveTimeFrames();
    return activeFrames.contains(timeFrame);
  }

  /// ğŸ¯ í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ (ì„¤ì • ê¸°ë°˜)
  List<String> getActiveTimeFrames() {
    return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ í‘œì‹œ ì´ë¦„ ì¡°íšŒ (ìœ í‹¸ë¦¬í‹°)
  String getTimeFrameDisplayName(String timeFrame) {
    final minutes = parseTimeFrameMinutes(timeFrame);
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }

  /// ğŸ¯ ë³¼ë¥¨ í¬ë§·íŒ… (ìœ í‹¸ë¦¬í‹°)
  String formatVolume(double volume) {
    if (volume >= 1000000000) {
      return '${(volume / 1000000000).toStringAsFixed(1)}B';
    } else if (volume >= 1000000) {
      return '${(volume / 1000000).toStringAsFixed(1)}M';
    } else if (volume >= 1000) {
      return '${(volume / 1000).toStringAsFixed(1)}K';
    }
    return volume.toStringAsFixed(0);
  }

  /// ğŸ¯ ë¦¬ì…‹ê¹Œì§€ ë‚¨ì€ ì‹œê°„ ê³„ì‚° (ìœ í‹¸ë¦¬í‹°)
  Duration? getTimeUntilReset(String timeFrame, DateTime startTime) {
    final nextReset = calculateNextResetTime(timeFrame, startTime);
    if (nextReset == null) return null;
    
    final now = DateTime.now();
    final remaining = nextReset.difference(now);
    
    return remaining.isNegative ? Duration.zero : remaining;
  }

  /// ğŸ¯ ë§ˆì¼“ì´ KRW ë§ˆì¼“ì¸ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isKrwMarket(String market) {
    return market.startsWith('KRW-');
  }

  /// ğŸ¯ ë³¼ë¥¨ ìˆœìœ„ ê³„ì‚° (ìˆœìˆ˜ í•¨ìˆ˜)
  Map<String, int> calculateVolumeRanks(List<Volume> volumes) {
    final ranks = <String, int>{};
    for (int i = 0; i < volumes.length; i++) {
      ranks[volumes[i].market] = i + 1;
    }
    return ranks;
  }

  /// ğŸ¯ ì‹œê°„ëŒ€ë³„ ì§„í–‰ë¥  ê³„ì‚° (ìœ í‹¸ë¦¬í‹°)
  double calculateTimeFrameProgress(String timeFrame, DateTime startTime) {
    final minutes = parseTimeFrameMinutes(timeFrame);
    if (minutes == null) return 0.0;
    
    final now = DateTime.now();
    final elapsed = now.difference(startTime);
    final totalDuration = Duration(minutes: minutes);
    
    final progress = elapsed.inMilliseconds / totalDuration.inMilliseconds;
    return progress.clamp(0.0, 1.0);
  }
}\n\n// ====== lib/domain/entities/volume.dart ======\n
// lib/domain/entities/volume.dart

import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë³¼ë¥¨ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Volume extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì´ ê±°ë˜ëŸ‰ (ì›í™” ê¸°ì¤€)
  final double totalVolume;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Volume({
    required this.market,
    required this.totalVolume,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    totalVolume,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³¼ë¥¨ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ë³´ë‹¤ í¼)
  bool get hasVolume => totalVolume > 0;
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Volume copyWith({
    String? market,
    double? totalVolume,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Volume(
      market: market ?? this.market,
      totalVolume: totalVolume ?? this.totalVolume,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
// lib/presentation/controllers/volume_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../../domain/usecases/volume_usecase.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ë¦¬íŒ©í† ë§ëœ VolumeController (ìƒˆ AsyncNotifier Provider êµ¬ì¡° ì ìš©)
class VolumeController extends StateNotifier<VolumeControllerState> with RankHotMixin {
  final Ref _ref;
  final VolumeUsecase _usecase;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ ì €ì¥ (ë¸”ë§í¬ë§Œ, HOTì€ Mixinì—ì„œ ê´€ë¦¬)
  final Map<String, bool> _blinkStates = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  VolumeController(this._usecase, this._ref) : super(const VolumeControllerState()) {
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStates.clear();
  }

  /// ğŸ”¥ ìƒˆ AsyncNotifier Provider êµ¬ì¡°ì— ë§ì¶˜ ë°ì´í„° êµ¬ë…
  void _initializeDataSubscription() {
    // âœ… AsyncNotifier ê¸°ë°˜ volumeListProvider êµ¬ë…
    final volumeSubscription = _ref.listen(
      volumeListProvider,
      (previous, next) {
        next.when(
          data: (volumes) {
            _processVolumeData(volumes);
          },
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(volumeSubscription);

    // âœ… ì‹œê°„ëŒ€ ë³€ê²½ ê°ì§€ (TimeFrame Enum ê¸°ë°˜)
    final timeFrameSubscription = _ref.listen(
      volumeTimeFrameProvider,
      (previous, next) {
        if (previous != null && previous != next) {
          // ì‹œê°„ëŒ€ ë³€ê²½ì‹œ HOT ìƒíƒœ ì´ˆê¸°í™” (ì‹œê°„ëŒ€ë³„ ë…ë¦½)
          _initializeTimeFrameStates(next);
        }
      },
    );
    _subscriptions.add(timeFrameSubscription);
  }

  /// âœ… ì‹œê°„ëŒ€ë³„ ìƒíƒœ ì´ˆê¸°í™” (ë…ë¦½ì  ê´€ë¦¬)
  void _initializeTimeFrameStates(TimeFrame timeFrame) {
    initializeTimeFrame(timeFrame.key);
    _rankTracker.initializeTimeFrame(timeFrame.key);
    _blinkStates.clear();
    
    // í˜„ì¬ ë³¼ë¥¨ ë°ì´í„°ë¡œ ìƒíƒœ ì¬ê³„ì‚°
    final volumesAsync = _ref.read(volumeListProvider);
    volumesAsync.whenData((volumes) => _processVolumeData(volumes));
  }

  /// âœ… ë³¼ë¥¨ ë°ì´í„° ì²˜ë¦¬ - ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
  void _processVolumeData(List<Volume> volumes) {
    // 1. ë°ì´í„° ì •ë ¬ ë° ì œí•œ
    final processedVolumes = _applySorting(volumes);
    
    // 2. ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° (build ë°–ì—ì„œ!)
    _calculateAllStates(processedVolumes);
    
    // 3. ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      volumes: processedVolumes,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - ì‹œê°„ëŒ€ë³„ ë…ë¦½
  void _calculateAllStates(List<Volume> sortedVolumes) {
    final currentTimeFrame = this.currentTimeFrame;
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™”
    initializeTimeFrame(currentTimeFrame);
    _rankTracker.initializeTimeFrame(currentTimeFrame);
    
    // âœ… ë¸”ë§í¬ ìƒíƒœë§Œ ì´ˆê¸°í™” (HOTì€ Mixinì´ ê´€ë¦¬)
    _blinkStates.clear();
    
    for (int i = 0; i < sortedVolumes.length; i++) {
      final volume = sortedVolumes[i];
      final market = volume.market;
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœëŠ” Mixinì—ì„œ ì§ì ‘ ê´€ë¦¬
      checkIfHot(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
        menuType: 'volume', 
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (RankTracker ì‚¬ìš©)
      _blinkStates[market] = _rankTracker.checkRankChange(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrame,
      );
    }
  }

  /// âœ… ë°ì´í„° ì •ë ¬ ë° ì œí•œ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Volume> _applySorting(List<Volume> volumeData) {
    // UseCaseì˜ ìˆœìˆ˜ í•¨ìˆ˜ ì‚¬ìš©
    final filteredData = _usecase.filterVolumesByMinimum(volumeData, 0);
    final sortedData = _usecase.sortVolumesByAmount(filteredData, descending: true);
    
    // í˜„ì¬ ì„¤ì •ì— ë”°ë¼ 50ê°œ ë˜ëŠ” 100ê°œë¡œ ì œí•œ
    final int limit = state.isTop100 ? 100 : 50;
    return _usecase.limitVolumeCount(sortedData, limit);
  }

  /// âœ… Top 50/100 í† ê¸€
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
    
    // ê¸°ì¡´ ë°ì´í„°ë¡œ ì¬ì²˜ë¦¬
    if (state.volumes.isNotEmpty) {
      final volumesAsync = _ref.read(volumeListProvider);
      volumesAsync.whenData((volumes) => _processVolumeData(volumes));
    }
  }

  /// ğŸ”¥ ì‹œê°„ëŒ€ ë³€ê²½ - ìƒˆ Controllerë¡œ ìœ„ì„ (TimeFrame Enum ì‚¬ìš©)
  void setTimeFrame(TimeFrame timeFrame, int index) {
    // âœ… ìƒˆ VolumeTimeFrameController ì‚¬ìš©
    _ref.read(volumeTimeFrameController).setTimeFrame(timeFrame, index);
  }

  /// ğŸ”„ í˜¸í™˜ì„±: String í‚¤ë¡œ ì‹œê°„ëŒ€ ë³€ê²½
  void setTimeFrameByKey(String timeFrame, int index) {
    // âœ… ìƒˆ Controllerì˜ í˜¸í™˜ì„± ë©”ì„œë“œ ì‚¬ìš©
    _ref.read(volumeTimeFrameController).setTimeFrameByKey(timeFrame, index);
  }

  /// âœ… í˜„ì¬ í‘œì‹œ ê°œìˆ˜
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// âœ… í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (Mixinì˜ í˜„ì¬ HOT ì•„ì´í…œ ëª©ë¡ì—ì„œ í™•ì¸)
  bool isHot(String market) {
    final hotItems = getHotItems(currentTimeFrame);
    return hotItems.contains(market);
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ (buildì—ì„œ ì•ˆì „í•˜ê²Œ í˜¸ì¶œ ê°€ëŠ¥)
  bool shouldBlink(String market) {
    return _blinkStates[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ í˜¸ì¶œ)
  void clearBlinkState(String market) {
    _blinkStates[market] = false;
    // ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ notify
    state = state.copyWith();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ TimeFrame ê´€ë ¨ ë©”ì„œë“œë“¤ - ìƒˆ Provider êµ¬ì¡° í™œìš©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// âœ… í˜„ì¬ ì‹œê°„ëŒ€ (TimeFrame Enum)
  TimeFrame get currentTimeFrameEnum => _ref.read(volumeTimeFrameProvider);
  
  /// âœ… í˜„ì¬ ì‹œê°„ëŒ€ (String í‚¤ - í˜¸í™˜ì„±)
  String get currentTimeFrame => currentTimeFrameEnum.key;
  
  /// âœ… í˜„ì¬ ì¸ë±ìŠ¤
  int get currentIndex => _ref.read(volumeTimeFrameIndexProvider);
  
  /// âœ… ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë“¤ (TimeFrame Enum ë¦¬ìŠ¤íŠ¸)
  List<TimeFrame> get availableTimeFrameEnums => VolumeConfig.supportedTimeFrames;
  
  /// âœ… ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë“¤ (String í‚¤ ë¦¬ìŠ¤íŠ¸ - í˜¸í™˜ì„±)
  List<String> get availableTimeFrames => availableTimeFrameEnums.keys;

  /// âœ… ì‹œê°„ëŒ€ í‘œì‹œ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
  String getTimeFrameName(String timeFrame) {
    final timeFrameEnum = TimeFrame.fromKey(timeFrame);
    return timeFrameEnum.displayName;
  }

  /// âœ… í˜„ì¬ ì‹œê°„ëŒ€ ë¦¬ì…‹
  void resetCurrentTimeFrame() {
    _ref.read(volumeTimeFrameController).resetCurrentTimeFrame();
  }

  /// âœ… ëª¨ë“  ì‹œê°„ëŒ€ ë¦¬ì…‹
  void resetAllTimeFrames() {
    _ref.read(volumeTimeFrameController).resetAllTimeFrames();
  }

  /// âœ… ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„
  DateTime? getNextResetTime() {
    return _ref.read(volumeTimeFrameController).getNextResetTime();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ UseCase í™œìš© ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// âœ… ë³¼ë¥¨ í¬ë§·íŒ… (UseCase í™œìš©)
  String formatVolume(double volume) {
    return _usecase.formatVolume(volume);
  }

  /// âœ… ì‹œê°„ëŒ€ ì§„í–‰ë¥  ê³„ì‚° (UseCase í™œìš©)
  double getTimeFrameProgress() {
    final timeFrame = currentTimeFrame;
    final now = DateTime.now();
    
    return _usecase.calculateTimeFrameProgress(timeFrame, now);
  }

  /// âœ… ë¦¬ì…‹ê¹Œì§€ ë‚¨ì€ ì‹œê°„ (UseCase í™œìš©)
  Duration? getTimeUntilReset() {
    final timeFrame = currentTimeFrame;
    final now = DateTime.now();
    
    return _usecase.getTimeUntilReset(timeFrame, now);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ” ë””ë²„ê¹… ë° ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// âœ… ë””ë²„ê¹…ìš© ë¸”ë§í¬ ì •ë³´
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  /// âœ… ë””ë²„ê¹…ìš© í˜„ì¬ ìƒíƒœ ì •ë³´
  Map<String, dynamic> getDebugInfo() {
    return {
      'currentTimeFrame': currentTimeFrame,
      'currentIndex': currentIndex,
      'volumeCount': state.volumes.length,
      'isTop100': state.isTop100,
      'isLoading': state.isLoading,
      'hotItemsCount': getHotItems(currentTimeFrame).length,
      'blinkStatesCount': _blinkStates.length,
    };
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬ (ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œ ê¶Œì¥)
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStates.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class VolumeControllerState {
  final List<Volume> volumes;      // ì •ë ¬ëœ ë³¼ë¥¨ ë°ì´í„°
  final bool isTop100;            // Top 50/100 ëª¨ë“œ
  final bool isLoading;           // ë¡œë”© ìƒíƒœ
  final String? errorMessage;     // ì—ëŸ¬ ë©”ì‹œì§€

  const VolumeControllerState({
    this.volumes = const [],
    this.isTop100 = false,
    this.isLoading = false,
    this.errorMessage,
  });

  VolumeControllerState copyWith({
    List<Volume>? volumes,
    bool? isTop100,
    bool? isLoading,
    String? errorMessage,
  }) {
    return VolumeControllerState(
      volumes: volumes ?? this.volumes,
      isTop100: isTop100 ?? this.isTop100,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }

  @override
  String toString() {
    return 'VolumeControllerState('
        'volumes: ${volumes.length}, '
        'isTop100: $isTop100, '
        'isLoading: $isLoading, '
        'errorMessage: $errorMessage)';
  }
}

/// âœ… Provider ì„ ì–¸ (ìƒˆ Provider êµ¬ì¡° í™œìš©)
final volumeControllerProvider = StateNotifierProvider<VolumeController, VolumeControllerState>(
  (ref) {
    final usecase = ref.read(volumeUsecaseProvider);
    return VolumeController(usecase, ref);
  },
);\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
// lib/presentation/pages/volume_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/di/volume_provider.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';

class VolumePage extends ConsumerWidget {
  final ScrollController scrollController;

  const VolumePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (íƒ€ì… ì•ˆì „ ë²„ì „)
    final state = ref.watch(volumeControllerProvider);
    final controller = ref.read(volumeControllerProvider.notifier);

    // âœ… íƒ€ì… ì•ˆì „ ì‹œê°„ëŒ€ ì •ë³´ (ìƒˆ Provider êµ¬ì¡° í™œìš©)
    final currentTimeFrame = controller.currentTimeFrameEnum;  // TimeFrame Enum ì§ì ‘ ì‚¬ìš©
    final availableTimeFrames = controller.availableTimeFrameEnums;  // TimeFrame Enum ë¦¬ìŠ¤íŠ¸
    final currentIndex = controller.currentIndex;

    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ (3-way ë ˆì´ì•„ì›ƒ, TimeFrame Enum ê¸°ë°˜)
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${currentTimeFrame.displayName}',
      sliderValue: currentIndex.toDouble(),
      sliderMin: 0.0,
      sliderMax: (availableTimeFrames.length - 1).toDouble(),
      sliderDivisions: availableTimeFrames.length - 1,
      sliderLabel: currentTimeFrame.displayName,
      onSliderChanged: (value) {
        final index = value.round();
        if (index >= 0 && index < availableTimeFrames.length) {
          final selectedTimeFrame = availableTimeFrames[index];
          // âœ… ìƒˆ Controllerì˜ TimeFrame Enum ë©”ì„œë“œ ì‚¬ìš©
          controller.setTimeFrame(selectedTimeFrame, index);
        }
      },
      centerWidget: CommonToggleButton(
        text: controller.currentLimitName,
        isActive: state.isTop100,
        onTap: () => controller.toggleTopLimit(),
      ),
      rightWidget: CommonCountdownWidget(
        nextResetTime: controller.getNextResetTime(),
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(
            child: _buildVolumeList(
              state,
              controller,
              availableTimeFrames,
              currentIndex,
              context,
            ),
          ),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (ê³µí†µ ìœ„ì ¯ ì‚¬ìš© + TimeFrame Enum íŒŒë¼ë¯¸í„°)
  Widget _buildVolumeList(
    VolumeControllerState state,
    VolumeController controller,
    List<TimeFrame> availableTimeFrames,  // TimeFrame Enum ë¦¬ìŠ¤íŠ¸
    int currentIndex,
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ë³¼ë¥¨ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„° (TimeFrame Enum ì‹œê°„ëŒ€ í‘œì‹œ í¬í•¨)
    if (state.volumes.isEmpty) {
      final currentTimeFrame = availableTimeFrames[currentIndex];
      return Center(
        child: Text(
          'ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${currentTimeFrame.displayName})',
          textAlign: TextAlign.center,
          style: TextStyle(
            color: Theme.of(context).hintColor,
            fontSize: 16,
          ),
        ),
      );
    }

    // âœ… ê³µí†µ ìŠ¤í¬ë¡¤ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ì‚¬ìš© (ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ í™œìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.volumes.length,
      itemBuilder: (_, i) {
        final volume = state.volumes[i];
        final rank = i + 1;
        
        return VolumeTile(
          market: volume.market,
          totalVolume: volume.totalVolume,
          rank: rank,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ (ë¯¸ë¦¬ ê³„ì‚°ëœ ìƒíƒœ ì‚¬ìš©)
          isHot: controller.isHot(volume.market),
          shouldBlink: controller.shouldBlink(volume.market),
        );
      },
    );
  }
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/volume_controller.dart';

class VolumeTile extends ConsumerStatefulWidget {
  final String market;
  final double totalVolume;
  final int rank;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  
  const VolumeTile({
    Key? key, 
    required this.market,
    required this.totalVolume,
    required this.rank,
    required this.isHot,
    required this.shouldBlink,
  }) : super(key: key);

  @override
  ConsumerState<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends ConsumerState<VolumeTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (ì„¤ì • ì²´í¬ + Controller ìƒíƒœ ì´ˆê¸°í™”)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­
            ref.read(volumeControllerProvider.notifier).clearBlinkState(widget.market);
          }
        });
      }
    });
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜ (ì„¤ì • ì²´í¬ - ë¸”ë§í¬ì™€ ë™ì¼í•œ íŒ¨í„´)
                    Consumer(
                      builder: (context, ref, child) {
                        final hotEnabled = ref.watch(appSettingsProvider).hotEnabled;
                        if (hotEnabled && widget.isHot) {
                          return TileCommon.buildHotIcon(true) ?? const SizedBox.shrink();
                        }
                        return const SizedBox.shrink();
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''),
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
                  
                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget(
                          totalAmount: widget.totalVolume,
                          isBuy: true,
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text(
                          AmountFormatter.formatVolume(widget.totalVolume),
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    // âœ… ë¸”ë§í¬ ìƒíƒœì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: Colors.amber,
      );
    }
    
    return cardWidget;
  }
}