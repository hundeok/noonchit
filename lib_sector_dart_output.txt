\n\n// ====== lib/core/di/sector_provider.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../utils/logger.dart';
import '../common/time_frame_manager.dart'; // ğŸ”¥ ê°„ì†Œí™”ëœ TimeFrame ì‹œìŠ¤í…œ ì‚¬ìš©
import '../common/time_frame_types.dart';   // ğŸ”¥ ê³µí†µ íƒ€ì… ì‚¬ìš©
import 'volume_provider.dart';
import '../../domain/entities/volume.dart';
import '../../shared/widgets/sector_classification.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ ì„¹í„° ì´ë²¤íŠ¸ í´ë˜ìŠ¤ (ê¸°ì¡´ ìœ ì§€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@immutable
class SectorVolumeEvent {
  final List<Volume> volumes;
  final TimeFrame timeFrame;
  final bool isReset;
  final DateTime? resetTime;
  final DateTime eventTime;

  const SectorVolumeEvent({
    required this.volumes,
    required this.timeFrame,
    this.isReset = false,
    this.resetTime,
    required this.eventTime,
  });

  factory SectorVolumeEvent.data({
    required List<Volume> volumes,
    required TimeFrame timeFrame,
  }) {
    return SectorVolumeEvent(
      volumes: volumes,
      timeFrame: timeFrame,
      eventTime: DateTime.now(),
    );
  }

  factory SectorVolumeEvent.reset({
    required TimeFrame timeFrame,
    DateTime? resetTime,
  }) {
    final now = resetTime ?? DateTime.now();
    return SectorVolumeEvent(
      volumes: const [],
      timeFrame: timeFrame,
      isReset: true,
      resetTime: now,
      eventTime: now,
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ ê¸°ë³¸ Providerë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì„¹í„° ë¶„ë¥˜ Provider (ê¸°ì¡´ ìœ ì§€)
final sectorClassificationProvider = ChangeNotifierProvider<SectorClassificationProvider>(
  (ref) => SectorClassificationProvider(),
);

/// ğŸ”¥ ì„¹í„° ì „ìš© ì‹œê°„ëŒ€ Provider (Volumeê³¼ ë…ë¦½)
final selectedSectorTimeFrameProvider = StateProvider<TimeFrame>((ref) => TimeFrame.min1);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ ë©”ì¸ ì„¹í„° ë³¼ë¥¨ Provider - ê°„ì†Œí™”ëœ ì‹œìŠ¤í…œ ì—°ë™
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì„¹í„° ë³¼ë¥¨ ë°ì´í„° Provider (ê°„ì†Œí™”ëœ TimeFrame ì‹œìŠ¤í…œ ì—°ë™)
final sectorVolumeDataProvider = StreamProvider<SectorVolumeEvent>((ref) async* {
  ref.keepAlive();
  
  // ğŸ”¥ ì„¹í„° ì „ìš© ì‹œê°„ëŒ€ Provider ì‚¬ìš© (Volumeê³¼ ë…ë¦½)
  final selectedTimeFrame = ref.watch(selectedSectorTimeFrameProvider);
  final sectorClassification = ref.watch(sectorClassificationProvider);
  
  // ğŸ”¥ ê°„ì†Œí™”ëœ Volume ì‹œê°„ëŒ€ë³„ ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ ì§ì ‘ ë°›ê¸°
  final controllers = ref.read(volumeTimeFrameControllersProvider);
  final controller = controllers[selectedTimeFrame];
  
  if (controller == null) {
    if (AppConfig.enableTradeLog) {
      log.e('ğŸ’¥ Sector: Volume controller not found for $selectedTimeFrame');
    }
    return;
  }
  
  // Volume ìŠ¤íŠ¸ë¦¼ ë°”ì¸ë” í™œì„±í™”
  await ref.read(volumeStreamBinderProvider);
  
  if (AppConfig.enableTradeLog) {
    log.i('ğŸ”¥ Sector stream started: $selectedTimeFrame');
  }
  
  await for (final volumeEvent in controller.stream) {
    if (volumeEvent.isReset) {
      yield SectorVolumeEvent.reset(
        timeFrame: volumeEvent.timeFrame,
        resetTime: volumeEvent.resetTime,
      );
    } else {
      // ì„¹í„°ë³„ ì§‘ê³„
      final sectorVolumes = _aggregateVolumesBySector(
        volumeEvent.volumes,
        sectorClassification.currentSectors,
      );
      
      yield SectorVolumeEvent.data(
        volumes: sectorVolumes,
        timeFrame: volumeEvent.timeFrame,
      );
    }
  }
});

/// í˜„ì¬ ì„¹í„° ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (ê¸°ì¡´ ìœ ì§€)
final currentSectorVolumeListProvider = Provider<List<Volume>>((ref) {
  final sectorEvent = ref.watch(sectorVolumeDataProvider).valueOrNull;
  return sectorEvent?.volumes ?? [];
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ ì„¹í„°ë³„ ì§‘ê³„ ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

List<Volume> _aggregateVolumesBySector(
  List<Volume> coinVolumes,
  Map<String, List<String>> sectorMapping,
) {
  if (coinVolumes.isEmpty) return [];
  
  final Map<String, double> sectorVolumeMap = {};
  final sampleVolume = coinVolumes.first;
  
  // ê° ì½”ì¸ì„ í•´ë‹¹ ì„¹í„°ì— í•©ì‚°
  for (final coinVolume in coinVolumes) {
    final ticker = coinVolume.market.replaceFirst('KRW-', '');
    
    sectorMapping.forEach((sectorName, coins) {
      if (coins.contains(ticker)) {
        sectorVolumeMap[sectorName] = 
          (sectorVolumeMap[sectorName] ?? 0.0) + coinVolume.totalVolume;
      }
    });
  }
  
  // ë³¼ë¥¨ì´ 0ì¸ ì„¹í„° ì œê±°í•˜ê³  Volume ê°ì²´ë¡œ ë³€í™˜
  final sectorVolumes = sectorVolumeMap.entries
      .where((entry) => entry.value > 0)
      .map((entry) => Volume(
            market: 'SECTOR-${entry.key}',
            totalVolume: entry.value,
            lastUpdatedMs: sampleVolume.lastUpdatedMs,
            timeFrame: sampleVolume.timeFrame,
            timeFrameStartMs: sampleVolume.timeFrameStartMs,
          ))
      .toList();
  
  // ë³¼ë¥¨ ìˆœ ì •ë ¬
  sectorVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
  
  return sectorVolumes;
}\n\n// ====== lib/shared/widgets/sector_logo_provider.dart ======\n
// ğŸš€ ìºì‹œ ì‹œìŠ¤í…œì´ ì ìš©ëœ ì„¹í„° ë¡œê³  í”„ë¡œë°”ì´ë”

import 'package:flutter/material.dart';

/// ğŸ¨ ì„¹í„° ë¡œê³  ê´€ë¦¬ ì „ìš© Provider
/// ìºì‹œ ì‹œìŠ¤í…œ + WebP ì§€ì›
class SectorLogoProvider {
  
  /// ğŸ†• ë©”ëª¨ë¦¬ ìºì‹œ (ìœ„ì ¯ ë ˆë²¨ ìºì‹±)
  static final Map<String, Widget> _widgetCache = {};
  
  /// ğŸ†• ìºì‹œ ì„¤ì •
  static const int _maxCacheObjects = 50; // ìµœëŒ€ 50ê°œ ì•„ì´ì½˜ ìºì‹œ
  
  /// ğŸš€ ìºì‹œëœ ì„¹í„° ë¡œê³  ìœ„ì ¯ ìƒì„± (ë©”ì¸ í•¨ìˆ˜)
  static Widget buildSectorIcon({
    required int sectorNumber,
    double size = 40.0,
  }) {
    final cacheKey = 'sector_${sectorNumber}_${size.toInt()}';
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
    if (_widgetCache.containsKey(cacheKey)) {
      return _widgetCache[cacheKey]!;
    }
    
    // ìƒˆë¡œìš´ ìœ„ì ¯ ìƒì„±
    final logoWidget = _buildSectorIconWidget(
      sectorNumber: sectorNumber,
      size: size,
    );
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì— ì €ì¥ (ìš©ëŸ‰ ì œí•œ)
    if (_widgetCache.length < _maxCacheObjects) {
      _widgetCache[cacheKey] = logoWidget;
    }
    
    return logoWidget;
  }

  /// ğŸ¯ ì‹¤ì œ ì„¹í„° ì•„ì´ì½˜ ìœ„ì ¯ ìƒì„±
  static Widget _buildSectorIconWidget({
    required int sectorNumber,
    required double size,
  }) {
    return SizedBox(
      width: size,
      height: size,
      child: Image.asset(
        'assets/icons/sector/sector$sectorNumber.webp',
        width: size,
        height: size,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return Container(
            width: size,
            height: size,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.grey.shade300,
            ),
            child: Center(
              child: Text(
                'ğŸ“Š',
                style: TextStyle(fontSize: size * 0.5),
              ),
            ),
          );
        },
      ),
    );
  }

  /// ğŸ§¹ ìºì‹œ ì •ë¦¬ í•¨ìˆ˜ë“¤
  static void clearCache() {
    _widgetCache.clear();
  }
  
  static void clearSpecificCache(int sectorNumber) {
    _widgetCache.removeWhere((key, value) => key.startsWith('sector_$sectorNumber'));
  }
  
  static int getCacheSize() {
    return _widgetCache.length;
  }

  /// ğŸ¯ ì„¹í„° ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì‚¬ (âœ… ìˆ˜ì •ëœ ë¶€ë¶„)
  static bool isValidSectorNumber(int sectorNumber) {
    // 46ì„ 47ë¡œ ë³€ê²½í•˜ì—¬ ìƒˆë¡œìš´ ì„¹í„° ë²ˆí˜¸ë¥¼ ìœ íš¨í•œ ë²”ìœ„ì— í¬í•¨ì‹œí‚µë‹ˆë‹¤.
    return sectorNumber >= 1 && sectorNumber <= 47;
  }

  /// ğŸ”§ ë””ë²„ê¹…ìš©: ìºì‹œ ìƒíƒœ ì •ë³´
  static Map<String, dynamic> getCacheStatus() {
    return {
      'totalCached': _widgetCache.length,
      'maxCapacity': _maxCacheObjects,
      'cacheKeys': _widgetCache.keys.toList(),
      'memoryUsage': '${(_widgetCache.length / _maxCacheObjects * 100).toStringAsFixed(1)}%',
    };
  }
}\n\n// ====== lib/shared/widgets/sector_names.dart ======\n
// ğŸ†• ì‹¤ì œ ì„¹í„° ë¶„ë¥˜ì— ë§ì¶˜ ë„¤ì´ë° ë§¤í•‘

import '../../domain/entities/app_settings.dart';

class SectorNames {
  // ğŸ¯ ìƒì„¸ ë¶„ë¥˜ (28ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘
  static const Map<String, Map<String, String>> detailedSectorNaming = {
    // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
    'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': {
      'ticker': 'BTC-GRP',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹',
      'english': 'Bitcoin Group',
    },
    'ì´ë”ë¦¬ì›€ ê·¸ë£¹': {
      'ticker': 'ETH-GRP',
      'korean': 'ì´ë”ë¦¬ì›€ ê·¸ë£¹',
      'english': 'Ethereum Group',
    },
    'ìŠ¤í…Œì´í‚¹': {
      'ticker': 'STAKE',
      'korean': 'ìŠ¤í…Œì´í‚¹',
      'english': 'Staking',
    },

    // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
    'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MONO',
      'korean': 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸',
      'english': 'Monolithic Blockchain',
    },
    'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MODU',
      'korean': 'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸',
      'english': 'Modular Blockchain',
    },

    // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
    'ìŠ¤í…Œì´ë¸” ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸” ì½”ì¸',
      'english': 'Stablecoin',
    },

    // ==================== DeFi ìƒíƒœê³„ ====================
    'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': {
      'ticker': 'DEX',
      'korean': 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°',
      'english': 'DEX/Aggregator',
    },
    'ëœë”©': {
      'ticker': 'LEND',
      'korean': 'ëœë”©',
      'english': 'Lending',
    },
    'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': {
      'ticker': 'LSTAKE',
      'korean': 'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹',
      'english': 'Liquid Staking/Restaking',
    },
    'RWA': {
      'ticker': 'RWA',
      'korean': 'RWA',
      'english': 'Real World Assets',
    },

    // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
    'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': {
      'ticker': 'PAY',
      'korean': 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼',
      'english': 'Payment Infrastructure',
    },
    'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': {
      'ticker': 'BRIDGE',
      'korean': 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€',
      'english': 'Interoperability/Bridge',
    },
    'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': {
      'ticker': 'ENTER',
      'korean': 'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸',
      'english': 'Enterprise Blockchain',
    },
    'ì˜¤ë¼í´': {
      'ticker': 'ORACLE',
      'korean': 'ì˜¤ë¼í´',
      'english': 'Oracle',
    },
    'ë°ì´í„° ì¸í”„ë¼': {
      'ticker': 'DATA',
      'korean': 'ë°ì´í„° ì¸í”„ë¼',
      'english': 'Data Infrastructure',
    },
    'ìŠ¤í† ë¦¬ì§€': {
      'ticker': 'STORAGE',
      'korean': 'ìŠ¤í† ë¦¬ì§€',
      'english': 'Storage',
    },
    'AI': {
      'ticker': 'AI',
      'korean': 'AI',
      'english': 'Artificial Intelligence',
    },

    // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
    'ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'META',
      'korean': 'ë©”íƒ€ë²„ìŠ¤',
      'english': 'Metaverse',
    },
    'NFT/ê²Œì„': {
      'ticker': 'NFT-GAME',
      'korean': 'NFT/ê²Œì„',
      'english': 'NFT/Gaming',
    },

    // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
    'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': {
      'ticker': 'MEDIA',
      'korean': 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°',
      'english': 'Media/Streaming',
    },
    'ê´‘ê³ ': {
      'ticker': 'AD',
      'korean': 'ê´‘ê³ ',
      'english': 'Advertising',
    },
    'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': {
      'ticker': 'EDU',
      'korean': 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ',
      'english': 'Education/Content',
    },

    // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
    'ì†Œì…œ/DAO': {
      'ticker': 'SOCIAL',
      'korean': 'ì†Œì…œ/DAO',
      'english': 'Social/DAO',
    },
    'íŒ¬í† í°': {
      'ticker': 'FAN',
      'korean': 'íŒ¬í† í°',
      'english': 'Fan Token',
    },
    'ë°ˆ': {
      'ticker': 'MEME',
      'korean': 'ë°ˆ',
      'english': 'Meme',
    },

    // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
    'DID': {
      'ticker': 'DID',
      'korean': 'DID',
      'english': 'Decentralized Identity',
    },
    'ì˜ë£Œ': {
      'ticker': 'MED',
      'korean': 'ì˜ë£Œ',
      'english': 'Medical',
    },
    'ì›”ë ›/ë©”ì„¸ì§•': {
      'ticker': 'WALLET',
      'korean': 'ì›”ë ›/ë©”ì„¸ì§•',
      'english': 'Wallet/Messaging',
    },
  };

  // ğŸ¯ ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘ - ğŸ†• ì‹ ê·œìƒì¥ 5ê°œ ì„¹í„° ì¶”ê°€
  static const Map<String, Map<String, String>> basicSectorNaming = {
    'ë©”ì´ì € ì½”ì¸': {
      'ticker': 'MAJOR',
      'korean': 'ë©”ì´ì € ì½”ì¸',
      'english': 'Major Coins',
    },
    'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': {
      'ticker': 'BTC-FAM',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´',
      'english': 'Bitcoin Family',
    },
    'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': {
      'ticker': 'ETH-ECO',
      'korean': 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„',
      'english': 'Ethereum Ecosystem',
    },
    'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': {
      'ticker': 'L1',
      'korean': 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸',
      'english': 'Layer 1 Blockchain',
    },
    'ê³  ì‹œì´': {
      'ticker': 'LARGE-CAP',
      'korean': 'ê³  ì‹œì´',
      'english': 'Large Market Cap',
    },
    'ì¤‘ ì‹œì´': {
      'ticker': 'MID-CAP',
      'korean': 'ì¤‘ ì‹œì´',
      'english': 'Mid Market Cap',
    },
    'ì € ì‹œì´': {
      'ticker': 'SMALL-CAP',
      'korean': 'ì € ì‹œì´',
      'english': 'Small Market Cap',
    },
    'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': {
      'ticker': 'MINOR-ALT',
      'korean': 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸',
      'english': 'Minor Altcoins',
    },
    'DeFi í† í°': {
      'ticker': 'DEFI',
      'korean': 'DeFi í† í°',
      'english': 'DeFi Tokens',
    },
    'ìŠ¤í…Œì´ë¸”ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸”ì½”ì¸',
      'english': 'Stablecoins',
    },
    'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'GAMING',
      'korean': 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤',
      'english': 'Gaming/NFT/Metaverse',
    },
    'í•œêµ­ í”„ë¡œì íŠ¸': {
      'ticker': 'KOREA',
      'korean': 'í•œêµ­ í”„ë¡œì íŠ¸',
      'english': 'Korean Projects',
    },
    'ì†”ë¼ë‚˜ ìƒíƒœê³„': {
      'ticker': 'SOL-ECO',
      'korean': 'ì†”ë¼ë‚˜ ìƒíƒœê³„',
      'english': 'Solana Ecosystem',
    },
    'AI/ê¸°ìˆ  í† í°': {
      'ticker': 'AI-TECH',
      'korean': 'AI/ê¸°ìˆ  í† í°',
      'english': 'AI/Tech Tokens',
    },

    // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„°
    '2023ë…„ ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-23',
      'korean': '2023ë…„ ì‹ ê·œìƒì¥',
      'english': '2023 New Listings',
    },
    '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H1',
      'korean': '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H1 New Listings',
    },
    '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H2',
      'korean': '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H2 New Listings',
    },
    '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-25H1',
      'korean': '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2025 H1 New Listings',
    },
    '2025ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-25H2',
      'korean': '2025ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2025 H2 New Listings',
    },
  };

  /// ğŸ¯ ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ ë³€í™˜ (ê¸°ë³¸/ìƒì„¸ ë¶„ë¥˜ ìë™ ê°ì§€)
  static String getDisplayName(String sectorKey, DisplayMode displayMode, {bool isDetailed = false}) {
    // ì •ê·œí™” (ì…ë ¥ëœ ì„¹í„°ëª… ê·¸ëŒ€ë¡œ ë§¤í•‘ì—ì„œ ì°¾ê¸°)
    final normalizedKey = sectorKey.trim();
    
    // ìƒì„¸/ê¸°ë³¸ ë¶„ë¥˜ì— ë”°ë¼ ì ì ˆí•œ ë§¤í•‘ ì„ íƒ
    final sectorData = isDetailed 
        ? detailedSectorNaming[normalizedKey] 
        : basicSectorNaming[normalizedKey];
    
    // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ë‹¤ë¥¸ ë¶„ë¥˜ì—ì„œ ì°¾ê¸° ì‹œë„
    final fallbackData = isDetailed 
        ? basicSectorNaming[normalizedKey]
        : detailedSectorNaming[normalizedKey];
    
    final finalData = sectorData ?? fallbackData;
    
    if (finalData == null) {
      // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ì›ë³¸ ë°˜í™˜ (fallback)
      return sectorKey;
    }

    switch (displayMode) {
      case DisplayMode.ticker:
        return finalData['ticker'] ?? sectorKey;
      case DisplayMode.korean:
        return finalData['korean'] ?? sectorKey;
      case DisplayMode.english:
        return finalData['english'] ?? sectorKey;
    }
  }

  /// ğŸ”§ ëª¨ë“  ì„¹í„° í‚¤ ëª©ë¡ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static List<String> getAllSectorKeys({bool isDetailed = false}) {
    return isDetailed 
        ? detailedSectorNaming.keys.toList()
        : basicSectorNaming.keys.toList();
  }

  /// ğŸ”§ íŠ¹ì • ì„¹í„°ê°€ ë§¤í•‘ì— ìˆëŠ”ì§€ í™•ì¸
  static bool hasSector(String sectorKey, {bool isDetailed = false}) {
    final normalizedKey = sectorKey.trim();
    
    return isDetailed 
        ? detailedSectorNaming.containsKey(normalizedKey)
        : basicSectorNaming.containsKey(normalizedKey);
  }

  /// ğŸ”§ ë””ë²„ê¹…ìš© - ë§¤í•‘ë˜ì§€ ì•Šì€ ì„¹í„° ì°¾ê¸°
  static List<String> findUnmappedSectors(List<String> actualSectorKeys, {bool isDetailed = false}) {
    final unmapped = <String>[];
    
    for (final sectorKey in actualSectorKeys) {
      if (!hasSector(sectorKey, isDetailed: isDetailed)) {
        unmapped.add(sectorKey);
      }
    }
    
    return unmapped;
  }

  /// ğŸ”§ ì „ì²´ ë§¤í•‘ ì •ë³´ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static Map<String, Map<String, String>> getAllMappings({bool isDetailed = false}) {
    return isDetailed ? detailedSectorNaming : basicSectorNaming;
  }
}

// ğŸ†• SectorTileì—ì„œ ì‚¬ìš©í•  í—¬í¼ í™•ì¥
extension SectorDisplayExtension on String {
  /// ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ í‘œì‹œ
  String toDisplayName(DisplayMode displayMode, {bool isDetailed = false}) {
    return SectorNames.getDisplayName(this, displayMode, isDetailed: isDetailed);
  }
}\n\n// ====== lib/shared/widgets/sector_classification.dart ======\n
import 'package:flutter/foundation.dart';

/// ì„¹í„° ë¶„ë¥˜ ê´€ë¦¬ ì „ìš© Provider (ê³µìœ  ìœ„ì ¯ ë ˆì´ì–´)
/// ìƒì„¸(28ê°œ) vs ê¸°ë³¸(18ê°œ) ë¶„ë¥˜ í† ê¸€ ë° ë§¤í•‘ ë°ì´í„° ì œê³µ
class SectorClassificationProvider extends ChangeNotifier {
 // í˜„ì¬ ì„ íƒëœ ë¶„ë¥˜ íƒ€ì… (true: ìƒì„¸, false: ê¸°ë³¸)
 bool _isDetailedClassification = true;
 
 // ğŸš€ ìºì‹œ ì‹œìŠ¤í…œ ì¶”ê°€
 Map<String, List<String>>? _cachedCurrentSectors;
 Map<String, List<String>>? _cachedCoinToSectorsMap;
 
 bool get isDetailedClassification => _isDetailedClassification;
 
 /// ë¶„ë¥˜ íƒ€ì… í† ê¸€
 void toggleClassificationType() {
   // ğŸš€ ìºì‹œ ë¬´íš¨í™”
   _cachedCurrentSectors = null;
   _cachedCoinToSectorsMap = null;
   
   _isDetailedClassification = !_isDetailedClassification;
   notifyListeners();
 }
 
 /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„°ë³„ ì½”ì¸ ë§¤í•‘ (28ê°œ ì„¹í„°)
 static const Map<String, List<String>> _detailedSectors = {
   // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
   'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': ['BTC', 'BCH', 'BSV', 'XEC'],
   'ì´ë”ë¦¬ì›€ ê·¸ë£¹': ['ETH', 'ETC'],
   'ìŠ¤í…Œì´í‚¹': ['ETH', 'SOL', 'ADA', 'POL', 'ATOM'],

   // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
   'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': [
     'SOL', 'ADA', 'TRX', 'SUI', 'AVAX', 'NEAR', 'CRO', 'APT', 'ETC', 'VET',
     'ATOM', 'ALGO', 'INJ', 'A', 'SEI', 'IOTA', 'XTZ', 'FLOW', 'KAVA', 'EGLD',
     'NEO', 'MINA', 'BERA', 'ZIL', 'QTUM', 'ASTR', 'GAS', 'VTHO', 'VANA', 'ELF',
     'WAVES', 'ICX', 'ONT', 'HIVE', 'SXP', 'POWR', 'ARDR', 'XEM', 'IOST', 'ONG',
     'GLMR', 'ARK', 'AERGO', 'QKC', 'META', 'TT', 'FCT2'
   ],
   'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': [
     'ETH', 'DOT', 'MNT', 'POL', 'ARB', 'STX', 'SONIC', 'MOVE', 'CKB', 'CELO',
     'LSK', 'BLAST', 'TAIKO', 'MTL', 'TOKAMAK'
   ],

   // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
   'ìŠ¤í…Œì´ë¸” ì½”ì¸': ['USDT', 'USDC'],

   // ==================== DeFi ìƒíƒœê³„ ====================
   'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': [
     'UNI', 'JUP', 'DEEP', '1INCH', 'ZRX', 'ORCA', 'COW', 'ORBS', 'AUCTION', 'KNC'
   ],
   'ëœë”©': ['AAVE', 'COMP', 'STRIKE'],
   'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': ['PENDLE', 'JTO', 'LAYER'],
   'RWA': ['ONDO', 'CTC'],

   // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
   'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': ['BTC', 'XRP', 'BCH', 'XLM', 'BSV', 'XEC', 'PUNDIX', 'GRS'],
   'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': ['ZRO', 'W', 'T', 'ZETA', 'STG'],
   'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': ['HBAR', 'POLYX', 'STRAX'],
   'ì˜¤ë¼í´': ['LINK', 'PYTH'],
   'ë°ì´í„° ì¸í”„ë¼': ['GRT', 'KAITO', 'ANKR', 'ARKM', 'MVL', 'CARV'],
   'ìŠ¤í† ë¦¬ì§€': ['FIL', 'THETA', 'BTT', 'WAL', 'AKT', 'LPT', 'GLM', 'TFUEL', 'SC', 'STORJ'],
   'AI': ['VIRTUAL', 'RENDER', 'ATH'],

   // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
   'ë©”íƒ€ë²„ìŠ¤': ['SAND', 'MANA', 'MOCA', 'MOC'],
   'NFT/ê²Œì„': [
     'IMX', 'AXS', 'BEAM', 'BLUR', 'ENJ', 'GMT', 'ANIME', 'ME', 'BORA',
     'BIGTIME', 'WAXP', 'AGLD', 'GAME2', 'AQT'
   ],

   // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
   'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': ['MBL'],
   'ê´‘ê³ ': ['BAT', 'MLK', 'STMX'],
   'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': ['IQ', 'AHT'],

   // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
   'ì†Œì…œ/DAO': ['G', 'UXLINK', 'STEEM', 'CBK'],
   'íŒ¬í† í°': ['CHZ'],
   'ë°ˆ': ['DOGE', 'SHIB', 'PEPE', 'TRUMP', 'BONK', 'MEW', 'PENGU', 'MOODENG'],

   // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
   'DID': ['ENS', 'ID', 'CVC'],
   'ì˜ë£Œ': ['MED'],
   'ì›”ë ›/ë©”ì„¸ì§•': ['SAFE', 'MASK', 'WCT', 'SNT'],
 };

 /// ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) - ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 5ê°œ ì¶”ê°€
 static const Map<String, List<String>> _basicSectors = {
   'ë©”ì´ì € ì½”ì¸': [
     'BTC', 'ETH', 'XRP', 'ADA', 'SOL', 'DOT', 'AVAX', 'MATIC', 'POL', 'NEAR',
     'ATOM', 'LINK', 'UNI', 'ALGO', 'VET', 'SAND', 'MANA', 'AXS', 'THETA',
     'FIL', 'AAVE', 'DOGE', 'SHIB', 'PEPE'
   ],
   'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': [
     'BTC', 'BCH', 'BSV', 'BTT', '1000SATS', 'ORDI'
   ],
   'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': [
     'ETH', 'ETC', 'ENS', 'LPT', 'COMP', 'MKR', 'YFI', 'SUSHI', 'BAL',
     '1INCH', 'LRC', 'ZRX', 'BAT', 'ENJ', 'CRV', 'SNX', 'MASK', 'BLUR', 'GRT'
   ],
   'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': [
     'EGLD', 'INJ', 'APT', 'SUI', 'ARB', 'OP', 'STX', 'TIA', 'SEI', 'PYTH',
     'JTO', 'JUP', 'TNSR', 'W', 'ENA', 'OMNI', 'REZ', 'BB', 'NOT', 'IO',
     'ZK', 'LISTA', 'ZRO', 'G', 'BANANA', 'RENDER', 'TON', 'NEO', 'GAS',
     'ONT', 'ONG', 'QTUM', 'WAVES', 'LSK', 'STRAX', 'ARK', 'STORJ', 'SC',
     'ARDR', 'KMD', 'ZEC', 'DASH', 'XMR', 'ICX', 'ZIL', 'IOTA', 'XTZ',
     'CELO', 'FLOW', 'MINA', 'HBAR', 'CKB', 'BEAM', 'ZETA', 'TAIKO', 'AERGO'
   ],
   
   // ğŸ†• ì‹œì´ë³„ ë¶„ë¥˜ (í™˜ìœ¨ 1,400ì› ì ìš© ê¸°ì¤€)
   'ê³  ì‹œì´': [
     'BTC', 'ETH', 'XRP', 'SOL', 'DOGE', 'AVAX', 'TRUMP'
   ],
   'ì¤‘ ì‹œì´': [
     'SUI', 'APT', 'NEAR', 'UNI', 'LINK', 'AAVE', 'INJ', 'STX', 'AXS', 'FIL',
     'ATOM', 'DOT', 'PENDLE', 'RENDER', 'GAS', 'ORCA', 'BERA', 'ZRO', 'TIA',
     'MASK', 'VIRTUAL', 'KAITO', 'QTUM', 'JTO', 'OM', 'ONDO', 'ME', 'LAYER',
     'AGLD', 'THETA', 'MTL', 'MNT', 'ADA', 'TAIKO',      'VAULTA', 'DRIFT', 'CTC',
     'XTZ', 'IMX', 'ARKM', 'SAFE', 'JUP', 'WAL', 'LSK', 'KAVA', 'COW',
     'UXLINK', 'ARK', 'FLOW', 'CARV', 'ARB', 'CELO', 'PUNDIX', 'KNC',
     'MANA', 'TRX', 'SAND', 'STORJ', 'XLM', 'HUNT', 'SONIC', 'GLM', 'ZRX',
     'HIVE', 'ZETA', 'MINA', 'POL', '1INCH', 'ALGO', 'SEI', 'STG', 'IOTA',
     'ID', 'SXP', 'HBAR', 'POWR', 'DEEP', 'MOVE', 'POLYX', 'STEEM', 'ONT',
     'BAT', 'CVC', 'AERGO', 'ICX', 'PYTH', 'CRO', 'GRT', 'BLUR', 'ARDR',
     'BORA', 'W', 'MOCA', 'BIGTIME', 'GMT', 'STRAX', 'CHZ', 'SNT', 'TFUEL',
     'JST', 'VET', 'ANIME', 'WAXP', 'ORBS', 'ANKR', 'T', 'G', 'ZIL', 'PENGU',
     'XEM', 'BEAM', 'CKB', 'IQ', 'AHT', 'IOST'
   ],
   'ì € ì‹œì´': [
     'GAME2', 'MVL', 'SC', 'MEW', 'BLAST', 'STMX', 'TT', 'MBL', 'VTHO', 'XEC',
     'BONK', 'SHIB', 'PEPE', 'BTT', 'CBK', 'MLK', 'POKT', 'SIGN', 'MOC',
     'SOPH', 'AWE', 'ATH', 'BOUNTY', 'HP', 'FCT2', 'ASTR', 'META', 'DKA',
     'QKC', 'MED'
   ],
   
   // ğŸ†• ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸ (ê¸°ì¡´ ì•ŒíŠ¸ì½”ì¸ ë³µì›)
   'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': [
     'LTC', 'A', 'TRX', 'XLM', 'STEEM', 'IOST', 'MTL', 'GRS', 'POWR',
     'XEM', 'XEC', 'VTHO', 'TFUEL', 'HIVE', 'CVC', 'SNT', 'SXP', 'T', 'PUNDIX'
   ],
   
   'DeFi í† í°': [
     'CAKE', 'RUNE', 'ALPHA', 'DODO', 'RAY', 'SRM', 'KNC', 'ANKR', 'CELR',
     'KAVA', 'HARD', 'SWP', 'JST', 'SUN', 'CRO', 'CHZ', 'GLM', 'AUCTION',
     'PENDLE', 'STG', 'COW', 'OM', 'ONDO', 'SAFE'
   ],
   'ìŠ¤í…Œì´ë¸”ì½”ì¸': [
     'USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDD'
   ],
   'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': [
     'GALA', 'APE', 'GMT', 'GST', 'LOOKS', 'PLA', 'WAXP', 'TLM', 'SLP',
     'IMX', 'BIGTIME', 'GAME2', 'AGLD', 'YGG', 'ME', 'VIRTUAL', 'MOCA',
     'PENGU', 'MEW', 'ANIME', 'FLOKI', 'BONK', 'WIF', 'BOME'
   ],
   'í•œêµ­ í”„ë¡œì íŠ¸': [
     'KLAY', 'BORA', 'META', 'WEMIX', 'MBL', 'HUNT', 'TEMCO', 'SOLVE',
     'PROM', 'ORBS', 'MIX', 'CENNZ', 'STPT', 'MDT', 'LAMB', 'COTI',
     'WTC', 'NPXS', 'APIS', 'DAC', 'ELF', 'KARMA', 'MEET', 'QKC',
     'SSX', 'UPP', 'TOKAMAK', 'MLK', 'DKA', 'CBK', 'MOC', 'HP',
     'BOUNTY', 'MED', 'MVL', 'ASTR', 'TT', 'MNT', 'FCT2', 'IQ',
     'AHT', 'AWE', 'ATH', 'SOPH', 'SIGN'
   ],
   'ì†”ë¼ë‚˜ ìƒíƒœê³„': [
     'SOL', 'ORCA', 'DRIFT', 'SONIC', 'LAYER', 'DEEP', 'MOVE'
   ],
   'AI/ê¸°ìˆ  í† í°': [
     'ARKM', 'KAITO', 'NXPC', 'WCT', 'AKT', 'AQT', 'CARV', 'UXLINK',
     'WAL', 'CTC', 'POLYX', 'ID', 'VANA', 'STRIKE', 'BERA', 'TRUMP',
     'POKT', 'STMX', 'BLAST'
   ],

   // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„°
   '2023ë…„ ì‹ ê·œìƒì¥': [
     'SHIB', 'MASK', 'EGLD', 'SUI', 'GRT', 'BLUR', 'IMX', 'SEI', 'MINA', 'CTC', 'ASTR'
   ],
   '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
     'ID', 'PYTH', 'MNT', 'BIGTIME', 'AKT', 'ZETA', 'STG', 'BEAM', 'TAIKO', 'ONDO', 'ZRO', 'BLAST'
   ],
   '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': [
     'JUP', 'ENS', 'GAL', 'PENDLE', 'ATH', 'UXLINK', 'CKB', 'W', 'CARV', 'INJ', 'MEW', 'UNI', 
     'SAFE', 'DRIFT', 'AGLD', 'PEPE', 'BONK', 'RENDER', 'MOVE', 'ME', 'MOCA', 'VANA'
   ],
   '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
     'SONIC', 'VTHO', 'ANIME', 'VIRTUAL', 'BERA', 'LAYER', 'TRUMP', 'JTO', 'COW', 'KAITO', 
     'ARKM', 'ORCA', 'WAL', 'COMP', 'FIL', 'WCT', 'DEEP', 'SIGN', 'TIA', 'PENGU', 
     'NXPC', 'OM', 'SOPH', 'LPT', 'POKT', 'RVN', 'AXL', 'ALT', 'RAY', 'NEWT', 'SAHARA'
   ],
   '2025ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': [
     'MOODENG', 'HYPER', 'BABY'
   ],
 };

 /// ğŸš€ ìºì‹œëœ í˜„ì¬ í™œì„±í™”ëœ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get currentSectors {
   _cachedCurrentSectors ??= _isDetailedClassification ? _detailedSectors : _basicSectors;
   return _cachedCurrentSectors!;
 }

 /// ğŸš€ ìºì‹œëœ ì½”ì¸â†’ì„¹í„° ì—­ìƒ‰ì¸ ë§µ ë°˜í™˜ (O(1) ì¡°íšŒìš©)
 Map<String, List<String>> get coinToSectorsMap {
   if (_cachedCoinToSectorsMap == null) {
     _cachedCoinToSectorsMap = <String, List<String>>{};
     currentSectors.forEach((sector, coins) {
       for (final coin in coins) {
         _cachedCoinToSectorsMap!.putIfAbsent(coin, () => []).add(sector);
       }
     });
     
     if (kDebugMode) {
       debugPrint('ğŸš€ SectorClassification: coinToSectorsMap built with ${_cachedCoinToSectorsMap!.length} coins');
     }
   }
   return _cachedCoinToSectorsMap!;
 }

 /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get detailedSectors => _detailedSectors;

 /// ê¸°ë³¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get basicSectors => _basicSectors;

 /// ì„¹í„° ëª©ë¡ ë°˜í™˜
 List<String> get sectorNames => currentSectors.keys.toList();

 /// íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ë°˜í™˜
 List<String> getCoinsInSector(String sectorName) {
   return currentSectors[sectorName] ?? [];
 }

 /// ğŸš€ ìµœì í™”ëœ íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ë°˜í™˜ (O(1) ì¡°íšŒ)
 List<String> getSectorsForCoin(String ticker) {
   return coinToSectorsMap[ticker.toUpperCase()] ?? [];
 }

 /// í˜„ì¬ ë¶„ë¥˜ íƒ€ì… ë¬¸ìì—´ ë°˜í™˜
 String get currentClassificationName {
   return _isDetailedClassification ? 'ìƒì„¸' : 'ê¸°ë³¸';
 }

 /// ì„¹í„°ë³„ í†µê³„ ì •ë³´
 Map<String, int> get sectorSizes {
   return currentSectors.map((sector, coins) => 
       MapEntry(sector, coins.length));
 }

 /// ì „ì²´ ê³ ìœ  ì½”ì¸ ê°œìˆ˜
 int get totalUniqueCoins {
   return currentSectors.values
       .expand((coins) => coins)
       .toSet()
       .length;
 }

 /// ì¤‘ë³µë„ê°€ ë†’ì€ ì½”ì¸ë“¤ (ì—¬ëŸ¬ ì„¹í„°ì— ì†í•œ ì½”ì¸ë“¤)
 Map<String, int> getCoinDuplicationCount() {
   Map<String, int> duplications = {};
   
   currentSectors.forEach((sector, coins) {
     for (String coin in coins) {
       duplications[coin] = (duplications[coin] ?? 0) + 1;
     }
   });
   
   return Map.fromEntries(
     duplications.entries.toList()
       ..sort((a, b) => b.value.compareTo(a.value))
   );
 }

 /// ğŸ”§ ë””ë²„ê¹…ìš©: ìºì‹œ ìƒíƒœ ì •ë³´
 Map<String, dynamic> get cacheStatus {
   return {
     'isDetailed': _isDetailedClassification,
     'currentSectorsCached': _cachedCurrentSectors != null,
     'coinToSectorsMapCached': _cachedCoinToSectorsMap != null,
     'totalSectors': currentSectors.length,
     'totalCoins': coinToSectorsMap.length,
     'averageCoinsPerSector': currentSectors.values.map((e) => e.length).reduce((a, b) => a + b) / currentSectors.length,
   };
 }
}\n\n// ====== lib/presentation/controllers/sector_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/sector_provider.dart';
import '../../core/common/time_frame_manager.dart'; // ğŸ”¥ ê°„ì†Œí™”ëœ TimeFrame ì‹œìŠ¤í…œ ì‚¬ìš©
import '../../core/common/time_frame_types.dart';   // ğŸ”¥ ê³µí†µ íƒ€ì… ì‚¬ìš©
import '../../domain/entities/volume.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ê°„ì†Œí™”ëœ SectorController - Trade ìŠ¤íƒ€ì¼
class SectorController extends StateNotifier<SectorControllerState> with RankHotMixin {
  final Ref _ref;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ì‹œê°„ëŒ€ë³„ ë¸”ë§í¬ ìƒíƒœ ê´€ë¦¬ (TimeFrame enum ê¸°ë°˜)
  final Map<TimeFrame, Map<String, bool>> _blinkStatesByTimeFrame = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  SectorController(this._ref) : super(const SectorControllerState()) {
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStatesByTimeFrame.clear();
  }

  /// ğŸ”¥ í†µí•© ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      sectorVolumeDataProvider,
      (previous, next) {
        next.when(
          data: (event) {
            // ğŸš€ ë°ì´í„° ì²˜ë¦¬
            _processSectorData(event.volumes);
            
            // ğŸ”¥ ë¦¬ì…‹ ì •ë³´ ì²˜ë¦¬ (ìƒˆë¡œìš´ SectorVolumeEvent êµ¬ì¡°)
            if (event.isReset) {
              clearTimeFrameHot(event.timeFrame.key);
              _clearTimeFrameBlinkStates(event.timeFrame);
            }
          },
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ì„¹í„° ë°ì´í„° ì²˜ë¦¬
  void _processSectorData(List<Volume> volumes) {
    // âœ… Providerì—ì„œ ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ê·¸ëŒ€ë¡œ ì‚¬ìš©
    final processedVolumes = volumes;
    
    // âœ… ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
    _calculateAllStates(processedVolumes);
    
    // âœ… ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      sectorVolumes: processedVolumes,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - TimeFrame enum ê¸°ë°˜
  void _calculateAllStates(List<Volume> volumes) {
    final currentTimeFrame = this.currentTimeFrame;
    final currentTimeFrameKey = currentTimeFrame.key; // TimeFrame â†’ String
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™” (String key ì‚¬ìš© - Mixin í˜¸í™˜)
    initializeTimeFrame(currentTimeFrameKey);
    _rankTracker.initializeTimeFrame(currentTimeFrameKey);
    
    // âœ… í˜„ì¬ ì‹œê°„ëŒ€ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum ì‚¬ìš©)
    _initializeTimeFrameBlinkStates(currentTimeFrame);
    
    for (int i = 0; i < volumes.length; i++) {
      final volume = volumes[i];
      final sectorName = volume.market.replaceFirst('SECTOR-', '');
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœëŠ” Mixinì—ì„œ ì§ì ‘ ê´€ë¦¬ (String key ì‚¬ìš©)
      checkIfHot(
        key: sectorName,
        currentRank: currentRank,
        timeFrame: currentTimeFrameKey,
        menuType: 'sector',
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (Sector ì „ìš© ë©”ì„œë“œ ì‚¬ìš©)
      final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame]!;
      
      // ì„¹í„° ìˆœìœ„ ë³€í™” ì²´í¬ (ìˆœìœ„ + ì‹¤ì œ ë³¼ë¥¨ ê°’ ê¸°ì¤€)
      final isRankChange = _rankTracker.checkRankChangeWithValue(
        key: sectorName,
        currentRank: currentRank,
        currentValue: volume.totalVolume,
        timeFrame: currentTimeFrameKey,
      );
      
      // ì˜ë¯¸ìˆëŠ” ë³€í™”ê°€ ìˆì„ ë•Œë§Œ ë¸”ë§í¬
      blinkStates[sectorName] = isRankChange;
    }
  }

  /// âœ… ì‹œê°„ëŒ€ë³„ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum)
  void _initializeTimeFrameBlinkStates(TimeFrame timeFrame) {
    if (!_blinkStatesByTimeFrame.containsKey(timeFrame)) {
      _blinkStatesByTimeFrame[timeFrame] = <String, bool>{};
    }
  }

  /// âœ… íŠ¹ì • ì‹œê°„ëŒ€ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum)
  void _clearTimeFrameBlinkStates(TimeFrame timeFrame) {
    _blinkStatesByTimeFrame[timeFrame]?.clear();
  }

  /// ğŸ”¥ ì‹œê°„ëŒ€ ë³€ê²½ - Trade ìŠ¤íƒ€ì¼ (ì§ì ‘ Provider ì¡°ì‘)
  void setTimeFrame(TimeFrame timeFrame) {
    _ref.read(selectedSectorTimeFrameProvider.notifier).state = timeFrame;
    // ğŸ¯ ìƒíƒœ ì´ˆê¸°í™” ì œê±° - ê° ì‹œê°„ëŒ€ê°€ ë…ë¦½ì ìœ¼ë¡œ ìœ ì§€ë¨
  }

  /// ğŸ”¥ ì‹œê°„ëŒ€ ë³€ê²½ (ì¸ë±ìŠ¤ ê¸°ë°˜) - í˜¸í™˜ì„± ìœ ì§€
  void setTimeFrameByIndex(int index) {
    final availableTimeFrames = this.availableTimeFrames;
    if (index >= 0 && index < availableTimeFrames.length) {
      setTimeFrame(availableTimeFrames[index]);
    }
  }

  /// ğŸš€ ì„¹í„° ë¶„ë¥˜ í† ê¸€ - ì„¹í„°ë§Œì˜ ê³ ìœ  ê¸°ëŠ¥
  void toggleSectorClassification() {
    _ref.read(sectorClassificationProvider.notifier).toggleClassificationType();
  }

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (String key ì‚¬ìš© - Mixin í˜¸í™˜)
  bool isHot(String sectorName) {
    final hotItems = getHotItems(currentTimeFrame.key);
    return hotItems.contains(sectorName);
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ - TimeFrame enum ê¸°ë°˜
  bool shouldBlink(String sectorName) {
    final currentTimeFrame = this.currentTimeFrame;
    final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame];
    return blinkStates?[sectorName] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” - ê°•ì œ notify ë¬¸ì œ í•´ê²°
  void clearBlinkState(String sectorName) {
    final currentTimeFrame = this.currentTimeFrame;
    final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame];
    if (blinkStates != null) {
      blinkStates[sectorName] = false;
      // âœ… ì‹¤ì œ ë³€í™”ê°€ ìˆì„ ë•Œë§Œ notify (ë¶ˆí•„ìš”í•œ copyWith ì œê±°)
    }
  }

  /// ğŸ”¥ TimeFrame ê´€ë ¨ ë©”ì„œë“œë“¤ - ê°„ì†Œí™”ëœ êµ¬ì¡°
  TimeFrame get currentTimeFrame => _ref.read(selectedSectorTimeFrameProvider);
  
  int get currentIndex {
    final availableTimeFrames = this.availableTimeFrames;
    return availableTimeFrames.indexOf(currentTimeFrame);
  }
  
  List<TimeFrame> get availableTimeFrames => TimeFrame.fromAppConfig();

  String getTimeFrameName(TimeFrame timeFrame) => timeFrame.displayName;

  /// ğŸ”¥ ë¦¬ì…‹ ë©”ì„œë“œë“¤ - ê°„ì†Œí™”ëœ Manager ì§ì ‘ ì‚¬ìš©
  void resetCurrentTimeFrame() {
    final currentTimeFrame = this.currentTimeFrame;
    GlobalTimeFrameManager().resetTimeFrame(currentTimeFrame);
  }

  void resetAllTimeFrames() {
    GlobalTimeFrameManager().resetAll();
  }

  /// ğŸ”¥ ì™„ë²½í•œ íƒ€ì´ë¨¸ ë™ê¸°í™” - ê°„ì†Œí™”ëœ Manager ì§ì ‘ ì‚¬ìš©
  DateTime? getNextResetTime() {
    final currentTimeFrame = this.currentTimeFrame;
    return GlobalTimeFrameManager().getNextResetTime(currentTimeFrame);
  }

  /// ğŸš€ ì„¹í„° ê³ ìœ  ê¸°ëŠ¥ë“¤ - ì§ì ‘ Provider ì ‘ê·¼
  String get currentSectorClassificationName {
    return _ref.read(sectorClassificationProvider).currentClassificationName;
  }

  bool get isDetailedClassification {
    return _ref.read(sectorClassificationProvider).isDetailedClassification;
  }

  int get totalSectors {
    return _ref.read(sectorClassificationProvider).currentSectors.length;
  }

  Map<String, int> getSectorSizes() {
    return _ref.read(sectorClassificationProvider).sectorSizes;
  }

  /// âœ… íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ì¡°íšŒ
  List<String> getCoinsInSector(String sectorName) {
    return _ref.read(sectorClassificationProvider).getCoinsInSector(sectorName);
  }

  /// âœ… íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì¡°íšŒ
  List<String> getSectorsForCoin(String ticker) {
    return _ref.read(sectorClassificationProvider).getSectorsForCoin(ticker);
  }

  /// âœ… ë””ë²„ê¹…ìš© ë©”ì„œë“œë“¤
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
    _cleanupOldBlinkStates();
  }

  /// âœ… ì˜¤ë˜ëœ ë¸”ë§í¬ ìƒíƒœ ì •ë¦¬ (TimeFrame enum ê¸°ë°˜)
  void _cleanupOldBlinkStates() {
    final currentTimeFrame = this.currentTimeFrame;
    final availableTimeFrames = this.availableTimeFrames.toSet();
    
    _blinkStatesByTimeFrame.removeWhere((timeFrame, _) => 
      timeFrame != currentTimeFrame && !availableTimeFrames.contains(timeFrame)
    );
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStatesByTimeFrame.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class SectorControllerState {
  final List<Volume> sectorVolumes;        // ì •ë ¬ëœ ì„¹í„° ë³¼ë¥¨ ë°ì´í„°
  final bool isLoading;                   // ë¡œë”© ìƒíƒœ
  final String? errorMessage;             // ì—ëŸ¬ ë©”ì‹œì§€

  const SectorControllerState({
    this.sectorVolumes = const [],
    this.isLoading = false,
    this.errorMessage,
  });

  SectorControllerState copyWith({
    List<Volume>? sectorVolumes,
    bool? isLoading,
    String? errorMessage,
  }) {
    return SectorControllerState(
      sectorVolumes: sectorVolumes ?? this.sectorVolumes,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// Provider ì„ ì–¸ - UIìš© SectorController
final sectorControllerProvider = StateNotifierProvider<SectorController, SectorControllerState>(
  (ref) => SectorController(ref),
);\n\n// ====== lib/presentation/pages/sector_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/common/time_frame_types.dart';
import '../../core/common/time_frame_manager.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/sector_controller.dart';
import '../widgets/sector_tile.dart';

class SectorPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SectorPage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ)
    final state = ref.watch(sectorControllerProvider);
    final controller = ref.read(sectorControllerProvider.notifier);
    
    // ğŸ”¥ í•µì‹¬ ìˆ˜ì •: ref.watchë¡œ ì‹¤ì‹œê°„ ìƒíƒœ ê°ì§€
    final currentTimeFrame = ref.watch(selectedSectorTimeFrameProvider);
    final availableTimeFrames = controller.availableTimeFrames;
    final currentIndex = availableTimeFrames.indexOf(currentTimeFrame);
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ - Controller ì¤‘ì‹¬ ì„¤ê³„
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${currentTimeFrame.displayName}',
      sliderValue: currentIndex.toDouble(),
      sliderMin: 0.0,
      sliderMax: (availableTimeFrames.length - 1).toDouble(),
      sliderDivisions: availableTimeFrames.length - 1,
      sliderLabel: currentTimeFrame.displayName,
      onSliderChanged: (value) {
        final newIndex = value.round();
        if (newIndex >= 0 && newIndex < availableTimeFrames.length) {
          // ğŸ”¥ Surge/Volumeê³¼ ë™ì¼í•˜ê²Œ ì§ì ‘ setTimeFrame í˜¸ì¶œ
          controller.setTimeFrame(availableTimeFrames[newIndex]);
        }
      },
      // ğŸš€ Sector ê³ ìœ : ì„¹í„° ë¶„ë¥˜ í† ê¸€ ë²„íŠ¼
      centerWidget: CommonToggleButton(
        text: controller.currentSectorClassificationName,
        isActive: controller.isDetailedClassification,
        onTap: () => controller.toggleSectorClassification(),
        icon: controller.isDetailedClassification ? Icons.view_module : Icons.view_list,
        fontSize: 10,
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
      ),
      rightWidget: CommonCountdownWidget(
        // ğŸ”¥ Controller ì¤‘ì‹¬ ì„¤ê³„ - Controller ë©”ì„œë“œ ì‚¬ìš©
        nextResetTime: controller.getNextResetTime(),
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildSectorList(state, controller, currentTimeFrame, context)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ì„¹í„° ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜) - Controller ì¤‘ì‹¬ ì„¤ê³„
  Widget _buildSectorList(
    SectorControllerState state,
    SectorController controller,
    TimeFrame currentTimeFrame, // ğŸ”¥ Controllerì—ì„œ ë°›ì€ TimeFrame
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ì„¹í„° ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.sectorVolumes.isEmpty) {
      return Center(
        child: Text(
          'ì„¹í„° ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${currentTimeFrame.displayName})', // ğŸ”¥ enum ì§ì ‘ ì‚¬ìš©
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ì„¹í„° ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì‚¬ìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.sectorVolumes.length,
      itemBuilder: (_, i) {
        final volume = state.sectorVolumes[i];
        final sectorName = volume.market.replaceFirst('SECTOR-', '');
        final rank = i + 1;
        
        return SectorTile(
          sectorName: sectorName,
          totalVolume: volume.totalVolume,
          rank: rank,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ (ê¸°ì¡´ íŒ¨í„´ ìœ ì§€)
          isHot: controller.isHot(sectorName),
          shouldBlink: controller.shouldBlink(sectorName),
        );
      },
    );
  }
}\n\n// ====== lib/presentation/widgets/sector_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../shared/widgets/sector_names.dart';
import '../../shared/widgets/sector_logo_provider.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/sector_controller.dart';

class SectorTile extends ConsumerStatefulWidget {
  final String sectorName;
  final double totalVolume;
  final int rank;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’

  const SectorTile({
    Key? key,
    required this.sectorName,
    required this.totalVolume,
    required this.rank,
    required this.isHot,
    required this.shouldBlink,
  }) : super(key: key);

  @override
  ConsumerState<SectorTile> createState() => _SectorTileState();
}

class _SectorTileState extends ConsumerState<SectorTile>
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (Volumeê³¼ ì™„ì „ ë™ì¼)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SectorTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (Volumeê³¼ ì™„ì „ ë™ì¼)
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (Volumeê³¼ ì™„ì „ ë™ì¼í•œ ë¡œì§)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­ (Volumeê³¼ ë™ì¼)
            ref.read(sectorControllerProvider.notifier).clearBlinkState(widget.sectorName);
          }
        });
      }
    });
  }

  /// âœ… ì„¹í„° ë²ˆí˜¸ ë§¤í•‘ (ì„¹í„°ë§Œì˜ ê³ ìœ  ë¡œì§)
  int _getSectorNumber(String sectorName) {
    const sectorNumberMap = {
      // ìƒì„¸ ë¶„ë¥˜ (1-28ë²ˆ)
      'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': 1, 'ì´ë”ë¦¬ì›€ ê·¸ë£¹': 2, 'ìŠ¤í…Œì´í‚¹': 3, 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': 4,
      'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': 5, 'ìŠ¤í…Œì´ë¸” ì½”ì¸': 6, 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': 7, 'ëœë”©': 8,
      'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': 9, 'RWA': 10, 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': 11, 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': 12,
      'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': 13, 'ì˜¤ë¼í´': 14, 'ë°ì´í„° ì¸í”„ë¼': 15, 'ìŠ¤í† ë¦¬ì§€': 16,
      'AI': 17, 'ë©”íƒ€ë²„ìŠ¤': 18, 'NFT/ê²Œì„': 19, 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': 20,
      'ê´‘ê³ ': 21, 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': 22, 'ì†Œì…œ/DAO': 23, 'íŒ¬í† í°': 24,
      'ë°ˆ': 25, 'DID': 26, 'ì˜ë£Œ': 27, 'ì›”ë ›/ë©”ì„¸ì§•': 28,
      // ê¸°ë³¸ ë¶„ë¥˜ (29-46ë²ˆ)
      'ë©”ì´ì € ì½”ì¸': 29, 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': 30, 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': 31, 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': 32,
      'ê³  ì‹œì´': 33, 'ì¤‘ ì‹œì´': 34, 'ì € ì‹œì´': 35, 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': 36,
      'DeFi í† í°': 37, 'ìŠ¤í…Œì´ë¸”ì½”ì¸': 38, 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': 39, 'í•œêµ­ í”„ë¡œì íŠ¸': 40,
      'ì†”ë¼ë‚˜ ìƒíƒœê³„': 41, 'AI/ê¸°ìˆ  í† í°': 42, '2023ë…„ ì‹ ê·œìƒì¥': 43, '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 44,
      '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': 45, '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 46,
    };
    return sectorNumberMap[sectorName] ?? 1;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    
    // ğŸš€ Controllerì—ì„œ ì§ì ‘ ìƒíƒœ ì¡°íšŒ (Volumeê³¼ ë™ì¼í•œ íŒ¨í„´)
    final controller = ref.read(sectorControllerProvider.notifier);
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    
    // âœ… ì„¹í„°ëª… í‘œì‹œ (Controllerì—ì„œ ë¶„ë¥˜ ìƒíƒœ ì¡°íšŒ)
    final displaySectorName = SectorNames.getDisplayName(
      widget.sectorName, 
      displayMode, 
      isDetailed: controller.isDetailedClassification, // ğŸš€ Controllerì—ì„œ ì¡°íšŒ!
    );

    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„± (Volumeê³¼ ì™„ì „ ë™ì¼í•œ êµ¬ì¡°)
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„ (Volumeê³¼ ë™ì¼)
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),

          const FlexChild.fixed(SizedBox(width: 12)),

          // ğŸ¨ ì„¹í„° ì•„ì´ì½˜ ë¶€ë¶„ (ì„¹í„°ë§Œì˜ ê³ ìœ  ìš”ì†Œ)
          FlexChild.fixed(
            SectorLogoProvider.buildSectorIcon(
              sectorNumber: _getSectorNumber(widget.sectorName),
              size: 40.0,
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 12)),

          // ğŸ“± ì„¹í„°ëª… ë¶€ë¶„ (Volumeê³¼ ë™ì¼í•œ êµ¬ì¡°)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        displaySectorName,
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜ (ì„¤ì • ì²´í¬ - ë¸”ë§í¬ì™€ ë™ì¼í•œ íŒ¨í„´)
                    Consumer(
                      builder: (context, ref, child) {
                        final hotEnabled = ref.watch(appSettingsProvider).hotEnabled;
                        if (hotEnabled && widget.isHot) {
                          return TileCommon.buildHotIcon(true) ?? const SizedBox.shrink();
                        }
                        return const SizedBox.shrink();
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  SectorNames.getDisplayName(
                    widget.sectorName, 
                    DisplayMode.ticker, 
                    isDetailed: controller.isDetailedClassification, // ğŸš€ Controllerì—ì„œ ì¡°íšŒ!
                  ),
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),

          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„ (Volumeê³¼ ì™„ì „ ë™ì¼)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;

                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget(
                          totalAmount: widget.totalVolume,
                          isBuy: true,
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text(
                          AmountFormatter.formatVolume(widget.totalVolume),
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (Volumeê³¼ ì™„ì „ ë™ì¼)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;

    // âœ… ë¸”ë§í¬ ìƒíƒœì— ë”°ë¥¸ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (Volumeê³¼ ì™„ì „ ë™ì¼)
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: Colors.amber,
      );
    }

    return cardWidget;
  }
}