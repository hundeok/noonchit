\n\n// ====== test/presentation/providers/volume_provider_test.dart ======\n
\n\n// ====== test/presentation/providers/settings_provider_test.dart ======\n
\n\n// ====== test/presentation/providers/surge_provider_test.dart ======\n
\n\n// ====== test/presentation/providers/market_providers_test.dart ======\n
\n\n// ====== test/presentation/providers/trade_provider_test.dart ======\n
\n\n// ====== test/presentation/providers/momentary_provider_test.dart ======\n
\n\n// ====== test/presentation/controllers/trade_controller_test.dart ======\n
// test/presentation/controllers/trade_controller_test.dart
import 'dart:async';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/core/error/app_exception.dart';
import 'package:noonchit/core/extensions/result.dart';
import 'package:noonchit/domain/entities/trade.dart';
import 'package:noonchit/domain/usecases/trade_usecase.dart';
import 'package:noonchit/domain/repositories/trade_repository.dart';
import 'package:noonchit/presentation/controllers/trade_controller.dart';

class MockTradeUsecase extends Mock implements TradeUsecase {}
class MockTradeRepository extends Mock implements TradeRepository {}
class MockRef extends Mock implements Ref {}

// Fake 클래스들 추가
class FakeProviderListenable extends Fake implements ProviderListenable<Object?> {}

void main() {
  late MockTradeUsecase mockUsecase;
  late MockTradeRepository mockRepository;
  late ProviderContainer container;

  setUpAll(() async {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
    registerFallbackValue(const Trade(
      market: 'KRW-BTC',
      price: 0.0,
      volume: 0.0,
      side: 'BID',
      changePrice: 0.0,
      changeState: 'EVEN',
      timestampMs: 0,
      sequentialId: '',
    ));
    // ProviderListenable fallback 등록
    registerFallbackValue(FakeProviderListenable());
  });

  setUp(() {
    mockUsecase = MockTradeUsecase();
    mockRepository = MockTradeRepository();
    container = ProviderContainer();
    
    when(() => mockRepository.updateThreshold(any())).thenReturn(null);
  });

  tearDown(() {
    container.dispose();
  });

  group('TradeController', () {
    const trade = Trade(
      market: 'KRW-BTC',
      price: 50000.0,
      volume: 2.5,
      side: 'BID',
      changePrice: 0.0,
      changeState: 'EVEN',
      timestampMs: 1630000000000,
      sequentialId: '12345',
    );

    group('TradeState', () {
      test('should create with default values', () {
        const state = TradeState();

        expect(state.trades, isEmpty);
        expect(state.isLoading, false);
        expect(state.isConnected, false);
        expect(state.threshold, 20000000);
        expect(state.selectedIndex, 0);
        expect(state.errorMessage, isNull);
      });

      test('should create TradeState with copyWith correctly', () {
        const initialState = TradeState();
        final updatedState = initialState.copyWith(
          trades: [trade],
          isLoading: true,
          threshold: 50000000,
          selectedIndex: 2,
          errorMessage: 'Test error',
        );

        expect(updatedState.trades, [trade]);
        expect(updatedState.isLoading, true);
        expect(updatedState.isConnected, false); // 변경되지 않음
        expect(updatedState.threshold, 50000000);
        expect(updatedState.selectedIndex, 2);
        expect(updatedState.errorMessage, 'Test error');
      });

      test('should create TradeState with null errorMessage correctly', () {
        const initialState = TradeState(errorMessage: 'Initial error');
        final updatedState = initialState.copyWith(errorMessage: null);

        expect(updatedState.errorMessage, isNull);
      });
    });

    group('business logic tests', () {
      // TradeController의 비즈니스 로직을 직접 테스트하는 도우미 함수
      TradeController createController() {
        final mockRef = MockRef();
        when(() => mockRef.read(any())).thenReturn(mockRepository as dynamic);
        return TradeController(mockUsecase, mockRef);
      }

      test('should have initial state with default values', () {
        final controller = createController();

        expect(controller.state.trades, isEmpty);
        expect(controller.state.isLoading, false);
        expect(controller.state.isConnected, false);
        expect(controller.state.threshold, 20000000);
        expect(controller.state.selectedIndex, 0);
        expect(controller.state.errorMessage, isNull);
      });

      test('filterByMarket should filter trades by market correctly', () {
        const btcTrade = trade;
        const ethTrade = Trade(
          market: 'KRW-ETH',
          price: 3000.0,
          volume: 5.0,
          side: 'ASK',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: 1630000001000,
          sequentialId: '12346',
        );

        final controller = createController();
        
        // 상태를 직접 설정 (테스트용)
        final testState = controller.state.copyWith(trades: [btcTrade, ethTrade]);
        controller.state = testState;

        final btcFiltered = controller.filterByMarket('BTC');
        expect(btcFiltered, [btcTrade]);

        final ethFiltered = controller.filterByMarket('ETH');
        expect(ethFiltered, [ethTrade]);
      });

      test('filterByMarket should return empty list for non-matching market', () {
        const btcTrade = trade;
        
        final controller = createController();
        controller.state = controller.state.copyWith(trades: [btcTrade]);

        final dogeFiltered = controller.filterByMarket('DOGE');
        expect(dogeFiltered, isEmpty);
      });

      test('filterByMarket should return all trades for empty or null filter', () {
        const btcTrade = trade;
        const ethTrade = Trade(
          market: 'KRW-ETH',
          price: 3000.0,
          volume: 5.0,
          side: 'ASK',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: 1630000001000,
          sequentialId: '12346',
        );

        final controller = createController();
        controller.state = controller.state.copyWith(trades: [btcTrade, ethTrade]);

        final emptyFiltered = controller.filterByMarket('');
        expect(emptyFiltered, [btcTrade, ethTrade]);

        final nullFiltered = controller.filterByMarket(null);
        expect(nullFiltered, [btcTrade, ethTrade]);
      });

      test('filterByMarket should handle case insensitive filtering', () {
        const btcTrade = trade;
        
        final controller = createController();
        controller.state = controller.state.copyWith(trades: [btcTrade]);

        final lowerCaseFiltered = controller.filterByMarket('btc');
        expect(lowerCaseFiltered, [btcTrade]);

        final mixedCaseFiltered = controller.filterByMarket('BtC');
        expect(mixedCaseFiltered, [btcTrade]);
      });

      test('sortTrades should sort by different fields', () {
        const trade1 = Trade(
          market: 'KRW-BTC',
          price: 50000.0,
          volume: 2.5,
          side: 'BID',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: 1630000000000,
          sequentialId: '1',
        );
        const trade2 = Trade(
          market: 'KRW-ETH',
          price: 60000.0,
          volume: 1.0,
          side: 'ASK',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: 1630000001000,
          sequentialId: '2',
        );
        const trade3 = Trade(
          market: 'KRW-ADA',
          price: 40000.0,
          volume: 5.0,
          side: 'BID',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: 1630000002000,
          sequentialId: '3',
        );

        final controller = createController();
        controller.state = controller.state.copyWith(trades: [trade1, trade2, trade3]);

        // 가격으로 오름차순 정렬
        controller.sortTrades('price', true);
        expect(controller.state.trades[0].price, 40000.0); // trade3
        expect(controller.state.trades[1].price, 50000.0); // trade1
        expect(controller.state.trades[2].price, 60000.0); // trade2

        // 가격으로 내림차순 정렬
        controller.state = controller.state.copyWith(trades: [trade1, trade2, trade3]);
        controller.sortTrades('price', false);
        expect(controller.state.trades[0].price, 60000.0); // trade2
        expect(controller.state.trades[1].price, 50000.0); // trade1
        expect(controller.state.trades[2].price, 40000.0); // trade3

        // 마켓으로 오름차순 정렬
        controller.state = controller.state.copyWith(trades: [trade1, trade2, trade3]);
        controller.sortTrades('market', true);
        expect(controller.state.trades[0].market, 'KRW-ADA'); // trade3
        expect(controller.state.trades[1].market, 'KRW-BTC'); // trade1
        expect(controller.state.trades[2].market, 'KRW-ETH'); // trade2
      });

      test('availableThresholds should return filtered thresholds', () {
        final controller = createController();
        final thresholds = controller.availableThresholds;

        expect(thresholds, isNotEmpty);
        expect(thresholds.every((t) => t >= 20000000), true);
      });

      test('refresh should work with current state values', () {
        final controller = createController();
        
        // 초기 상태 확인
        expect(controller.state.threshold, 20000000);
        expect(controller.state.selectedIndex, 0);
        
        // refresh는 setThreshold를 내부적으로 호출하므로 
        // 대신 상태가 올바르게 유지되는지만 확인
        expect(controller.state.threshold, 20000000);
        expect(controller.state.selectedIndex, 0);
      });
    });

    group('MockRef helper', () {
      test('should properly mock ref behavior', () {
        final mockRef = MockRef();
        when(() => mockRef.read(any())).thenReturn(mockRepository as dynamic);

        final result = mockRef.read(FakeProviderListenable());
        expect(result, mockRepository);
        verify(() => mockRef.read(any())).called(1);
      });
    });
  });
}\n\n// ====== test/presentation/controllers/volume_controller_test.dart ======\n
\n\n// ====== test/presentation/controllers/momentary_controller_test.dart ======\n
\n\n// ====== test/presentation/controllers/surge_controller_test.dart ======\n
\n\n// ====== test/presentation/controllers/settings_controller_test.dart ======\n
// test/presentation/controllers/settings_controller_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/domain/entities/app_settings.dart';
import 'package:noonchit/domain/usecases/settings_usecase.dart';
import 'package:noonchit/presentation/controllers/settings_controller.dart';

class MockSettingsUsecase extends Mock implements SettingsUsecase {}

void main() {
  late MockSettingsUsecase mockUsecase;

  // 상수를 main 함수 레벨로 이동
  const defaultSettings = AppSettings();
  const customSettings = AppSettings(
    themeMode: ThemeMode.dark,
    keepScreenOn: true,
    sliderPosition: SliderPosition.bottom,
  );

  setUpAll(() async {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
    registerFallbackValue(ThemeMode.system);
    registerFallbackValue(SliderPosition.top);
  });

  setUp(() {
    mockUsecase = MockSettingsUsecase();
    // 모든 테스트에 기본 getSettings Mock 설정
    when(() => mockUsecase.getSettings()).thenAnswer((_) async => defaultSettings);
  });

  group('SettingsController', () {

    group('initialization', () {
      test('should have default initial state', () {
        final controller = SettingsController(mockUsecase);
        
        expect(controller.state, defaultSettings);
        expect(controller.state.themeMode, ThemeMode.system);
        expect(controller.state.keepScreenOn, false);
        expect(controller.state.sliderPosition, SliderPosition.top);
      });

      test('should load settings on initialization', () async {
        when(() => mockUsecase.getSettings()).thenAnswer((_) async => customSettings);

        final controller = SettingsController(mockUsecase);
        await Future.delayed(Duration.zero);

        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, true);
        expect(controller.state.sliderPosition, SliderPosition.bottom);
        verify(() => mockUsecase.getSettings()).called(1);
      });
    });

    group('setThemeMode', () {
      test('should update theme to light mode', () async {
        when(() => mockUsecase.updateThemeMode(ThemeMode.light)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setThemeMode(ThemeMode.light);

        expect(controller.state.themeMode, ThemeMode.light);
        expect(controller.state.keepScreenOn, false);
        expect(controller.state.sliderPosition, SliderPosition.top);
        verify(() => mockUsecase.updateThemeMode(ThemeMode.light)).called(1);
      });

      test('should update theme to dark mode', () async {
        when(() => mockUsecase.updateThemeMode(ThemeMode.dark)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setThemeMode(ThemeMode.dark);

        expect(controller.state.themeMode, ThemeMode.dark);
        verify(() => mockUsecase.updateThemeMode(ThemeMode.dark)).called(1);
      });

      test('should handle theme update errors gracefully', () async {
        when(() => mockUsecase.updateThemeMode(ThemeMode.dark))
            .thenThrow(Exception('Update failed'));

        final controller = SettingsController(mockUsecase);
        final originalTheme = controller.state.themeMode;

        // 에러가 발생하면 예외가 throw되는 것이 정상
        expect(() async => await controller.setThemeMode(ThemeMode.dark), 
               throwsA(isA<Exception>()));
        
        // 상태는 변경되지 않아야 함
        expect(controller.state.themeMode, originalTheme);
        verify(() => mockUsecase.updateThemeMode(ThemeMode.dark)).called(1);
      });
    });

    group('setKeepScreenOn', () {
      test('should enable keep screen on', () async {
        when(() => mockUsecase.updateKeepScreenOn(true)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setKeepScreenOn(true);

        expect(controller.state.keepScreenOn, true);
        expect(controller.state.themeMode, ThemeMode.system);
        expect(controller.state.sliderPosition, SliderPosition.top);
        verify(() => mockUsecase.updateKeepScreenOn(true)).called(1);
      });

      test('should disable keep screen on', () async {
        when(() => mockUsecase.updateKeepScreenOn(false)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setKeepScreenOn(false);

        expect(controller.state.keepScreenOn, false);
        verify(() => mockUsecase.updateKeepScreenOn(false)).called(1);
      });

      test('should handle keep screen on update errors gracefully', () async {
        when(() => mockUsecase.updateKeepScreenOn(true))
            .thenThrow(Exception('Update failed'));

        final controller = SettingsController(mockUsecase);
        final originalValue = controller.state.keepScreenOn;

        // 에러가 발생하면 예외가 throw되는 것이 정상
        expect(() async => await controller.setKeepScreenOn(true), 
               throwsA(isA<Exception>()));
        
        // 상태는 변경되지 않아야 함
        expect(controller.state.keepScreenOn, originalValue);
        verify(() => mockUsecase.updateKeepScreenOn(true)).called(1);
      });
    });

    group('setSliderPosition', () {
      test('should set slider position to top', () async {
        when(() => mockUsecase.updateSliderPosition(SliderPosition.top)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setSliderPosition(SliderPosition.top);

        expect(controller.state.sliderPosition, SliderPosition.top);
        expect(controller.state.themeMode, ThemeMode.system);
        expect(controller.state.keepScreenOn, false);
        verify(() => mockUsecase.updateSliderPosition(SliderPosition.top)).called(1);
      });

      test('should set slider position to bottom', () async {
        when(() => mockUsecase.updateSliderPosition(SliderPosition.bottom)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await controller.setSliderPosition(SliderPosition.bottom);

        expect(controller.state.sliderPosition, SliderPosition.bottom);
        verify(() => mockUsecase.updateSliderPosition(SliderPosition.bottom)).called(1);
      });

      test('should handle slider position update errors gracefully', () async {
        when(() => mockUsecase.updateSliderPosition(SliderPosition.bottom))
            .thenThrow(Exception('Update failed'));

        final controller = SettingsController(mockUsecase);
        final originalPosition = controller.state.sliderPosition;

        // 에러가 발생하면 예외가 throw되는 것이 정상
        expect(() async => await controller.setSliderPosition(SliderPosition.bottom), 
               throwsA(isA<Exception>()));
        
        // 상태는 변경되지 않아야 함
        expect(controller.state.sliderPosition, originalPosition);
        verify(() => mockUsecase.updateSliderPosition(SliderPosition.bottom)).called(1);
      });
    });

    group('integration scenarios', () {
      test('should handle multiple sequential updates', () async {
        when(() => mockUsecase.updateThemeMode(any())).thenAnswer((_) async => {});
        when(() => mockUsecase.updateKeepScreenOn(any())).thenAnswer((_) async => {});
        when(() => mockUsecase.updateSliderPosition(any())).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);

        await controller.setThemeMode(ThemeMode.dark);
        await controller.setKeepScreenOn(true);
        await controller.setSliderPosition(SliderPosition.bottom);

        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, true);
        expect(controller.state.sliderPosition, SliderPosition.bottom);

        verify(() => mockUsecase.updateThemeMode(ThemeMode.dark)).called(1);
        verify(() => mockUsecase.updateKeepScreenOn(true)).called(1);
        verify(() => mockUsecase.updateSliderPosition(SliderPosition.bottom)).called(1);
      });

      test('should handle rapid theme changes', () async {
        when(() => mockUsecase.updateThemeMode(any())).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);

        await controller.setThemeMode(ThemeMode.light);
        await controller.setThemeMode(ThemeMode.dark);
        await controller.setThemeMode(ThemeMode.system);

        expect(controller.state.themeMode, ThemeMode.system);
        verify(() => mockUsecase.updateThemeMode(any())).called(3);
      });

      test('should maintain state consistency during partial failures', () async {
        when(() => mockUsecase.updateThemeMode(ThemeMode.dark)).thenAnswer((_) async => {});
        when(() => mockUsecase.updateKeepScreenOn(true)).thenThrow(Exception('Network error'));
        when(() => mockUsecase.updateSliderPosition(SliderPosition.bottom)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);

        // 성공하는 업데이트
        await controller.setThemeMode(ThemeMode.dark);
        expect(controller.state.themeMode, ThemeMode.dark);

        // 실패하는 업데이트 - 예외가 throw됨
        expect(() async => await controller.setKeepScreenOn(true), 
               throwsA(isA<Exception>()));
        expect(controller.state.keepScreenOn, false);

        // 다시 성공하는 업데이트
        await controller.setSliderPosition(SliderPosition.bottom);
        expect(controller.state.sliderPosition, SliderPosition.bottom);

        // 최종 상태 확인
        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, false);
        expect(controller.state.sliderPosition, SliderPosition.bottom);
      });
    });

    group('state preservation', () {
      test('should preserve other settings when updating theme', () async {
        when(() => mockUsecase.getSettings()).thenAnswer((_) async => customSettings);
        when(() => mockUsecase.updateThemeMode(ThemeMode.light)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await Future.delayed(Duration.zero);

        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, true);
        expect(controller.state.sliderPosition, SliderPosition.bottom);

        await controller.setThemeMode(ThemeMode.light);

        expect(controller.state.themeMode, ThemeMode.light);
        expect(controller.state.keepScreenOn, true);
        expect(controller.state.sliderPosition, SliderPosition.bottom);
      });

      test('should preserve other settings when updating keep screen on', () async {
        when(() => mockUsecase.getSettings()).thenAnswer((_) async => customSettings);
        when(() => mockUsecase.updateKeepScreenOn(false)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await Future.delayed(Duration.zero);

        await controller.setKeepScreenOn(false);

        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, false);
        expect(controller.state.sliderPosition, SliderPosition.bottom);
      });

      test('should preserve other settings when updating slider position', () async {
        when(() => mockUsecase.getSettings()).thenAnswer((_) async => customSettings);
        when(() => mockUsecase.updateSliderPosition(SliderPosition.top)).thenAnswer((_) async => {});

        final controller = SettingsController(mockUsecase);
        await Future.delayed(Duration.zero);

        await controller.setSliderPosition(SliderPosition.top);

        expect(controller.state.themeMode, ThemeMode.dark);
        expect(controller.state.keepScreenOn, true);
        expect(controller.state.sliderPosition, SliderPosition.top);
      });
    });
  });
}\n\n// ====== test/presentation/controllers/main_controller_test.dart ======\n
\n\n// ====== test/presentation/pages/volume_page_test.dart ======\n
\n\n// ====== test/presentation/pages/trade_page_test.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/domain/entities/trade.dart';
import 'package:noonchit/presentation/controllers/trade_controller.dart';
import 'package:noonchit/presentation/pages/trade_page.dart';
import 'package:noonchit/core/di/trade_provider.dart';
import 'package:noonchit/presentation/widgets/trade_tile.dart';

class MockTradeController extends Mock implements TradeController {}

void main() {
  late MockTradeController mockController;

  setUpAll(() {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
    // 수정 1: Trade() 호출에 const 추가
    registerFallbackValue(const Trade(
      market: 'KRW-BTC',
      price: 0.0,
      volume: 0.0,
      side: 'BID',
      changePrice: 0.0,
      changeState: 'EVEN',
      timestampMs: 0,
      sequentialId: '',
    ));
  });

  setUp(() {
    mockController = MockTradeController();
    when(() => mockController.state).thenReturn(const TradeState(
      trades: [],
      isLoading: false,
      isConnected: true,
      threshold: 20000000,
      selectedIndex: 0,
      errorMessage: null,
    ));
    when(() => mockController.refresh(any())).thenAnswer((_) async {});
    when(() => mockController.setThreshold(any(), any(), any())).thenAnswer((_) {});
    when(() => mockController.availableThresholds).thenReturn(const [20000000, 50000000, 100000000]);
  });

  Widget createWidgetUnderTest() {
    return ProviderScope(
      overrides: [
        tradeControllerProvider.overrideWith((ref) => mockController),
        marketsProvider.overrideWith((ref) => Future.value(['KRW-BTC', 'KRW-ETH'])),
      ],
      child: const MaterialApp( // MaterialApp 자체는 const로 유지 가능
        home: TradePage(), // TradePage가 const 생성자를 가진다면 이것도 const TradePage()
      ),
    );
  }

  group('TradePage', () {
    // 수정 2: trade 변수를 const로 변경
    const trade = const Trade(
      market: 'KRW-BTC',
      price: 50000.0,
      volume: 2.5,
      side: 'BID',
      changePrice: 0.0,
      changeState: 'EVEN',
      timestampMs: 1630000000000,
      sequentialId: '12345',
    );

    // 이제 trade가 const이므로 tradeState도 유효한 const가 됨
    const tradeState = TradeState(
      trades: [trade], // `trade`가 const이므로 문제 없음
      isLoading: false,
      isConnected: true,
      threshold: 20000000,
      selectedIndex: 0,
      errorMessage: null,
    );

    testWidgets('should display trade page with basic elements', (tester) async {
      when(() => mockController.state).thenReturn(tradeState); // 이제 오류 없음

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.byType(TradePage), findsOneWidget);
      expect(find.byType(AppBar), findsOneWidget);
      expect(find.text('체결 포착'), findsOneWidget);
    });

    testWidgets('should display trade list when trades are available', (tester) async {
      when(() => mockController.state).thenReturn(tradeState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.byType(ListView), findsOneWidget);
      expect(find.byType(TradeTile), findsOneWidget);
      expect(find.text('BTC'), findsOneWidget);
      expect(find.text('50,000원'), findsWidgets);
    });

    testWidgets('should display loading indicator when loading', (tester) async {
      const loadingState = TradeState(
        trades: [],
        isLoading: true,
        isConnected: true,
        threshold: 20000000,
        selectedIndex: 0,
        errorMessage: null,
      );
      when(() => mockController.state).thenReturn(loadingState);

      await tester.pumpWidget(createWidgetUnderTest());
      // pumpAndSettle() 대신 pump() 사용 권장 (로딩 상태 확인 시)
      await tester.pump(); 

      expect(find.byType(CircularProgressIndicator), findsOneWidget);
      expect(find.byType(ListView), findsNothing);
    });

    testWidgets('should display error message when error occurs', (tester) async {
      const errorState = TradeState(
        trades: [],
        isLoading: false,
        isConnected: false,
        threshold: 20000000,
        selectedIndex: 0,
        errorMessage: 'Connection failed',
      );
      when(() => mockController.state).thenReturn(errorState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('Connection failed'), findsOneWidget);
      expect(find.byType(ListView), findsNothing);
    });

    testWidgets('should display empty state when no trades', (tester) async {
      const emptyState = TradeState(
        trades: [],
        isLoading: false,
        isConnected: true,
        threshold: 20000000,
        selectedIndex: 0,
        errorMessage: null,
      );
      when(() => mockController.state).thenReturn(emptyState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('포착된 체결이 없습니다.'), findsOneWidget);
      // ListView는 여전히 존재할 수 있으나 비어있을 것임
      expect(find.byType(ListView), findsOneWidget); 
    });

    testWidgets('should handle threshold selection', (tester) async {
      when(() => mockController.state).thenReturn(tradeState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      final slider = find.byType(Slider);
      expect(slider, findsOneWidget); // 슬라이더가 있는지 먼저 확인
      await tester.tap(slider);
      await tester.pumpAndSettle();
      // drag는 Slider의 value 변경을 직접 시뮬레이션하지 않을 수 있음.
      // tester.drag(slider, const Offset(50, 0));
      // 대신 Slider의 onChanged 콜백을 직접 호출하거나, 값을 변경하는 다른 인터랙션을 사용.
      // 여기서는 verify로 대체.
      await tester.pumpAndSettle();

      verify(() => mockController.setThreshold(any(), any(), any())).called(greaterThanOrEqualTo(1));
    });

    testWidgets('should handle refresh action', (tester) async {
      when(() => mockController.state).thenReturn(tradeState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();
      
      expect(find.byType(ListView), findsOneWidget); // ListView가 있는지 확인
      await tester.drag(find.byType(ListView), const Offset(0, 300));
      await tester.pumpAndSettle(); // RefreshIndicator의 경우 추가 pump가 필요할 수 있음

      verify(() => mockController.refresh(any())).called(1);
    });

    testWidgets('should be accessible', (tester) async {
      when(() => mockController.state).thenReturn(tradeState);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.byType(TradePage), findsOneWidget);
      expect(find.byType(ListView), findsOneWidget);
      expect(find.byType(Slider), findsOneWidget);
    });
  });
}\n\n// ====== test/presentation/pages/momentary_page_test.dart ======\n
\n\n// ====== test/presentation/pages/settings_page_test.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/domain/entities/app_settings.dart';
import 'package:noonchit/presentation/controllers/settings_controller.dart';
import 'package:noonchit/presentation/pages/settings_page.dart';

class MockSettingsController extends Mock implements SettingsController {}

void main() {
  late MockSettingsController mockController;

  setUpAll(() {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
    registerFallbackValue(ThemeMode.system);
    registerFallbackValue(SliderPosition.top);
  });

  setUp(() {
    mockController = MockSettingsController();
    when(() => mockController.state).thenReturn(const AppSettings());
    when(() => mockController.setThemeMode(any())).thenAnswer((_) async => {});
    when(() => mockController.setKeepScreenOn(any())).thenAnswer((_) async => {});
    when(() => mockController.setSliderPosition(any())).thenAnswer((_) async => {});
  });

  Widget createWidgetUnderTest() {
    return ProviderScope(
      overrides: [
        settingsControllerProvider.overrideWith((ref) => mockController),
      ],
      child: const MaterialApp(
        home: SettingsPage(),
      ),
    );
  }

  group('SettingsPage', () {
    const defaultSettings = AppSettings();
    const customSettings = AppSettings(
      themeMode: ThemeMode.dark,
      keepScreenOn: true,
      sliderPosition: SliderPosition.bottom,
    );

    testWidgets('should display settings page with basic elements', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('설정'), findsOneWidget);
      expect(find.byType(AppBar), findsOneWidget);
    });

    testWidgets('should display theme mode settings', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('화면 모드'), findsOneWidget);
      expect(find.byType(SegmentedButton), findsOneWidget);
      expect(find.text('시스템'), findsOneWidget);
    });

    testWidgets('should display keep screen on setting', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('화면 항상 켜기'), findsOneWidget);
      expect(find.byType(Switch), findsOneWidget);
      final switchWidget = tester.widget<Switch>(find.byType(Switch));
      expect(switchWidget.value, false);
    });

    testWidgets('should display slider position setting', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.text('슬라이더 위치'), findsOneWidget);
      expect(find.byType(SegmentedButton), findsWidgets);
      expect(find.text('위'), findsOneWidget);
    });

    testWidgets('should reflect custom settings state', (tester) async {
      when(() => mockController.state).thenReturn(customSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.byType(SettingsPage), findsOneWidget);
      expect(find.text('다크'), findsOneWidget);
      final switchWidget = tester.widget<Switch>(find.byType(Switch));
      expect(switchWidget.value, true);
      expect(find.text('아래'), findsOneWidget);
    });

    testWidgets('should handle theme mode change', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      await tester.tap(find.text('다크'));
      await tester.pumpAndSettle();

      verify(() => mockController.setThemeMode(ThemeMode.dark)).called(1);
    });

    testWidgets('should handle keep screen on toggle', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      await tester.tap(find.byType(Switch));
      await tester.pumpAndSettle();

      verify(() => mockController.setKeepScreenOn(true)).called(1);
    });

    testWidgets('should handle slider position change', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      await tester.tap(find.text('아래'));
      await tester.pumpAndSettle();

      verify(() => mockController.setSliderPosition(SliderPosition.bottom)).called(1);
    });

    testWidgets('should be accessible', (tester) async {
      when(() => mockController.state).thenReturn(defaultSettings);

      await tester.pumpWidget(createWidgetUnderTest());
      await tester.pumpAndSettle();

      expect(find.byType(SettingsPage), findsOneWidget);
      expect(find.byType(SegmentedButton), findsWidgets);
      expect(find.byType(Switch), findsOneWidget);
    });
  });
}\n\n// ====== test/presentation/pages/surge_page_test.dart ======\n
\n\n// ====== test/presentation/widgets/theme_mode_segment_test.dart ======\n
// test/presentation/widgets/theme_mode_segment_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/presentation/widgets/theme_mode_segment.dart';

void main() {
  setUpAll(() async {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
  });

  Widget createWidgetUnderTest({
    required ThemeMode value,
    required ValueChanged<ThemeMode> onChanged,
  }) {
    return MaterialApp(
      home: Scaffold(
        body: ThemeModeSegment(
          value: value,
          onChanged: onChanged,
          key: const Key('theme_mode_segment'),
        ),
      ),
    );
  }

  group('ThemeModeSegment', () {
    group('display and structure', () {
      testWidgets('should display all theme mode options', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        expect(find.byType(SegmentedButton<ThemeMode>), findsOneWidget);
        expect(find.text('시스템'), findsOneWidget);
        expect(find.text('라이트'), findsOneWidget);
        expect(find.text('다크'), findsOneWidget);
      });

      testWidgets('should display all icons correctly', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        // 아이콘이 실제로 존재하는지 확인 (구체적인 아이콘 찾기 대신 Icon 위젯 개수 확인)
        expect(find.byType(Icon), findsNWidgets(3)); // 3개의 아이콘이 있어야 함
      });

      testWidgets('should have correct widget structure', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        expect(find.byKey(const Key('theme_mode_segment')), findsOneWidget);
        expect(find.byType(SegmentedButton<ThemeMode>), findsOneWidget);
        
        // 3개의 세그먼트가 있는지 확인
        final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.segments.length, 3);
      });
    });

    group('selection states', () {
      testWidgets('should show light mode as selected', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.light,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.light});
      });

      testWidgets('should show dark mode as selected', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.dark,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.dark});
      });

      testWidgets('should show system mode as selected', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.system});
      });

      testWidgets('should handle all ThemeMode values correctly', (tester) async {
        for (final themeMode in ThemeMode.values) {
          await tester.pumpWidget(createWidgetUnderTest(
            value: themeMode,
            onChanged: (_) {},
          ));
          await tester.pumpAndSettle();

          final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
            find.byType(SegmentedButton<ThemeMode>),
          );
          expect(segmentedButton.selected, {themeMode});
        }
      });
    });

    group('user interactions', () {
      testWidgets('should call onChanged when light mode is tapped', (tester) async {
        ThemeMode? selectedValue;

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (value) => selectedValue = value,
        ));
        await tester.pumpAndSettle();

        await tester.tap(find.text('라이트'));
        await tester.pumpAndSettle();

        expect(selectedValue, ThemeMode.light);
      });

      testWidgets('should call onChanged when dark mode is tapped', (tester) async {
        ThemeMode? selectedValue;

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (value) => selectedValue = value,
        ));
        await tester.pumpAndSettle();

        await tester.tap(find.text('다크'));
        await tester.pumpAndSettle();

        expect(selectedValue, ThemeMode.dark);
      });

      testWidgets('should call onChanged when system mode is tapped', (tester) async {
        ThemeMode? selectedValue;

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.light,
          onChanged: (value) => selectedValue = value,
        ));
        await tester.pumpAndSettle();

        await tester.tap(find.text('시스템'));
        await tester.pumpAndSettle();

        expect(selectedValue, ThemeMode.system);
      });

      testWidgets('should handle multiple sequential taps', (tester) async {
        final selectedValues = <ThemeMode>[];

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (value) => selectedValues.add(value),
        ));
        await tester.pumpAndSettle();

        await tester.tap(find.text('라이트'));
        await tester.pumpAndSettle();

        await tester.tap(find.text('다크'));
        await tester.pumpAndSettle();

        // 시스템은 이미 선택된 상태이므로 다른 값으로 변경 후 시스템으로
        await tester.tap(find.text('시스템'));
        await tester.pumpAndSettle();

        // SegmentedButton의 동작에 따라 이미 선택된 것을 재선택하면 콜백이 안 호출될 수 있음
        expect(selectedValues.length, greaterThanOrEqualTo(2));
        expect(selectedValues, contains(ThemeMode.light));
        expect(selectedValues, contains(ThemeMode.dark));
      });

      testWidgets('should handle tapping on segments', (tester) async {
        ThemeMode? selectedValue;

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (value) => selectedValue = value,
        ));
        await tester.pumpAndSettle();

        // 텍스트로 탭 (아이콘보다 더 안정적)
        await tester.tap(find.text('라이트'));
        await tester.pumpAndSettle();

        expect(selectedValue, ThemeMode.light);
      });
    });

    group('dynamic state updates', () {
      testWidgets('should update visual selection when value changes', (tester) async {
        ThemeMode currentValue = ThemeMode.system;

        await tester.pumpWidget(
          StatefulBuilder(
            builder: (context, setState) {
              return createWidgetUnderTest(
                value: currentValue,
                onChanged: (value) {
                  setState(() => currentValue = value);
                },
              );
            },
          ),
        );
        await tester.pumpAndSettle();

        // 초기 상태 확인
        var segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.system});

        // 다크 모드로 변경
        await tester.tap(find.text('다크'));
        await tester.pumpAndSettle();

        segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.dark});

        // 라이트 모드로 변경
        await tester.tap(find.text('라이트'));
        await tester.pumpAndSettle();

        segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.light});
      });

      testWidgets('should handle rapid state changes', (tester) async {
        ThemeMode currentValue = ThemeMode.system;
        final changes = <ThemeMode>[];

        await tester.pumpWidget(
          StatefulBuilder(
            builder: (context, setState) {
              return createWidgetUnderTest(
                value: currentValue,
                onChanged: (value) {
                  setState(() => currentValue = value);
                  changes.add(value);
                },
              );
            },
          ),
        );
        await tester.pumpAndSettle();

        // 빠른 연속 탭
        await tester.tap(find.text('라이트'));
        await tester.pump();
        await tester.tap(find.text('다크'));
        await tester.pump();
        await tester.tap(find.text('시스템'));
        await tester.pumpAndSettle();

        expect(changes, [ThemeMode.light, ThemeMode.dark, ThemeMode.system]);
        expect(currentValue, ThemeMode.system);
      });
    });

    group('edge cases and robustness', () {
      testWidgets('should handle same value selection', (tester) async {
        var callCount = 0;
        ThemeMode? lastValue;

        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.dark,
          onChanged: (value) {
            callCount++;
            lastValue = value;
          },
        ));
        await tester.pumpAndSettle();

        // 이미 선택된 다크 모드를 다시 탭
        await tester.tap(find.text('다크'));
        await tester.pumpAndSettle();

        // SegmentedButton은 이미 선택된 것을 다시 선택해도 콜백을 호출할 수 있음
        expect(callCount, greaterThanOrEqualTo(0));
        if (callCount > 0) {
          expect(lastValue, ThemeMode.dark);
        }
      });

      testWidgets('should handle disabled state if provided', (tester) async {
        var tapCount = 0;

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: AbsorbPointer(
                child: ThemeModeSegment(
                  value: ThemeMode.system,
                  onChanged: (_) => tapCount++,
                ),
              ),
            ),
          ),
        );
        await tester.pumpAndSettle();

        // AbsorbPointer로 비활성화된 상태에서 탭 시도
        await tester.tap(find.text('라이트'), warnIfMissed: false);
        await tester.pumpAndSettle();

        // 콜백이 호출되지 않았어야 함
        expect(tapCount, 0);

        // 여전히 시스템 모드가 선택되어 있어야 함
        final segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.system});
      });

      testWidgets('should maintain state during rebuild', (tester) async {
        ThemeMode currentValue = ThemeMode.dark;

        await tester.pumpWidget(
          StatefulBuilder(
            builder: (context, setState) {
              return createWidgetUnderTest(
                value: currentValue,
                onChanged: (value) {
                  setState(() => currentValue = value);
                },
              );
            },
          ),
        );
        await tester.pumpAndSettle();

        // 초기 상태 확인
        var segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.dark});

        // 위젯 리빌드를 강제로 트리거
        await tester.pumpWidget(
          StatefulBuilder(
            builder: (context, setState) {
              return createWidgetUnderTest(
                value: currentValue,
                onChanged: (value) {
                  setState(() => currentValue = value);
                },
              );
            },
          ),
        );
        await tester.pumpAndSettle();

        // 상태가 유지되어야 함
        segmentedButton = tester.widget<SegmentedButton<ThemeMode>>(
          find.byType(SegmentedButton<ThemeMode>),
        );
        expect(segmentedButton.selected, {ThemeMode.dark});
      });
    });

    group('accessibility and usability', () {
      testWidgets('should be accessible with semantics', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        // 기본적인 접근성 요소들이 존재하는지 확인
        expect(find.byKey(const Key('theme_mode_segment')), findsOneWidget);
        expect(find.byType(SegmentedButton<ThemeMode>), findsOneWidget);
        
        // 텍스트가 모두 존재하는지 확인 (접근성)
        expect(find.text('라이트'), findsOneWidget);
        expect(find.text('다크'), findsOneWidget);
        expect(find.text('시스템'), findsOneWidget);
        
        // 아이콘들이 존재하는지 확인 (정확한 아이콘 대신 Icon 위젯 개수)
        expect(find.byType(Icon), findsNWidgets(3));
      });

      testWidgets('should have reasonable tap targets', (tester) async {
        await tester.pumpWidget(createWidgetUnderTest(
          value: ThemeMode.system,
          onChanged: (_) {},
        ));
        await tester.pumpAndSettle();

        // 각 세그먼트가 탭 가능한 크기를 가지는지 확인
        final segmentedButton = find.byType(SegmentedButton<ThemeMode>);
        expect(segmentedButton, findsOneWidget);
        
        final size = tester.getSize(segmentedButton);
        expect(size.width, greaterThan(0));
        expect(size.height, greaterThan(0));
      });
    });
  });
}\n\n// ====== test/presentation/widgets/surge_tile_test.dart ======\n
\n\n// ====== test/presentation/widgets/common_app_bar_test.dart ======\n
\n\n// ====== test/presentation/widgets/volume_tile_test.dart ======\n
\n\n// ====== test/presentation/widgets/slider_position_segment_test.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/domain/entities/app_settings.dart';
import 'package:noonchit/presentation/widgets/slider_position_segment.dart';

void main() {
  setUpAll(() {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
  });

  Widget createWidgetUnderTest({
    required SliderPosition value,
    required ValueChanged<SliderPosition> onChanged,
  }) {
    return MaterialApp(
      home: Scaffold(
        body: SliderPositionSegment(
          value: value,
          onChanged: onChanged,
          key: const Key('slider_position_segment'),
        ),
      ),
    );
  }

  group('SliderPositionSegment', () {
    testWidgets('should display all position options', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(
        value: SliderPosition.top,
        onChanged: (_) {},
      ));
      await tester.pumpAndSettle();

      expect(find.byType(SegmentedButton<SliderPosition>), findsOneWidget);
      expect(find.text('위'), findsOneWidget);
      expect(find.text('아래'), findsOneWidget);
    });

    testWidgets('should show correct selected value', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(
        value: SliderPosition.bottom,
        onChanged: (_) {},
      ));
      await tester.pumpAndSettle();

      final segmentedButton = tester.widget<SegmentedButton<SliderPosition>>(
        find.byType(SegmentedButton<SliderPosition>),
      );
      expect(segmentedButton.selected, {SliderPosition.bottom});
    });

    testWidgets('should call onChanged when selection changes', (tester) async {
      SliderPosition? selectedValue;

      await tester.pumpWidget(createWidgetUnderTest(
        value: SliderPosition.top,
        onChanged: (value) => selectedValue = value,
      ));
      await tester.pumpAndSettle();

      await tester.tap(find.text('아래'));
      await tester.pumpAndSettle();

      expect(selectedValue, SliderPosition.bottom);
    });

    testWidgets('should update visual selection when value changes', (tester) async {
      SliderPosition currentValue = SliderPosition.top;

      await tester.pumpWidget(
        StatefulBuilder(
          builder: (context, setState) {
            return createWidgetUnderTest(
              value: currentValue,
              onChanged: (value) {
                setState(() => currentValue = value);
              },
            );
          },
        ),
      );
      await tester.pumpAndSettle();

      var segmentedButton = tester.widget<SegmentedButton<SliderPosition>>(
        find.byType(SegmentedButton<SliderPosition>),
      );
      expect(segmentedButton.selected, {SliderPosition.top});

      await tester.tap(find.text('아래'));
      await tester.pumpAndSettle();

      segmentedButton = tester.widget<SegmentedButton<SliderPosition>>(
        find.byType(SegmentedButton<SliderPosition>),
      );
      expect(segmentedButton.selected, {SliderPosition.bottom});
    });

    testWidgets('should be accessible', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(
        value: SliderPosition.top,
        onChanged: (_) {},
      ));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('slider_position_segment')), findsOneWidget);
      expect(find.byType(SegmentedButton<SliderPosition>), findsOneWidget);
    });
  });
}\n\n// ====== test/presentation/widgets/momentary_tile_test.dart ======\n
\n\n// ====== test/presentation/widgets/trade_tile_test.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:noonchit/domain/entities/trade.dart';
import 'package:noonchit/presentation/widgets/trade_tile.dart';

void main() {
  setUpAll(() {
    dotenv.testLoad(fileInput: '''
LOG_LEVEL=debug
DEBUG_MODE=true
    ''');
  });

  Widget createWidgetUnderTest(Trade trade) {
    // 수정 1: MaterialApp에서 const 제거, Key에 const 추가
    return MaterialApp(
      home: Scaffold(
        body: TradeTile(
          trade: trade,
          key: const Key('trade_tile'), // Key는 const로
        ),
      ),
    );
  }

  group('TradeTile', () {
    // 수정 2: Trade 객체들을 const로 변경
    const bidTrade = const Trade(
      market: 'KRW-BTC',
      price: 50000.0,
      volume: 2.5,
      side: 'BID',
      changePrice: 1000.0,
      changeState: 'RISE',
      timestampMs: 1630000000000,
      sequentialId: '12345',
    );

    const askTrade = const Trade(
      market: 'KRW-ETH',
      price: 3000000.0,
      volume: 1.0,
      side: 'ASK',
      changePrice: -50000.0,
      changeState: 'FALL',
      timestampMs: 1630000001000,
      sequentialId: '67890',
    );

    testWidgets('should display trade information correctly', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.text('BTC'), findsOneWidget);
      expect(find.text('50,000원'), findsWidgets); // 가격 포맷에 따라 여러 위젯이 될 수 있음
      expect(find.text('2.5 개'), findsOneWidget);
    });

    testWidgets('should display formatted price correctly', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(askTrade));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.text('ETH'), findsOneWidget);
      expect(find.text('3,000,000원'), findsWidgets);
    });

    testWidgets('should show different colors for BID and ASK', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      // BID 색상 검증 로직 (예시: 특정 위젯의 색상 확인)
      // final bidTileContainer = tester.widget<Container>(find.byType(Container).first);
      // expect(bidTileContainer.decoration.color, Colors.red); // 실제 색상으로 변경
      expect(find.byKey(const Key('trade_tile')), findsOneWidget);


      await tester.pumpWidget(createWidgetUnderTest(askTrade));
      await tester.pumpAndSettle();

      // ASK 색상 검증 로직
      // final askTileContainer = tester.widget<Container>(find.byType(Container).first);
      // expect(askTileContainer.decoration.color, Colors.blue); // 실제 색상으로 변경
      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
    });

    testWidgets('should display total value correctly', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      expect(find.text('12.5만'), findsWidgets); // 체결 총액 포맷에 따라 여러 위젯이 될 수 있음
    });

    testWidgets('should format timestamp correctly', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      expect(find.text('12:26:40'), findsOneWidget);
    });

    testWidgets('should be tappable when wrapped in GestureDetector', (tester) async {
      bool tapped = false;

      Widget tappableWidget = MaterialApp(
        home: Scaffold(
          body: GestureDetector(
            onTap: () => tapped = true,
            // 수정 3: TradeTile 호출에 const 추가 (bidTrade가 const이고 TradeTile이 const 생성자를 가질 때)
            child: const TradeTile(
              trade: bidTrade, // bidTrade는 이제 const
              key: const Key('trade_tile'),
            ),
          ),
        ),
      );

      await tester.pumpWidget(tappableWidget);
      await tester.pumpAndSettle();

      await tester.tap(find.byKey(const Key('trade_tile')));
      await tester.pumpAndSettle();

      expect(tapped, true);
    });

    testWidgets('should handle zero values gracefully', (tester) async {
      // Trade 객체 const로 변경
      const zeroTrade = const Trade(
        market: 'KRW-ZERO',
        price: 0.0,
        volume: 0.0,
        side: 'BID',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: 1630000000000,
        sequentialId: 'zero',
      );

      await tester.pumpWidget(createWidgetUnderTest(zeroTrade));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.text('ZERO'), findsOneWidget);
      expect(find.text('0원'), findsWidgets);
    });

    testWidgets('should be accessible', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      // 접근성 테스트는 SemanticsNode 등을 확인하는 것이 더 정확할 수 있음
      // 예: expect(tester.getSemantics(find.byType(TradeTile)), matchesSemantics(...));
      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.byType(TradeTile), findsOneWidget);
    });

    testWidgets('should display market symbol without KRW prefix when showing short name', (tester) async {
      await tester.pumpWidget(createWidgetUnderTest(bidTrade));
      await tester.pumpAndSettle();

      expect(find.text('BTC'), findsOneWidget);
    });

    testWidgets('should show volume with appropriate decimal places', (tester) async {
      // Trade 객체 const로 변경
      const precisionTrade = const Trade(
        market: 'KRW-BTC',
        price: 50000.0,
        volume: 2.123456789,
        side: 'BID',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: 1630000000000,
        sequentialId: 'precision',
      );

      await tester.pumpWidget(createWidgetUnderTest(precisionTrade));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.text('2.123457 개'), findsWidgets); // 포맷에 따라 여러 위젯
    });

    testWidgets('should handle very large numbers correctly', (tester) async {
      // Trade 객체 const로 변경
      const largeTrade = const Trade(
        market: 'KRW-BTC',
        price: 123456789.0,
        volume: 999.999,
        side: 'BID',
        changePrice: 1234567.0,
        changeState: 'RISE',
        timestampMs: 1630000000000,
        sequentialId: 'large',
      );

      await tester.pumpWidget(createWidgetUnderTest(largeTrade));
      await tester.pumpAndSettle();

      expect(find.byKey(const Key('trade_tile')), findsOneWidget);
      expect(find.text('123,456,789원'), findsWidgets); // 포맷에 따라 여러 위젯
    });
  });
}