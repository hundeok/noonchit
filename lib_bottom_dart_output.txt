\n\n// ====== lib/core/di/bottom_line_provider.dart ======\n
// core/di/bottom_line_provider.dart
// ğŸ”¥ ë°”í…€ë¼ì¸ Provider - ì‹¤ì‹œê°„ ëˆ„ì  ë°ì´í„° ê¸°ë°˜

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../utils/logger.dart';
import '../services/openai_service.dart';
import '../utils/bottom_line_queue.dart';
import '../utils/bottom_line_constants.dart';
import '../utils/bottom_line_insight_engine.dart';
import '../../data/processors/bottom_line_aggregator.dart';
import '../../domain/entities/bottom_line.dart';
import '../../domain/entities/trade.dart';

// ğŸ”¥ ëª¨ë“  í•„ìš”í•œ Providerë“¤ì„ app_providersì—ì„œ import
import 'app_providers.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”¥ ë°”í…€ë¼ì¸ ì „ìš© ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘ (íƒ€ì„í”„ë ˆì„ ë¬´ê´€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ ì „ìš© ì‹¤ì‹œê°„ Trade ìŠ¤íŠ¸ë¦¼ (ë¦¬ì…‹ ì—†ìŒ)
final bottomLineTradeStreamProvider = StreamProvider<Trade>((ref) async* {
  ref.keepAlive(); // ì—°ê²° ìœ ì§€
  
  // ğŸ¯ Master Trade Stream ì§ì ‘ êµ¬ë… (íƒ€ì„í”„ë ˆì„ ë³€í™˜ ì—†ìŒ)
  final masterStream = await ref.read(masterTradeStreamProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.d('ğŸ”¥ Bottom line real-time stream started');
  }
  
  // ì‹¤ì‹œê°„ ë°ì´í„° ê·¸ëŒ€ë¡œ í˜ë ¤ë³´ë‚´ê¸° (í•„í„°ë§/ì§‘ê³„ ì—†ìŒ)
  yield* masterStream;
});

/// ë°”í…€ë¼ì¸ ì „ìš© ë°ì´í„° ì• ê·¸ë¦¬ê²Œì´í„° (ì§€ì†ì  ëˆ„ì )
final bottomLineRealtimeDataProvider = StreamProvider<MarketSnapshot>((ref) async* {
  final aggregator = ref.read(bottomLineAggregatorProvider);
  
  // 30ì´ˆë§ˆë‹¤ ìŠ¤ëƒ…ìƒ· ìƒì„± (ëˆ„ì  ë°ì´í„° ê¸°ë°˜)
  Timer.periodic(const Duration(seconds: BottomLineConstants.refreshIntervalSeconds), (timer) {
    final snapshot = aggregator.generateRealtimeSnapshot();
    if (snapshot != null) {
      // StreamControllerë¥¼ í†µí•´ ìŠ¤ëƒ…ìƒ· ë°©ì¶œ
    }
  });
  
  // ğŸ”¥ ì˜¬ë°”ë¥¸ ë°©ë²•: StreamProviderì—ì„œ .streamìœ¼ë¡œ ì ‘ê·¼
  final tradeStream = ref.watch(bottomLineTradeStreamProvider.stream);
  await for (final trade in tradeStream) {
    // ğŸ”¥ ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì† ëˆ„ì  (ë¦¬ì…‹ ì—†ìŒ)
    aggregator.addRealtimeTrade(trade);
    
    // 30ì´ˆ ê°„ê²©ìœ¼ë¡œë§Œ ìŠ¤ëƒ…ìƒ· ìƒì„±
    if (aggregator.shouldGenerateSnapshot()) {
      final snapshot = aggregator.generateRealtimeSnapshot();
      if (snapshot != null) {
        yield snapshot;
      }
    }
  }
});

/// ë°”í…€ë¼ì¸ ìŠ¤ëƒ…ìƒ· Provider (30ì´ˆë§ˆë‹¤ ê°±ì‹ )
final bottomLineSnapshotProvider = Provider<MarketSnapshot?>((ref) {
  final realtimeSnapshot = ref.watch(bottomLineRealtimeDataProvider).valueOrNull;
  
  if (realtimeSnapshot == null) {
    // ì´ˆê¸° ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ Providerì—ì„œ í˜„ì¬ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
    return _getInitialSnapshot(ref);
  }
  
  return realtimeSnapshot;
});

/// ì´ˆê¸° ìŠ¤ëƒ…ìƒ· ìƒì„± (ì•± ì‹œì‘ ì‹œ)
MarketSnapshot? _getInitialSnapshot(Ref ref) {
  try {
    // ğŸ¯ ì‹¤ì œ Providerì—ì„œ í˜„ì¬ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
    final currentTrades = ref.read(tradeListProvider).valueOrNull ?? [];
    final currentVolumes = ref.read(currentVolumeListProvider);
    final currentSurges = ref.read(currentSurgeListProvider);
    final currentSectors = ref.read(currentSectorVolumeListProvider);
    
    if (currentTrades.isEmpty && currentVolumes.isEmpty && currentSurges.isEmpty) {
      return null;
    }
    
    // ì´ˆê¸° ìŠ¤ëƒ…ìƒ· ìƒì„± (ì´ì „ ìŠ¤ëƒ…ìƒ· ì—†ìŒ)
    return MarketSnapshot.create(
      trades: currentTrades.take(50).toList(), // ìµœê·¼ 50ê°œë§Œ
      volumes: currentVolumes.take(50).toList(),
      surges: currentSurges,
      sectors: currentSectors.take(10).toList(),
      previousSnapshot: null,
    );
  } catch (e) {
    log.e('ğŸš¨ Initial snapshot generation failed: $e');
    return null;
  }
}

/// ë°”í…€ë¼ì¸ ì¸ì‚¬ì´íŠ¸ ìƒì„± Provider
final bottomLineInsightsProvider = Provider<List<CandidateInsight>>((ref) {
  final snapshot = ref.watch(bottomLineSnapshotProvider);
  
  if (snapshot == null) {
    return [];
  }
  
  // ì¸ì‚¬ì´íŠ¸ ì—”ì§„ìœ¼ë¡œ ë£° ì‹¤í–‰
  final insights = RuleRegistry.generateInsights(snapshot);
  
  if (AppConfig.enableTradeLog && insights.isNotEmpty) {
    log.d('ğŸ”¥ Generated ${insights.length} insights: ${insights.map((i) => '${i.id}(${i.finalScore.toStringAsFixed(1)})').join(', ')}');
  }
  
  return insights;
});

/// AI ìƒì„± ë°”í…€ë¼ì¸ Provider (OpenAI í˜¸ì¶œ)
final bottomLineGeneratedProvider = FutureProvider<List<BottomLineItem>>((ref) async {
  final insights = ref.watch(bottomLineInsightsProvider);
  
  if (insights.isEmpty) {
    // ì¸ì‚¬ì´íŠ¸ê°€ ì—†ìœ¼ë©´ í”Œë ˆì´ìŠ¤í™€ë” ë°˜í™˜
    return [
      BottomLineItem(
        headline: 'ğŸ“Š ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘ ì¤‘...',
        timestamp: DateTime.now(),
        priority: 0.1,
        sourceInsightId: 'placeholder',
      ),
    ];
  }
  
  try {
    // OpenAI ì„œë¹„ìŠ¤ë¡œ ë°”í…€ë¼ì¸ ìƒì„±
    final openAI = ref.read(openAIServiceProvider);
    final headlines = await openAI.generateBottomLines(insights);
    
    // BottomLineItemìœ¼ë¡œ ë³€í™˜
    final items = <BottomLineItem>[];
    for (int i = 0; i < headlines.length && i < insights.length; i++) {
      items.add(BottomLineItem.fromInsight(
        headline: headlines[i],
        insight: insights[i],
      ));
    }
    
    if (AppConfig.enableTradeLog) {
      log.d('ğŸ¤– AI generated ${items.length} bottom lines');
    }
    
    return items;
    
  } catch (e, stackTrace) {
    log.e('ğŸš¨ Bottom line generation failed: $e', e, stackTrace);
    
    // AI ì‹¤íŒ¨ ì‹œ í…œí”Œë¦¿ ê¸°ë°˜ ëŒ€ì²´
    return insights.map((insight) => BottomLineItem.fromInsight(
      headline: insight.populatedTemplate,
      insight: insight,
    )).toList();
  }
});

/// ë°”í…€ë¼ì¸ ë©”ì¸ ë°ì´í„° Provider (íì— ìë™ ì¶”ê°€)
final bottomLineDataProvider = Provider<List<BottomLineItem>>((ref) {
  final generatedItems = ref.watch(bottomLineGeneratedProvider);
  final queueNotifier = ref.read(bottomLineQueueProvider.notifier);
  
  generatedItems.when(
    data: (items) {
      if (items.isNotEmpty) {
        // ê¸´ê¸‰ ì•„ì´í…œê³¼ ì¼ë°˜ ì•„ì´í…œ ë¶„ë¦¬
        final urgentItems = items.where((item) => item.isUrgent).toList();
        final normalItems = items.where((item) => !item.isUrgent).toList();
        
        // ê¸´ê¸‰ ì•„ì´í…œì€ ì¦‰ì‹œ í ì•ì— ì¶”ê°€
        for (final urgentItem in urgentItems) {
          queueNotifier.addUrgentItem(urgentItem);
        }
        
        // ì¼ë°˜ ì•„ì´í…œì€ ë°°ì¹˜ë¡œ ì¶”ê°€
        if (normalItems.isNotEmpty) {
          queueNotifier.addItems(normalItems);
        }
      }
    },
    loading: () {},
    error: (error, stack) {
      log.e('ğŸš¨ Bottom line data error: $error');
    },
  );
  
  return generatedItems.valueOrNull ?? [];
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ UIìš© Providerë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// í˜„ì¬ í‘œì‹œí•  ë°”í…€ë¼ì¸ ì•„ì´í…œ Provider
final currentBottomLineItemProvider = Provider<BottomLineItem?>((ref) {
  final queue = ref.watch(bottomLineQueueProvider);
  
  // ë°ì´í„° ìƒì„± íŠ¸ë¦¬ê±° (watchë§Œ í•˜ê³  ê°’ì€ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
  ref.watch(bottomLineDataProvider);
  
  return queue.currentItem?.item;
});

/// ë°”í…€ë¼ì¸ í ìƒíƒœ Provider (ë””ë²„ê¹…ìš©)
final bottomLineQueueStateProvider = Provider<Map<String, dynamic>>((ref) {
  final queue = ref.watch(bottomLineQueueProvider);
  
  return {
    'queue_length': queue.queueLength,
    'current_item': queue.currentItem?.item.headline ?? 'None',
    'has_urgent': queue.hasUrgentItems,
    'next_refresh_in': BottomLineConstants.refreshIntervalSeconds,
  };
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ ì˜ì¡´ì„± Providerë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ ì• ê·¸ë¦¬ê²Œì´í„° Provider
final bottomLineAggregatorProvider = Provider<BottomLineAggregator>((ref) {
  return BottomLineAggregator();
});

/// ë°”í…€ë¼ì¸ í Provider
final bottomLineQueueProvider = StateNotifierProvider<BottomLineQueueNotifier, BottomLineQueue>((ref) {
  return BottomLineQueueNotifier();
});

/// ë°”í…€ë¼ì¸ í ê´€ë¦¬ Notifier
class BottomLineQueueNotifier extends StateNotifier<BottomLineQueue> {
  BottomLineQueueNotifier() : super(BottomLineQueue());

  void addItem(BottomLineItem item) {
    state.addItem(item);
    // StateNotifierëŠ” ìƒíƒœ ë³€ê²½ì„ ì•Œë¦¬ê¸° ìœ„í•´ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•´ì•¼ í•˜ì§€ë§Œ
    // BottomLineQueueëŠ” ë‚´ë¶€ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ë°©ì‹ì´ë¯€ë¡œ ì´ë ‡ê²Œ ì²˜ë¦¬
    state = state;
  }

  void addItems(List<BottomLineItem> items) {
    state.addItems(items);
    state = state;
  }

  void addUrgentItem(BottomLineItem item) {
    state.addUrgentItem(item);
    state = state;
  }

  void showNext() {
    state.showNext();
    state = state;
  }

  void skipCurrent() {
    state.skipCurrent();
    state = state;
  }

  void setPaused(bool paused) {
    state.setPaused(paused);
    state = state;
  }

  void setSpeedMultiplier(double multiplier) {
    state.setSpeedMultiplier(multiplier);
    state = state;
  }

  void clear() {
    state.clear();
    state = state;
  }
}

/// OpenAI ì„œë¹„ìŠ¤ Provider  
final openAIServiceProvider = Provider<OpenAIService>((ref) {
  return OpenAIService();
});

/// ì¸ì‚¬ì´íŠ¸ ì—”ì§„ Provider
final insightEngineProvider = Provider<BottomLineInsightEngine>((ref) {
  return BottomLineInsightEngine();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›ï¸ ì„¤ì • Providerë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ í™œì„±í™”/ë¹„í™œì„±í™” Provider
final bottomLineEnabledProvider = StateProvider<bool>((ref) => true);

/// ë°”í…€ë¼ì¸ í‘œì‹œ ì†ë„ Provider (ê°œë°œììš©)
final bottomLineSpeedMultiplierProvider = StateProvider<double>((ref) => 1.0);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš¨ ì—ëŸ¬ ì²˜ë¦¬ ë° ëŒ€ì²´ Providerë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ ì—ëŸ¬ ìƒíƒœ Provider
final bottomLineErrorProvider = StateProvider<String?>((ref) => null);

/// ë°”í…€ë¼ì¸ ì—°ê²° ìƒíƒœ Provider
final bottomLineConnectionProvider = Provider<bool>((ref) {
  // 4ëŒ€ Provider ì¤‘ í•˜ë‚˜ë¼ë„ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì—°ê²°ë¨ìœ¼ë¡œ ê°„ì£¼
  final hasTradeData = ref.watch(tradeListProvider).hasValue;
  final hasVolumeData = ref.watch(currentVolumeListProvider).isNotEmpty;
  final hasSurgeData = ref.watch(currentSurgeListProvider).isNotEmpty;
  
  return hasTradeData || hasVolumeData || hasSurgeData;
});

/// ëŒ€ì²´ ë°”í…€ë¼ì¸ Provider (AI ì‹¤íŒ¨ ì‹œ)
final fallbackBottomLineProvider = Provider<BottomLineItem>((ref) {
  final timestamp = DateTime.now();
  final minute = timestamp.minute;
  
  // ì‹œê°„ëŒ€ë³„ ë‹¤ë¥¸ ë©”ì‹œì§€
  const messages = [
    'ğŸ“Š ì•”í˜¸í™”í ì‹œì¥ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¤‘',
    'ğŸ’° ê³ ì•¡ê±°ë˜ íŒ¨í„´ ë¶„ì„ ì¤‘', 
    'âš¡ ê¸‰ë“± ì½”ì¸ ìŠ¤ìº” ì§„í–‰ ì¤‘',
    'ğŸ”¥ ì‹œì¥ íŠ¸ë Œë“œ ë¶„ì„ ì¤‘',
    'ğŸ“ˆ ê±°ë˜ëŸ‰ ê¸‰ì¦ ê°ì§€ ëŒ€ê¸° ì¤‘',
  ];
  
  return BottomLineItem(
    headline: messages[minute % messages.length],
    timestamp: timestamp,
    priority: 0.1,
    sourceInsightId: 'fallback_$minute',
  );
});\n\n// ====== lib/core/utils/bottom_line_insight_engine.dart ======\n
// core/utils/bottom_line_insight_engine.dart
// ğŸ§  ë°”í…€ë¼ì¸ ì¸ì‚¬ì´íŠ¸ ì—”ì§„ - ë£° ê¸°ë°˜ ì‹œì¥ íŒ¨í„´ ë¶„ì„
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import '../../domain/entities/bottom_line.dart';
import 'bottom_line_constants.dart';
import 'logger.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ ì¸ì‚¬ì´íŠ¸ ìƒì„± ê²°ê³¼
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì¸ì‚¬ì´íŠ¸ ìƒì„± ê²°ê³¼ (ì„±ê³µ/ì‹¤íŒ¨ ì •ë³´ í¬í•¨)
@immutable
class InsightGenerationResult {
  final List<CandidateInsight> insights;
  final List<String> triggeredRules;
  final List<String> failedRules;
  final Duration processingTime;
  final Map<String, dynamic> diagnostics;

  const InsightGenerationResult({
    required this.insights,
    required this.triggeredRules,
    required this.failedRules,
    required this.processingTime,
    required this.diagnostics,
  });

  /// ì„±ê³µì ìœ¼ë¡œ ìƒì„±ëœ ì¸ì‚¬ì´íŠ¸ ê°œìˆ˜
  int get successCount => insights.length;

  /// ì‹¤í–‰ëœ ë£° ê°œìˆ˜
  int get totalRulesExecuted => triggeredRules.length + failedRules.length;

  /// ì„±ê³µë¥ 
  double get successRate => totalRulesExecuted > 0
      ? triggeredRules.length / totalRulesExecuted
      : 0.0;

  /// ê³ ìš°ì„ ìˆœìœ„ ì¸ì‚¬ì´íŠ¸ ê°œìˆ˜
  int get highPriorityCount => insights.where((i) => i.isHighPriority).length;

  @override
  String toString() {
    return 'InsightResult($successCount insights, ${triggeredRules.length}/$totalRulesExecuted rules, ${processingTime.inMilliseconds}ms)';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  ì¸ì‚¬ì´íŠ¸ ì—”ì§„ ë©”ì¸ í´ë˜ìŠ¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ ì¸ì‚¬ì´íŠ¸ ì—”ì§„ - ë£° ê¸°ë°˜ íŒ¨í„´ ë¶„ì„ ë° ì¸ì‚¬ì´íŠ¸ ìƒì„±
class BottomLineInsightEngine {
  // ğŸ“Š ì„±ëŠ¥ í†µê³„
  int _totalExecutions = 0;
  int _totalInsightsGenerated = 0;
  int _totalRulesExecuted = 0;
  Duration _totalProcessingTime = Duration.zero;
  final Map<String, int> _ruleExecutionCount = {};
  final Map<String, int> _ruleSuccessCount = {};
  final Map<String, Duration> _ruleProcessingTime = {};

  // ğŸ” ë£° ì‹¤í–‰ í†µê³„
  DateTime? _lastExecution;
  MarketSnapshot? _lastSnapshot;

  /// ëª¨ë“  ë“±ë¡ëœ ë£°ë“¤ (RuleRegistryì—ì„œ ê°€ì ¸ì˜´)
  List<InsightRule> get allRules => RuleRegistry.allRules;

  /// í™œì„±í™”ëœ ë£°ë“¤ë§Œ
  List<InsightRule> get activeRules => allRules
      .where((rule) => BottomLineConstants.isRuleEnabled(rule.id))
      .toList();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ ë©”ì¸ ì¸ì‚¬ì´íŠ¸ ìƒì„± ë©”ì„œë“œ
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì‹œì¥ ìŠ¤ëƒ…ìƒ·ì—ì„œ ì¸ì‚¬ì´íŠ¸ ìƒì„± (ë©”ì¸ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸)
  InsightGenerationResult generateInsights(MarketSnapshot snapshot) {
    final stopwatch = Stopwatch()..start();
    
    try {
      // ğŸ“Š ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸
      _totalExecutions++;
      _lastExecution = DateTime.now();
      _lastSnapshot = snapshot;

      // ğŸ” ìŠ¤ëƒ…ìƒ· ê²€ì¦
      final validation = _validateSnapshot(snapshot);
      if (!validation['isValid']) {
        return _createEmptyResult(
          stopwatch.elapsed,
          'Invalid snapshot: ${validation['reason']}',
        );
      }

      // ğŸ§  ë£° ì‹¤í–‰
      final results = _executeAllRules(snapshot);

      // ğŸ“ˆ ì¸ì‚¬ì´íŠ¸ í›„ì²˜ë¦¬
      final processedInsights = _postProcessInsights(results['insights'], snapshot);

      // ğŸ“Š í†µê³„ ì—…ë°ì´íŠ¸
      _updateStats(processedInsights, results, stopwatch.elapsed);

      stopwatch.stop();

      final result = InsightGenerationResult(
        insights: processedInsights,
        triggeredRules: results['triggeredRules'],
        failedRules: results['failedRules'],
        processingTime: stopwatch.elapsed,
        diagnostics: _generateDiagnostics(snapshot, results),
      );

      if (BottomLineConstants.enableLogging && processedInsights.isNotEmpty) {
        log.d('ğŸ§  Generated ${processedInsights.length} insights: ${processedInsights.map((i) => '${i.id}(${i.finalScore.toStringAsFixed(1)})').join(', ')}');
      }

      return result;
    } catch (e, stackTrace) {
      stopwatch.stop();
      log.e('ğŸš¨ Insight generation failed: $e', e, stackTrace);
      return _createErrorResult(stopwatch.elapsed, e.toString());
    }
  }

  /// ëª¨ë“  í™œì„± ë£° ì‹¤í–‰
  Map<String, dynamic> _executeAllRules(MarketSnapshot snapshot) {
    final insights = <CandidateInsight>[];
    final triggeredRules = <String>[];
    final failedRules = <String>[];

    for (final rule in activeRules) {
      try {
        final ruleStopwatch = Stopwatch()..start();

        // ğŸ” ë£° ì‹¤í–‰ (íƒ€ì„ì•„ì›ƒ ì²´í¬)
        final insight = _executeRuleWithTimeout(rule, snapshot);

        ruleStopwatch.stop();

        // ğŸ“Š ë£°ë³„ í†µê³„ ì—…ë°ì´íŠ¸
        _updateRuleStats(rule.id, ruleStopwatch.elapsed, insight != null);

        if (insight != null) {
          insights.add(insight);
          triggeredRules.add(rule.id);

          if (BottomLineConstants.enableDetailedLogging) {
            log.d('âœ… Rule ${rule.id} triggered: score=${insight.finalScore.toStringAsFixed(2)}');
          }
        } else {
          if (BottomLineConstants.enableDetailedLogging) {
            log.d('âŒ Rule ${rule.id} not triggered');
          }
        }
      } catch (e) {
        failedRules.add(rule.id);
        log.w('ğŸš¨ Rule ${rule.id} failed: $e');
      }
    }

    return {
      'insights': insights,
      'triggeredRules': triggeredRules,
      'failedRules': failedRules,
    };
  }

  /// íƒ€ì„ì•„ì›ƒì´ ìˆëŠ” ë£° ì‹¤í–‰
  CandidateInsight? _executeRuleWithTimeout(InsightRule rule, MarketSnapshot snapshot) {
    final timeout = Duration(milliseconds: BottomLineConstants.ruleExecutionTimeoutMs);

    try {
      // ê°„ë‹¨í•œ íƒ€ì„ì•„ì›ƒ êµ¬í˜„ (Isolate ì‚¬ìš© ì•ˆ í•¨)
      final startTime = DateTime.now();
      final insight = rule.generateInsight(snapshot);
      final elapsed = DateTime.now().difference(startTime);

      if (elapsed > timeout) {
        log.w('â±ï¸ Rule ${rule.id} took ${elapsed.inMilliseconds}ms (timeout: ${timeout.inMilliseconds}ms)');
      }

      return insight;
    } catch (e) {
      log.w('ğŸš¨ Rule ${rule.id} execution error: $e');
      return null;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ˆ ì¸ì‚¬ì´íŠ¸ í›„ì²˜ë¦¬ & ìµœì í™”
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ìƒì„±ëœ ì¸ì‚¬ì´íŠ¸ë“¤ í›„ì²˜ë¦¬ (ì •ë ¬, í•„í„°ë§, ìµœì í™”)
  List<CandidateInsight> _postProcessInsights(List<CandidateInsight> insights, MarketSnapshot snapshot) {
    if (insights.isEmpty) return insights;

    // ğŸ” 1. ì¤‘ë³µ ì œê±° (ê°™ì€ ì‹œì¥/íŒ¨í„´)
    final deduplicated = _removeDuplicateInsights(insights);

    // ğŸ“Š 2. ì ìˆ˜ ì •ê·œí™” ë° ì¡°ì •
    final normalized = _normalizeInsightScores(deduplicated, snapshot);

    // ğŸ“ˆ 3. ìš°ì„ ìˆœìœ„ ì •ë ¬ (ì ìˆ˜ ë†’ì€ ìˆœ)
    normalized.sort((a, b) => b.finalScore.compareTo(a.finalScore));

    // ğŸ¯ 4. ìƒìœ„ Nê°œë§Œ ì„ íƒ (AI ë¹„ìš© ì ˆì•½)
    final selected = normalized.take(BottomLineConstants.maxInsightsPerSnapshot).toList();

    // ğŸ”¥ 5. ê¸´ê¸‰ ì¸ì‚¬ì´íŠ¸ ì‹ë³„ ë° ë§ˆí‚¹
    final marked = _markUrgentInsights(selected);

    if (BottomLineConstants.enableDetailedLogging) {
      log.d('ğŸ“ˆ Post-processed insights: ${insights.length} â†’ ${marked.length}');
    }

    return marked;
  }

  /// ì¤‘ë³µ ì¸ì‚¬ì´íŠ¸ ì œê±°
  List<CandidateInsight> _removeDuplicateInsights(List<CandidateInsight> insights) {
    final uniqueInsights = <String, CandidateInsight>{};

    for (final insight in insights) {
      // í…œí”Œë¦¿ ë³€ìˆ˜ì—ì„œ ì‹œì¥ ì •ë³´ ì¶”ì¶œ
      final market = insight.templateVars['market'] as String? ?? '';
      final ruleType = insight.id.split('_').first;

      // í‚¤: ë£°íƒ€ì…_ì‹œì¥ (ì˜ˆ: smart_money_KRW-BTC)
      final key = '${ruleType}_$market';

      // ë” ë†’ì€ ì ìˆ˜ì˜ ì¸ì‚¬ì´íŠ¸ë§Œ ìœ ì§€
      if (!uniqueInsights.containsKey(key) ||
          uniqueInsights[key]!.finalScore < insight.finalScore) {
        uniqueInsights[key] = insight;
      }
    }

    return uniqueInsights.values.toList();
  }

  /// ì¸ì‚¬ì´íŠ¸ ì ìˆ˜ ì •ê·œí™”
  List<CandidateInsight> _normalizeInsightScores(List<CandidateInsight> insights, MarketSnapshot snapshot) {
    if (insights.isEmpty) return insights;

    // í˜„ì¬ ìµœê³ ì ê³¼ ìµœì €ì 
    final scores = insights.map((i) => i.finalScore).toList();
    final maxScore = scores.reduce(math.max);
    final minScore = scores.reduce(math.min);

    // ì ìˆ˜ ë²”ìœ„ê°€ ë„ˆë¬´ ì¢ìœ¼ë©´ ì •ê·œí™” ìƒëµ
    if (maxScore - minScore < 0.5) return insights;

    // ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ë³´ì •
    final marketContext = _analyzeMarketContext(snapshot);

    return insights.map((insight) {
      double adjustedScore = insight.finalScore;

      // ì‹œì¥ ìƒí™©ì— ë”°ë¥¸ ì ìˆ˜ ì¡°ì •
      if (marketContext['isVolatile']) {
        // ë³€ë™ì„± ë†’ì€ ìƒí™©ì—ì„œëŠ” ê¸‰ë“±/ê¸‰ë½ ì¸ì‚¬ì´íŠ¸ ê°•í™”
        if (insight.id.contains('surge') || insight.id.contains('spike')) {
          adjustedScore *= 1.2;
        }
      }

      if (marketContext['isHighVolume']) {
        // ê³ ê±°ë˜ëŸ‰ ìƒí™©ì—ì„œëŠ” ìŠ¤ë§ˆíŠ¸ë¨¸ë‹ˆ ì¸ì‚¬ì´íŠ¸ ê°•í™”
        if (insight.id.contains('smart_money')) {
          adjustedScore *= 1.1;
        }
      }

      // ì •ê·œí™” (0.0 ~ 5.0 ë²”ìœ„)
      adjustedScore = math.min(adjustedScore, BottomLineConstants.maxInsightScore);

      return CandidateInsight(
        id: insight.id,
        template: insight.template,
        score: adjustedScore,
        weight: insight.weight,
        templateVars: insight.templateVars,
        timestamp: insight.timestamp,
        isUrgent: adjustedScore >= BottomLineConstants.urgentInsightThreshold,
      );
    }).toList();
  }

  /// ê¸´ê¸‰ ì¸ì‚¬ì´íŠ¸ ë§ˆí‚¹
  List<CandidateInsight> _markUrgentInsights(List<CandidateInsight> insights) {
    return insights.map((insight) {
      final isUrgent = insight.finalScore >= BottomLineConstants.urgentInsightThreshold;

      if (isUrgent && !insight.isUrgent) {
        return CandidateInsight(
          id: insight.id,
          template: insight.template,
          score: insight.score,
          weight: insight.weight,
          templateVars: insight.templateVars,
          timestamp: insight.timestamp,
          isUrgent: true,
        );
      }

      return insight;
    }).toList();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ” ì‹œì¥ ì»¨í…ìŠ¤íŠ¸ ë¶„ì„
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì‹œì¥ ìƒí™© ë¶„ì„ (ì ìˆ˜ ì¡°ì •ìš©)
  Map<String, dynamic> _analyzeMarketContext(MarketSnapshot snapshot) {
    // ë³€ë™ì„± ë¶„ì„
    final priceChanges = snapshot.priceDelta.values.where((change) => change.abs() > 0).toList();
    final avgPriceChange = priceChanges.isNotEmpty
        ? priceChanges.map((c) => c.abs()).reduce((a, b) => a + b) / priceChanges.length
        : 0.0;
    final isVolatile = avgPriceChange > 5.0; // í‰ê·  5% ì´ìƒ ë³€ë™

    // ê±°ë˜ëŸ‰ ë¶„ì„
    final totalVolume = snapshot.topVolumes.fold<double>(0, (sum, v) => sum + v.totalVolume);
    final isHighVolume = totalVolume > 1000000000; // 10ì–µ ì´ìƒ

    // ê¸‰ë“±/ê¸‰ë½ ì½”ì¸ ê°œìˆ˜
    final surgingCount = snapshot.surges.where((s) => s.changePercent > 10).length;
    final plungingCount = snapshot.surges.where((s) => s.changePercent < -10).length;

    // ê³ ì•¡ê±°ë˜ í™œì„±ë„
    final largeTradeCount = snapshot.topTrades
        .where((t) => t.total >= BottomLineConstants.largeTradeThreshold)
        .length;

    return {
      'isVolatile': isVolatile,
      'isHighVolume': isHighVolume,
      'avgPriceChange': avgPriceChange,
      'totalVolume': totalVolume,
      'surgingCount': surgingCount,
      'plungingCount': plungingCount,
      'largeTradeCount': largeTradeCount,
      'marketMood': _classifyMarketMood(surgingCount, plungingCount, avgPriceChange),
    };
  }

  /// ì‹œì¥ ë¶„ìœ„ê¸° ë¶„ë¥˜
  String _classifyMarketMood(int surgingCount, int plungingCount, double avgPriceChange) {
    if (surgingCount > plungingCount * 2 && avgPriceChange > 3.0) {
      return 'bullish'; // ê°•ì„¸
    } else if (plungingCount > surgingCount * 2 && avgPriceChange > 3.0) {
      return 'bearish'; // ì•½ì„¸
    } else if (avgPriceChange > 5.0) {
      return 'volatile'; // ë³€ë™ì„±
    } else {
      return 'neutral'; // ì¤‘ë¦½
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š í†µê³„ ë° ê²€ì¦
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ìŠ¤ëƒ…ìƒ· ìœ íš¨ì„± ê²€ì¦
  Map<String, dynamic> _validateSnapshot(MarketSnapshot snapshot) {
    // ê¸°ë³¸ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€
    if (snapshot.topTrades.isEmpty &&
        snapshot.topVolumes.isEmpty &&
        snapshot.surges.isEmpty) {
      return {
      'isValid': false, 
      'reason': 'No data available'
    };
    }

    // íƒ€ì„ìŠ¤íƒ¬í”„ ê²€ì¦ (ë„ˆë¬´ ì˜¤ë˜ëœ ë°ì´í„°)
    final age = DateTime.now().difference(snapshot.timestamp);
    if (age.inMinutes > 10) {
      return {
      'isValid': false, 
      'reason': 'Data too old: ${age.inMinutes} minutes'
    };
    }

    // ë°ì´í„° ì¼ê´€ì„± ê²€ì¦
    final inconsistencies = <String>[];

    // ê°€ê²© ë³€í™”ìœ¨ ê²€ì¦ (-100% ~ +1000% ë²”ìœ„)
    for (final entry in snapshot.priceDelta.entries) {
      if (entry.value < -100 || entry.value > 1000) {
        inconsistencies.add('Invalid price change: ${entry.key} ${entry.value}%');
      }
    }

    // ë³¼ë¥¨ ë³€í™”ìœ¨ ê²€ì¦ (-100% ~ +10000% ë²”ìœ„)
    for (final entry in snapshot.volChangePct.entries) {
      if (entry.value < -100 || entry.value > 10000) {
        inconsistencies.add('Invalid volume change: ${entry.key} ${entry.value}%');
      }
    }

    if (inconsistencies.isNotEmpty) {
      log.w('âš ï¸ Snapshot inconsistencies: ${inconsistencies.join(', ')}');
    }

    return {
      'isValid': true, 
      'inconsistencies': inconsistencies
    };
  }

  /// ë£°ë³„ ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸
  void _updateRuleStats(String ruleId, Duration elapsed, bool success) {
    _ruleExecutionCount[ruleId] = (_ruleExecutionCount[ruleId] ?? 0) + 1;
    if (success) {
      _ruleSuccessCount[ruleId] = (_ruleSuccessCount[ruleId] ?? 0) + 1;
    }

    final currentTime = _ruleProcessingTime[ruleId] ?? Duration.zero;
    _ruleProcessingTime[ruleId] = currentTime + elapsed;
    _totalRulesExecuted++;
  }

  /// ì „ì²´ í†µê³„ ì—…ë°ì´íŠ¸
  void _updateStats(List<CandidateInsight> insights, Map<String, dynamic> results, Duration elapsed) {
    _totalInsightsGenerated += insights.length;
    _totalProcessingTime += elapsed;
  }

  /// ì§„ë‹¨ ì •ë³´ ìƒì„±
  Map<String, dynamic> _generateDiagnostics(MarketSnapshot snapshot, Map<String, dynamic> results) {
    final marketContext = _analyzeMarketContext(snapshot);

    return {
      'snapshot_age_seconds': DateTime.now().difference(snapshot.timestamp).inSeconds,
      'data_points': {
        'trades': snapshot.topTrades.length,
        'volumes': snapshot.topVolumes.length,
        'surges': snapshot.surges.length,
        'sectors': snapshot.sectorVolumes.length,
      },
      'market_context': marketContext,
      'rule_performance': _getRulePerformanceSnapshot(),
      'engine_stats': getEngineStats(),
    };
  }

  /// ë¹ˆ ê²°ê³¼ ìƒì„±
  InsightGenerationResult _createEmptyResult(Duration elapsed, String reason) {
    return InsightGenerationResult(
      insights: const <CandidateInsight>[],
      triggeredRules: const <String>[],
      failedRules: const <String>[],
      processingTime: elapsed,
      diagnostics: {'reason': reason},
    );
  }

  /// ì—ëŸ¬ ê²°ê³¼ ìƒì„±
  InsightGenerationResult _createErrorResult(Duration elapsed, String error) {
    return InsightGenerationResult(
      insights: const <CandidateInsight>[],
      triggeredRules: const <String>[],
      failedRules: activeRules.map((r) => r.id).toList(),
      processingTime: elapsed,
      diagnostics: {'error': error},
    );
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ & í†µê³„
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì—”ì§„ ì „ì²´ í†µê³„
  Map<String, dynamic> getEngineStats() {
    final avgProcessingTime = _totalExecutions > 0
        ? _totalProcessingTime.inMilliseconds / _totalExecutions
        : 0.0;

    final avgInsightsPerExecution = _totalExecutions > 0
        ? _totalInsightsGenerated / _totalExecutions
        : 0.0;

    return {
      'total_executions': _totalExecutions,
      'total_insights_generated': _totalInsightsGenerated,
      'total_rules_executed': _totalRulesExecuted,
      'avg_processing_time_ms': avgProcessingTime,
      'avg_insights_per_execution': avgInsightsPerExecution,
      'last_execution': _lastExecution?.toIso8601String() ?? 'Never',
      'active_rules_count': activeRules.length,
      'total_rules_count': allRules.length,
    };
  }

  /// ë£°ë³„ ì„±ëŠ¥ í†µê³„
  Map<String, dynamic> _getRulePerformanceSnapshot() {
    final performance = <String, Map<String, dynamic>>{};

    for (final ruleId in _ruleExecutionCount.keys) {
      final executions = _ruleExecutionCount[ruleId] ?? 0;
      final successes = _ruleSuccessCount[ruleId] ?? 0;
      final totalTime = _ruleProcessingTime[ruleId] ?? Duration.zero;

      performance[ruleId] = {
        'executions': executions,
        'successes': successes,
        'success_rate': executions > 0 ? successes / executions : 0.0,
        'avg_time_ms': executions > 0 ? totalTime.inMilliseconds / executions : 0.0,
        'total_time_ms': totalTime.inMilliseconds,
      };
    }

    return performance;
  }

  /// ì—”ì§„ ìƒíƒœ ë¦¬ì…‹
  void resetStats() {
    _totalExecutions = 0;
    _totalInsightsGenerated = 0;
    _totalRulesExecuted = 0;
    _totalProcessingTime = Duration.zero;
    _ruleExecutionCount.clear();
    _ruleSuccessCount.clear();
    _ruleProcessingTime.clear();
    _lastExecution = null;
    _lastSnapshot = null;

    if (BottomLineConstants.enableLogging) {
      log.d('ğŸ“Š Insight engine stats reset');
    }
  }

  /// ìƒì„¸ ì§„ë‹¨ ë³´ê³ ì„œ ìƒì„± (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> generateDiagnosticReport() {
    return {
      'engine_info': {
        'version': '1.0.0',
        'initialization_time': DateTime.now().toIso8601String(),
        'rules_loaded': allRules.map((r) => r.id).toList(),
        'active_rules': activeRules.map((r) => r.id).toList(),
      },
      'performance': getEngineStats(),
      'rule_performance': _getRulePerformanceSnapshot(),
      'configuration': {
        'min_insight_score': BottomLineConstants.minInsightScore,
        'urgent_threshold': BottomLineConstants.urgentInsightThreshold,
        'max_insights_per_snapshot': BottomLineConstants.maxInsightsPerSnapshot,
        'rule_timeout_ms': BottomLineConstants.ruleExecutionTimeoutMs,
      },
      'last_snapshot_info': _lastSnapshot != null ? {
        'timestamp': _lastSnapshot!.timestamp.toIso8601String(),
        'trades_count': _lastSnapshot!.topTrades.length,
        'volumes_count': _lastSnapshot!.topVolumes.length,
        'surges_count': _lastSnapshot!.surges.length,
      } : null,
    };
  }
}\n\n// ====== lib/core/utils/bottom_line_circular_buffer.dart ======\n
// core/utils/bottom_line_circular_buffer.dart
// ğŸ”„ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ìˆœí™˜ ë²„í¼ êµ¬í˜„ (ë°”í…€ë¼ì¸ ì „ìš©)

import 'dart:math' as math;
import 'bottom_line_constants.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ ê¸°ë³¸ ìˆœí™˜ ë²„í¼ (ì œë„¤ë¦­)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ìˆœí™˜ ë²„í¼ (FIFO)
/// ìµœëŒ€ í¬ê¸° ê³ ì •ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì œí•œ
class CircularBuffer<T> {
  final int _maxSize;
  final List<T?> _buffer;
  int _head = 0;  // ë‹¤ìŒ ì¶”ê°€ë  ìœ„ì¹˜
  int _tail = 0;  // ê°€ì¥ ì˜¤ë˜ëœ ë°ì´í„° ìœ„ì¹˜
  int _count = 0; // í˜„ì¬ ì €ì¥ëœ ë°ì´í„° ê°œìˆ˜

  CircularBuffer(this._maxSize) 
    : assert(_maxSize > 0, 'Buffer size must be positive'),
      _buffer = List<T?>.filled(_maxSize, null);

  /// í˜„ì¬ ì €ì¥ëœ ë°ì´í„° ê°œìˆ˜
  int get length => _count;

  /// ë²„í¼ ìµœëŒ€ í¬ê¸°
  int get maxSize => _maxSize;

  /// ë²„í¼ê°€ ë¹„ì–´ìˆëŠ”ì§€
  bool get isEmpty => _count == 0;

  /// ë²„í¼ê°€ ê°€ë“ ì°¼ëŠ”ì§€
  bool get isFull => _count == _maxSize;

  /// ì‚¬ìš©ë¥  (0.0 ~ 1.0)
  double get utilization => _count / _maxSize;

  /// ë°ì´í„° ì¶”ê°€ (ì˜¤ë˜ëœ ë°ì´í„° ìë™ ì œê±°)
  void add(T item) {
    _buffer[_head] = item;
    _head = (_head + 1) % _maxSize;
    
    if (_count < _maxSize) {
      _count++;
    } else {
      // ë²„í¼ê°€ ê°€ë“ ì°¬ ê²½ìš°, tailë„ ì´ë™
      _tail = (_tail + 1) % _maxSize;
    }
  }

  /// ì—¬ëŸ¬ ë°ì´í„° í•œ ë²ˆì— ì¶”ê°€
  void addAll(Iterable<T> items) {
    for (final item in items) {
      add(item);
    }
  }

  /// ê°€ì¥ ìµœê·¼ ë°ì´í„° ë°˜í™˜ (ì œê±°í•˜ì§€ ì•ŠìŒ)
  T? get last {
    if (isEmpty) return null;
    final lastIndex = (_head - 1 + _maxSize) % _maxSize;
    return _buffer[lastIndex];
  }

  /// ê°€ì¥ ì˜¤ë˜ëœ ë°ì´í„° ë°˜í™˜ (ì œê±°í•˜ì§€ ì•ŠìŒ)
  T? get first {
    if (isEmpty) return null;
    return _buffer[_tail];
  }

  /// ì¸ë±ìŠ¤ë¡œ ë°ì´í„° ì ‘ê·¼ (0 = ê°€ì¥ ì˜¤ë˜ëœ ë°ì´í„°)
  T? operator [](int index) {
    if (index < 0 || index >= _count) return null;
    final actualIndex = (_tail + index) % _maxSize;
    return _buffer[actualIndex];
  }

  /// ëª¨ë“  ë°ì´í„°ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜ (ì˜¤ë˜ëœ ìˆœì„œ)
  List<T> get items {
    if (isEmpty) return <T>[];
    
    final result = <T>[];
    for (int i = 0; i < _count; i++) {
      final item = this[i];
      if (item != null) result.add(item);
    }
    return result;
  }

  /// ìµœì‹  Nê°œ ë°ì´í„° ë°˜í™˜
  List<T> getRecent(int count) {
    if (count <= 0 || isEmpty) return <T>[];
    
    final actualCount = math.min(count, _count);
    final result = <T>[];
    
    for (int i = _count - actualCount; i < _count; i++) {
      final item = this[i];
      if (item != null) result.add(item);
    }
    
    return result;
  }

  /// ì¡°ê±´ì— ë§ëŠ” ë°ì´í„° í•„í„°ë§
  List<T> where(bool Function(T) test) {
    return items.where(test).toList();
  }

  /// ë°ì´í„° ê°œìˆ˜ ì„¸ê¸°
  int count(bool Function(T) test) {
    return items.where(test).length;
  }

  /// ì¡°ê±´ì— ë§ëŠ” ì²« ë²ˆì§¸ ë°ì´í„° ì°¾ê¸°
  T? firstWhere(bool Function(T) test, {T? orElse}) {
    for (final item in items) {
      if (test(item)) return item;
    }
    return orElse;
  }

  /// ëª¨ë“  ë°ì´í„° ì œê±°
  void clear() {
    for (int i = 0; i < _maxSize; i++) {
      _buffer[i] = null;
    }
    _head = 0;
    _tail = 0;
    _count = 0;
  }

  /// ì˜¤ë˜ëœ ë°ì´í„° ì¼ë¶€ ì œê±°
  void removeOld(int count) {
    if (count <= 0 || isEmpty) return;
    
    final actualCount = math.min(count, _count);
    
    for (int i = 0; i < actualCount; i++) {
      _buffer[_tail] = null;
      _tail = (_tail + 1) % _maxSize;
      _count--;
    }
  }

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì • (ë°”ì´íŠ¸)
  int get estimatedMemoryBytes {
    // ëŒ€ëµì ì¸ ê³„ì‚° (ê°ì²´ ì˜¤ë²„í—¤ë“œ í¬í•¨)
    return _maxSize * 64 + 128; // 64ë°”ì´íŠ¸ per slot + ì˜¤ë²„í—¤ë“œ
  }

  /// ë²„í¼ ìƒíƒœ ìš”ì•½
  Map<String, dynamic> get stats {
    return {
      'max_size': _maxSize,
      'current_count': _count,
      'utilization': '${(utilization * 100).toStringAsFixed(1)}%',
      'is_full': isFull,
      'memory_bytes': estimatedMemoryBytes,
      'head_position': _head,
      'tail_position': _tail,
    };
  }

  @override
  String toString() {
    return 'CircularBuffer<$T>($_count/$maxSize, ${(utilization * 100).toStringAsFixed(1)}%)';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š ì‹œê°„ ê¸°ë°˜ ìˆœí™˜ ë²„í¼ (TTL ì§€ì›)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì‹œê°„ ì •ë³´ì™€ í•¨ê»˜ ì €ì¥ë˜ëŠ” ë°ì´í„°
class TimestampedData<T> {
  final T data;
  final DateTime timestamp;

  const TimestampedData(this.data, this.timestamp);

  /// ë°ì´í„° ìƒì„± í›„ ê²½ê³¼ ì‹œê°„
  Duration get age => DateTime.now().difference(timestamp);

  /// ì§€ì •ëœ ì‹œê°„ë³´ë‹¤ ì˜¤ë˜ë˜ì—ˆëŠ”ì§€
  bool isOlderThan(Duration duration) => age > duration;

  @override
  String toString() => 'TimestampedData($data, ${timestamp.toIso8601String()})';
}

/// ì‹œê°„ ê¸°ë°˜ ìˆœí™˜ ë²„í¼ (TTL ìë™ ì œê±°)
class TimeBasedCircularBuffer<T> extends CircularBuffer<TimestampedData<T>> {
  final Duration _ttl;
  DateTime? _lastCleanup;

  TimeBasedCircularBuffer(int maxSize, this._ttl) : super(maxSize);

  /// TTL (Time To Live)
  Duration get ttl => _ttl;

  /// ë°ì´í„° ì¶”ê°€ (ìë™ìœ¼ë¡œ íƒ€ì„ìŠ¤íƒ¬í”„ ë¶€ì—¬)
  void addData(T data) {
    add(TimestampedData(data, DateTime.now()));
    _autoCleanup();
  }

  /// ìœ íš¨í•œ ë°ì´í„°ë§Œ ë°˜í™˜ (TTL ì²´í¬)
  List<T> get validData {
    return items
      .where((item) => !item.isOlderThan(_ttl))
      .map((item) => item.data)
      .toList();
  }

  /// ìµœì‹  ìœ íš¨ ë°ì´í„° Nê°œ ë°˜í™˜
  List<T> getRecentValidData(int count) {
    final valid = validData;
    final actualCount = math.min(count, valid.length);
    return valid.reversed.take(actualCount).toList().reversed.toList();
  }

  /// ë§Œë£Œëœ ë°ì´í„° ê°œìˆ˜
  int get expiredCount {
    return items.where((item) => item.isOlderThan(_ttl)).length;
  }

  /// ìë™ ì •ë¦¬ (1ë¶„ë§ˆë‹¤)
  void _autoCleanup() {
    final now = DateTime.now();
    if (_lastCleanup == null || 
        now.difference(_lastCleanup!).inMinutes >= 1) {
      removeExpired();
      _lastCleanup = now;
    }
  }

  /// ë§Œë£Œëœ ë°ì´í„° ì œê±°
  void removeExpired() {
    if (isEmpty) return;

    int expiredCount = 0;
    while (!isEmpty && first!.isOlderThan(_ttl)) {
      removeOld(1);
      expiredCount++;
    }

    if (BottomLineConstants.enableDetailedLogging && expiredCount > 0) {
      // log.d('ğŸ—‘ï¸ Removed $expiredCount expired items from TimeBasedCircularBuffer');
    }
  }

  /// í†µê³„ ì •ë³´ (TTL í¬í•¨)
  @override
  Map<String, dynamic> get stats {
    final baseStats = super.stats;
    
    baseStats.addAll({
      'ttl_seconds': _ttl.inSeconds,
      'valid_count': validData.length,
      'expired_count': expiredCount,
      'oldest_age_seconds': isEmpty ? 0 : first!.age.inSeconds,
      'newest_age_seconds': isEmpty ? 0 : last!.age.inSeconds,
      'last_cleanup': _lastCleanup?.toIso8601String() ?? 'Never',
    });
    
    return baseStats;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ ë°”í…€ë¼ì¸ íŠ¹í™” ë²„í¼ë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ê±°ë˜ ë°ì´í„° ì „ìš© ìˆœí™˜ ë²„í¼
class TradeCircularBuffer extends CircularBuffer<Map<String, dynamic>> {
  TradeCircularBuffer() : super(BottomLineConstants.maxRecentTrades);

  /// ê³ ì•¡ê±°ë˜ë§Œ í•„í„°ë§
  List<Map<String, dynamic>> get largeTrades {
    return where((trade) {
      final amount = trade['amount'] as double? ?? 0.0;
      return amount >= BottomLineConstants.largeTradeThreshold;
    });
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ê±°ë˜ë“¤
  List<Map<String, dynamic>> getTradesForMarket(String market) {
    return where((trade) => trade['market'] == market);
  }

  /// ìµœê·¼ Në¶„ê°„ì˜ ê±°ë˜ë“¤
  List<Map<String, dynamic>> getTradesInLastMinutes(int minutes) {
    final cutoff = DateTime.now().subtract(Duration(minutes: minutes));
    return where((trade) {
      final timestamp = trade['timestamp'] as int? ?? 0;
      return DateTime.fromMillisecondsSinceEpoch(timestamp).isAfter(cutoff);
    });
  }

  /// ê±°ë˜ëŸ‰ í•©ê³„ ê³„ì‚°
  double getTotalVolume() {
    return items.fold(0.0, (sum, trade) {
      final volume = trade['volume'] as double? ?? 0.0;
      return sum + volume;
    });
  }

  /// ê±°ë˜ëŒ€ê¸ˆ í•©ê³„ ê³„ì‚°
  double getTotalAmount() {
    return items.fold(0.0, (sum, trade) {
      final amount = trade['amount'] as double? ?? 0.0;
      return sum + amount;
    });
  }
}

/// ë¬¸ìì—´ ë°ì´í„° ì „ìš© ìˆœí™˜ ë²„í¼ (ê³ ì•¡ê±°ë˜ ID ë“±)
class StringCircularBuffer extends CircularBuffer<String> {
  StringCircularBuffer(int maxSize) : super(maxSize);

  /// ì¤‘ë³µ ì œê±°ëœ ê³ ìœ  ë¬¸ìì—´ë“¤
  Set<String> get uniqueItems => items.toSet();

  /// íŠ¹ì • íŒ¨í„´ê³¼ ë§¤ì¹­ë˜ëŠ” ë¬¸ìì—´ë“¤
  List<String> getMatching(RegExp pattern) {
    return where((item) => pattern.hasMatch(item));
  }

  /// íŠ¹ì • ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ë¬¸ìì—´ë“¤
  List<String> getStartingWith(String prefix) {
    return where((item) => item.startsWith(prefix));
  }

  /// ë¬¸ìì—´ ê¸¸ì´ í†µê³„
  Map<String, dynamic> get lengthStats {
    if (isEmpty) {
      return {'min': 0, 'max': 0, 'avg': 0.0};
    }
    
    final lengths = items.map((item) => item.length).toList();
    return {
      'min': lengths.reduce(math.min),
      'max': lengths.reduce(math.max),
      'avg': lengths.reduce((a, b) => a + b) / lengths.length,
    };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ­ íŒ©í† ë¦¬ í´ë˜ìŠ¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ìš© ë²„í¼ íŒ©í† ë¦¬
class BottomLineBufferFactory {
  BottomLineBufferFactory._();

  /// ê±°ë˜ ë°ì´í„°ìš© ë²„í¼ ìƒì„±
  static TradeCircularBuffer createTradeBuffer() {
    return TradeCircularBuffer();
  }

  /// ê³ ì•¡ê±°ë˜ IDìš© ë²„í¼ ìƒì„±
  static StringCircularBuffer createLargeTradeBuffer() {
    return StringCircularBuffer(BottomLineConstants.maxRecentLargeTrades);
  }

  /// ì‹œì¥ ì´ë¦„ìš© ë²„í¼ ìƒì„±
  static StringCircularBuffer createMarketBuffer() {
    return StringCircularBuffer(BottomLineConstants.maxTrackedMarkets);
  }

  /// TTL ê¸°ë°˜ ë°ì´í„° ë²„í¼ ìƒì„±
  static TimeBasedCircularBuffer<T> createTimeBasedBuffer<T>(
    int maxSize, 
    Duration ttl,
  ) {
    return TimeBasedCircularBuffer<T>(maxSize, ttl);
  }

  /// ê¸°ë³¸ ì œë„¤ë¦­ ë²„í¼ ìƒì„±
  static CircularBuffer<T> createBuffer<T>(int maxSize) {
    return CircularBuffer<T>(maxSize);
  }

  /// ë²„í¼ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (ê°œë°œìš©)
  static Map<String, dynamic> performanceTest() {
    final stopwatch = Stopwatch()..start();
    
    // 1000ê°œ ë°ì´í„°ë¡œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    final buffer = CircularBuffer<int>(1000);
    
    // ì¶”ê°€ ì„±ëŠ¥
    for (int i = 0; i < 2000; i++) {
      buffer.add(i);
    }
    final addTime = stopwatch.elapsedMicroseconds;
    
    // ì¡°íšŒ ì„±ëŠ¥
    stopwatch.reset();
    for (int i = 0; i < 1000; i++) {
      buffer[i % buffer.length];
    }
    final accessTime = stopwatch.elapsedMicroseconds;
    
    // í•„í„°ë§ ì„±ëŠ¥
    stopwatch.reset();
    buffer.where((item) => item % 2 == 0);
    final filterTime = stopwatch.elapsedMicroseconds;
    
    stopwatch.stop();
    
    return {
      'add_2000_items_us': addTime,
      'access_1000_times_us': accessTime,
      'filter_once_us': filterTime,
      'memory_usage_bytes': buffer.estimatedMemoryBytes,
      'utilization': buffer.utilization,
    };
  }
}\n\n// ====== lib/core/utils/bottom_line_constants.dart ======\n
// core/utils/bottom_line_constants.dart
// ğŸ”¥ ë°”í…€ë¼ì¸ ì‹œìŠ¤í…œ - ëª¨ë“  ì„¤ì •ê°’ê³¼ ìƒìˆ˜ ì •ì˜

/// ë°”í…€ë¼ì¸ ì‹œìŠ¤í…œ ì „ì²´ ì„¤ì •ê°’
class BottomLineConstants {
  // ğŸš« ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë°©ì§€
  BottomLineConstants._();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // â° íƒ€ì´ë¨¸ & ì£¼ê¸° ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°”í…€ë¼ì¸ ìƒˆë¡œê³ ì¹¨ ê°„ê²© (ì´ˆ) - AI í˜¸ì¶œ ì£¼ê¸°
  static const int refreshIntervalSeconds = 30;

  /// ë°”í…€ë¼ì¸ í‘œì‹œ ê°„ê²© (ì´ˆ) - UI ì „í™˜ ì£¼ê¸°  
  static const int displayIntervalSeconds = 18;

  /// ìŠ¤ëƒ…ìƒ· ìƒì„± ìµœì†Œ ê°„ê²© (ì´ˆ)
  static const int minSnapshotIntervalSeconds = 15;

  /// ë©”ëª¨ë¦¬ ì •ë¦¬ ê°„ê²© (ë¶„)
  static const int cleanupIntervalMinutes = 5;

  /// ë² ì´ìŠ¤ë¼ì¸ ê°±ì‹  ê°„ê²© (ì‹œê°„)
  static const int baselineRefreshHours = 1;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’° ê±°ë˜ ì„ê³„ê°’ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê³ ì•¡ê±°ë˜ ì„ê³„ê°’ (ì›) - 2ì²œë§Œì›
  static const double largeTradeThreshold = 20000000.0;

  /// ì´ˆëŒ€í˜•ê±°ë˜ ì„ê³„ê°’ (ì›) - 1ì–µì›  
  static const double megaTradeThreshold = 100000000.0;

  /// ìŠ¤ë§ˆíŠ¸ë¨¸ë‹ˆ ë£° ìµœì†Œ ê³ ì•¡ê±°ë˜ íšŸìˆ˜
  static const int smartMoneyMinTradeCount = 3;

  /// ë³¼ë¥¨ ê¸‰ì¦ ì„ê³„ê°’ (%) - 200% ì´ìƒ
  static const double volumeSpikeThreshold = 200.0;

  /// ê¸‰ë“±/ê¸‰ë½ ì„ê³„ê°’ (%) - 10% ì´ìƒ
  static const double surgeThreshold = 10.0;

  /// ì„¹í„° ë¡œí…Œì´ì…˜ ì„ê³„ê°’ (%p) - 7%p ì´ìƒ
  static const double sectorRotationThreshold = 7.0;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š ì¸ì‚¬ì´íŠ¸ ì ìˆ˜ ê³„ì‚° ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì¸ì‚¬ì´íŠ¸ ìƒì„± ìµœì†Œ ì ìˆ˜
  static const double minInsightScore = 1.0;

  /// ê¸´ê¸‰ ì¸ì‚¬ì´íŠ¸ ì„ê³„ê°’
  static const double urgentInsightThreshold = 2.5;

  /// ìµœê³  ì¸ì‚¬ì´íŠ¸ ì ìˆ˜ (ì •ê·œí™”ìš©)
  static const double maxInsightScore = 5.0;

  /// ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ - ê°€ê²© ë³€í™”
  static const double scorePriceChangeWeight = 0.3;

  /// ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ - ë³¼ë¥¨ ë³€í™”
  static const double scoreVolumeChangeWeight = 0.25;

  /// ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ - ê³ ì•¡ê±°ë˜
  static const double scoreLargeTradeWeight = 0.25;

  /// ì ìˆ˜ ê³„ì‚° ê°€ì¤‘ì¹˜ - ì„¹í„° ë³€í™”
  static const double scoreSectorChangeWeight = 0.2;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”„ ë©”ëª¨ë¦¬ ê´€ë¦¬ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ìµœê·¼ ê±°ë˜ ìµœëŒ€ ë³´ê´€ ê°œìˆ˜
  static const int maxRecentTrades = 1000;

  /// ìµœê·¼ ê³ ì•¡ê±°ë˜ ìµœëŒ€ ë³´ê´€ ê°œìˆ˜
  static const int maxRecentLargeTrades = 100;

  /// ì‹œì¥ë³„ ìµœëŒ€ ì¶”ì  ê°œìˆ˜
  static const int maxTrackedMarkets = 200;

  /// ì„¹í„°ë³„ ìµœëŒ€ ì¶”ì  ê°œìˆ˜
  static const int maxTrackedSectors = 20;

  /// ì‹œì¥ ë¹„í™œì„± ì œê±° ì‹œê°„ (ë¶„) - 5ë¶„ê°„ ê±°ë˜ ì—†ìœ¼ë©´ ì œê±°
  static const int marketInactiveMinutes = 5;

  /// ìºì‹œëœ ìŠ¤ëƒ…ìƒ· ìµœëŒ€ ê°œìˆ˜
  static const int maxCachedSnapshots = 3;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¨ UI í ê´€ë¦¬ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°”í…€ë¼ì¸ í ìµœëŒ€ í¬ê¸°
  static const int maxQueueSize = 12;

  /// í ë¶€ì¡± ì„ê³„ê°’ (ì´í•˜ì¼ ë•Œ ìƒˆë¡œ ìƒì„±)
  static const int queueRefillThreshold = 4;

  /// ê¸´ê¸‰ ì•„ì´í…œ ìµœëŒ€ ê°œìˆ˜
  static const int maxUrgentItems = 3;

  /// ì¼ë°˜ ì•„ì´í…œ ìµœëŒ€ ê°œìˆ˜
  static const int maxNormalItems = 9;

  /// í”Œë ˆì´ìŠ¤í™€ë” ì•„ì´í…œ ê°œìˆ˜
  static const int placeholderItemCount = 3;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¤– AI ì„œë¹„ìŠ¤ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// OpenAI API íƒ€ì„ì•„ì›ƒ (ì´ˆ)
  static const int openAITimeoutSeconds = 10;

  /// AI ì¬ì‹œë„ ìµœëŒ€ íšŸìˆ˜
  static const int aiMaxRetryCount = 2;

  /// AI ì¬ì‹œë„ ê°„ê²© (ì´ˆ)
  static const int aiRetryDelaySeconds = 1;

  /// GPT ëª¨ë¸ëª… (ì¼ë°˜)
  static const String gptModelNormal = 'gpt-3.5-turbo';

  /// GPT ëª¨ë¸ëª… (ê¸´ê¸‰)
  static const String gptModelUrgent = 'gpt-4';

  /// ë°”í…€ë¼ì¸ ìµœëŒ€ ê¸¸ì´ (ê¸€ì)
  static const int maxHeadlineLength = 120;

  /// ë°”í…€ë¼ì¸ ìµœì†Œ ê¸¸ì´ (ê¸€ì)
  static const int minHeadlineLength = 15;

  /// AI ìƒì„± ë°°ì¹˜ í¬ê¸°
  static const int aiBatchSize = 5;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ ë¡œê¹… & ë””ë²„ê¹… ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°”í…€ë¼ì¸ ë¡œê¹… í™œì„±í™”
  static const bool enableLogging = true;

  /// ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ í™œì„±í™”
  static const bool enablePerformanceMonitoring = true;

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¡œê¹… í™œì„±í™”
  static const bool enableMemoryLogging = false;

  /// AI í˜¸ì¶œ ë¡œê¹… í™œì„±í™”
  static const bool enableAILogging = true;

  /// ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ ìƒì„¸ ë¡œê¹…
  static bool get enableDetailedLogging => 
    enableLogging && const bool.fromEnvironment('dart.vm.product') == false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ›ï¸ ë£° ì‹œìŠ¤í…œ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë£°ë³„ ê°€ì¤‘ì¹˜ ì„¤ì •
  static const Map<String, double> ruleWeights = {
    'smart_money': 1.0,      // ìŠ¤ë§ˆíŠ¸ë¨¸ë‹ˆ ë£°
    'volume_spike': 0.8,     // ë³¼ë¥¨ ê¸‰ì¦ ë£°
    'surge_chain': 0.7,      // ì—°ì‡„ ê¸‰ë“± ë£°  
    'sector_rotation': 0.8,  // ì„¹í„° ë¡œí…Œì´ì…˜ ë£°
    'fallback': 0.3,         // í´ë°± ë£°
  };

  /// ë£°ë³„ í™œì„±í™” ìƒíƒœ
  static const Map<String, bool> ruleEnabled = {
    'smart_money': true,
    'volume_spike': true,
    'surge_chain': true,
    'sector_rotation': true,
    'fallback': true,
  };

  /// ì¸ì‚¬ì´íŠ¸ ìƒì„± ìµœëŒ€ ê°œìˆ˜ (AI ë¹„ìš© ì ˆì•½)
  static const int maxInsightsPerSnapshot = 5;

  /// ë£° ì‹¤í–‰ íƒ€ì„ì•„ì›ƒ (ë°€ë¦¬ì´ˆ)
  static const int ruleExecutionTimeoutMs = 1000;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸš¨ ì—ëŸ¬ ì²˜ë¦¬ & ëŒ€ì²´ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì—°ì† ì—ëŸ¬ í—ˆìš© íšŸìˆ˜
  static const int maxConsecutiveErrors = 3;

  /// ì—ëŸ¬ í›„ ëŒ€ê¸° ì‹œê°„ (ì´ˆ)
  static const int errorBackoffSeconds = 30;

  /// AI ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ë©”ì‹œì§€ ì‚¬ìš© ì—¬ë¶€
  static const bool useFallbackMessages = true;

  /// ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì²´í¬ ê°„ê²© (ì´ˆ)
  static const int connectionCheckIntervalSeconds = 60;

  /// ë°ì´í„° ë¶€ì¡± ì‹œ í”Œë ˆì´ìŠ¤í™€ë” í‘œì‹œ ì—¬ë¶€
  static const bool showPlaceholderWhenNoData = true;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¨ UI ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°”í…€ë¼ì¸ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
  static const int transitionAnimationMs = 300;

  /// ë§ˆí€´ í…ìŠ¤íŠ¸ ìŠ¤í¬ë¡¤ ì†ë„ (í”½ì…€/ì´ˆ)
  static const double marqueeScrollSpeed = 50.0;

  /// ê¸´ê¸‰ ë°”í…€ë¼ì¸ ê¹œë¹¡ì„ ê°„ê²© (ë°€ë¦¬ì´ˆ)
  static const int urgentBlinkIntervalMs = 1000;

  /// ë°”í…€ë¼ì¸ ë†’ì´ (í”½ì…€)
  static const double bottomLineHeight = 50.0;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“± í”Œë«í¼ë³„ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì•ˆë“œë¡œì´ë“œ ìµœì í™” ì„¤ì •
  static const Map<String, dynamic> androidOptimizations = {
    'reduce_animations': false,
    'battery_optimization': true,
    'background_processing': true,
  };

  /// iOS ìµœì í™” ì„¤ì •
  static const Map<String, dynamic> iosOptimizations = {
    'background_app_refresh': true,
    'memory_pressure_handling': true,
    'smooth_animations': true,
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”¢ ìˆ˜ì¹˜ í¬ë§·íŒ… ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê¸ˆì•¡ í‘œì‹œ ë‹¨ìœ„ (ì–µì›)
  static const double amountUnit = 100000000.0;

  /// ì†Œìˆ˜ì  ìë¦¬ìˆ˜ - ê°€ê²©
  static const int priceDecimalPlaces = 1;

  /// ì†Œìˆ˜ì  ìë¦¬ìˆ˜ - í¼ì„¼íŠ¸
  static const int percentDecimalPlaces = 1;

  /// ì†Œìˆ˜ì  ìë¦¬ìˆ˜ - ë³¼ë¥¨
  static const int volumeDecimalPlaces = 1;

  /// í° ìˆ˜ í‘œì‹œ ì„ê³„ê°’ (ì–µ)
  static const double largeNumberThreshold = 1.0;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ¯ ê°œë°œ/í…ŒìŠ¤íŠ¸ ì„¤ì •
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê°œë°œ ëª¨ë“œì—ì„œ íƒ€ì´ë¨¸ ê°€ì†í™” (ë°°ìˆ˜)
  static const double devModeSpeedMultiplier = 1.0;

  /// í…ŒìŠ¤íŠ¸ ëª¨ë“œì—ì„œ AI í˜¸ì¶œ ë¹„í™œì„±í™”
  static const bool disableAIInTest = true;

  /// ëª©ì—… ë°ì´í„° ì‚¬ìš© ì—¬ë¶€
  static const bool useMockData = false;

  /// ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí‚¹ í™œì„±í™”
  static const bool enableBenchmarking = false;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ í—¬í¼ ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í˜„ì¬ í™˜ê²½ì— ë§ëŠ” íƒ€ì´ë¨¸ ê°„ê²© ë°˜í™˜
  static Duration getRefreshInterval() {
    const base = Duration(seconds: refreshIntervalSeconds);
    if (const bool.fromEnvironment('dart.vm.product') == false) {
      // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ê°€ì†í™”
      return Duration(seconds: (base.inSeconds / devModeSpeedMultiplier).round());
    }
    return base;
  }

  /// í˜„ì¬ í™˜ê²½ì— ë§ëŠ” í‘œì‹œ ê°„ê²© ë°˜í™˜
  static Duration getDisplayInterval() {
    const base = Duration(seconds: displayIntervalSeconds);
    if (const bool.fromEnvironment('dart.vm.product') == false) {
      return Duration(seconds: (base.inSeconds / devModeSpeedMultiplier).round());
    }
    return base;
  }

  /// ë£°ì´ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  static bool isRuleEnabled(String ruleId) {
    return ruleEnabled[ruleId] ?? false;
  }

  /// ë£°ì˜ ê°€ì¤‘ì¹˜ ë°˜í™˜
  static double getRuleWeight(String ruleId) {
    return ruleWeights[ruleId] ?? 0.0;
  }

  /// ê¸ˆì•¡ì„ ì–µì› ë‹¨ìœ„ë¡œ í¬ë§·íŒ…
  static String formatAmount(double amount) {
    final amountInEok = amount / amountUnit;
    return '${amountInEok.toStringAsFixed(priceDecimalPlaces)}ì–µì›';
  }

  /// í¼ì„¼íŠ¸ í¬ë§·íŒ…
  static String formatPercent(double percent) {
    return '${percent.toStringAsFixed(percentDecimalPlaces)}%';
  }

  /// í˜„ì¬ ì„¤ì • ìš”ì•½ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static Map<String, dynamic> getConfigSummary() {
    return {
      'refresh_interval': refreshIntervalSeconds,
      'display_interval': displayIntervalSeconds,
      'large_trade_threshold': formatAmount(largeTradeThreshold),
      'max_queue_size': maxQueueSize,
      'max_recent_trades': maxRecentTrades,
      'ai_timeout': openAITimeoutSeconds,
      'logging_enabled': enableLogging,
      'rules_enabled': ruleEnabled.values.where((e) => e).length,
      'memory_limits': {
        'markets': maxTrackedMarkets,
        'trades': maxRecentTrades,
        'large_trades': maxRecentLargeTrades,
      },
    };
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ê²€ì¦
  static bool validateConfig() {
    // ê¸°ë³¸ì ì¸ ì„¤ì •ê°’ ê²€ì¦
    if (refreshIntervalSeconds <= 0) return false;
    if (displayIntervalSeconds <= 0) return false;
    if (maxQueueSize <= 0) return false;
    if (largeTradeThreshold <= 0) return false;
    
    // íƒ€ì´ë¨¸ ê°„ê²© ê²€ì¦ (í‘œì‹œ ê°„ê²© < ìƒˆë¡œê³ ì¹¨ ê°„ê²©)
    if (displayIntervalSeconds >= refreshIntervalSeconds) return false;
    
    // í í¬ê¸° ê²€ì¦
    if (queueRefillThreshold >= maxQueueSize) return false;
    
    // ê°€ì¤‘ì¹˜ ê²€ì¦ (0 ~ 1 ë²”ìœ„)
    for (final weight in ruleWeights.values) {
      if (weight < 0.0 || weight > 1.0) return false;
    }
    
    return true;
  }
}\n\n// ====== lib/core/utils/bottom_line_queue.dart ======\n
// core/utils/bottom_line_queue.dart
// ğŸ¨ ë°”í…€ë¼ì¸ UI í ê´€ë¦¬ ì‹œìŠ¤í…œ (18ì´ˆ ê°„ê²© í‘œì‹œ)

import 'dart:collection';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';
import '../../domain/entities/bottom_line.dart';
import 'bottom_line_constants.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ ë°”í…€ë¼ì¸ í ìƒíƒœ ì—´ê±°í˜•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

enum BottomLineQueueState {
  /// ì •ìƒ ìƒíƒœ - ì¶©ë¶„í•œ ì•„ì´í…œ ë³´ìœ 
  normal,
  
  /// ë¶€ì¡± ìƒíƒœ - ë¦¬í•„ í•„ìš” (4ê°œ ë¯¸ë§Œ)
  needsRefill,
  
  /// ë¹ˆ ìƒíƒœ - í‘œì‹œí•  ì•„ì´í…œ ì—†ìŒ
  empty,
  
  /// ê¸´ê¸‰ ìƒíƒœ - ê¸´ê¸‰ ì•„ì´í…œ ìš°ì„  í‘œì‹œ
  urgent,
  
  /// ì¼ì‹œì •ì§€ ìƒíƒœ - í‘œì‹œ ì¤‘ë‹¨
  paused,
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ ë°”í…€ë¼ì¸ í ì•„ì´í…œ ë˜í¼
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// íì—ì„œ ê´€ë¦¬ë˜ëŠ” ë°”í…€ë¼ì¸ ì•„ì´í…œ (ë©”íƒ€ë°ì´í„° í¬í•¨)
@immutable
class QueuedBottomLineItem {
  final BottomLineItem item;
  final DateTime queuedAt;        // íì— ì¶”ê°€ëœ ì‹œê°„
  final int displayCount;         // í‘œì‹œëœ íšŸìˆ˜
  final bool isUrgent;           // ê¸´ê¸‰ ì•„ì´í…œ ì—¬ë¶€
  final double priority;         // ìš°ì„ ìˆœìœ„ (ë†’ì„ìˆ˜ë¡ ë¨¼ì € í‘œì‹œ)
  final String id;               // ê³ ìœ  ID

  const QueuedBottomLineItem({
    required this.item,
    required this.queuedAt,
    this.displayCount = 0,
    required this.isUrgent,
    required this.priority,
    required this.id,
  });

  /// í ì•„ì´í…œ ìƒì„± íŒ©í† ë¦¬
  factory QueuedBottomLineItem.fromBottomLineItem(BottomLineItem item) {
    return QueuedBottomLineItem(
      item: item,
      queuedAt: DateTime.now(),
      isUrgent: item.isUrgent,
      priority: item.priority,
      id: '${item.sourceInsightId}_${DateTime.now().millisecondsSinceEpoch}',
    );
  }

  /// í‘œì‹œ íšŸìˆ˜ ì¦ê°€
  QueuedBottomLineItem incrementDisplayCount() {
    return QueuedBottomLineItem(
      item: item,
      queuedAt: queuedAt,
      displayCount: displayCount + 1,
      isUrgent: isUrgent,
      priority: priority,
      id: id,
    );
  }

  /// íì—ì„œ ëŒ€ê¸°í•œ ì‹œê°„
  Duration get queuedDuration => DateTime.now().difference(queuedAt);

  /// ë§Œë£Œ ì—¬ë¶€ (5ë¶„ ì´ìƒ ëŒ€ê¸°)
  bool get isExpired => queuedDuration.inMinutes > 5;

  /// ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚° (ê¸´ê¸‰ë„ + ì‹œê°„ ê°€ì¤‘ì¹˜)
  double get effectivePriority {
    double score = priority;
    
    // ê¸´ê¸‰ ì•„ì´í…œì€ +2.0 ë³´ë„ˆìŠ¤
    if (isUrgent) score += 2.0;
    
    // ì˜¤ë˜ ëŒ€ê¸°í•œ ì•„ì´í…œì€ ìš°ì„ ìˆœìœ„ ìƒìŠ¹ (ìµœëŒ€ +1.0)
    final waitMinutes = queuedDuration.inMinutes;
    final timeBonus = math.min(waitMinutes * 0.1, 1.0);
    score += timeBonus;
    
    return score;
  }

  @override
  String toString() {
    return 'QueuedItem(${item.headline.substring(0, math.min(20, item.headline.length))}..., '
           'urgent: $isUrgent, priority: ${priority.toStringAsFixed(1)}, '
           'displayed: $displayCount, queued: ${queuedDuration.inSeconds}s)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is QueuedBottomLineItem && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ ë°”í…€ë¼ì¸ í ê´€ë¦¬ì
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ESPN ìŠ¤íƒ€ì¼ ë°”í…€ë¼ì¸ í ê´€ë¦¬ ì‹œìŠ¤í…œ
class BottomLineQueue {
  // ğŸ¯ í ì €ì¥ì†Œ (ìš°ì„ ìˆœìœ„ë³„ ë¶„ë¦¬)
  final Queue<QueuedBottomLineItem> _urgentQueue = Queue<QueuedBottomLineItem>();
  final Queue<QueuedBottomLineItem> _normalQueue = Queue<QueuedBottomLineItem>();
  final Queue<QueuedBottomLineItem> _fallbackQueue = Queue<QueuedBottomLineItem>();
  
  // ğŸ“Š ìƒíƒœ ê´€ë¦¬
  QueuedBottomLineItem? _currentItem;
  BottomLineQueueState _state = BottomLineQueueState.empty;
  DateTime? _lastDisplayTime;
  DateTime? _lastRefillTime;
  int _totalDisplayed = 0;
  int _totalAdded = 0;
  
  // ğŸ›ï¸ ì„¤ì •
  bool _isPaused = false;
  double _speedMultiplier = 1.0;
  
  /// í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì•„ì´í…œ
  QueuedBottomLineItem? get currentItem => _currentItem;
  
  /// í˜„ì¬ í ìƒíƒœ
  BottomLineQueueState get state => _state;
  
  /// ì´ í ê¸¸ì´ (ëª¨ë“  í í•©ê³„)
  int get queueLength => _urgentQueue.length + _normalQueue.length + _fallbackQueue.length;
  
  /// ê¸´ê¸‰ ì•„ì´í…œ ê°œìˆ˜
  int get urgentCount => _urgentQueue.length;
  
  /// ì¼ë°˜ ì•„ì´í…œ ê°œìˆ˜
  int get normalCount => _normalQueue.length;
  
  /// ëŒ€ì²´ ì•„ì´í…œ ê°œìˆ˜
  int get fallbackCount => _fallbackQueue.length;
  
  /// ê¸´ê¸‰ ì•„ì´í…œì´ ìˆëŠ”ì§€
  bool get hasUrgentItems => _urgentQueue.isNotEmpty;
  
  /// íê°€ ë¹„ì–´ìˆëŠ”ì§€
  bool get isEmpty => queueLength == 0;
  
  /// ë¦¬í•„ì´ í•„ìš”í•œì§€ (4ê°œ ë¯¸ë§Œ)
  bool get needsRefill => queueLength < BottomLineConstants.queueRefillThreshold;
  
  /// ì¼ì‹œì •ì§€ ìƒíƒœì¸ì§€
  bool get isPaused => _isPaused;
  
  /// ì†ë„ ë°°ìˆ˜
  double get speedMultiplier => _speedMultiplier;
  
  /// ë§ˆì§€ë§‰ í‘œì‹œ ì‹œê°„
  DateTime? get lastDisplayTime => _lastDisplayTime;
  
  /// ë‹¤ìŒ í‘œì‹œê¹Œì§€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get secondsUntilNext {
    if (_lastDisplayTime == null) return 0;
    
    final elapsed = DateTime.now().difference(_lastDisplayTime!).inSeconds;
    final interval = (BottomLineConstants.displayIntervalSeconds / _speedMultiplier).round();
    
    return math.max(0, interval - elapsed);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¥ ì•„ì´í…œ ì¶”ê°€ ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°”í…€ë¼ì¸ ì•„ì´í…œ ì¶”ê°€ (ìë™ ë¶„ë¥˜)
  void addItem(BottomLineItem item) {
    final queuedItem = QueuedBottomLineItem.fromBottomLineItem(item);
    
    if (item.isUrgent) {
      _addToUrgentQueue(queuedItem);
    } else {
      _addToNormalQueue(queuedItem);
    }
    
    _totalAdded++;
    _updateState();
    
    if (BottomLineConstants.enableDetailedLogging) {
      // log.d('ğŸ“¥ Added item to queue: ${queuedItem}');
    }
  }

  /// ì—¬ëŸ¬ ì•„ì´í…œ í•œ ë²ˆì— ì¶”ê°€
  void addItems(List<BottomLineItem> items) {
    for (final item in items) {
      addItem(item);
    }
    
    if (BottomLineConstants.enableLogging) {
      // log.d('ğŸ“¥ Added ${items.length} items to queue (total: $queueLength)');
    }
  }

  /// ê¸´ê¸‰ ì•„ì´í…œ ì¦‰ì‹œ ì¶”ê°€ (ë§¨ ì•ì—)
  void addUrgentItem(BottomLineItem item) {
    final queuedItem = QueuedBottomLineItem.fromBottomLineItem(item);
    _urgentQueue.addFirst(queuedItem);
    _totalAdded++;
    _updateState();
    
    if (BottomLineConstants.enableLogging) {
      // log.d('ğŸš¨ Added urgent item to front: ${queuedItem}');
    }
  }

  /// ëŒ€ì²´ ì•„ì´í…œ ì¶”ê°€ (í ê³ ê°ˆ ë°©ì§€ìš©)
  void addFallbackItem(BottomLineItem item) {
    final queuedItem = QueuedBottomLineItem.fromBottomLineItem(item);
    _fallbackQueue.addLast(queuedItem);
    _updateState();
    
    if (BottomLineConstants.enableDetailedLogging) {
      // log.d('ğŸ›¡ï¸ Added fallback item: ${queuedItem}');
    }
  }

  /// ê¸´ê¸‰ íì— ì¶”ê°€ (ì¤‘ë³µ ì²´í¬)
  void _addToUrgentQueue(QueuedBottomLineItem item) {
    // ì¤‘ë³µ ì œê±° (ê°™ì€ insightëŠ” í•˜ë‚˜ë§Œ)
    _urgentQueue.removeWhere((existing) => 
      existing.item.sourceInsightId == item.item.sourceInsightId);
    
    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    while (_urgentQueue.length >= BottomLineConstants.maxUrgentItems) {
      _urgentQueue.removeFirst();
    }
    
    _urgentQueue.addLast(item);
  }

  /// ì¼ë°˜ íì— ì¶”ê°€ (ìš°ì„ ìˆœìœ„ ì •ë ¬)
  void _addToNormalQueue(QueuedBottomLineItem item) {
    final queueList = _normalQueue.toList();
    
    // ì¤‘ë³µ ì œê±°
    queueList.removeWhere((existing) => 
      existing.item.sourceInsightId == item.item.sourceInsightId);
    
    // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì‚½ì…
    queueList.add(item);
    queueList.sort((a, b) => b.effectivePriority.compareTo(a.effectivePriority));
    
    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    final limitedList = queueList.take(BottomLineConstants.maxNormalItems).toList();
    
    _normalQueue.clear();
    _normalQueue.addAll(limitedList);
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¤ ì•„ì´í…œ í‘œì‹œ ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë‹¤ìŒ ì•„ì´í…œ í‘œì‹œ (18ì´ˆ ê°„ê²©)
  BottomLineQueue showNext() {
    if (_isPaused) return this;
    
    // í˜„ì¬ ì•„ì´í…œ í‘œì‹œ íšŸìˆ˜ ì¦ê°€
    if (_currentItem != null) {
      _currentItem = _currentItem!.incrementDisplayCount();
    }
    
    // ë‹¤ìŒ ì•„ì´í…œ ì„ íƒ
    final nextItem = _getNextItem();
    
    if (nextItem != null) {
      _currentItem = nextItem;
      _lastDisplayTime = DateTime.now();
      _totalDisplayed++;
      
      // ì‚¬ìš©ëœ ì•„ì´í…œì„ íì—ì„œ ì œê±°
      _removeUsedItem(nextItem);
      
      if (BottomLineConstants.enableDetailedLogging) {
        // log.d('ğŸ“º Showing next item: ${nextItem}');
      }
    } else {
      // í‘œì‹œí•  ì•„ì´í…œì´ ì—†ìŒ
      _currentItem = null;
      
      if (BottomLineConstants.enableLogging) {
        // log.w('ğŸ“º No items to display, queue is empty');
      }
    }
    
    _updateState();
    return this;
  }

  /// ë‹¤ìŒ í‘œì‹œí•  ì•„ì´í…œ ì„ íƒ (ìš°ì„ ìˆœìœ„ ìˆœ)
  QueuedBottomLineItem? _getNextItem() {
    // 1. ê¸´ê¸‰ ì•„ì´í…œ ìš°ì„ 
    if (_urgentQueue.isNotEmpty) {
      return _urgentQueue.first;
    }
    
    // 2. ì¼ë°˜ ì•„ì´í…œ (ìš°ì„ ìˆœìœ„ ìˆœ)
    if (_normalQueue.isNotEmpty) {
      return _normalQueue.first;
    }
    
    // 3. ëŒ€ì²´ ì•„ì´í…œ (í ê³ ê°ˆ ì‹œ)
    if (_fallbackQueue.isNotEmpty) {
      return _fallbackQueue.first;
    }
    
    return null;
  }

  /// ì‚¬ìš©ëœ ì•„ì´í…œì„ íì—ì„œ ì œê±°
  void _removeUsedItem(QueuedBottomLineItem item) {
    _urgentQueue.remove(item);
    _normalQueue.remove(item);
    _fallbackQueue.remove(item);
  }

  /// ì¦‰ì‹œ ë‹¤ìŒ ì•„ì´í…œìœ¼ë¡œ ìŠ¤í‚µ
  BottomLineQueue skipCurrent() {
    if (_currentItem != null) {
      if (BottomLineConstants.enableLogging) {
        // log.d('â­ï¸ Skipping current item: ${_currentItem}');
      }
    }
    
    return showNext();
  }

  /// í˜„ì¬ ì•„ì´í…œ ë‹¤ì‹œ í‘œì‹œ (18ì´ˆ ì—°ì¥)
  BottomLineQueue repeatCurrent() {
    if (_currentItem != null) {
      _lastDisplayTime = DateTime.now();
      
      if (BottomLineConstants.enableDetailedLogging) {
        // log.d('ğŸ”„ Repeating current item: ${_currentItem}');
      }
    }
    
    return this;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ›ï¸ í ì œì–´ ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í ì¼ì‹œì •ì§€/ì¬ê°œ
  BottomLineQueue setPaused(bool paused) {
    _isPaused = paused;
    _updateState();
    
    if (BottomLineConstants.enableLogging) {
      // log.d('â¸ï¸ Queue ${paused ? 'paused' : 'resumed'}');
    }
    
    return this;
  }

  /// í‘œì‹œ ì†ë„ ë³€ê²½ (ë°°ìˆ˜)
  BottomLineQueue setSpeedMultiplier(double multiplier) {
    _speedMultiplier = math.max(0.1, math.min(5.0, multiplier));
    
    if (BottomLineConstants.enableLogging) {
      // log.d('âš¡ Speed multiplier set to ${_speedMultiplier}x');
    }
    
    return this;
  }

  /// í ì „ì²´ ë¹„ìš°ê¸°
  BottomLineQueue clear() {
    _urgentQueue.clear();
    _normalQueue.clear();
    _fallbackQueue.clear();
    _currentItem = null;
    _updateState();
    
    if (BottomLineConstants.enableLogging) {
      // log.d('ğŸ—‘ï¸ Queue cleared');
    }
    
    return this;
  }

  /// ë§Œë£Œëœ ì•„ì´í…œ ì œê±°
  BottomLineQueue removeExpired() {
    int removedCount = 0;
    
    // ê° íì—ì„œ ë§Œë£Œëœ ì•„ì´í…œ ì œê±°
    removedCount += _removeExpiredFromQueue(_urgentQueue);
    removedCount += _removeExpiredFromQueue(_normalQueue);
    removedCount += _removeExpiredFromQueue(_fallbackQueue);
    
    if (removedCount > 0) {
      _updateState();
      
      if (BottomLineConstants.enableLogging) {
        // log.d('ğŸ—‘ï¸ Removed $removedCount expired items');
      }
    }
    
    return this;
  }

  /// íŠ¹ì • íì—ì„œ ë§Œë£Œëœ ì•„ì´í…œ ì œê±°
  int _removeExpiredFromQueue(Queue<QueuedBottomLineItem> queue) {
    final originalLength = queue.length;
    queue.removeWhere((item) => item.isExpired);
    return originalLength - queue.length;
  }

  /// í ìƒíƒœ ì—…ë°ì´íŠ¸
  void _updateState() {
    if (_isPaused) {
      _state = BottomLineQueueState.paused;
    } else if (hasUrgentItems) {
      _state = BottomLineQueueState.urgent;
    } else if (isEmpty) {
      _state = BottomLineQueueState.empty;
    } else if (needsRefill) {
      _state = BottomLineQueueState.needsRefill;
    } else {
      _state = BottomLineQueueState.normal;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š í†µê³„ ë° ëª¨ë‹ˆí„°ë§
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í í†µê³„ ì •ë³´
  Map<String, dynamic> get stats {
    
    return {
      'state': _state.name,
      'queue_length': queueLength,
      'urgent_count': urgentCount,
      'normal_count': normalCount,
      'fallback_count': fallbackCount,
      'current_item': _currentItem?.item.headline ?? 'None',
      'total_added': _totalAdded,
      'total_displayed': _totalDisplayed,
      'display_rate': _totalAdded > 0 ? (_totalDisplayed / _totalAdded * 100).toStringAsFixed(1) : '0.0',
      'is_paused': _isPaused,
      'speed_multiplier': _speedMultiplier,
      'seconds_until_next': secondsUntilNext,
      'last_display': _lastDisplayTime?.toIso8601String() ?? 'Never',
      'needs_refill': needsRefill,
      'memory_usage_items': queueLength,
    };
  }

  /// ìš°ì„ ìˆœìœ„ ë¶„í¬ í†µê³„
  Map<String, dynamic> get priorityStats {
    final allItems = [
      ..._urgentQueue,
      ..._normalQueue,
      ..._fallbackQueue,
    ];
    
    if (allItems.isEmpty) {
      return {'count': 0, 'min': 0.0, 'max': 0.0, 'avg': 0.0};
    }
    
    final priorities = allItems.map((item) => item.effectivePriority).toList();
    priorities.sort();
    
    return {
      'count': priorities.length,
      'min': priorities.first,
      'max': priorities.last,
      'avg': priorities.reduce((a, b) => a + b) / priorities.length,
      'median': priorities[priorities.length ~/ 2],
    };
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­
  Map<String, dynamic> get performanceMetrics {
    final now = DateTime.now();
    final startTime = _lastRefillTime ?? now;
    final uptimeMinutes = now.difference(startTime).inMinutes;
    
    return {
      'uptime_minutes': uptimeMinutes,
      'items_per_minute': uptimeMinutes > 0 ? _totalAdded / uptimeMinutes : 0.0,
      'display_efficiency': _totalAdded > 0 ? _totalDisplayed / _totalAdded : 0.0,
      'queue_turnover_rate': queueLength > 0 ? _totalDisplayed / queueLength : 0.0,
      'average_queue_length': queueLength.toDouble(),
      'urgent_ratio': queueLength > 0 ? urgentCount / queueLength : 0.0,
    };
  }

  @override
  String toString() {
    return 'BottomLineQueue(state: ${_state.name}, length: $queueLength, '
           'urgent: $urgentCount, current: ${_currentItem?.item.headline ?? 'None'})';
  }
}\n\n// ====== lib/data/processors/bottom_line_aggregator.dart ======\n
// data/processors/bottom_line_aggregator.dart
// ğŸ”„ ë°”í…€ë¼ì¸ ë°ì´í„° ì• ê·¸ë¦¬ê²Œì´í„° - ì‹¤ì‹œê°„ ëˆ„ì  & ìŠ¤ëƒ…ìƒ· ìƒì„±

import 'dart:collection';
import 'dart:math' as math;
import 'package:flutter/foundation.dart';

import '../../core/utils/bottom_line_circular_buffer.dart';
import '../../core/utils/bottom_line_constants.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/bottom_line.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart';
import '../../domain/entities/surge.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š ì‹¤ì‹œê°„ ì‹œì¥ í†µê³„ í´ë˜ìŠ¤ë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì‹œì¥ë³„ ì‹¤ì‹œê°„ ì§‘ê³„ í†µê³„ (ë©”ëª¨ë¦¬ íš¨ìœ¨ì )
@immutable
class RealtimeMarketStats {
  final String market;
  final double totalVolume;           // ëˆ„ì  ê±°ë˜ëŸ‰
  final double totalAmount;           // ëˆ„ì  ê±°ë˜ëŒ€ê¸ˆ
  final int tradeCount;               // ì´ ê±°ë˜ íšŸìˆ˜
  final double basePrice;             // ì‹œì‘ ê°€ê²© (ê¸‰ë“±/ê¸‰ë½ ê³„ì‚°ìš©)
  final double currentPrice;          // í˜„ì¬ ê°€ê²©
  final double highPrice;             // ìµœê³ ê°€
  final double lowPrice;              // ìµœì €ê°€
  final int largeTradeCount;          // ê³ ì•¡ê±°ë˜ íšŸìˆ˜
  final DateTime firstTradeTime;      // ì²« ê±°ë˜ ì‹œê°„
  final DateTime lastTradeTime;       // ë§ˆì§€ë§‰ ê±°ë˜ ì‹œê°„
  final double weightedAvgPrice;      // ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· ê°€

  const RealtimeMarketStats({
    required this.market,
    required this.totalVolume,
    required this.totalAmount,
    required this.tradeCount,
    required this.basePrice,
    required this.currentPrice,
    required this.highPrice,
    required this.lowPrice,
    required this.largeTradeCount,
    required this.firstTradeTime,
    required this.lastTradeTime,
    required this.weightedAvgPrice,
  });

  /// ì´ˆê¸° í†µê³„ ìƒì„±
  factory RealtimeMarketStats.initial(Trade firstTrade) {
    return RealtimeMarketStats(
      market: firstTrade.market,
      totalVolume: firstTrade.volume,
      totalAmount: firstTrade.total,
      tradeCount: 1,
      basePrice: firstTrade.price,
      currentPrice: firstTrade.price,
      highPrice: firstTrade.price,
      lowPrice: firstTrade.price,
      largeTradeCount: firstTrade.total >= BottomLineConstants.largeTradeThreshold ? 1 : 0,
      firstTradeTime: DateTime.fromMillisecondsSinceEpoch(firstTrade.timestampMs),
      lastTradeTime: DateTime.fromMillisecondsSinceEpoch(firstTrade.timestampMs),
      weightedAvgPrice: firstTrade.price,
    );
  }

  /// ìƒˆ ê±°ë˜ ì¶”ê°€í•˜ì—¬ í†µê³„ ì—…ë°ì´íŠ¸
  RealtimeMarketStats addTrade(Trade trade) {
    final newTotalVolume = totalVolume + trade.volume;
    final newTotalAmount = totalAmount + trade.total;
    final newTradeCount = tradeCount + 1;
    final newLargeTradeCount = largeTradeCount + 
      (trade.total >= BottomLineConstants.largeTradeThreshold ? 1 : 0);
    
    // ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· ê°€ ê³„ì‚°
    final newWeightedAvgPrice = newTotalVolume > 0
      ? (weightedAvgPrice * totalVolume + trade.price * trade.volume) / newTotalVolume
      : trade.price;

    return RealtimeMarketStats(
      market: market,
      totalVolume: newTotalVolume,
      totalAmount: newTotalAmount,
      tradeCount: newTradeCount,
      basePrice: basePrice, // ë³€ê²½í•˜ì§€ ì•ŠìŒ (ì‹œì‘ì  ìœ ì§€)
      currentPrice: trade.price,
      highPrice: math.max(highPrice, trade.price),
      lowPrice: math.min(lowPrice, trade.price),
      largeTradeCount: newLargeTradeCount,
      firstTradeTime: firstTradeTime, // ë³€ê²½í•˜ì§€ ì•ŠìŒ
      lastTradeTime: DateTime.fromMillisecondsSinceEpoch(trade.timestampMs),
      weightedAvgPrice: newWeightedAvgPrice,
    );
  }

  /// ê°€ê²© ë³€í™”ìœ¨ ê³„ì‚°
  double get changePercent {
    if (basePrice <= 0) return 0.0;
    return ((currentPrice - basePrice) / basePrice) * 100;
  }

  /// ë³€ë™ì„± ê³„ì‚° (ê³ ê°€-ì €ê°€ ë²”ìœ„)
  double get volatilityPercent {
    if (lowPrice <= 0) return 0.0;
    return ((highPrice - lowPrice) / lowPrice) * 100;
  }

  /// ê±°ë˜ í™œë°œë„ (ë¶„ë‹¹ ê±°ë˜ íšŸìˆ˜)
  double get tradesPerMinute {
    final duration = lastTradeTime.difference(firstTradeTime);
    if (duration.inMinutes == 0) return tradeCount.toDouble();
    return tradeCount / duration.inMinutes;
  }

  /// ê³ ì•¡ê±°ë˜ ë¹„ìœ¨
  double get largeTradeRatio {
    if (tradeCount == 0) return 0.0;
    return largeTradeCount / tradeCount;
  }

  /// í™œì„±ë„ ì—¬ë¶€ (ìµœê·¼ 5ë¶„ ë‚´ ê±°ë˜)
  bool get isActive {
    return DateTime.now().difference(lastTradeTime).inMinutes < 5;
  }

  /// Trade Entityë¡œ ë³€í™˜
  Trade toTradeEntity() {
    return Trade(
      market: market,
      price: currentPrice,
      volume: totalVolume,
      side: 'BID', // ê¸°ë³¸ê°’
      changePrice: currentPrice - basePrice,
      changeState: changePercent > 0 ? 'RISE' : (changePercent < 0 ? 'FALL' : 'EVEN'),
      timestampMs: lastTradeTime.millisecondsSinceEpoch,
      sequentialId: 'aggregated_${market}_${lastTradeTime.millisecondsSinceEpoch}',
    );
  }

  /// Volume Entityë¡œ ë³€í™˜
  Volume toVolumeEntity() {
    return Volume(
      market: market,
      totalVolume: totalVolume,
      lastUpdatedMs: lastTradeTime.millisecondsSinceEpoch,
      timeFrame: 'realtime',
      timeFrameStartMs: firstTradeTime.millisecondsSinceEpoch,
    );
  }

  /// Surge Entityë¡œ ë³€í™˜
  Surge toSurgeEntity() {
    return Surge(
      market: market,
      changePercent: changePercent,
      basePrice: basePrice,
      currentPrice: currentPrice,
      lastUpdatedMs: lastTradeTime.millisecondsSinceEpoch,
      timeFrame: 'realtime',
      timeFrameStartMs: firstTradeTime.millisecondsSinceEpoch,
    );
  }

  @override
  String toString() {
    return 'MarketStats($market: ${tradeCount}trades, ${changePercent.toStringAsFixed(1)}%, ${(totalAmount/100000000).toStringAsFixed(1)}ì–µ)';
  }
}

/// ì„¹í„°ë³„ ì‹¤ì‹œê°„ ì§‘ê³„ í†µê³„
@immutable
class RealtimeSectorStats {
  final String sector;
  final double totalVolume;
  final double totalAmount;
  final Set<String> activeMarkets;
  final DateTime firstUpdateTime;
  final DateTime lastUpdateTime;
  final int marketCount;

  const RealtimeSectorStats({
    required this.sector,
    required this.totalVolume,
    required this.totalAmount,
    required this.activeMarkets,
    required this.firstUpdateTime,
    required this.lastUpdateTime,
    required this.marketCount,
  });

  /// ì´ˆê¸° ì„¹í„° í†µê³„ ìƒì„±
  factory RealtimeSectorStats.initial(String sector, String market, double volume, double amount) {
    final now = DateTime.now();
    return RealtimeSectorStats(
      sector: sector,
      totalVolume: volume,
      totalAmount: amount,
      activeMarkets: {market},
      firstUpdateTime: now,
      lastUpdateTime: now,
      marketCount: 1,
    );
  }

  /// ë§ˆì¼“ ë°ì´í„° ì¶”ê°€
  RealtimeSectorStats addMarketData(String market, double volume, double amount) {
    final newActiveMarkets = Set<String>.from(activeMarkets)..add(market);
    
    return RealtimeSectorStats(
      sector: sector,
      totalVolume: totalVolume + volume,
      totalAmount: totalAmount + amount,
      activeMarkets: newActiveMarkets,
      firstUpdateTime: firstUpdateTime,
      lastUpdateTime: DateTime.now(),
      marketCount: newActiveMarkets.length,
    );
  }

  /// Volume Entityë¡œ ë³€í™˜
  Volume toVolumeEntity() {
    return Volume(
      market: 'SECTOR-$sector',
      totalVolume: totalVolume,
      lastUpdatedMs: lastUpdateTime.millisecondsSinceEpoch,
      timeFrame: 'realtime',
      timeFrameStartMs: firstUpdateTime.millisecondsSinceEpoch,
    );
  }

  @override
  String toString() {
    return 'SectorStats($sector: ${marketCount}markets, ${(totalAmount/100000000).toStringAsFixed(1)}ì–µ)';
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ ë°”í…€ë¼ì¸ ì‹¤ì‹œê°„ ë°ì´í„° ì• ê·¸ë¦¬ê²Œì´í„° (ë©”ì¸ í´ë˜ìŠ¤)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë°”í…€ë¼ì¸ìš© ì‹¤ì‹œê°„ ë°ì´í„° ì• ê·¸ë¦¬ê²Œì´í„° - ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ëˆ„ì  ì²˜ë¦¬
class BottomLineAggregator {
  // ğŸ“Š ì‹¤ì‹œê°„ í†µê³„ ì €ì¥ì†Œ
  final Map<String, RealtimeMarketStats> _marketStats = <String, RealtimeMarketStats>{};
  final Map<String, RealtimeSectorStats> _sectorStats = <String, RealtimeSectorStats>{};
  
  // ğŸ”„ ìˆœí™˜ ë²„í¼ë“¤ (ë©”ëª¨ë¦¬ íš¨ìœ¨ì )
  late final TradeCircularBuffer _recentTrades;
  late final StringCircularBuffer _recentLargeTrades;
  late final TimeBasedCircularBuffer<String> _marketActivity;
  
  // ğŸ“¸ ìŠ¤ëƒ…ìƒ· ìºì‹œ
  final Queue<MarketSnapshot> _snapshotHistory = Queue<MarketSnapshot>();
  MarketSnapshot? _lastSnapshot;
  MarketSnapshot? _baselineSnapshot;
  
  // â° ì‹œê°„ ê´€ë¦¬
  late final DateTime _startTime;
  DateTime? _lastSnapshotTime;
  DateTime? _lastCleanupTime;
  int _snapshotCounter = 0;
  
  // ğŸ“Š ì„±ëŠ¥ í†µê³„
  int _totalTradesProcessed = 0;
  int _totalSnapshotsGenerated = 0;
  Duration _totalProcessingTime = Duration.zero;

  BottomLineAggregator() : _startTime = DateTime.now() {
    _initializeBuffers();
    
    if (BottomLineConstants.enableLogging) {
      log.d('ğŸ”„ BottomLine Aggregator initialized at $_startTime');
    }
  }

  void _initializeBuffers() {
    _recentTrades = BottomLineBufferFactory.createTradeBuffer();
    _recentLargeTrades = BottomLineBufferFactory.createLargeTradeBuffer();
    _marketActivity = BottomLineBufferFactory.createTimeBasedBuffer<String>(
      BottomLineConstants.maxTrackedMarkets,
      const Duration(minutes: 10), // 10ë¶„ TTL
    );
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š ì‹¤ì‹œê°„ ë°ì´í„° ì¶”ê°€ (ë©”ì¸ ë¡œì§)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì‹¤ì‹œê°„ ê±°ë˜ ë°ì´í„° ì¶”ê°€ ë° í†µê³„ ì—…ë°ì´íŠ¸
  void addRealtimeTrade(Trade trade) {
    final stopwatch = Stopwatch()..start();
    
    try {
      // ğŸ”„ ìˆœí™˜ ë²„í¼ì— ì¶”ê°€
      final tradeMap = _tradeToMap(trade);
      _recentTrades.add(tradeMap);
      
      // ğŸ“Š ì‹œì¥ë³„ í†µê³„ ì—…ë°ì´íŠ¸
      _updateMarketStats(trade);
      
      // ğŸ·ï¸ ì„¹í„°ë³„ í†µê³„ ì—…ë°ì´íŠ¸
      _updateSectorStats(trade);
      
      // ğŸ¯ ê³ ì•¡ê±°ë˜ ì¶”ì 
      if (trade.total >= BottomLineConstants.largeTradeThreshold) {
        _recentLargeTrades.add('${trade.market}:${trade.total.toInt()}:${trade.timestampMs}');
      }
      
      // ğŸ“ˆ ì‹œì¥ í™œë™ ì¶”ì 
      _marketActivity.addData(trade.market);
      
      // ğŸ—‘ï¸ ì£¼ê¸°ì  ì •ë¦¬
      _performPeriodicCleanup();
      
      // ğŸ“Š í†µê³„ ì—…ë°ì´íŠ¸
      _totalTradesProcessed++;
      stopwatch.stop();
      _totalProcessingTime += stopwatch.elapsed;
      
      if (BottomLineConstants.enableDetailedLogging && _totalTradesProcessed % 100 == 0) {
        log.d('ğŸ“Š Processed ${_totalTradesProcessed} trades, ${_marketStats.length} markets tracked');
      }
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      log.e('ğŸš¨ Trade processing failed: $e', e, stackTrace);
    }
  }

  /// Tradeë¥¼ Mapìœ¼ë¡œ ë³€í™˜ (CircularBuffer í˜¸í™˜)
  Map<String, dynamic> _tradeToMap(Trade trade) {
    return {
      'market': trade.market,
      'price': trade.price,
      'volume': trade.volume,
      'amount': trade.total,
      'timestamp': trade.timestampMs,
      'side': trade.side,
    };
  }

  /// ì‹œì¥ë³„ í†µê³„ ì—…ë°ì´íŠ¸
  void _updateMarketStats(Trade trade) {
    final market = trade.market;
    
    if (_marketStats.containsKey(market)) {
      _marketStats[market] = _marketStats[market]!.addTrade(trade);
    } else {
      _marketStats[market] = RealtimeMarketStats.initial(trade);
    }
  }

  /// ì„¹í„°ë³„ í†µê³„ ì—…ë°ì´íŠ¸
  void _updateSectorStats(Trade trade) {
    final sector = _classifyMarketSector(trade.market);
    
    if (_sectorStats.containsKey(sector)) {
      _sectorStats[sector] = _sectorStats[sector]!
        .addMarketData(trade.market, trade.volume, trade.total);
    } else {
      _sectorStats[sector] = RealtimeSectorStats.initial(
        sector, trade.market, trade.volume, trade.total);
    }
  }

  /// ì‹œì¥ ì„¹í„° ë¶„ë¥˜ (ê¸°ì¡´ SectorClassification í™œìš©)
  String _classifyMarketSector(String market) {
    final ticker = market.replaceFirst('KRW-', '');
    
    // ë©”ì´ì € ì½”ì¸
    if (['BTC', 'ETH'].contains(ticker)) {
      return 'Major';
    }
    
    // ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸
    if (['SOL', 'ADA', 'AVAX', 'DOT', 'MATIC'].contains(ticker)) {
      return 'Layer1';
    }
    
    // DeFi í† í°
    if (['UNI', 'AAVE', 'COMP', 'SUSHI', 'CRV'].contains(ticker)) {
      return 'DeFi';
    }
    
    // ë©”íƒ€ë²„ìŠ¤/ê²Œì„
    if (['SAND', 'MANA', 'AXS', 'ENJ'].contains(ticker)) {
      return 'Metaverse';
    }
    
    // AI/ë¹…ë°ì´í„°
    if (['FET', 'OCEAN', 'GRT'].contains(ticker)) {
      return 'AI';
    }
    
    // ê¸°ë³¸ê°’
    return 'Altcoin';
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¸ ìŠ¤ëƒ…ìƒ· ìƒì„± (30ì´ˆë§ˆë‹¤)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ìŠ¤ëƒ…ìƒ· ìƒì„± í•„ìš” ì—¬ë¶€ í™•ì¸
  bool shouldGenerateSnapshot() {
    if (_lastSnapshotTime == null) return true;
    
    final elapsed = DateTime.now().difference(_lastSnapshotTime!);
    return elapsed.inSeconds >= BottomLineConstants.refreshIntervalSeconds;
  }

  /// ì‹¤ì‹œê°„ í†µê³„ì—ì„œ ë§ˆì¼“ ìŠ¤ëƒ…ìƒ· ìƒì„±
  MarketSnapshot? generateRealtimeSnapshot() {
    if (!shouldGenerateSnapshot()) return null;
    
    final stopwatch = Stopwatch()..start();
    
    try {
      final now = DateTime.now();
      
      // ğŸ“Š ê° íƒ€ì…ë³„ Entity ìƒì„±
      final trades = _generateTradeEntities();
      final volumes = _generateVolumeEntities();
      final surges = _generateSurgeEntities();
      final sectors = _generateSectorVolumeEntities();
      
      // ğŸ“ˆ ë¸íƒ€ ê³„ì‚° (ì´ì „ ìŠ¤ëƒ…ìƒ· ëŒ€ë¹„)
      final deltas = _calculateDeltas();
      
      // ğŸ“¸ ìŠ¤ëƒ…ìƒ· ìƒì„±
      final snapshot = MarketSnapshot(
        timestamp: now,
        timeFrame: 'min5', // TimeFrame.min5 ëŒ€ì‹  ë¬¸ìì—´ ì‚¬ìš©
        topTrades: trades,
        topVolumes: volumes,
        surges: surges,
        sectorVolumes: sectors,
        volChangePct: deltas['volume'] ?? {},
        sectorShareDelta: deltas['sector'] ?? {},
        priceDelta: deltas['price'] ?? {},
      );
      
      // ğŸ“¦ ìŠ¤ëƒ…ìƒ· ìºì‹±
      _cacheSnapshot(snapshot);
      
      // â° ì‹œê°„ ì—…ë°ì´íŠ¸
      _lastSnapshotTime = now;
      _snapshotCounter++;
      
      // ğŸ“Š í†µê³„ ì—…ë°ì´íŠ¸
      _totalSnapshotsGenerated++;
      stopwatch.stop();
      _totalProcessingTime += stopwatch.elapsed;
      
      if (BottomLineConstants.enableLogging) {
        log.d('ğŸ“¸ Snapshot #$_snapshotCounter generated: ${trades.length}T/${volumes.length}V/${surges.length}S/${sectors.length}SEC (${stopwatch.elapsedMilliseconds}ms)');
      }
      
      return snapshot;
      
    } catch (e, stackTrace) {
      stopwatch.stop();
      log.e('ğŸš¨ Snapshot generation failed: $e', e, stackTrace);
      return null;
    }
  }

  /// ì‹¤ì‹œê°„ í†µê³„ì—ì„œ Trade ì—”í‹°í‹°ë“¤ ìƒì„±
  List<Trade> _generateTradeEntities() {
    // ê³ ì•¡ê±°ë˜ ì¤‘ì‹¬ìœ¼ë¡œ ìµœê·¼ ê±°ë˜ë“¤ ì„ íƒ
    final largeTrades = _recentTrades.largeTrades;
    
    // ì‹œì¥ë³„ë¡œ ê·¸ë£¹í•‘í•˜ì—¬ ì¤‘ë³µ ì œê±°
    final marketTrades = <String, Map<String, dynamic>>{};
    for (final trade in largeTrades) {
      final market = trade['market'] as String;
      if (!marketTrades.containsKey(market) || 
          (trade['amount'] as double) > (marketTrades[market]!['amount'] as double)) {
        marketTrades[market] = trade;
      }
    }
    
    // Trade ì—”í‹°í‹°ë¡œ ë³€í™˜
    final trades = marketTrades.values.map((tradeMap) {
      return Trade(
        market: tradeMap['market'] as String,
        price: tradeMap['price'] as double,
        volume: tradeMap['volume'] as double,
        side: tradeMap['side'] as String? ?? 'BID',
        changePrice: 0.0, // ê³„ì‚° í•„ìš”ì‹œ ì¶”ê°€
        changeState: 'EVEN', // ê³„ì‚° í•„ìš”ì‹œ ì¶”ê°€
        timestampMs: tradeMap['timestamp'] as int,
        sequentialId: 'agg_${tradeMap['market']}_${tradeMap['timestamp']}',
      );
    }).toList();
    
    // ê±°ë˜ëŒ€ê¸ˆ ìˆœ ì •ë ¬
    trades.sort((a, b) => b.total.compareTo(a.total));
    
    return trades.take(50).toList();
  }

  /// ì‹¤ì‹œê°„ í†µê³„ì—ì„œ Volume ì—”í‹°í‹°ë“¤ ìƒì„±
  List<Volume> _generateVolumeEntities() {
    final volumes = _marketStats.values
      .where((stats) => stats.isActive && stats.totalVolume > 0)
      .map((stats) => stats.toVolumeEntity())
      .toList();
    
    // ë³¼ë¥¨ ìˆœ ì •ë ¬
    volumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    
    return volumes.take(50).toList();
  }

  /// ì‹¤ì‹œê°„ í†µê³„ì—ì„œ Surge ì—”í‹°í‹°ë“¤ ìƒì„±
  List<Surge> _generateSurgeEntities() {
    final surges = _marketStats.values
      .where((stats) => stats.isActive && stats.changePercent.abs() > 0.1)
      .map((stats) => stats.toSurgeEntity())
      .toList();
    
    // ë³€í™”ìœ¨ ì ˆëŒ“ê°’ ìˆœ ì •ë ¬ (ê¸‰ë“±ì´ ë¨¼ì €)
    surges.sort((a, b) {
      if (a.changePercent > 0 && b.changePercent < 0) return -1;
      if (a.changePercent < 0 && b.changePercent > 0) return 1;
      return b.changePercent.abs().compareTo(a.changePercent.abs());
    });
    
    return surges;
  }

  /// ì‹¤ì‹œê°„ í†µê³„ì—ì„œ ì„¹í„° Volume ì—”í‹°í‹°ë“¤ ìƒì„±
  List<Volume> _generateSectorVolumeEntities() {
    final sectorVolumes = _sectorStats.values
      .where((stats) => stats.totalVolume > 0)
      .map((stats) => stats.toVolumeEntity())
      .toList();
    
    // ë³¼ë¥¨ ìˆœ ì •ë ¬
    sectorVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    
    return sectorVolumes.take(10).toList();
  }

  /// ì´ì „ ìŠ¤ëƒ…ìƒ· ëŒ€ë¹„ ë¸íƒ€ ê³„ì‚°
  Map<String, Map<String, double>> _calculateDeltas() {
    if (_lastSnapshot == null) {
      return {'volume': {}, 'sector': {}, 'price': {}};
    }
    
    // ë³¼ë¥¨ ë³€í™”ìœ¨ ê³„ì‚°
    final volChangePct = <String, double>{};
    for (final stats in _marketStats.values) {
      final prevVolume = _lastSnapshot!.topVolumes
        .where((v) => v.market == stats.market)
        .firstOrNull?.totalVolume ?? 0.0;
      
      if (prevVolume > 0) {
        volChangePct[stats.market] = 
          ((stats.totalVolume - prevVolume) / prevVolume) * 100;
      }
    }
    
    // ì„¹í„° ì ìœ ìœ¨ ë³€í™” ê³„ì‚°
    final sectorShareDelta = <String, double>{};
    final currentTotalVolume = _sectorStats.values
      .fold<double>(0, (sum, stats) => sum + stats.totalVolume);
    
    if (currentTotalVolume > 0) {
      for (final stats in _sectorStats.values) {
        final currentShare = (stats.totalVolume / currentTotalVolume) * 100;
        
        final prevTotalVolume = _lastSnapshot!.sectorVolumes
          .fold<double>(0, (sum, v) => sum + v.totalVolume);
        final prevSectorVolume = _lastSnapshot!.sectorVolumes
          .where((v) => v.market == 'SECTOR-${stats.sector}')
          .firstOrNull?.totalVolume ?? 0.0;
        
        if (prevTotalVolume > 0) {
          final prevShare = (prevSectorVolume / prevTotalVolume) * 100;
          sectorShareDelta['SECTOR-${stats.sector}'] = currentShare - prevShare;
        }
      }
    }
    
    // ê°€ê²© ë³€í™”ìœ¨
    final priceDelta = <String, double>{};
    for (final stats in _marketStats.values) {
      priceDelta[stats.market] = stats.changePercent;
    }
    
    return {
      'volume': volChangePct,
      'sector': sectorShareDelta,
      'price': priceDelta,
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ìŠ¤ëƒ…ìƒ· ìºì‹± ë° ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ìŠ¤ëƒ…ìƒ· ìºì‹±
  void _cacheSnapshot(MarketSnapshot snapshot) {
    _lastSnapshot = snapshot;
    
    // ì²« ë²ˆì§¸ ìŠ¤ëƒ…ìƒ·ì„ ë² ì´ìŠ¤ë¼ì¸ìœ¼ë¡œ ì„¤ì •
    _baselineSnapshot ??= snapshot;
    
    // ìŠ¤ëƒ…ìƒ· íˆìŠ¤í† ë¦¬ ê´€ë¦¬ (ìµœëŒ€ 3ê°œ)
    _snapshotHistory.addLast(snapshot);
    while (_snapshotHistory.length > BottomLineConstants.maxCachedSnapshots) {
      _snapshotHistory.removeFirst();
    }
  }

  /// ë§ˆì§€ë§‰ ìŠ¤ëƒ…ìƒ· ë°˜í™˜
  MarketSnapshot? getLastSnapshot() => _lastSnapshot;

  /// ë² ì´ìŠ¤ë¼ì¸ ìŠ¤ëƒ…ìƒ· ë°˜í™˜
  MarketSnapshot? getBaselineSnapshot() => _baselineSnapshot;

  /// ìŠ¤ëƒ…ìƒ· íˆìŠ¤í† ë¦¬ ë°˜í™˜
  List<MarketSnapshot> getSnapshotHistory() => _snapshotHistory.toList();

  /// ë² ì´ìŠ¤ë¼ì¸ ìŠ¤ëƒ…ìƒ· ê°±ì‹  (1ì‹œê°„ë§ˆë‹¤)
  void refreshBaseline() {
    if (_lastSnapshot != null) {
      _baselineSnapshot = _lastSnapshot;
      
      if (BottomLineConstants.enableLogging) {
        log.d('ğŸ“ Baseline snapshot refreshed');
      }
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ—‘ï¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ ë° ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì£¼ê¸°ì  ì •ë¦¬ ìˆ˜í–‰
  void _performPeriodicCleanup() {
    final now = DateTime.now();
    
    // 5ë¶„ë§ˆë‹¤ ì •ë¦¬
    if (_lastCleanupTime == null || 
        now.difference(_lastCleanupTime!).inMinutes >= BottomLineConstants.cleanupIntervalMinutes) {
      _performCleanup();
      _lastCleanupTime = now;
    }
    
    // 1ì‹œê°„ë§ˆë‹¤ ë² ì´ìŠ¤ë¼ì¸ ê°±ì‹ 
    if (_baselineSnapshot != null &&
        now.difference(_baselineSnapshot!.timestamp).inHours >= BottomLineConstants.baselineRefreshHours) {
      refreshBaseline();
    }
  }

  /// ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰
  void _performCleanup() {
    final beforeSize = getMemoryUsageEstimate();
    int removedMarkets = 0;
    int removedSectors = 0;
    
    // ë¹„í™œì„± ì‹œì¥ ì œê±°
    final inactiveMarkets = _marketStats.entries
      .where((entry) => !entry.value.isActive)
      .map((entry) => entry.key)
      .toList();
    
    for (final market in inactiveMarkets) {
      _marketStats.remove(market);
      removedMarkets++;
    }
    
    // ë¹ˆ ì„¹í„° ì œê±°
    final emptySectors = _sectorStats.entries
      .where((entry) => entry.value.totalVolume == 0)
      .map((entry) => entry.key)
      .toList();
    
    for (final sector in emptySectors) {
      _sectorStats.remove(sector);
      removedSectors++;
    }
    
    // ìˆœí™˜ ë²„í¼ ì •ë¦¬ (ìë™)
    _marketActivity.removeExpired();
    
    final afterSize = getMemoryUsageEstimate();
    
    if (BottomLineConstants.enableLogging && (removedMarkets > 0 || removedSectors > 0)) {
      log.d('ğŸ—‘ï¸ Cleanup completed: -${removedMarkets}markets, -${removedSectors}sectors, ${beforeSize}Bâ†’${afterSize}B');
    }
  }

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì •
  int getMemoryUsageEstimate() {
    int total = 0;
    
    // ì‹œì¥ë³„ í†µê³„
    total += _marketStats.length * 300; // ~300ë°”ì´íŠ¸ per market
    
    // ì„¹í„°ë³„ í†µê³„
    total += _sectorStats.length * 200; // ~200ë°”ì´íŠ¸ per sector
    
    // ìˆœí™˜ ë²„í¼ë“¤
    total += _recentTrades.estimatedMemoryBytes;
    total += _recentLargeTrades.estimatedMemoryBytes;
    total += _marketActivity.estimatedMemoryBytes;
    
    // ìŠ¤ëƒ…ìƒ· íˆìŠ¤í† ë¦¬
    total += _snapshotHistory.length * 10000; // ~10KB per snapshot
    
    return total;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“Š í†µê³„ ë° ëª¨ë‹ˆí„°ë§
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì „ì²´ ì• ê·¸ë¦¬ê²Œì´í„° í†µê³„
  Map<String, dynamic> getStats() {
    final now = DateTime.now();
    final uptimeMinutes = now.difference(_startTime).inMinutes;
    
    final avgProcessingTime = _totalTradesProcessed > 0
      ? _totalProcessingTime.inMicroseconds / _totalTradesProcessed
      : 0.0;
    
    final tradesPerMinute = uptimeMinutes > 0
      ? _totalTradesProcessed / uptimeMinutes
      : 0.0;
    
    return {
      'uptime_minutes': uptimeMinutes,
      'total_trades_processed': _totalTradesProcessed,
      'total_snapshots_generated': _totalSnapshotsGenerated,
      'trades_per_minute': tradesPerMinute.toStringAsFixed(1),
      'avg_processing_time_us': avgProcessingTime.toStringAsFixed(1),
      'markets_tracked': _marketStats.length,
      'sectors_tracked': _sectorStats.length,
      'active_markets': _marketStats.values.where((s) => s.isActive).length,
      'memory_usage_bytes': getMemoryUsageEstimate(),
      'last_snapshot': _lastSnapshotTime?.toIso8601String() ?? 'Never',
      'last_cleanup': _lastCleanupTime?.toIso8601String() ?? 'Never',
      'snapshot_counter': _snapshotCounter,
      'cache_sizes': {
        'recent_trades': _recentTrades.length,
        'large_trades': _recentLargeTrades.length,
        'market_activity': _marketActivity.length,
        'snapshot_history': _snapshotHistory.length,
      },
    };
  }

  /// ì‹œì¥ë³„ ìƒì„¸ í†µê³„
  Map<String, dynamic> getMarketStats() {
    final marketStats = <String, Map<String, dynamic>>{};
    
    for (final entry in _marketStats.entries) {
      final stats = entry.value;
      marketStats[entry.key] = {
        'total_volume': stats.totalVolume,
        'total_amount': (stats.totalAmount / 100000000).toStringAsFixed(1), // ì–µì›
        'trade_count': stats.tradeCount,
        'change_percent': stats.changePercent.toStringAsFixed(2),
        'volatility_percent': stats.volatilityPercent.toStringAsFixed(2),
        'large_trade_count': stats.largeTradeCount,
        'large_trade_ratio': (stats.largeTradeRatio * 100).toStringAsFixed(1),
        'trades_per_minute': stats.tradesPerMinute.toStringAsFixed(1),
        'is_active': stats.isActive,
        'current_price': stats.currentPrice,
        'price_range': '${stats.lowPrice} ~ ${stats.highPrice}',
        'first_trade': stats.firstTradeTime.toIso8601String(),
        'last_trade': stats.lastTradeTime.toIso8601String(),
      };
    }
    
    return marketStats;
  }

  /// ì„¹í„°ë³„ ìƒì„¸ í†µê³„
  Map<String, dynamic> getSectorStats() {
    final sectorStats = <String, Map<String, dynamic>>{};
    
    for (final entry in _sectorStats.entries) {
      final stats = entry.value;
      sectorStats[entry.key] = {
        'total_volume': stats.totalVolume,
        'total_amount': (stats.totalAmount / 100000000).toStringAsFixed(1), // ì–µì›
        'market_count': stats.marketCount,
        'active_markets': stats.activeMarkets.toList(),
        'first_update': stats.firstUpdateTime.toIso8601String(),
        'last_update': stats.lastUpdateTime.toIso8601String(),
      };
    }
    
    return sectorStats;
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­
  Map<String, dynamic> getPerformanceMetrics() {
    final now = DateTime.now();
    final uptimeSeconds = now.difference(_startTime).inSeconds;
    
    return {
      'uptime_seconds': uptimeSeconds,
      'throughput': {
        'trades_per_second': uptimeSeconds > 0 ? _totalTradesProcessed / uptimeSeconds : 0.0,
        'snapshots_per_hour': uptimeSeconds > 0 ? (_totalSnapshotsGenerated * 3600) / uptimeSeconds : 0.0,
      },
      'efficiency': {
        'avg_trade_processing_us': _totalTradesProcessed > 0 
          ? _totalProcessingTime.inMicroseconds / _totalTradesProcessed 
          : 0.0,
        'memory_per_market_bytes': _marketStats.isNotEmpty 
          ? getMemoryUsageEstimate() / _marketStats.length 
          : 0,
        'active_market_ratio': _marketStats.isNotEmpty
          ? _marketStats.values.where((s) => s.isActive).length / _marketStats.length
          : 0.0,
      },
      'quality': {
        'data_completeness': _calculateDataCompleteness(),
        'market_coverage': _calculateMarketCoverage(),
        'temporal_consistency': _calculateTemporalConsistency(),
      },
    };
  }

  /// ë°ì´í„° ì™„ì „ì„± ê³„ì‚°
  double _calculateDataCompleteness() {
    if (_marketStats.isEmpty) return 0.0;
    
    int completeMarkets = 0;
    for (final stats in _marketStats.values) {
      // ì™„ì „í•œ ë°ì´í„° ê¸°ì¤€: ê±°ë˜ 5íšŒ ì´ìƒ + ê°€ê²© ë³€í™” ìˆìŒ
      if (stats.tradeCount >= 5 && stats.currentPrice != stats.basePrice) {
        completeMarkets++;
      }
    }
    
    return completeMarkets / _marketStats.length;
  }

  /// ì‹œì¥ ì»¤ë²„ë¦¬ì§€ ê³„ì‚°
  double _calculateMarketCoverage() {
    // í™œì„± ì‹œì¥ì˜ ë¹„ìœ¨
    if (_marketStats.isEmpty) return 0.0;
    
    final activeMarkets = _marketStats.values.where((s) => s.isActive).length;
    return activeMarkets / _marketStats.length;
  }

  /// ì‹œê°„ì  ì¼ê´€ì„± ê³„ì‚°
  double _calculateTemporalConsistency() {
    // ìµœê·¼ ë°ì´í„°ì˜ ì‹ ì„ ë„
    if (_marketStats.isEmpty) return 0.0;
    
    final now = DateTime.now();
    int freshMarkets = 0;
    
    for (final stats in _marketStats.values) {
      final age = now.difference(stats.lastTradeTime).inMinutes;
      if (age <= 5) { // 5ë¶„ ì´ë‚´ ë°ì´í„°
        freshMarkets++;
      }
    }
    
    return freshMarkets / _marketStats.length;
  }

  /// ìƒìœ„ ì‹œì¥ ìˆœìœ„ (ë‹¤ì–‘í•œ ê¸°ì¤€)
  Map<String, List<String>> getTopMarkets() {
    final allStats = _marketStats.values.where((s) => s.isActive).toList();
    
    return {
      'by_volume': (allStats.toList()
        ..sort((a, b) => b.totalVolume.compareTo(a.totalVolume)))
        .take(10)
        .map((s) => s.market)
        .toList(),
      
      'by_amount': (allStats.toList()
        ..sort((a, b) => b.totalAmount.compareTo(a.totalAmount)))
        .take(10)
        .map((s) => s.market)
        .toList(),
      
      'by_change': (allStats.toList()
        ..sort((a, b) => b.changePercent.abs().compareTo(a.changePercent.abs())))
        .take(10)
        .map((s) => s.market)
        .toList(),
      
      'by_trades': (allStats.toList()
        ..sort((a, b) => b.tradeCount.compareTo(a.tradeCount)))
        .take(10)
        .map((s) => s.market)
        .toList(),
      
      'by_large_trades': (allStats.toList()
        ..sort((a, b) => b.largeTradeCount.compareTo(a.largeTradeCount)))
        .take(10)
        .map((s) => s.market)
        .toList(),
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// íŠ¹ì • ì‹œì¥ì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ
  RealtimeMarketStats? getMarketDetails(String market) {
    return _marketStats[market];
  }

  /// íŠ¹ì • ì„¹í„°ì˜ ìƒì„¸ ì •ë³´ ì¡°íšŒ
  RealtimeSectorStats? getSectorDetails(String sector) {
    return _sectorStats[sector];
  }

  /// ìµœê·¼ ê³ ì•¡ê±°ë˜ ëª©ë¡ ì¡°íšŒ
  List<String> getRecentLargeTrades({int limit = 20}) {
    return _recentLargeTrades.items.reversed.take(limit).toList();
  }

  /// ìµœê·¼ í™œì„± ì‹œì¥ ëª©ë¡ ì¡°íšŒ
  List<String> getRecentActiveMarkets({int limit = 20}) {
    return _marketActivity.validData.reversed.toSet().take(limit).toList();
  }

  /// ì‹œì¥ í™œì„±ë„ íˆíŠ¸ë§µ ë°ì´í„°
  Map<String, int> getMarketActivityHeatmap() {
    final heatmap = <String, int>{};
    
    for (final market in _marketActivity.validData) {
      heatmap[market] = (heatmap[market] ?? 0) + 1;
    }
    
    return heatmap;
  }

  /// ë°ì´í„° ìƒíƒœ ê²€ì¦
  Map<String, dynamic> validateDataIntegrity() {
    final issues = <String>[];
    final warnings = <String>[];
    
    // ê¸°ë³¸ ë°ì´í„° ì¡´ì¬ ì—¬ë¶€
    if (_marketStats.isEmpty) {
      issues.add('No market data available');
    }
    
    // ì‹œê°„ ì¼ê´€ì„± ì²´í¬
    final now = DateTime.now();
    for (final entry in _marketStats.entries) {
      final stats = entry.value;
      
      // ë¯¸ë˜ ì‹œê°„ ì²´í¬
      if (stats.lastTradeTime.isAfter(now)) {
        issues.add('Future timestamp detected in ${entry.key}');
      }
      
      // ì²« ê±°ë˜ë³´ë‹¤ ë§ˆì§€ë§‰ ê±°ë˜ê°€ ì´ì „ì¸ ê²½ìš°
      if (stats.lastTradeTime.isBefore(stats.firstTradeTime)) {
        issues.add('Invalid time sequence in ${entry.key}');
      }
      
      // ë„ˆë¬´ ì˜¤ë˜ëœ ë°ì´í„°
      if (now.difference(stats.lastTradeTime).inHours > 1) {
        warnings.add('Stale data in ${entry.key} (${now.difference(stats.lastTradeTime).inHours}h old)');
      }
      
      // ë¹„ì •ìƒì ì¸ ê°€ê²© ë°ì´í„°
      if (stats.currentPrice <= 0 || stats.basePrice <= 0) {
        issues.add('Invalid price data in ${entry.key}');
      }
      
      // ë¹„ì •ìƒì ì¸ ë³¼ë¥¨ ë°ì´í„°
      if (stats.totalVolume < 0) {
        issues.add('Negative volume in ${entry.key}');
      }
    }
    
    return {
      'is_valid': issues.isEmpty,
      'issues': issues,
      'warnings': warnings,
      'markets_checked': _marketStats.length,
      'sectors_checked': _sectorStats.length,
      'check_timestamp': now.toIso8601String(),
    };
  }

  /// í†µê³„ ë¦¬ì…‹
  void resetStats() {
    _totalTradesProcessed = 0;
    _totalSnapshotsGenerated = 0;
    _totalProcessingTime = Duration.zero;
    _snapshotCounter = 0;
    
    if (BottomLineConstants.enableLogging) {
      log.d('ğŸ“Š Aggregator stats reset');
    }
  }

  /// ì „ì²´ ë°ì´í„° ë¦¬ì…‹ (ì‹œì‘ ì‹œì  ì¬ì„¤ì •)
  void resetAllData() {
    _marketStats.clear();
    _sectorStats.clear();
    _recentTrades.clear();
    _recentLargeTrades.clear();
    _marketActivity.clear();
    _snapshotHistory.clear();
    
    _lastSnapshot = null;
    _baselineSnapshot = null;
    _lastSnapshotTime = null;
    _lastCleanupTime = null;
    
    resetStats();
    
    if (BottomLineConstants.enableLogging) {
      log.d('ğŸ”„ Aggregator completely reset');
    }
  }

  /// ë””ë²„ê·¸ ì •ë³´ ìƒì„±
  Map<String, dynamic> generateDebugReport() {
    return {
      'aggregator_info': {
        'start_time': _startTime.toIso8601String(),
        'uptime': DateTime.now().difference(_startTime).toString(),
        'version': '1.0.0',
      },
      'data_summary': getStats(),
      'performance': getPerformanceMetrics(),
      'top_markets': getTopMarkets(),
      'integrity_check': validateDataIntegrity(),
      'memory_breakdown': {
        'market_stats': '${_marketStats.length} Ã— 300B = ${_marketStats.length * 300}B',
        'sector_stats': '${_sectorStats.length} Ã— 200B = ${_sectorStats.length * 200}B',
        'recent_trades': '${_recentTrades.estimatedMemoryBytes}B',
        'large_trades': '${_recentLargeTrades.estimatedMemoryBytes}B',
        'market_activity': '${_marketActivity.estimatedMemoryBytes}B',
        'snapshots': '${_snapshotHistory.length} Ã— 10KB = ${_snapshotHistory.length * 10000}B',
        'total_estimated': '${getMemoryUsageEstimate()}B',
      },
      'buffer_states': {
        'recent_trades': _recentTrades.stats,
        'large_trades': _recentLargeTrades.stats,
        'market_activity': _marketActivity.stats,
      },
    };
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    resetAllData();
    
    if (BottomLineConstants.enableLogging) {
      log.d('ğŸ›‘ BottomLine Aggregator disposed');
    }
  }
}\n\n// ====== lib/domain/entities/bottom_line.freezed.dart ======\n
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bottom_line.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MarketSnapshot {
  DateTime get timestamp => throw _privateConstructorUsedError;
  String get timeFrame => throw _privateConstructorUsedError;
  List<Trade> get topTrades =>
      throw _privateConstructorUsedError; // â‰¥20M, ìµœê·¼ 50ê±´
  List<Volume> get topVolumes =>
      throw _privateConstructorUsedError; // í™œì„± ë§ˆì¼“ ìƒìœ„ 50ê°œ
  List<Surge> get surges => throw _privateConstructorUsedError; // ë³€í™” ìˆëŠ” ì½”ì¸ë§Œ
  List<Volume> get sectorVolumes =>
      throw _privateConstructorUsedError; // ì£¼ìš” ì„¹í„° 10ê°œ
  Map<String, double> get volChangePct =>
      throw _privateConstructorUsedError; // ë³¼ë¥¨ ë³€í™”ìœ¨
  Map<String, double> get sectorShareDelta =>
      throw _privateConstructorUsedError; // ì„¹í„° ì ìœ ìœ¨ ë³€í™” (ìˆ˜ì •ë¨)
  Map<String, double> get priceDelta => throw _privateConstructorUsedError;

  /// Create a copy of MarketSnapshot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MarketSnapshotCopyWith<MarketSnapshot> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MarketSnapshotCopyWith<$Res> {
  factory $MarketSnapshotCopyWith(
          MarketSnapshot value, $Res Function(MarketSnapshot) then) =
      _$MarketSnapshotCopyWithImpl<$Res, MarketSnapshot>;
  @useResult
  $Res call(
      {DateTime timestamp,
      String timeFrame,
      List<Trade> topTrades,
      List<Volume> topVolumes,
      List<Surge> surges,
      List<Volume> sectorVolumes,
      Map<String, double> volChangePct,
      Map<String, double> sectorShareDelta,
      Map<String, double> priceDelta});
}

/// @nodoc
class _$MarketSnapshotCopyWithImpl<$Res, $Val extends MarketSnapshot>
    implements $MarketSnapshotCopyWith<$Res> {
  _$MarketSnapshotCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MarketSnapshot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? timestamp = null,
    Object? timeFrame = null,
    Object? topTrades = null,
    Object? topVolumes = null,
    Object? surges = null,
    Object? sectorVolumes = null,
    Object? volChangePct = null,
    Object? sectorShareDelta = null,
    Object? priceDelta = null,
  }) {
    return _then(_value.copyWith(
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      timeFrame: null == timeFrame
          ? _value.timeFrame
          : timeFrame // ignore: cast_nullable_to_non_nullable
              as String,
      topTrades: null == topTrades
          ? _value.topTrades
          : topTrades // ignore: cast_nullable_to_non_nullable
              as List<Trade>,
      topVolumes: null == topVolumes
          ? _value.topVolumes
          : topVolumes // ignore: cast_nullable_to_non_nullable
              as List<Volume>,
      surges: null == surges
          ? _value.surges
          : surges // ignore: cast_nullable_to_non_nullable
              as List<Surge>,
      sectorVolumes: null == sectorVolumes
          ? _value.sectorVolumes
          : sectorVolumes // ignore: cast_nullable_to_non_nullable
              as List<Volume>,
      volChangePct: null == volChangePct
          ? _value.volChangePct
          : volChangePct // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
      sectorShareDelta: null == sectorShareDelta
          ? _value.sectorShareDelta
          : sectorShareDelta // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
      priceDelta: null == priceDelta
          ? _value.priceDelta
          : priceDelta // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MarketSnapshotImplCopyWith<$Res>
    implements $MarketSnapshotCopyWith<$Res> {
  factory _$$MarketSnapshotImplCopyWith(_$MarketSnapshotImpl value,
          $Res Function(_$MarketSnapshotImpl) then) =
      __$$MarketSnapshotImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DateTime timestamp,
      String timeFrame,
      List<Trade> topTrades,
      List<Volume> topVolumes,
      List<Surge> surges,
      List<Volume> sectorVolumes,
      Map<String, double> volChangePct,
      Map<String, double> sectorShareDelta,
      Map<String, double> priceDelta});
}

/// @nodoc
class __$$MarketSnapshotImplCopyWithImpl<$Res>
    extends _$MarketSnapshotCopyWithImpl<$Res, _$MarketSnapshotImpl>
    implements _$$MarketSnapshotImplCopyWith<$Res> {
  __$$MarketSnapshotImplCopyWithImpl(
      _$MarketSnapshotImpl _value, $Res Function(_$MarketSnapshotImpl) _then)
      : super(_value, _then);

  /// Create a copy of MarketSnapshot
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? timestamp = null,
    Object? timeFrame = null,
    Object? topTrades = null,
    Object? topVolumes = null,
    Object? surges = null,
    Object? sectorVolumes = null,
    Object? volChangePct = null,
    Object? sectorShareDelta = null,
    Object? priceDelta = null,
  }) {
    return _then(_$MarketSnapshotImpl(
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      timeFrame: null == timeFrame
          ? _value.timeFrame
          : timeFrame // ignore: cast_nullable_to_non_nullable
              as String,
      topTrades: null == topTrades
          ? _value._topTrades
          : topTrades // ignore: cast_nullable_to_non_nullable
              as List<Trade>,
      topVolumes: null == topVolumes
          ? _value._topVolumes
          : topVolumes // ignore: cast_nullable_to_non_nullable
              as List<Volume>,
      surges: null == surges
          ? _value._surges
          : surges // ignore: cast_nullable_to_non_nullable
              as List<Surge>,
      sectorVolumes: null == sectorVolumes
          ? _value._sectorVolumes
          : sectorVolumes // ignore: cast_nullable_to_non_nullable
              as List<Volume>,
      volChangePct: null == volChangePct
          ? _value._volChangePct
          : volChangePct // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
      sectorShareDelta: null == sectorShareDelta
          ? _value._sectorShareDelta
          : sectorShareDelta // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
      priceDelta: null == priceDelta
          ? _value._priceDelta
          : priceDelta // ignore: cast_nullable_to_non_nullable
              as Map<String, double>,
    ));
  }
}

/// @nodoc

class _$MarketSnapshotImpl extends _MarketSnapshot {
  const _$MarketSnapshotImpl(
      {required this.timestamp,
      required this.timeFrame,
      required final List<Trade> topTrades,
      required final List<Volume> topVolumes,
      required final List<Surge> surges,
      required final List<Volume> sectorVolumes,
      required final Map<String, double> volChangePct,
      required final Map<String, double> sectorShareDelta,
      required final Map<String, double> priceDelta})
      : _topTrades = topTrades,
        _topVolumes = topVolumes,
        _surges = surges,
        _sectorVolumes = sectorVolumes,
        _volChangePct = volChangePct,
        _sectorShareDelta = sectorShareDelta,
        _priceDelta = priceDelta,
        super._();

  @override
  final DateTime timestamp;
  @override
  final String timeFrame;
  final List<Trade> _topTrades;
  @override
  List<Trade> get topTrades {
    if (_topTrades is EqualUnmodifiableListView) return _topTrades;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topTrades);
  }

// â‰¥20M, ìµœê·¼ 50ê±´
  final List<Volume> _topVolumes;
// â‰¥20M, ìµœê·¼ 50ê±´
  @override
  List<Volume> get topVolumes {
    if (_topVolumes is EqualUnmodifiableListView) return _topVolumes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_topVolumes);
  }

// í™œì„± ë§ˆì¼“ ìƒìœ„ 50ê°œ
  final List<Surge> _surges;
// í™œì„± ë§ˆì¼“ ìƒìœ„ 50ê°œ
  @override
  List<Surge> get surges {
    if (_surges is EqualUnmodifiableListView) return _surges;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_surges);
  }

// ë³€í™” ìˆëŠ” ì½”ì¸ë§Œ
  final List<Volume> _sectorVolumes;
// ë³€í™” ìˆëŠ” ì½”ì¸ë§Œ
  @override
  List<Volume> get sectorVolumes {
    if (_sectorVolumes is EqualUnmodifiableListView) return _sectorVolumes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sectorVolumes);
  }

// ì£¼ìš” ì„¹í„° 10ê°œ
  final Map<String, double> _volChangePct;
// ì£¼ìš” ì„¹í„° 10ê°œ
  @override
  Map<String, double> get volChangePct {
    if (_volChangePct is EqualUnmodifiableMapView) return _volChangePct;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_volChangePct);
  }

// ë³¼ë¥¨ ë³€í™”ìœ¨
  final Map<String, double> _sectorShareDelta;
// ë³¼ë¥¨ ë³€í™”ìœ¨
  @override
  Map<String, double> get sectorShareDelta {
    if (_sectorShareDelta is EqualUnmodifiableMapView) return _sectorShareDelta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_sectorShareDelta);
  }

// ì„¹í„° ì ìœ ìœ¨ ë³€í™” (ìˆ˜ì •ë¨)
  final Map<String, double> _priceDelta;
// ì„¹í„° ì ìœ ìœ¨ ë³€í™” (ìˆ˜ì •ë¨)
  @override
  Map<String, double> get priceDelta {
    if (_priceDelta is EqualUnmodifiableMapView) return _priceDelta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_priceDelta);
  }

  @override
  String toString() {
    return 'MarketSnapshot(timestamp: $timestamp, timeFrame: $timeFrame, topTrades: $topTrades, topVolumes: $topVolumes, surges: $surges, sectorVolumes: $sectorVolumes, volChangePct: $volChangePct, sectorShareDelta: $sectorShareDelta, priceDelta: $priceDelta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MarketSnapshotImpl &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.timeFrame, timeFrame) ||
                other.timeFrame == timeFrame) &&
            const DeepCollectionEquality()
                .equals(other._topTrades, _topTrades) &&
            const DeepCollectionEquality()
                .equals(other._topVolumes, _topVolumes) &&
            const DeepCollectionEquality().equals(other._surges, _surges) &&
            const DeepCollectionEquality()
                .equals(other._sectorVolumes, _sectorVolumes) &&
            const DeepCollectionEquality()
                .equals(other._volChangePct, _volChangePct) &&
            const DeepCollectionEquality()
                .equals(other._sectorShareDelta, _sectorShareDelta) &&
            const DeepCollectionEquality()
                .equals(other._priceDelta, _priceDelta));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      timestamp,
      timeFrame,
      const DeepCollectionEquality().hash(_topTrades),
      const DeepCollectionEquality().hash(_topVolumes),
      const DeepCollectionEquality().hash(_surges),
      const DeepCollectionEquality().hash(_sectorVolumes),
      const DeepCollectionEquality().hash(_volChangePct),
      const DeepCollectionEquality().hash(_sectorShareDelta),
      const DeepCollectionEquality().hash(_priceDelta));

  /// Create a copy of MarketSnapshot
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MarketSnapshotImplCopyWith<_$MarketSnapshotImpl> get copyWith =>
      __$$MarketSnapshotImplCopyWithImpl<_$MarketSnapshotImpl>(
          this, _$identity);
}

abstract class _MarketSnapshot extends MarketSnapshot {
  const factory _MarketSnapshot(
      {required final DateTime timestamp,
      required final String timeFrame,
      required final List<Trade> topTrades,
      required final List<Volume> topVolumes,
      required final List<Surge> surges,
      required final List<Volume> sectorVolumes,
      required final Map<String, double> volChangePct,
      required final Map<String, double> sectorShareDelta,
      required final Map<String, double> priceDelta}) = _$MarketSnapshotImpl;
  const _MarketSnapshot._() : super._();

  @override
  DateTime get timestamp;
  @override
  String get timeFrame;
  @override
  List<Trade> get topTrades; // â‰¥20M, ìµœê·¼ 50ê±´
  @override
  List<Volume> get topVolumes; // í™œì„± ë§ˆì¼“ ìƒìœ„ 50ê°œ
  @override
  List<Surge> get surges; // ë³€í™” ìˆëŠ” ì½”ì¸ë§Œ
  @override
  List<Volume> get sectorVolumes; // ì£¼ìš” ì„¹í„° 10ê°œ
  @override
  Map<String, double> get volChangePct; // ë³¼ë¥¨ ë³€í™”ìœ¨
  @override
  Map<String, double> get sectorShareDelta; // ì„¹í„° ì ìœ ìœ¨ ë³€í™” (ìˆ˜ì •ë¨)
  @override
  Map<String, double> get priceDelta;

  /// Create a copy of MarketSnapshot
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MarketSnapshotImplCopyWith<_$MarketSnapshotImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CandidateInsight {
  String get id => throw _privateConstructorUsedError;
  String get template => throw _privateConstructorUsedError;
  double get score => throw _privateConstructorUsedError;
  double get weight => throw _privateConstructorUsedError;
  Map<String, dynamic> get templateVars => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  bool get isUrgent => throw _privateConstructorUsedError;

  /// Create a copy of CandidateInsight
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CandidateInsightCopyWith<CandidateInsight> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CandidateInsightCopyWith<$Res> {
  factory $CandidateInsightCopyWith(
          CandidateInsight value, $Res Function(CandidateInsight) then) =
      _$CandidateInsightCopyWithImpl<$Res, CandidateInsight>;
  @useResult
  $Res call(
      {String id,
      String template,
      double score,
      double weight,
      Map<String, dynamic> templateVars,
      DateTime timestamp,
      bool isUrgent});
}

/// @nodoc
class _$CandidateInsightCopyWithImpl<$Res, $Val extends CandidateInsight>
    implements $CandidateInsightCopyWith<$Res> {
  _$CandidateInsightCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CandidateInsight
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? template = null,
    Object? score = null,
    Object? weight = null,
    Object? templateVars = null,
    Object? timestamp = null,
    Object? isUrgent = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      template: null == template
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      templateVars: null == templateVars
          ? _value.templateVars
          : templateVars // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isUrgent: null == isUrgent
          ? _value.isUrgent
          : isUrgent // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CandidateInsightImplCopyWith<$Res>
    implements $CandidateInsightCopyWith<$Res> {
  factory _$$CandidateInsightImplCopyWith(_$CandidateInsightImpl value,
          $Res Function(_$CandidateInsightImpl) then) =
      __$$CandidateInsightImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String template,
      double score,
      double weight,
      Map<String, dynamic> templateVars,
      DateTime timestamp,
      bool isUrgent});
}

/// @nodoc
class __$$CandidateInsightImplCopyWithImpl<$Res>
    extends _$CandidateInsightCopyWithImpl<$Res, _$CandidateInsightImpl>
    implements _$$CandidateInsightImplCopyWith<$Res> {
  __$$CandidateInsightImplCopyWithImpl(_$CandidateInsightImpl _value,
      $Res Function(_$CandidateInsightImpl) _then)
      : super(_value, _then);

  /// Create a copy of CandidateInsight
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? template = null,
    Object? score = null,
    Object? weight = null,
    Object? templateVars = null,
    Object? timestamp = null,
    Object? isUrgent = null,
  }) {
    return _then(_$CandidateInsightImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      template: null == template
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      templateVars: null == templateVars
          ? _value._templateVars
          : templateVars // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isUrgent: null == isUrgent
          ? _value.isUrgent
          : isUrgent // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$CandidateInsightImpl extends _CandidateInsight {
  const _$CandidateInsightImpl(
      {required this.id,
      required this.template,
      required this.score,
      required this.weight,
      required final Map<String, dynamic> templateVars,
      required this.timestamp,
      this.isUrgent = false})
      : _templateVars = templateVars,
        super._();

  @override
  final String id;
  @override
  final String template;
  @override
  final double score;
  @override
  final double weight;
  final Map<String, dynamic> _templateVars;
  @override
  Map<String, dynamic> get templateVars {
    if (_templateVars is EqualUnmodifiableMapView) return _templateVars;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_templateVars);
  }

  @override
  final DateTime timestamp;
  @override
  @JsonKey()
  final bool isUrgent;

  @override
  String toString() {
    return 'CandidateInsight(id: $id, template: $template, score: $score, weight: $weight, templateVars: $templateVars, timestamp: $timestamp, isUrgent: $isUrgent)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CandidateInsightImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.template, template) ||
                other.template == template) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.weight, weight) || other.weight == weight) &&
            const DeepCollectionEquality()
                .equals(other._templateVars, _templateVars) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.isUrgent, isUrgent) ||
                other.isUrgent == isUrgent));
  }

  @override
  int get hashCode => Object.hash(runtimeType, id, template, score, weight,
      const DeepCollectionEquality().hash(_templateVars), timestamp, isUrgent);

  /// Create a copy of CandidateInsight
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CandidateInsightImplCopyWith<_$CandidateInsightImpl> get copyWith =>
      __$$CandidateInsightImplCopyWithImpl<_$CandidateInsightImpl>(
          this, _$identity);
}

abstract class _CandidateInsight extends CandidateInsight {
  const factory _CandidateInsight(
      {required final String id,
      required final String template,
      required final double score,
      required final double weight,
      required final Map<String, dynamic> templateVars,
      required final DateTime timestamp,
      final bool isUrgent}) = _$CandidateInsightImpl;
  const _CandidateInsight._() : super._();

  @override
  String get id;
  @override
  String get template;
  @override
  double get score;
  @override
  double get weight;
  @override
  Map<String, dynamic> get templateVars;
  @override
  DateTime get timestamp;
  @override
  bool get isUrgent;

  /// Create a copy of CandidateInsight
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CandidateInsightImplCopyWith<_$CandidateInsightImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BottomLineItem {
  String get headline => throw _privateConstructorUsedError;
  DateTime get timestamp => throw _privateConstructorUsedError;
  double get priority => throw _privateConstructorUsedError;
  String get sourceInsightId => throw _privateConstructorUsedError;
  bool get isUrgent => throw _privateConstructorUsedError;
  int get displayDurationSeconds => throw _privateConstructorUsedError;

  /// Create a copy of BottomLineItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BottomLineItemCopyWith<BottomLineItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BottomLineItemCopyWith<$Res> {
  factory $BottomLineItemCopyWith(
          BottomLineItem value, $Res Function(BottomLineItem) then) =
      _$BottomLineItemCopyWithImpl<$Res, BottomLineItem>;
  @useResult
  $Res call(
      {String headline,
      DateTime timestamp,
      double priority,
      String sourceInsightId,
      bool isUrgent,
      int displayDurationSeconds});
}

/// @nodoc
class _$BottomLineItemCopyWithImpl<$Res, $Val extends BottomLineItem>
    implements $BottomLineItemCopyWith<$Res> {
  _$BottomLineItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BottomLineItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? headline = null,
    Object? timestamp = null,
    Object? priority = null,
    Object? sourceInsightId = null,
    Object? isUrgent = null,
    Object? displayDurationSeconds = null,
  }) {
    return _then(_value.copyWith(
      headline: null == headline
          ? _value.headline
          : headline // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as double,
      sourceInsightId: null == sourceInsightId
          ? _value.sourceInsightId
          : sourceInsightId // ignore: cast_nullable_to_non_nullable
              as String,
      isUrgent: null == isUrgent
          ? _value.isUrgent
          : isUrgent // ignore: cast_nullable_to_non_nullable
              as bool,
      displayDurationSeconds: null == displayDurationSeconds
          ? _value.displayDurationSeconds
          : displayDurationSeconds // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BottomLineItemImplCopyWith<$Res>
    implements $BottomLineItemCopyWith<$Res> {
  factory _$$BottomLineItemImplCopyWith(_$BottomLineItemImpl value,
          $Res Function(_$BottomLineItemImpl) then) =
      __$$BottomLineItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String headline,
      DateTime timestamp,
      double priority,
      String sourceInsightId,
      bool isUrgent,
      int displayDurationSeconds});
}

/// @nodoc
class __$$BottomLineItemImplCopyWithImpl<$Res>
    extends _$BottomLineItemCopyWithImpl<$Res, _$BottomLineItemImpl>
    implements _$$BottomLineItemImplCopyWith<$Res> {
  __$$BottomLineItemImplCopyWithImpl(
      _$BottomLineItemImpl _value, $Res Function(_$BottomLineItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of BottomLineItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? headline = null,
    Object? timestamp = null,
    Object? priority = null,
    Object? sourceInsightId = null,
    Object? isUrgent = null,
    Object? displayDurationSeconds = null,
  }) {
    return _then(_$BottomLineItemImpl(
      headline: null == headline
          ? _value.headline
          : headline // ignore: cast_nullable_to_non_nullable
              as String,
      timestamp: null == timestamp
          ? _value.timestamp
          : timestamp // ignore: cast_nullable_to_non_nullable
              as DateTime,
      priority: null == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as double,
      sourceInsightId: null == sourceInsightId
          ? _value.sourceInsightId
          : sourceInsightId // ignore: cast_nullable_to_non_nullable
              as String,
      isUrgent: null == isUrgent
          ? _value.isUrgent
          : isUrgent // ignore: cast_nullable_to_non_nullable
              as bool,
      displayDurationSeconds: null == displayDurationSeconds
          ? _value.displayDurationSeconds
          : displayDurationSeconds // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BottomLineItemImpl extends _BottomLineItem {
  const _$BottomLineItemImpl(
      {required this.headline,
      required this.timestamp,
      required this.priority,
      required this.sourceInsightId,
      this.isUrgent = false,
      this.displayDurationSeconds = 18})
      : super._();

  @override
  final String headline;
  @override
  final DateTime timestamp;
  @override
  final double priority;
  @override
  final String sourceInsightId;
  @override
  @JsonKey()
  final bool isUrgent;
  @override
  @JsonKey()
  final int displayDurationSeconds;

  @override
  String toString() {
    return 'BottomLineItem(headline: $headline, timestamp: $timestamp, priority: $priority, sourceInsightId: $sourceInsightId, isUrgent: $isUrgent, displayDurationSeconds: $displayDurationSeconds)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BottomLineItemImpl &&
            (identical(other.headline, headline) ||
                other.headline == headline) &&
            (identical(other.timestamp, timestamp) ||
                other.timestamp == timestamp) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.sourceInsightId, sourceInsightId) ||
                other.sourceInsightId == sourceInsightId) &&
            (identical(other.isUrgent, isUrgent) ||
                other.isUrgent == isUrgent) &&
            (identical(other.displayDurationSeconds, displayDurationSeconds) ||
                other.displayDurationSeconds == displayDurationSeconds));
  }

  @override
  int get hashCode => Object.hash(runtimeType, headline, timestamp, priority,
      sourceInsightId, isUrgent, displayDurationSeconds);

  /// Create a copy of BottomLineItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BottomLineItemImplCopyWith<_$BottomLineItemImpl> get copyWith =>
      __$$BottomLineItemImplCopyWithImpl<_$BottomLineItemImpl>(
          this, _$identity);
}

abstract class _BottomLineItem extends BottomLineItem {
  const factory _BottomLineItem(
      {required final String headline,
      required final DateTime timestamp,
      required final double priority,
      required final String sourceInsightId,
      final bool isUrgent,
      final int displayDurationSeconds}) = _$BottomLineItemImpl;
  const _BottomLineItem._() : super._();

  @override
  String get headline;
  @override
  DateTime get timestamp;
  @override
  double get priority;
  @override
  String get sourceInsightId;
  @override
  bool get isUrgent;
  @override
  int get displayDurationSeconds;

  /// Create a copy of BottomLineItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BottomLineItemImplCopyWith<_$BottomLineItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
\n\n// ====== lib/domain/entities/bottom_line.dart ======\n
// domain/entities/bottom_line.dart
// ğŸ”¥ ë°”í…€ë¼ì¸ ì‹œìŠ¤í…œ - ëª¨ë“  Entity & Rule í†µí•©

import 'package:freezed_annotation/freezed_annotation.dart';
import '../entities/trade.dart';
import '../entities/volume.dart';
import '../entities/surge.dart';

part 'bottom_line.freezed.dart';
// part 'bottom_line.g.dart'; â† ì´ ë¼ì¸ ì œê±°

// ===== 1. ì‹œì¥ ìŠ¤ëƒ…ìƒ· Entity =====
@freezed
class MarketSnapshot with _$MarketSnapshot {
  const factory MarketSnapshot({
    required DateTime timestamp,
    required String timeFrame,
    required List<Trade> topTrades,           // â‰¥20M, ìµœê·¼ 50ê±´
    required List<Volume> topVolumes,         // í™œì„± ë§ˆì¼“ ìƒìœ„ 50ê°œ
    required List<Surge> surges,              // ë³€í™” ìˆëŠ” ì½”ì¸ë§Œ
    required List<Volume> sectorVolumes,      // ì£¼ìš” ì„¹í„° 10ê°œ
    required Map<String, double> volChangePct,    // ë³¼ë¥¨ ë³€í™”ìœ¨
    required Map<String, double> sectorShareDelta,    // ì„¹í„° ì ìœ ìœ¨ ë³€í™” (ìˆ˜ì •ë¨)
    required Map<String, double> priceDelta,          // ê°€ê²© ë³€í™”ìœ¨ (ìˆ˜ì •ë¨)
  }) = _MarketSnapshot;

  // factory MarketSnapshot.fromJson(Map<String, dynamic> json) => 
  //   _$MarketSnapshotFromJson(json); â† ì´ ë¼ì¸ë“¤ ì œê±°

  const MarketSnapshot._();

  // ë¸íƒ€ ê³„ì‚° í—¬í¼
  static MarketSnapshot create({
    required List<Trade> trades,
    required List<Volume> volumes,
    required List<Surge> surges,
    required List<Volume> sectors,
    MarketSnapshot? previousSnapshot,
  }) {
    final now = DateTime.now();
    
    // ë³¼ë¥¨ ë³€í™”ìœ¨ ê³„ì‚°
    final volChangePct = <String, double>{};
    if (previousSnapshot != null) {
      for (final vol in volumes) {
        final prevVol = previousSnapshot.topVolumes
          .where((p) => p.market == vol.market)
          .firstOrNull;
        if (prevVol != null && prevVol.totalVolume > 0) {
          volChangePct[vol.market] = 
            ((vol.totalVolume - prevVol.totalVolume) / prevVol.totalVolume) * 100;
        }
      }
    }

    // ì„¹í„° ì ìœ ìœ¨ ë³€í™” ê³„ì‚°
    final sectorShareDelta = <String, double>{};
    final totalVolume = volumes.fold<double>(0, (sum, v) => sum + v.totalVolume);
    if (previousSnapshot != null && totalVolume > 0) {
      for (final sector in sectors) {
        final currentShare = (sector.totalVolume / totalVolume) * 100;
        final prevTotalVol = previousSnapshot.topVolumes
          .fold<double>(0, (sum, v) => sum + v.totalVolume);
        if (prevTotalVol > 0) {
          final prevSector = previousSnapshot.sectorVolumes
            .where((s) => s.market == sector.market)
            .firstOrNull;
          if (prevSector != null) {
            final prevShare = (prevSector.totalVolume / prevTotalVol) * 100;
            sectorShareDelta[sector.market] = currentShare - prevShare;
          }
        }
      }
    }

    // ê°€ê²© ë³€í™”ìœ¨ ê³„ì‚°
    final priceDelta = <String, double>{};
    for (final surge in surges) {
      priceDelta[surge.ticker] = surge.changePercent;
    }

    return MarketSnapshot(
      timestamp: now,
      timeFrame: 'min5', // ê¸°ë³¸ê°’
      topTrades: trades.take(50).toList(),
      topVolumes: volumes.take(50).toList(),
      surges: surges,
      sectorVolumes: sectors.take(10).toList(),
      volChangePct: volChangePct,
      sectorShareDelta: sectorShareDelta,
      priceDelta: priceDelta,
    );
  }

  // ìŠ¤ëƒ…ìƒ· í•´ì‹œ (ìºì‹±ìš©)
  String get hash {
    final content = [
      timestamp.millisecondsSinceEpoch,
      topTrades.length,
      topVolumes.length,
      surges.length,
      sectorVolumes.length,
    ].join('-');
    return content.hashCode.toString();
  }
}

// ===== 2. í›„ë³´ ì¸ì‚¬ì´íŠ¸ Entity =====
@freezed
class CandidateInsight with _$CandidateInsight {
  const factory CandidateInsight({
    required String id,
    required String template,
    required double score,
    required double weight,
    required Map<String, dynamic> templateVars,
    required DateTime timestamp,
    @Default(false) bool isUrgent,
  }) = _CandidateInsight;

  // factory CandidateInsight.fromJson(Map<String, dynamic> json) => 
  //   _$CandidateInsightFromJson(json); â† ì´ ë¼ì¸ë“¤ë„ ì œê±°

  const CandidateInsight._();

  // ìµœì¢… ì ìˆ˜ (ê°€ì¤‘ì¹˜ ì ìš©)
  double get finalScore => score * weight;

  // ê¸´ê¸‰ ì—¬ë¶€ íŒë‹¨ (ì ìˆ˜ 2.5 ì´ìƒ)
  bool get isHighPriority => finalScore >= 2.5;

  // í…œí”Œë¦¿ ë³€ìˆ˜ ì ìš©
  String get populatedTemplate {
    String result = template;
    templateVars.forEach((key, value) {
      result = result.replaceAll('{$key}', value.toString());
    });
    return result;
  }
}

// ===== 3. ë°”í…€ë¼ì¸ ì•„ì´í…œ Entity =====
@freezed
class BottomLineItem with _$BottomLineItem {
  const factory BottomLineItem({
    required String headline,
    required DateTime timestamp,
    required double priority,
    required String sourceInsightId,
    @Default(false) bool isUrgent,
    @Default(18) int displayDurationSeconds,
  }) = _BottomLineItem;

  // factory BottomLineItem.fromJson(Map<String, dynamic> json) => 
  //   _$BottomLineItemFromJson(json); â† ì´ ë¼ì¸ë“¤ë„ ì œê±°

  const BottomLineItem._();

  // AI ìƒì„±ìš© íŒ©í† ë¦¬
  factory BottomLineItem.fromInsight({
    required String headline,
    required CandidateInsight insight,
  }) {
    return BottomLineItem(
      headline: headline,
      timestamp: DateTime.now(),
      priority: insight.finalScore,
      sourceInsightId: insight.id,
      isUrgent: insight.isHighPriority,
    );
  }

  // í‘œì‹œ ìˆœì„œ ë¹„êµ (ìš°ì„ ìˆœìœ„ ë†’ì€ ìˆœ)
  int compareTo(BottomLineItem other) {
    if (isUrgent != other.isUrgent) {
      return isUrgent ? -1 : 1; // ê¸´ê¸‰í•œ ê²ƒì´ ë¨¼ì €
    }
    return other.priority.compareTo(priority); // ë†’ì€ ì ìˆ˜ê°€ ë¨¼ì €
  }
}

// ===== 4. ì¸ì‚¬ì´íŠ¸ ë£° ì‹œìŠ¤í…œ =====
abstract class InsightRule {
  String get id;
  String get template;
  double get weight;
  
  bool canTrigger(MarketSnapshot snapshot);
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot);
  
  // ì ìˆ˜ ê³„ì‚°
  double calculateScore(MarketSnapshot snapshot) {
    if (!canTrigger(snapshot)) return 0.0;
    
    final vars = getTemplateVars(snapshot);
    
    // ê¸°ë³¸ ì ìˆ˜ ê³„ì‚° (ê°€ê²©ë³€í™”^0.3 + ë³¼ë¥¨Z-score^0.25 + ê³ ì•¡ê±°ë˜^0.25 + ì„¹í„°ë³€í™”^0.2)
    double score = 0.0;
    
    // ê°€ê²© ë³€í™” ìš”ì†Œ
    final priceChange = (vars['price_change'] as double?) ?? 0.0;
    score += (priceChange.abs() / 100).clamp(0.0, 1.0) * 0.3;
    
    // ë³¼ë¥¨ ìš”ì†Œ
    final volumeChange = (vars['volume_change'] as double?) ?? 0.0;
    score += (volumeChange.abs() / 500).clamp(0.0, 1.0) * 0.25;
    
    // ê³ ì•¡ê±°ë˜ ìš”ì†Œ
    final largeTradeCount = (vars['large_trade_count'] as int?) ?? 0;
    score += (largeTradeCount / 5).clamp(0.0, 1.0) * 0.25;
    
    // ì„¹í„° ë³€í™” ìš”ì†Œ
    final sectorChange = (vars['sector_change'] as double?) ?? 0.0;
    score += (sectorChange.abs() / 10).clamp(0.0, 1.0) * 0.2;
    
    return score * weight;
  }

  // ì¸ì‚¬ì´íŠ¸ ìƒì„±
  CandidateInsight? generateInsight(MarketSnapshot snapshot) {
    final score = calculateScore(snapshot);
    if (score < 1.0) return null; // ì„ê³„ê°’ ë¯¸ë‹¬
    
    return CandidateInsight(
      id: '${id}_${snapshot.timestamp.millisecondsSinceEpoch}',
      template: template,
      score: score,
      weight: weight,
      templateVars: getTemplateVars(snapshot),
      timestamp: snapshot.timestamp,
      isUrgent: score >= 2.5,
    );
  }
}

// ===== 5. êµ¬ì²´ì ì¸ ë£° êµ¬í˜„ë“¤ =====

// ìŠ¤ë§ˆíŠ¸ë¨¸ë‹ˆ ë£° (ê³ ì•¡ê±°ë˜ íŒ¨í„´)
class SmartMoneyRule extends InsightRule {
  @override
  String get id => 'smart_money';
  
  @override
  String get template => 'ğŸ”¥ {market} {count}ê±´ ëŒ€í˜•ë§¤ìˆ˜ íƒì§€ Â· ì´ {amount}ì–µì›';
  
  @override
  double get weight => 1.0;
  
  @override
  bool canTrigger(MarketSnapshot snapshot) {
    final largeTrades = snapshot.topTrades
      .where((t) => t.total >= 20000000) // 2ì²œë§Œì› ì´ìƒ
      .toList();
    
    // ê³ ì•¡ê±°ë˜ 3ê±´ ì´ìƒ + ë™ì¼ ë§ˆì¼“ ë³¼ë¥¨ ê¸‰ì¦
    if (largeTrades.length < 3) return false;
    
    final markets = largeTrades.map((t) => t.market).toSet();
    for (final market in markets) {
      final marketTrades = largeTrades.where((t) => t.market == market).length;
      final volumeChange = snapshot.volChangePct[market] ?? 0.0;
      if (marketTrades >= 3 && volumeChange > 50) return true;
    }
    
    return false;
  }
  
  @override
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot) {
    final largeTrades = snapshot.topTrades
      .where((t) => t.total >= 20000000)
      .toList();
    
    final marketGroups = <String, List<Trade>>{};
    for (final trade in largeTrades) {
      marketGroups.putIfAbsent(trade.market, () => []).add(trade);
    }
    
    // ê°€ì¥ í™œë°œí•œ ë§ˆì¼“ ì„ íƒ
    String topMarket = '';
    int maxCount = 0;
    double totalAmount = 0;
    
    for (final entry in marketGroups.entries) {
      if (entry.value.length > maxCount) {
        maxCount = entry.value.length;
        topMarket = entry.key;
        totalAmount = entry.value.fold(0, (sum, t) => sum + t.total);
      }
    }
    
    return {
      'market': topMarket,
      'count': maxCount,
      'amount': (totalAmount / 100000000).toStringAsFixed(1), // ì–µì› ë‹¨ìœ„
      'large_trade_count': maxCount,
      'volume_change': snapshot.volChangePct[topMarket] ?? 0.0,
      'price_change': snapshot.priceDelta[topMarket] ?? 0.0,
      'sector_change': 0.0,
    };
  }
}

// ë³¼ë¥¨ ê¸‰ì¦ ë£°
class VolumeSpikeRule extends InsightRule {
  @override
  String get id => 'volume_spike';
  
  @override
  String get template => 'âš¡ {market} ê±°ë˜ëŸ‰ {change}%â†‘ Â· í‰ì†Œ ëŒ€ë¹„ {multiplier}ë°°';
  
  @override
  double get weight => 0.8;
  
  @override
  bool canTrigger(MarketSnapshot snapshot) {
    return snapshot.volChangePct.values.any((change) => change > 200);
  }
  
  @override
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot) {
    final maxEntry = snapshot.volChangePct.entries
      .reduce((a, b) => a.value > b.value ? a : b);
    
    final multiplier = (maxEntry.value / 100 + 1).toStringAsFixed(1);
    
    return {
      'market': maxEntry.key,
      'change': maxEntry.value.toStringAsFixed(0),
      'multiplier': multiplier,
      'volume_change': maxEntry.value,
      'price_change': snapshot.priceDelta[maxEntry.key] ?? 0.0,
      'large_trade_count': 0,
      'sector_change': 0.0,
    };
  }
}

// ì—°ì‡„ ê¸‰ë“± ë£°
class SurgeChainRule extends InsightRule {
  @override
  String get id => 'surge_chain';
  
  @override
  String get template => 'ğŸ”— {theme} í…Œë§ˆ ì—°ì‡„ ê¸‰ë“± {count}ì¢… Â· í‰ê·  +{avg_change}%';
  
  @override
  double get weight => 0.7;
  
  @override
  bool canTrigger(MarketSnapshot snapshot) {
    final surgingCoins = snapshot.surges
      .where((s) => s.changePercent > 10)
      .toList();
    
    return surgingCoins.length >= 3;
  }
  
  @override
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot) {
    final surgingCoins = snapshot.surges
      .where((s) => s.changePercent > 10)
      .toList();
    
    final avgChange = surgingCoins.isEmpty ? 0.0 :
      surgingCoins.map((s) => s.changePercent).reduce((a, b) => a + b) / surgingCoins.length;
    
    return {
      'theme': 'ì—°ê´€ì½”ì¸', // TODO: ì‹¤ì œ í…Œë§ˆ ë¶„ë¥˜ ë¡œì§
      'count': surgingCoins.length,
      'avg_change': avgChange.toStringAsFixed(1),
      'volume_change': 0.0,
      'price_change': avgChange,
      'large_trade_count': 0,
      'sector_change': 0.0,
    };
  }
}

// ì„¹í„° ë¡œí…Œì´ì…˜ ë£°
class SectorRotationRule extends InsightRule {
  @override
  String get id => 'sector_rotation';
  
  @override
  String get template => 'ğŸ’« {sector} ì„¹í„° ì ìœ ìœ¨ +{change}%p Â· ìê¸ˆ ìœ ì… ê°ì§€';
  
  @override
  double get weight => 0.8;
  
  @override
  bool canTrigger(MarketSnapshot snapshot) {
    return snapshot.sectorShareDelta.values.any((change) => change > 7);
  }
  
  @override
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot) {
    final maxEntry = snapshot.sectorShareDelta.entries
      .reduce((a, b) => a.value > b.value ? a : b);
    
    return {
      'sector': maxEntry.key,
      'change': maxEntry.value.toStringAsFixed(1),
      'volume_change': 0.0,
      'price_change': 0.0,
      'large_trade_count': 0,
      'sector_change': maxEntry.value,
    };
  }
}

// í´ë°± ë£° (ë¹ˆ í ë°©ì§€)
class FallbackRule extends InsightRule {
  @override
  String get id => 'fallback';
  
  @override
  String get template => 'ğŸ’° {market} ì‹œì¥ í™œë°œ Â· ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì¤‘';
  
  @override
  double get weight => 0.3; // ë‚®ì€ ê°€ì¤‘ì¹˜
  
  @override
  bool canTrigger(MarketSnapshot snapshot) {
    // ê³ ì•¡ê±°ë˜ê°€ 1ê±´ ì´ìƒ ìˆìœ¼ë©´ ë¬´ì¡°ê±´ íŠ¸ë¦¬ê±°
    return snapshot.topTrades.isNotEmpty;
  }
  
  @override
  Map<String, dynamic> getTemplateVars(MarketSnapshot snapshot) {
    final topTrade = snapshot.topTrades.isNotEmpty 
      ? snapshot.topTrades.first 
      : null;
    
    return {
      'market': topTrade?.market ?? 'BTC',
      'volume_change': 0.0,
      'price_change': 0.0,
      'large_trade_count': snapshot.topTrades.length,
      'sector_change': 0.0,
    };
  }
}

// ===== 6. ë£° ë ˆì§€ìŠ¤íŠ¸ë¦¬ =====
class RuleRegistry {
  static final List<InsightRule> allRules = [
    SmartMoneyRule(),
    VolumeSpikeRule(),
    SurgeChainRule(),
    SectorRotationRule(),
    FallbackRule(),
  ];
  
  // íŠ¹ì • ìŠ¤ëƒ…ìƒ·ì— ëŒ€í•´ ëª¨ë“  ë£° ì‹¤í–‰
  static List<CandidateInsight> generateInsights(MarketSnapshot snapshot) {
    final insights = <CandidateInsight>[];
    
    for (final rule in allRules) {
      final insight = rule.generateInsight(snapshot);
      if (insight != null) {
        insights.add(insight);
      }
    }
    
    // ì ìˆ˜ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬
    insights.sort((a, b) => b.finalScore.compareTo(a.finalScore));
    
    // ìƒìœ„ 5ê°œë§Œ ë°˜í™˜ (AI í˜¸ì¶œ ë¹„ìš© ì ˆì•½)
    return insights.take(5).toList();
  }
  
  // ê¸´ê¸‰ ì¸ì‚¬ì´íŠ¸ í•„í„°
  static List<CandidateInsight> getUrgentInsights(List<CandidateInsight> insights) {
    return insights.where((i) => i.isHighPriority).toList();
  }
  
  // ë£° ì„±ëŠ¥ í†µê³„ (ë””ë²„ê¹…ìš©)
  static Map<String, int> getRuleStats(List<CandidateInsight> insights) {
    final stats = <String, int>{};
    for (final insight in insights) {
      final ruleId = insight.id.split('_').first;
      stats[ruleId] = (stats[ruleId] ?? 0) + 1;
    }
    return stats;
  }
}\n\n// ====== lib/presentation/widgets/bottom_line_widget.dart ======\n
