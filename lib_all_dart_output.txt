\n\n// ====== lib/core/di/trade_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../services/hive_service.dart';          // ğŸ¯ NEW
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider; // ğŸ†• WebSocket import
import '../../data/datasources/trade_cache_ds.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// ğŸ†• ë§ˆì¼“ ì •ë³´ í´ë˜ìŠ¤
class MarketInfo {
  final String market;      // KRW-BTC
  final String koreanName;  // ë¹„íŠ¸ì½”ì¸
  final String englishName; // Bitcoin

  const MarketInfo({
    required this.market,
    required this.koreanName,
    required this.englishName,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      market: json['market'] ?? '',
      koreanName: json['korean_name'] ?? '',
      englishName: json['english_name'] ?? '',
    );
  }
}

/// 0) REST API client
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient(
      apiKey: AppConfig.apiKey,
      apiSecret: AppConfig.apiSecret,
    ));

/// ğŸ¯ HiveService Provider (main.dartì—ì„œ override)
final hiveServiceProvider = Provider<HiveService>((ref) {
  throw UnimplementedError('HiveService must be provided via main.dart override');
});

/// ğŸ†• ë§ˆì¼“ ì •ë³´ Provider (1ì‹œê°„ ìºì‹œ + market_warning í•„í„°ë§)
final marketInfoProvider = FutureProvider<Map<String, MarketInfo>>((ref) async {
  final client = ref.read(apiClientProvider);
  
  try {
    final result = await client.request<List<dynamic>>(
      method: 'GET',
      path: '${AppConfig.upbitRestBase}/market/all',
      cacheDur: const Duration(hours: 1), // 1ì‹œê°„ ìºì‹œ
    );
    
    return result.when(
      ok: (markets) {
        final Map<String, MarketInfo> marketMap = {};
        int filteredCount = 0;
        
        for (final market in markets) {
          if (market is Map<String, dynamic>) {
            // ğŸ”’ market_warning í•„í„°ë§ (ì—…ë¹„íŠ¸ ë°±ì„œ ì¤€ìˆ˜)
            final warning = market['market_warning'] as String?;
            if (warning == 'CAUTION') {
              filteredCount++;
              if (AppConfig.enableTradeLog) {
                log.d('Filtered CAUTION market: ${market['market']}');
              }
              continue; // CAUTION ì¢…ëª©ì€ ê±´ë„ˆë›°ê¸°
            }
            
            final info = MarketInfo.fromJson(market);
            marketMap[info.market] = info;
          }
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('ë§ˆì¼“ ì •ë³´ ë¡œë“œë¨: ${marketMap.length}ê°œ (CAUTION í•„í„°ë§: $filteredCountê°œ)');
        }
        return marketMap;
      },
      err: (error) {
        log.w('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: $error');
        return <String, MarketInfo>{};
      },
    );
  } catch (e) {
    log.e('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e');
    return <String, MarketInfo>{};
  }
});

/// 1) KRW market list (top 199 by volume + essentials) + market_warning í•„í„°ë§
final marketsProvider = FutureProvider<List<String>>((ref) async {
  final client = ref.read(apiClientProvider);

  // fetch all markets (cache 5 minutes)
  final marketResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/market/all',
    cacheDur: const Duration(minutes: 5),
  );
  final allMarkets =
      marketResult.when(ok: (v) => v, err: (_) => <dynamic>[]);

  // ğŸ”’ filter KRW markets + market_warning í•„í„°ë§ (ì—…ë¹„íŠ¸ ë°±ì„œ ì¤€ìˆ˜)
  final krwMarkets = <String>[];
  int cautionCount = 0;
  
  for (final market in allMarkets.whereType<Map<String, dynamic>>()) {
    final marketCode = market['market'] as String?;
    if (marketCode != null && marketCode.startsWith('KRW-')) {
      // CAUTION ì¢…ëª©ì€ WebSocket êµ¬ë…ì—ì„œ ì œì™¸
      final warning = market['market_warning'] as String?;
      if (warning == 'CAUTION') {
        cautionCount++;
        continue;
      }
      krwMarkets.add(marketCode);
    }
  }
  
  if (AppConfig.enableTradeLog && cautionCount > 0) {
    log.i('CAUTION ì¢…ëª© $cautionCountê°œ ì œì™¸ë¨ (WebSocket êµ¬ë… ì•ˆì „ì„±)');
  }

  // pick top by 24h volume (or acc_trade_price when outside 9â€“10am)
  final now = DateTime.now();
  final isEarly = now.hour >= 9 && now.hour < 10;
  final key = isEarly ? 'acc_trade_price_24h' : 'acc_trade_price';

  // real-time ticker lookup (no cache)
  final tickerResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/ticker',
    query: {'markets': krwMarkets.join(',')},
    cacheDur: null,
  );
  final tickers = tickerResult
      .when(ok: (v) => v, err: (_) => <dynamic>[])  
      .whereType<Map<String, dynamic>>()
      .toList()
    ..sort((a, b) =>
        ((b[key] as num?) ?? 0).compareTo((a[key] as num?) ?? 0));

  // â”€â”€â”€ WS êµ¬ë… ì¢…ëª© ìŠ¬ë¼ì´ì‹± ë¡œì§ (essentials ìš°ì„  + ì¤‘ë³µ ì œê±° í›„ ìƒìœ„ 199ê°œ) â”€â”€â”€
  const essentials = ['KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL'];
  final sortedMarkets = tickers.map((e) => e['market'] as String).toList();
  final combined = [
    ...essentials.where((market) => krwMarkets.contains(market)), // ğŸ”’ essentialsë„ CAUTION ì²´í¬
    ...sortedMarkets.where((m) => !essentials.contains(m)),
  ];
  return combined.take(199).toList();
});

final cacheDSProvider = Provider<TradeCacheDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return TradeCacheDataSource(hive.tradeBox);
});

final remoteDSProvider = Provider((ref) => TradeRemoteDataSource(
      ref.read(wsClientProvider), // ğŸ”„ websocket_providerì—ì„œ import
      ref.read(signalBusProvider),
      useTestData: AppConfig.useTestDataInDev,
    ));

final repoProvider = Provider((ref) => TradeRepositoryImpl(
      ref.read(remoteDSProvider),
      ref.read(cacheDSProvider),
    ));

final usecaseProvider = Provider((ref) => TradeUsecase(ref.read(repoProvider)));

/// 3) Filter state
final tradeFilterIndexProvider = StateProvider<int>((_) => 0);
final tradeFilterThresholdProvider = StateProvider<double>((ref) =>
    AppConfig.tradeFilters.firstWhere(
      (f) => f >= 20000000,
      orElse: () => AppConfig.tradeFilters.last,
    ));

/// 4) Filtered trades stream
final tradeListProvider = StreamProvider.autoDispose<List<Trade>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ threshold ê°’ê³¼ marketsë¥¼ ì½ì–´ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  final threshold = ref.watch(tradeFilterThresholdProvider);
  final markets = await ref.watch(marketsProvider.future);
  final repository = ref.read(repoProvider);

  // threshold ë³€ê²½ ì‹œ Repositoryì—ë„ ì—…ë°ì´íŠ¸
  ref.listen<double>(tradeFilterThresholdProvider, (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i(
          'Threshold changed: ${prev.toStringAsFixed(0)} â†’ ${next.toStringAsFixed(0)}',
        );
      }
      repository.updateThreshold(next);
    }
  });

  // ì‹¤ì œ í•„í„°ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchFilteredTrades(threshold, markets);
});

/// 5) Aggregated trades stream
final aggregatedTradeProvider = StreamProvider.autoDispose<Trade>((ref) {
  // Prevent dispose on background
  ref.keepAlive();
  final repository = ref.read(repoProvider);
  return repository.watchAggregatedTrades();
});

/// 6) Helper to change threshold & index
final tradeThresholdController = Provider((ref) => TradeThresholdController(ref));

class TradeThresholdController {
  final Ref ref;
  TradeThresholdController(this.ref);

  void updateThreshold(double threshold, int index) {
    final options =
        AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    if (index < 0 || index >= options.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid threshold index: $index');
      return;
    }
    ref.read(tradeFilterThresholdProvider.notifier).state = threshold;
    ref.read(tradeFilterIndexProvider.notifier).state = index;
    AppConfig.updateFilters(options);
    if (AppConfig.enableTradeLog) {
      log.i(
        'Threshold updated: ${threshold.toStringAsFixed(0)} (index: $index)',
      );
    }
  }

  double get currentThreshold => ref.read(tradeFilterThresholdProvider);
  int get currentIndex => ref.read(tradeFilterIndexProvider);
  List<double> get availableThresholds =>
      AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
}\n\n// ====== lib/core/di/websocket_provider.dart ======\n
// lib/core/di/websocket_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../network/websocket/trade_ws_client.dart';
import '../network/websocket/base_ws_client.dart'; // WsStatus enum
import '../utils/logger.dart';
import '../bridge/signal_bus.dart';

/// ğŸ†• WebSocket ìƒì„¸ í†µê³„ í´ë˜ìŠ¤ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸° ì¤‘ì‹¬)
class WebSocketStats {
  final DateTime? connectTime;
  final int reconnectCount;
  final int totalSessions;
  final Duration cumulativeConnectTime;
  final int connectionAttempts;
  final DateTime? lastStateChangeTime;
  
  const WebSocketStats({
    this.connectTime,
    this.reconnectCount = 0,
    this.totalSessions = 0,
    this.cumulativeConnectTime = Duration.zero,
    this.connectionAttempts = 0,
    this.lastStateChangeTime,
  });

  /// ì—°ê²° ì§€ì† ì‹œê°„ ê³„ì‚°
  Duration? get uptime {
    if (connectTime == null) return null;
    return DateTime.now().difference(connectTime!);
  }

  /// í‰ê·  ì—°ê²° ì§€ì† ì‹œê°„
  Duration get averageSessionDuration {
    if (totalSessions == 0) return Duration.zero;
    return Duration(
      milliseconds: cumulativeConnectTime.inMilliseconds ~/ totalSessions,
    );
  }

  /// ì—°ê²° ì„±ê³µë¥  (%)
  double get connectionSuccessRate {
    if (connectionAttempts == 0) return 0.0;
    return (totalSessions / connectionAttempts) * 100;
  }
}

/// ğŸ”„ SignalBus Provider (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});

/// ğŸ†• WebSocket ìƒíƒœ ê´€ë¦¬
final wsStatusProvider = StateProvider<WsStatus>((ref) => WsStatus.disconnected);

/// ğŸ†• WebSocket í†µê³„ ê´€ë¦¬ (ê°œë³„ Providerë“¤ - ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
final wsConnectTimeProvider = StateProvider<DateTime?>((ref) => null);
final wsReconnectCountProvider = StateProvider<int>((ref) => 0);
final wsTotalSessionsProvider = StateProvider<int>((ref) => 0);
final wsCumulativeConnectTimeProvider = StateProvider<Duration>((ref) => Duration.zero);
final wsConnectionAttemptsProvider = StateProvider<int>((ref) => 0);
final wsLastStateChangeTimeProvider = StateProvider<DateTime?>((ref) => null);

/// ğŸ†• í†µí•© WebSocket í†µê³„ Provider (ê°œë³„ Providerë“¤ì„ ì¡°í•©)
final wsStatsProvider = Provider<WebSocketStats>((ref) {
  final connectTime = ref.watch(wsConnectTimeProvider);
  final reconnectCount = ref.watch(wsReconnectCountProvider);
  final totalSessions = ref.watch(wsTotalSessionsProvider);
  final cumulativeConnectTime = ref.watch(wsCumulativeConnectTimeProvider);
  final connectionAttempts = ref.watch(wsConnectionAttemptsProvider);
  final lastStateChangeTime = ref.watch(wsLastStateChangeTimeProvider);

  return WebSocketStats(
    connectTime: connectTime,
    reconnectCount: reconnectCount,
    totalSessions: totalSessions,
    cumulativeConnectTime: cumulativeConnectTime,
    connectionAttempts: connectionAttempts,
    lastStateChangeTime: lastStateChangeTime,
  );
});

/// ğŸ†• WebSocket í´ë¼ì´ì–¸íŠ¸ (ê¸°ë³¸ - ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
final wsClientProvider = Provider<TradeWsClient>((ref) {
  return TradeWsClient(
    onStatusChange: (status) {
      final now = DateTime.now();
      ref.read(wsStatusProvider.notifier).state = status;
      ref.read(wsLastStateChangeTimeProvider.notifier).state = now;
      
      // ê°„ë‹¨í•œ í†µê³„ ì—…ë°ì´íŠ¸ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
      switch (status) {
        case WsStatus.connecting:
          // ì—°ê²° ì‹œë„ ì¹´ìš´íŠ¸
          final attempts = ref.read(wsConnectionAttemptsProvider);
          ref.read(wsConnectionAttemptsProvider.notifier).state = attempts + 1;
          break;
          
        case WsStatus.connected:
          // ì—°ê²° ì„±ê³µ
          ref.read(wsConnectTimeProvider.notifier).state = now;
          
          // ì´ ì„¸ì…˜ ìˆ˜ ì¦ê°€
          final sessions = ref.read(wsTotalSessionsProvider);
          ref.read(wsTotalSessionsProvider.notifier).state = sessions + 1;
          break;
          
        case WsStatus.reconnecting:
          // ì¬ì—°ê²° ì¹´ìš´íŠ¸
          final currentCount = ref.read(wsReconnectCountProvider);
          ref.read(wsReconnectCountProvider.notifier).state = currentCount + 1;
          break;
          
        case WsStatus.disconnected:
          // ì—°ê²° ì¢…ë£Œ ì‹œ ëˆ„ì  ì‹œê°„ ì—…ë°ì´íŠ¸
          final connectTime = ref.read(wsConnectTimeProvider);
          if (connectTime != null) {
            final sessionDuration = now.difference(connectTime);
            final cumulative = ref.read(wsCumulativeConnectTimeProvider);
            ref.read(wsCumulativeConnectTimeProvider.notifier).state = 
                cumulative + sessionDuration;
          }
          ref.read(wsConnectTimeProvider.notifier).state = null;
          break;
          
        default:
          break;
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('WebSocket status changed: $status');
      }
    },
  );
});\n\n// ====== lib/core/di/signal_provider.dart ======\n
// lib/core/di/signal_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import '../utils/pattern_detector.dart';
import '../utils/pattern_config.dart';
import '../utils/advanced_metrics.dart';
import 'trade_provider.dart'; // ì „ì²´ import (app_providers.dart íŒ¨í„´)
import '../../data/repositories/signal_repository_impl.dart';
import '../../domain/entities/signal.dart';
import '../../domain/repositories/signal_repository.dart';
import '../../domain/usecases/signal_usecase.dart';

// ==========================================================================
// ğŸš€ V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì… êµ¬ì¡°
// ==========================================================================

/// AdvancedMetrics Provider (ì˜¨ë¼ì¸ ê³„ì‚°ê¸° ê´€ë¦¬)
final advancedMetricsProvider = Provider<AdvancedMetrics>((ref) {
  final metrics = AdvancedMetrics(
    maxGap: const Duration(seconds: 10),     // ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ì‹œê°„
    staleThreshold: const Duration(seconds: 30), // ë°ì´í„° ë§Œë£Œ ì‹œê°„
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() {
    metrics.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ AdvancedMetrics disposed - ì˜¨ë¼ì¸ ì§€í‘œ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return metrics;
});

/// PatternConfig Provider (ìƒíƒœ ê´€ë¦¬ ê°€ëŠ¥)
final patternConfigProvider = StateNotifierProvider<PatternConfigNotifier, PatternConfig>((ref) {
  return PatternConfigNotifier();
});

/// PatternDetector Provider (ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì…)
final patternDetectorProvider = Provider<PatternDetector>((ref) {
  final config = ref.watch(patternConfigProvider);
  final metrics = ref.watch(advancedMetricsProvider);
  
  final detector = PatternDetector(
    config: config,
    metrics: metrics,
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() {
    detector.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ PatternDetector disposed - ì¿¨ë‹¤ìš´ ë° ì§€í‘œ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return detector;
});

/// Signal Repository Provider (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì…)
final signalRepoProvider = Provider<SignalRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider);
  final patternDetector = ref.watch(patternDetectorProvider);
  final patternConfig = ref.watch(patternConfigProvider);
  
  final repository = SignalRepositoryImpl(
    remoteDS,
    patternDetector: patternDetector,
    patternConfig: patternConfig,
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ SignalRepository V4.1 disposed - ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return repository;
});

/// Signal UseCase Provider
final signalUsecaseProvider = Provider<SignalUseCase>((ref) {
  final repository = ref.read(signalRepoProvider);
  return SignalUseCase(repository);
});

// ==========================================================================
// ğŸ¯ ìƒíƒœ ê´€ë¦¬ Providers (V4.1 í™•ì¥)
// ==========================================================================

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ ì¸ë±ìŠ¤ (ìŠ¬ë¼ì´ë” ìœ„ì¹˜)
final signalPatternIndexProvider = StateProvider<int>((_) => 0);

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ íƒ€ì…
final signalPatternTypeProvider = StateProvider<PatternType>((ref) {
  final index = ref.watch(signalPatternIndexProvider);
  final patternName = AppConfig.getSignalPatternByIndex(index);
  
  // AppConfig íŒ¨í„´ëª…ì„ PatternTypeìœ¼ë¡œ ë³€í™˜
  switch (patternName) {
    case 'surge':
      return PatternType.surge;
    case 'flashFire':
      return PatternType.flashFire;
    case 'stackUp':
      return PatternType.stackUp;
    case 'stealthIn':
      return PatternType.stealthIn;
    case 'blackHole':
      return PatternType.blackHole;
    case 'reboundShot':
      return PatternType.reboundShot;
    default:
      return PatternType.surge; // ê¸°ë³¸ê°’
  }
});

/// íŒ¨í„´ë³„ ì„ê³„ê°’ ê´€ë¦¬ (V4.1 PatternConfig ê¸°ë°˜)
final signalThresholdProvider = StateProvider.family<double, PatternType>((ref, pattern) {
  final config = ref.watch(patternConfigProvider);
  return config.getConfigValue(pattern, 'priceChangePercent');
});

/// íŒ¨í„´ë³„ í™œì„±í™” ìƒíƒœ ê´€ë¦¬
final signalPatternEnabledProvider = StateProvider.family<bool, PatternType>((ref, pattern) => true);

/// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§
final onlineMetricsHealthProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final metrics = ref.watch(advancedMetricsProvider);
  
  yield* Stream.periodic(const Duration(seconds: 5), (_) {
    return metrics.getSystemHealth();
  });
});

/// ğŸ†• ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
final systemPerformanceProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final repository = ref.watch(signalRepoProvider) as SignalRepositoryImpl;
  
  yield* repository.watchPerformanceMetrics();
});

// ==========================================================================
// ğŸ”¥ ìŠ¤íŠ¸ë¦¼ Providers (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
// ==========================================================================

/// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
final signalListProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ ì„ íƒëœ íŒ¨í„´ê³¼ ë§ˆì¼“ ì •ë³´ êµ¬ë…
  final patternType = ref.watch(signalPatternTypeProvider);
  final repository = ref.read(signalRepoProvider);

  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);

  // íŒ¨í„´ ë³€ê²½ ì‹œ ë¡œê·¸
  if (AppConfig.enableTradeLog) {
    log.i('ğŸ¯ Signal pattern changed to: ${patternType.displayName} (V4.1-Online)');
  }

  // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ëª¨ë‹ˆí„°ë§
  ref.listen(onlineMetricsHealthProvider, (prev, next) {
    if (next.hasValue) {
      final health = next.value!;
      final staleMarkets = health['staleMarkets'] ?? 0;
      if (staleMarkets > 0 && AppConfig.enableTradeLog) {
        log.w('âš ï¸ ì˜¨ë¼ì¸ ì§€í‘œ ê²½ê³ : $staleMarketsê°œ ë§ˆì¼“ ë°ì´í„° ë§Œë£Œ');
      }
    }
  });

  // ì„ê³„ê°’ ë³€ê²½ ê°ì§€ ë° Repository ì—…ë°ì´íŠ¸
  ref.listen<double>(signalThresholdProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“Š Signal threshold changed: ${patternType.displayName} ${prev.toStringAsFixed(2)} â†’ ${next.toStringAsFixed(2)}');
      }
      repository.updatePatternThreshold(patternType, next);
    }
  });

  // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ë³€ê²½ ê°ì§€
  ref.listen<bool>(signalPatternEnabledProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Signal pattern ${next ? "enabled" : "disabled"}: ${patternType.displayName}');
      }
      repository.setPatternEnabled(patternType, next);
    }
  });

  // íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchSignalsByPattern(patternType, markets);
});

/// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ í†µí•© ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
final allSignalsProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent dispose on background
  ref.keepAlive();
  
  final repository = ref.read(signalRepoProvider);
  
  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.i('ğŸš€ All signals stream initialized with ${markets.length} markets (V4.1-Online)');
  }
  
  yield* repository.watchAllSignals(markets);
});

// ==========================================================================
// ğŸ› ï¸ PatternConfig StateNotifier (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì„¤ì • ê´€ë¦¬)
// ==========================================================================

class PatternConfigNotifier extends StateNotifier<PatternConfig> {
  PatternConfigNotifier() : super(PatternConfig());

  /// íŠ¹ì • íŒ¨í„´ì˜ ì„¤ì •ê°’ ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    try {
      state.updatePatternConfig(pattern, key, value);
      // ìƒíƒœ ê°±ì‹ ì„ ìœ„í•´ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Pattern config updated: ${pattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Pattern config update failed: $e');
      }
    }
  }

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    try {
      switch (presetName.toLowerCase()) {
        case 'conservative':
          state.applyConservativePreset();
          break;
        case 'aggressive':
          state.applyAggressivePreset();
          break;
        case 'balanced':
          state.applyBalancedPreset();
          break;
        default:
          throw ArgumentError('Unknown preset: $presetName');
      }
      
      // ìƒíƒœ ê°±ì‹ 
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Pattern preset applied: $presetName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Preset application failed: $e');
      }
    }
  }

  /// ì„¤ì • ê°€ì ¸ì˜¤ê¸°/ë‚´ë³´ë‚´ê¸°
  void importConfig(Map<String, dynamic> config) {
    try {
      state.importConfig(config);
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“¥ Pattern config imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Config import failed: $e');
      }
    }
  }

  Map<String, dynamic> exportConfig() {
    return state.exportConfig();
  }

  /// ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  void resetToDefault([PatternType? pattern]) {
    state.resetToDefault(pattern);
    state = PatternConfig(customConfig: state.getAllPatternConfigs());
    
    if (AppConfig.enableTradeLog) {
      final message = pattern != null 
          ? 'Pattern ${pattern.name} reset to default'
          : 'All patterns reset to default';
      log.i('ğŸ”„ $message');
    }
  }
}

// ==========================================================================
// ğŸ® Signal íŒ¨í„´ ì»¨íŠ¸ë¡¤ëŸ¬ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥)
// ==========================================================================

final signalPatternController = Provider((ref) => SignalPatternControllerV4(ref));

class SignalPatternControllerV4 {
  final Ref ref;
  SignalPatternControllerV4(this.ref);

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™)
  void updatePatternIndex(int index) {
    final maxIndex = AppConfig.signalPatterns.length - 1;
    if (index < 0 || index > maxIndex) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ Invalid pattern index: $index (max: $maxIndex)');
      }
      return;
    }

    ref.read(signalPatternIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      final patternName = AppConfig.getSignalPatternByIndex(index);
      log.i('ğŸ¯ Pattern index updated: $index (${AppConfig.getSignalPatternName(patternName)})');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½ (V4.1 PatternConfig ì—°ë™)
  void updateThreshold(double threshold) {
    final currentPattern = ref.read(signalPatternTypeProvider);
    
    // PatternConfigì—ë„ ë°˜ì˜
    ref.read(patternConfigProvider.notifier)
        .updatePatternConfig(currentPattern, 'priceChangePercent', threshold);
    
    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(signalThresholdProvider(currentPattern).notifier).state = threshold;
  }

  /// ğŸ†• V4.1 ê³ ê¸‰ ì„¤ì • ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    ref.read(patternConfigProvider.notifier).updatePatternConfig(pattern, key, value);
  }

  /// ğŸ†• í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    ref.read(patternConfigProvider.notifier).applyPreset(presetName);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™”
  void setPatternEnabled(PatternType pattern, bool enabled) {
    ref.read(signalPatternEnabledProvider(pattern).notifier).state = enabled;
  }

  /// ì‹œê·¸ë„ ì´ˆê¸°í™”
  void clearSignals([PatternType? pattern]) {
    final repository = ref.read(signalRepoProvider);
    repository.clearSignals(pattern);
    
    if (AppConfig.enableTradeLog) {
      final message = pattern != null 
          ? 'Signals cleared for pattern: ${pattern.displayName}'
          : 'All signals cleared';
      log.i('ğŸ§¹ $message');
    }
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
  void resetOnlineMetrics([String? market]) {
    final metrics = ref.read(advancedMetricsProvider);
    
    if (market != null) {
      metrics.resetMarket(market);
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Online metrics reset for market: $market');
      }
    } else {
      metrics.resetAll();
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ All online metrics reset');
      }
    }
  }

  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth() async {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return await repository.getSystemHealth();
  }

  /// ğŸ†• V4.1 íŒ¨í„´ë³„ í†µê³„ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<Map<String, dynamic>> getPatternStats(PatternType pattern) async {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return await repository.getPatternStats(pattern);
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getOnlineMetricsHealth() {
    final metricsHealth = ref.read(onlineMetricsHealthProvider);
    return metricsHealth.when(
      data: (health) => health,
      loading: () => {'status': 'loading'},
      error: (error, stack) => {'status': 'error', 'message': error.toString()},
    );
  }

  /// ğŸ†• V4.1 ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  Map<String, dynamic> exportConfiguration() {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return repository.exportConfiguration();
  }

  void importConfiguration(Map<String, dynamic> config) {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    repository.importConfiguration(config);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ“¥ Configuration imported successfully');
    }
  }

  /// í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  int get currentIndex => ref.read(signalPatternIndexProvider);
  PatternType get currentPattern => ref.read(signalPatternTypeProvider);
  double get currentThreshold => ref.read(signalThresholdProvider(currentPattern));
  bool get isCurrentPatternEnabled => ref.read(signalPatternEnabledProvider(currentPattern));

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ì •ë³´
  List<String> get availablePatterns => AppConfig.signalPatterns;
  List<String> get patternDisplayNames => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternName(p)).toList();
  List<String> get patternDescriptions => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternDescription(p)).toList();

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ ì¡°íšŒ (PatternConfig ê¸°ë°˜)
  double getDefaultThreshold(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getConfigValue(pattern, 'priceChangePercent');
  }

  /// V4.1 íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ì¡°íšŒ
  Duration getCooldownDuration(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getCooldownDuration(pattern);
  }

  /// V4.1 íŒ¨í„´ ì„¤ì • ì „ì²´ ì¡°íšŒ
  Map<String, double> getPatternConfig(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getPatternConfig(pattern);
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° ì¡°íšŒ (ê¸°ì¡´ í˜¸í™˜ì„±)
  int getTimeWindow(PatternType pattern) {
    final patternName = _getPatternConfigName(pattern);
    return AppConfig.getSignalTimeWindow(patternName);
  }

  /// íŒ¨í„´ í†µê³„ ì¡°íšŒ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥)
  Map<String, dynamic> getPatternStatsOverview() {
    final allSignals = ref.read(allSignalsProvider).value ?? [];
    final patternCounts = <PatternType, int>{};
    
    for (final signal in allSignals) {
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ì¶”ê°€
    final onlineHealth = getOnlineMetricsHealth();
    
    return {
      'totalSignals': allSignals.length,
      'patternCounts': patternCounts,
      'lastUpdate': allSignals.isNotEmpty ? allSignals.first.detectedAt : null,
      'version': '4.1-Online',
      'onlineMetrics': onlineHealth,
    };
  }

  /// ğŸ†• V4.1 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìŠ¤íŠ¸ë¦¼
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return repository.watchPerformanceMetrics();
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ëª¨ë‹ˆí„°ë§ ìŠ¤íŠ¸ë¦¼
  Stream<Map<String, dynamic>> watchOnlineMetricsHealth() {
    return Stream.periodic(const Duration(seconds: 5), (_) {
      final metrics = ref.read(advancedMetricsProvider);
      return metrics.getSystemHealth();
    });
  }
}

/// Helper function: PatternTypeì„ AppConfig íŒ¨í„´ëª…ìœ¼ë¡œ ë³€í™˜
String _getPatternConfigName(PatternType pattern) {
  switch (pattern) {
    case PatternType.surge:
      return 'surge';
    case PatternType.flashFire:
      return 'flashFire';
    case PatternType.stackUp:
      return 'stackUp';
    case PatternType.stealthIn:
      return 'stealthIn';
    case PatternType.blackHole:
      return 'blackHole';
    case PatternType.reboundShot:
      return 'reboundShot';
  }
}

// ==========================================================================
// ğŸ” ê°œë°œììš© ë””ë²„ê¹… Providers
// ==========================================================================

/// ğŸ†• ë””ë²„ê¹…ìš© Provider - ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ
final debugSystemStatusProvider = FutureProvider.autoDispose<Map<String, dynamic>>((ref) async {
  final controller = ref.watch(signalPatternController);
  final systemHealth = await controller.getSystemHealth();
  final onlineHealth = controller.getOnlineMetricsHealth();
  
  return {
    'timestamp': DateTime.now().toIso8601String(),
    'version': 'V4.1-Online-Debug',
    'systemHealth': systemHealth,
    'onlineMetrics': onlineHealth,
    'currentPattern': controller.currentPattern.name,
    'activeProviders': {
      'advancedMetrics': 'active',
      'patternDetector': 'active', 
      'signalRepository': 'active',
      'patternConfig': 'active',
    },
  };
});

/// Repository dispose ê´€ë¦¬ (V4.1)
final signalRepositoryDisposeProvider = Provider.autoDispose<SignalRepository>((ref) {
  final repository = ref.watch(signalRepoProvider);
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal repository V4.1 disposed - ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ì™„ì „ ì •ë¦¬');
    }
  });
  
  return repository;
});\n\n// ====== lib/core/di/sector_provider.dart ======\n
// lib/core/di/sector_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'volume_provider.dart' show volumeUsecaseProvider;
import 'trade_provider.dart' show marketsProvider;
import '../../domain/entities/volume.dart';
import '../../shared/widgets/sector_classification.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• SECTOR ì „ìš© Providerë“¤ (SectorClassificationProvider ì—°ë™)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ†• ì„¹í„° ë¶„ë¥˜ Provider (SectorClassificationProvider ì—°ë™)
final sectorClassificationProvider = ChangeNotifierProvider<SectorClassificationProvider>(
  (ref) => SectorClassificationProvider(),
);

/// ğŸ†• ì„¹í„° ì‹œê°„ëŒ€ ìƒíƒœ (ë³¼ë¥¨ê³¼ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬)
final sectorTimeFrameIndexProvider = StateProvider<int>((ref) => 0);

final sectorTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(sectorTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m';
});

/// ğŸ†• ì„¹í„°ë³„ ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (SectorClassificationProvider í™œìš©)
final sectorVolumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
  ref.keepAlive();

  try {
    final timeFrame = ref.watch(sectorTimeFrameProvider);
    final usecase = ref.read(volumeUsecaseProvider);
    
    // markets AsyncValue ì²˜ë¦¬
    final marketsAsync = ref.watch(marketsProvider);
    final markets = marketsAsync.when(
      data: (data) => data,
      loading: () => <String>[],
      error: (_, __) => <String>[],
    );

    if (markets.isEmpty) {
      yield <Volume>[];
      return;
    }

    if (AppConfig.enableTradeLog) {
      log.i('Sector volume stream started: $timeFrame, ${markets.length} markets');
    }

    // ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ ë³€í™˜
    yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (coinVolumes) {
          // SectorClassificationProviderì—ì„œ í˜„ì¬ ì„¹í„° ë§¤í•‘ ê°€ì ¸ì˜¤ê¸°
          final sectorProvider = ref.read(sectorClassificationProvider);
          final sectorMapping = sectorProvider.currentSectors;
          
          final sectorVolumes = _aggregateVolumesBySector(coinVolumes, sectorMapping);
          
          if (AppConfig.enableTradeLog) {
            log.d('Sector volumes aggregated: ${sectorVolumes.length} sectors from ${coinVolumes.length} coins');
          }
          
          return sectorVolumes;
        },
        err: (error) {
          log.e('Sector Volume error: ${error.message}');
          return <Volume>[];
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Sector volume stream error: $e', e, stackTrace);
    yield <Volume>[];
  }
});

/// ğŸ¯ í•µì‹¬ ë¡œì§: ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ í•©ì‚°
List<Volume> _aggregateVolumesBySector(List<Volume> coinVolumes, Map<String, List<String>> sectorMapping) {
  if (coinVolumes.isEmpty) return [];
  
  final Map<String, double> sectorVolumeMap = {};
  final sampleVolume = coinVolumes.first;
  
  // ê° ì½”ì¸ì„ í•´ë‹¹ ì„¹í„°ì— í•©ì‚°
  for (final coinVolume in coinVolumes) {
    final ticker = coinVolume.market.replaceFirst('KRW-', '');
    final sectors = _findSectorsForCoin(ticker, sectorMapping);
    
    for (final sector in sectors) {
      sectorVolumeMap[sector] = (sectorVolumeMap[sector] ?? 0.0) + coinVolume.totalVolume;
    }
  }
  
  // ë³¼ë¥¨ì´ 0ì¸ ì„¹í„° ì œê±°
  sectorVolumeMap.removeWhere((key, value) => value <= 0);
  
  // Volume ê°ì²´ë¡œ ë³€í™˜
  final sectorVolumes = sectorVolumeMap.entries
      .map((entry) => Volume(
            market: 'SECTOR-${entry.key}', // ì„¹í„° êµ¬ë¶„ìš© prefix
            totalVolume: entry.value,
            lastUpdatedMs: sampleVolume.lastUpdatedMs,
            timeFrame: sampleVolume.timeFrame,
            timeFrameStartMs: sampleVolume.timeFrameStartMs,
          ))
      .toList();
  
  // ë³¼ë¥¨ ìˆœ ì •ë ¬ (ë†’ì€ ìˆœ)
  sectorVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
  return sectorVolumes;
}

/// ğŸ¯ íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì°¾ê¸°
List<String> _findSectorsForCoin(String ticker, Map<String, List<String>> sectorMapping) {
  final sectors = <String>[];
  sectorMapping.forEach((sectorName, coins) {
    if (coins.contains(ticker)) {
      sectors.add(sectorName);
    }
  });
  return sectors;
}

/// ğŸ†• ì„¹í„° ì»¨íŠ¸ë¡¤ëŸ¬
final sectorTimeFrameController = Provider((ref) => SectorTimeFrameController(ref));

class SectorTimeFrameController {
  final Ref ref;
  SectorTimeFrameController(this.ref);

  /// ì‹œê°„ëŒ€ ë³€ê²½
  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid sector timeFrame index: $index');
      return;
    }
    
    ref.read(sectorTimeFrameProvider.notifier).state = timeFrame;
    ref.read(sectorTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Sector TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ğŸ†• ì„¹í„° ë¶„ë¥˜ í† ê¸€ (SectorClassificationProvider ì—°ë™)
  void toggleSectorClassification() {
    ref.read(sectorClassificationProvider.notifier).toggleClassificationType();
    
    if (AppConfig.enableTradeLog) {
      final currentName = ref.read(sectorClassificationProvider).currentClassificationName;
      log.i('Sector classification toggled: $currentName');
    }
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€ ì •ë³´
  String get currentTimeFrame => ref.read(sectorTimeFrameProvider);
  int get currentIndex => ref.read(sectorTimeFrameIndexProvider);
  
  /// í˜„ì¬ ì„¹í„° ë¶„ë¥˜ ì •ë³´ (SectorClassificationProvider ì—°ë™)
  bool get isDetailedClassification => ref.read(sectorClassificationProvider).isDetailedClassification;
  String get currentSectorClassificationName => ref.read(sectorClassificationProvider).currentClassificationName;
  int get totalSectors => ref.read(sectorClassificationProvider).currentSectors.length;
  
  /// ê¸°ë³¸ ì •ë³´
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }

  /// ğŸ†• ì„¹í„° ê´€ë ¨ ìœ í‹¸ë¦¬í‹° (SectorClassificationProvider ì—°ë™)
  Map<String, int> getSectorSizes() {
    return ref.read(sectorClassificationProvider).sectorSizes;
  }

  List<String> getCoinsInSector(String sectorName) {
    return ref.read(sectorClassificationProvider).getCoinsInSector(sectorName);
  }

  List<String> getSectorsForCoin(String ticker) {
    return ref.read(sectorClassificationProvider).getSectorsForCoin(ticker);
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (ë³¼ë¥¨ UseCase ì¬ì‚¬ìš©)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Sector volume reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(volumeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Sector volume reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get sector reset time failed: ${error.message}');
        return null;
      },
    );
  }
}\n\n// ====== lib/core/di/app_providers.dart ======\n
// lib/core/di/app_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../bridge/signal_bus.dart';

/// â–¶ App lifecycle
export '../utils/app_life_cycle_manager.dart'
    show appLifecycleManagerProvider;

/// â–¶ Settings DI + state
export 'settings_provider.dart'
    show
        sharedPreferencesProvider,
        settingsLocalDSProvider,
        settingsRepositoryProvider,
        settingsUsecaseProvider,
        appSettingsProvider;

/// â–¶ Domain entities
export '../../domain/entities/app_settings.dart'
    show
        DisplayMode,
        SliderPosition;

/// â–¶ WebSocket DI & stats
export 'websocket_provider.dart'
    show
        wsStatusProvider,
        wsClientProvider,
        wsStatsProvider,
        WebSocketStats;

/// â–¶ Trade DI & streams
export 'trade_provider.dart';

/// â–¶ Trade í™”ë©´ ë¡œì§
export '../../presentation/controllers/trade_controller.dart'
    show tradeControllerProvider;

/// â–¶ Volume DI & streams
export 'volume_provider.dart'
    show
        volumeRemoteDSProvider,
        volumeRepositoryProvider,
        volumeUsecaseProvider,
        volumeTimeFrameIndexProvider,
        volumeTimeFrameProvider,
        volumeDataProvider,
        volumeTimeFrameController;

/// â–¶ Volume í™”ë©´ ë¡œì§
export '../../presentation/controllers/volume_controller.dart'
    show volumeControllerProvider;

/// â–¶ Sector DI & streams
export 'sector_provider.dart'
    show
        sectorClassificationProvider,
        sectorTimeFrameIndexProvider,
        sectorTimeFrameProvider,
        sectorVolumeDataProvider,
        sectorTimeFrameController;

/// â–¶ Sector í™”ë©´ ë¡œì§
export '../../presentation/controllers/sector_controller.dart'
    show sectorControllerProvider;

/// â–¶ Signal DI & streams (V4.1 Online)
export 'signal_provider.dart'
    show
        // ğŸ”¥ V4.1 ì˜ì¡´ì„± ì£¼ì…
        advancedMetricsProvider,
        patternConfigProvider,
        patternDetectorProvider,
        signalRepoProvider,
        signalUsecaseProvider,
        
        // ğŸ¯ ìƒíƒœ ê´€ë¦¬
        signalPatternIndexProvider,
        signalPatternTypeProvider,
        signalThresholdProvider,
        signalPatternEnabledProvider,
        
        // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
        signalListProvider,
        allSignalsProvider,
        
        // ğŸ†• V4.1 ëª¨ë‹ˆí„°ë§
        onlineMetricsHealthProvider,
        systemPerformanceProvider,
        
        // ğŸ® V4.1 ì»¨íŠ¸ë¡¤ëŸ¬
        signalPatternController,
        SignalPatternControllerV4,
        
        // ğŸ› ï¸ StateNotifier
        PatternConfigNotifier,
        
        // ğŸ” ë””ë²„ê¹…
        debugSystemStatusProvider;

/// â–¶ Signal í™”ë©´ ë¡œì§
export '../../presentation/controllers/signal_controller.dart'
    show signalControllerProvider;

/// â–¶ Market Mood DI & streams
export 'market_mood_provider.dart'
    show
        coinGeckoApiClientProvider,
        marketMoodRemoteDSProvider,
        marketMoodLocalDSProvider,
        marketMoodRepositoryProvider,
        marketMoodUsecaseProvider,
        exchangeRateProvider,
        marketMoodProvider,
        marketMoodComputedDataProvider, // UIì—ì„œ ë¡œë”©/ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬ë¥¼ ìœ„í•´ export
        volumeComparisonProvider,
        currentMarketMoodProvider,
        marketMoodSummaryProvider,
        marketMoodSystemProvider,
        marketMoodControllerProvider,
        MarketMoodComputedData;

/// â–¶ Market Mood Domain Entities
export '../../domain/entities/market_mood.dart'
    show
        MarketMood,
        VolumeData,
        MarketMoodData,
        ComparisonResult,
        ComparisonData,
        MarketMoodSystemState,
        VolumeConstants;

/// â–¶ Sector ë¶„ë¥˜ ê´€ë¦¬ (shared layer)
export '../../shared/widgets/sector_classification.dart'
    show SectorClassificationProvider;

/// â–¶ ì „ì—­ SnackBar key
final scaffoldMessengerKeyProvider =
    Provider<GlobalKey<ScaffoldMessengerState>>((ref) {
  return GlobalKey<ScaffoldMessengerState>();
});

/// â–¶ BottomTab ì¸ë±ìŠ¤
final selectedTabProvider = StateProvider<int>((ref) => 0);

/// â–¶ SignalBus ì‹±ê¸€í„´
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});\n\n// ====== lib/core/di/notification_provider.dart ======\n
// lib/core/di/notification_provider.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../utils/logger.dart';
import 'app_providers.dart'; // scaffoldMessengerKeyProvider

/// ğŸ”” ì•Œë¦¼ íƒ€ì… enum
enum NotificationType {
  trade,       // ì²´ê²° ì•Œë¦¼
  priceAlert,  // ê°€ê²© ì•Œë¦¼  
  volume,      // ê±°ë˜ëŸ‰ ì•Œë¦¼
  surge,       // ê¸‰ë“±ë½ ì•Œë¦¼
  system,      // ì‹œìŠ¤í…œ ì•Œë¦¼
}

/// ğŸ”” ì•Œë¦¼ ìƒíƒœ enum  
enum NotificationStatus {
  unread,      // ì½ì§€ ì•ŠìŒ
  read,        // ì½ìŒ
  archived,    // ë³´ê´€ë¨
}

/// ğŸ”” ì•Œë¦¼ ë°ì´í„° ëª¨ë¸ (ì„ì‹œ)
class NotificationData {
  final String id;
  final String title;
  final String message;
  final NotificationType type;
  final NotificationStatus status;
  final DateTime createdAt;
  final Map<String, dynamic>? extra;

  const NotificationData({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    this.status = NotificationStatus.unread,
    required this.createdAt,
    this.extra,
  });

  NotificationData copyWith({
    NotificationStatus? status,
    Map<String, dynamic>? extra,
  }) {
    return NotificationData(
      id: id,
      title: title,
      message: message,
      type: type,
      status: status ?? this.status,
      createdAt: createdAt,
      extra: extra ?? this.extra,
    );
  }
}

/// ğŸ”” ì•Œë¦¼ ëª©ë¡ Provider
final notificationListProvider = StateProvider<List<NotificationData>>((ref) => []);

/// ğŸ”” ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
final unreadNotificationCountProvider = Provider<int>((ref) {
  final notifications = ref.watch(notificationListProvider);
  return notifications.where((n) => n.status == NotificationStatus.unread).length;
});

/// ğŸ”” ì•Œë¦¼ í•„í„° Provider
final notificationFilterProvider = StateProvider<NotificationType?>((ref) => null);

/// ğŸ”” í•„í„°ëœ ì•Œë¦¼ ëª©ë¡
final filteredNotificationProvider = Provider<List<NotificationData>>((ref) {
  final notifications = ref.watch(notificationListProvider);
  final filter = ref.watch(notificationFilterProvider);
  
  if (filter == null) return notifications;
  return notifications.where((n) => n.type == filter).toList();
});

/// ğŸ”” ì•Œë¦¼ ê´€ë¦¬ ì„œë¹„ìŠ¤
final notificationServiceProvider = Provider((ref) => NotificationService(ref));

/// ì•Œë¦¼ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// ğŸ†• Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (AppRouterì—ì„œ ì´ë™ë¨)
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // ì•±ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // ì•Œë¦¼ Providerì— ì €ì¥
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBarë¡œë„ í‘œì‹œ
        if (messenger != null) {
          messenger
            ..hideCurrentSnackBar()
            ..showSnackBar(SnackBar(content: Text('${n.title}: ${n.body}')));
        }
      }
    });
    
    // ì•±ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ ì•Œë¦¼ í´ë¦­í•´ì„œ ì•± ì‹œì‘
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          addNotification(
            title: n.title ?? 'ì•Œë¦¼',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆì„ ë•Œ ì•Œë¦¼ í´ë¦­
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    log.i('ğŸ”” Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
  }

  /// Firebase ë©”ì‹œì§€ ë°ì´í„°ë¡œë¶€í„° ì•Œë¦¼ íƒ€ì… ì¶”ë¡ 
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }
  
  /// Firebase ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('ğŸ§¹ Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¨');
  }
  
  /// ì•Œë¦¼ ì¶”ê°€
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('ğŸ”” ì•Œë¦¼ ì¶”ê°€: $title');
  }
  
  /// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ì•Œë¦¼ ì½ìŒ: $notificationId');
  }
  
  /// ì•Œë¦¼ ì œê±°
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ—‘ï¸ ì•Œë¦¼ ì œê±°: $notificationId');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì œê±°
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('ğŸ§¹ ëª¨ë“  ì•Œë¦¼ ì œê±°');
  }
  
  /// í•„í„° ì„¤ì •
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('ğŸ” ì•Œë¦¼ í•„í„°: ${type?.name ?? "ì „ì²´"}');
  }
  
  /// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
// lib/core/di/volume_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import 'trade_provider.dart' show marketsProvider; // ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ì¬ì‚¬ìš©
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart'; // ğŸ†• UseCase import
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import ì¶”ê°€!


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• VOLUME ì „ìš© Providerë“¤ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ¯ ë³¼ë¥¨ ì „ìš© RemoteDataSource (TradeRemoteDataSourceì™€ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤)
final volumeRemoteDSProvider = Provider<TradeRemoteDataSource>((ref) {
 return TradeRemoteDataSource(
   ref.read(wsClientProvider),
   ref.read(signalBusProvider),
   useTestData: AppConfig.useTestDataInDev,
 );
});

/// ğŸ†• VolumeRepository
final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
 return VolumeRepositoryImpl(
   ref.read(volumeRemoteDSProvider),
 );
});

/// ğŸ†• VolumeUsecase
final volumeUsecaseProvider = Provider<VolumeUsecase>((ref) {
 return VolumeUsecase(
   ref.read(volumeRepositoryProvider),
 );
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ìƒíƒœ (ê¸°ë³¸ê°’: 1ë¶„)
final volumeTimeFrameIndexProvider = StateProvider<int>((_) => 0); // 1ë¶„ì´ ê¸°ë³¸ (0:1m, 1:5m, 2:15m)

final volumeTimeFrameProvider = StateProvider<String>((ref) {
 final index = ref.watch(volumeTimeFrameIndexProvider);
 final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 if (index >= 0 && index < timeFrames.length) {
   return timeFrames[index];
 }
 return '1m'; // fallback (ê¸°ë³¸ê°’ 1ë¶„)
});

/// ğŸš€ ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (100ms ë°°ì¹˜ ì—…ë°ì´íŠ¸)
final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
 // Prevent immediate dispose on loss of listeners
 ref.keepAlive();

 try {
   // í˜„ì¬ ì‹œê°„ëŒ€ì™€ marketsë¥¼ ì½ì–´ì„œ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
   final timeFrame = ref.watch(volumeTimeFrameProvider);
   final markets = await ref.watch(marketsProvider.future);
   final usecase = ref.read(volumeUsecaseProvider); // ğŸ†• UseCase ì‚¬ìš©

   if (AppConfig.enableTradeLog) {
     log.i('Volume stream started: $timeFrame, ${markets.length} markets');
   }

   // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ëœ ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ (UseCaseë¥¼ í†µí•´)
   yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
     return result.when(
       ok: (volumes) => volumes,
       err: (error) {
         log.e('Volume UseCase error: ${error.message}');
         return <Volume>[]; // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
       },
     );
   });
   
 } catch (e, stackTrace) {
   log.e('Volume stream error: $e', e, stackTrace);
   
   // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
   yield <Volume>[];
 }
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ì»¨íŠ¸ë¡¤ëŸ¬
final volumeTimeFrameController = Provider((ref) => VolumeTimeFrameController(ref));

class VolumeTimeFrameController {
 final Ref ref;
 VolumeTimeFrameController(this.ref);

 void updateTimeFrame(String timeFrame, int index) {
   final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
   if (index < 0 || index >= timeFrames.length) {
     if (AppConfig.enableTradeLog) log.w('Invalid timeFrame index: $index');
     return;
   }
   
   ref.read(volumeTimeFrameProvider.notifier).state = timeFrame;
   ref.read(volumeTimeFrameIndexProvider.notifier).state = index;
   
   if (AppConfig.enableTradeLog) {
     log.i('Volume TimeFrame updated: $timeFrame (index: $index)');
   }
 }

 /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (UseCaseë¥¼ í†µí•´)
 void resetCurrentTimeFrame() {
   final usecase = ref.read(volumeUsecaseProvider);
   final timeFrame = ref.read(volumeTimeFrameProvider);
   
   final result = usecase.resetTimeFrame(timeFrame);
   result.when(
     ok: (_) {
       if (AppConfig.enableTradeLog) {
         log.i('Volume reset: $timeFrame');
       }
     },
     err: (error) {
       log.e('Volume reset failed: ${error.message}');
     },
   );
 }

 void resetAllTimeFrames() {
   final usecase = ref.read(volumeUsecaseProvider);
   
   final result = usecase.resetAllTimeFrames();
   result.when(
     ok: (_) {
       if (AppConfig.enableTradeLog) {
         log.i('Volume reset: all timeframes');
       }
     },
     err: (error) {
       log.e('Volume reset all failed: ${error.message}');
     },
   );
 }

 /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ (UseCaseë¥¼ í†µí•´)
 DateTime? getNextResetTime() {
   final usecase = ref.read(volumeUsecaseProvider);
   final timeFrame = ref.read(volumeTimeFrameProvider);
   
   final result = usecase.getNextResetTime(timeFrame);
   return result.when(
     ok: (resetTime) => resetTime,
     err: (error) {
       log.e('Get reset time failed: ${error.message}');
       return null;
     },
   );
 }

 /// Getters
 String get currentTimeFrame => ref.read(volumeTimeFrameProvider);
 int get currentIndex => ref.read(volumeTimeFrameIndexProvider);
 List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 
 /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
 String getTimeFrameName(String timeFrame) {
   final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
   return AppConfig.timeFrameNames[minutes] ?? timeFrame;
 }
}\n\n// ====== lib/core/di/market_mood_provider copy.dart ======\n
\n\n// ====== lib/core/di/surge_provider.dart ======\n
// lib/core/di/surge_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import 'trade_provider.dart' show marketsProvider; // ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ì¬ì‚¬ìš©
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/surge_repository_impl.dart';
import '../../domain/repositories/surge_repository.dart';
import '../../domain/usecases/surge_usecase.dart'; // ğŸ†• UseCase import
import '../../domain/entities/surge.dart'; // ğŸ†• Surge ì—”í‹°í‹° import ì¶”ê°€!

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ SURGE ì „ìš© Providerë“¤ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ¯ ê¸‰ë“±/ê¸‰ë½ ì „ìš© RemoteDataSource (TradeRemoteDataSourceì™€ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤)
final surgeRemoteDSProvider = Provider<TradeRemoteDataSource>((ref) {
  return TradeRemoteDataSource(
    ref.read(wsClientProvider),
    ref.read(signalBusProvider),
    useTestData: AppConfig.useTestDataInDev,
  );
});

/// ğŸš€ SurgeRepository
final surgeRepositoryProvider = Provider<SurgeRepository>((ref) {
  return SurgeRepositoryImpl(
    ref.read(surgeRemoteDSProvider),
  );
});

/// ğŸš€ SurgeUsecase
final surgeUsecaseProvider = Provider<SurgeUsecase>((ref) {
  return SurgeUsecase(
    ref.read(surgeRepositoryProvider),
  );
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì‹œê°„ëŒ€ ìƒíƒœ (ê¸°ë³¸ê°’: 1ë¶„)
final surgeTimeFrameIndexProvider = StateProvider<int>((_) => 0); // 1ë¶„ì´ ê¸°ë³¸ (0:1m, 1:5m, 2:15m)

final surgeTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(surgeTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m'; // fallback (ê¸°ë³¸ê°’ 1ë¶„)
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (ì‹¤ì‹œê°„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
final surgeDataProvider = StreamProvider.autoDispose<List<Surge>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  try {
    // í˜„ì¬ ì‹œê°„ëŒ€ì™€ marketsë¥¼ ì½ì–´ì„œ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    final timeFrame = ref.watch(surgeTimeFrameProvider);
    final markets = await ref.watch(marketsProvider.future);
    final usecase = ref.read(surgeUsecaseProvider); // ğŸš€ UseCase ì‚¬ìš©

    if (AppConfig.enableTradeLog) {
      log.i('Surge stream started: $timeFrame, ${markets.length} markets');
    }

    // ğŸš€ ì‹¤ì‹œê°„ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ (UseCaseë¥¼ í†µí•´)
    yield* usecase.getSurgeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (surges) => surges,
        err: (error) {
          log.e('Surge UseCase error: ${error.message}');
          return <Surge>[]; // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Surge stream error: $e', e, stackTrace);
    
    // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
    yield <Surge>[];
  }
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì‹œê°„ëŒ€ ì»¨íŠ¸ë¡¤ëŸ¬
final surgeTimeFrameController = Provider((ref) => SurgeTimeFrameController(ref));

class SurgeTimeFrameController {
  final Ref ref;
  SurgeTimeFrameController(this.ref);

  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid timeFrame index: $index');
      return;
    }
    
    ref.read(surgeTimeFrameProvider.notifier).state = timeFrame;
    ref.read(surgeTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Surge TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (UseCaseë¥¼ í†µí•´)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(surgeUsecaseProvider);
    final timeFrame = ref.read(surgeTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Surge reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Surge reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(surgeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Surge reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Surge reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ (UseCaseë¥¼ í†µí•´)
  DateTime? getNextResetTime() {
    final usecase = ref.read(surgeUsecaseProvider);
    final timeFrame = ref.read(surgeTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get reset time failed: ${error.message}');
        return null;
      },
    );
  }

  /// Getters
  String get currentTimeFrame => ref.read(surgeTimeFrameProvider);
  int get currentIndex => ref.read(surgeTimeFrameIndexProvider);
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }
}\n\n// ====== lib/core/di/market_mood_provider.dart ======\n
// lib/core/di/market_mood_provider.dart
// ğŸš€ Performance Optimized Provider - ë©”ëª¨ì´ì œì´ì…˜, ë°°ì¹˜ì²˜ë¦¬, ì„ íƒì  ë¬´íš¨í™”, ì£¼ê¸°ì  ê°±ì‹  ì ìš©

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart'; // ğŸš€ debounceTime, distinctUntilChanged
import 'dart:async';

import '../network/api_client_coingecko.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show hiveServiceProvider;
import '../../data/datasources/market_mood_remote_ds.dart';
import '../../data/datasources/market_mood_local_ds.dart';
import '../../data/repositories/market_mood_repository_impl.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/usecases/market_mood_usecase.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸ Provider
final coinGeckoApiClientProvider = Provider<CoinGeckoApiClient>((ref) {
  return CoinGeckoApiClient();
});

/// ğŸ”¥ Remote DataSource Provider
final marketMoodRemoteDSProvider = Provider<MarketMoodRemoteDataSource>((ref) {
  final client = ref.read(coinGeckoApiClientProvider);
  return MarketMoodRemoteDataSource(client);
});

/// ğŸ”¥ Local DataSource Provider
final marketMoodLocalDSProvider = Provider<MarketMoodLocalDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return MarketMoodLocalDataSource(hive);
});

/// ğŸ”¥ Repository Provider
final marketMoodRepositoryProvider = Provider<MarketMoodRepositoryImpl>((ref) {
  final remoteDS = ref.read(marketMoodRemoteDSProvider);
  final localDS = ref.read(marketMoodLocalDSProvider);
  return MarketMoodRepositoryImpl(remoteDS, localDS);
});

/// ğŸ”¥ UseCase Provider
final marketMoodUsecaseProvider = Provider<MarketMoodUsecase>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  return MarketMoodUsecase(repository);
});

/// ğŸš€ ë©”ëª¨ì´ì œì´ì…˜ëœ í™˜ìœ¨ Provider - ìºì‹œ ìœ ì§€ (TTL í•„ìš” ì‹œ autoDisposeë¡œ ë³€ê²½)
final exchangeRateProvider = FutureProvider.autoDispose<double>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);
  try {
    final rate = await usecase.getExchangeRate();
    log.d('í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate (ìºì‹œë¨)');
    return rate;
  } catch (e, st) {
    log.w('í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ 1400 ì‚¬ìš©: $e', e, st);
    return 1400.0;
  }
});

/// ğŸš€ ìµœì í™”ëœ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ - distinct + debounceTime ì ìš©
final marketMoodProvider = StreamProvider<MarketMoodData>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);

  ref.onDispose(repository.dispose);

  return repository
      .getMarketDataStream()
      .distinct((prev, next) => prev.totalVolumeUsd == next.totalVolumeUsd)
      .debounceTime(const Duration(milliseconds: 100));
});

/// ğŸš€ í†µí•© ê³„ì‚° Provider - ì£¼ê¸°ì  ê°±ì‹  ë° í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ìë™ invalidate ì ìš©
final marketMoodComputedDataProvider = FutureProvider.autoDispose<MarketMoodComputedData>((ref) async {
  // 1) autoDispose ë¹„í™œì„±í™” ë§í¬ (keepAlive)
  final link = ref.keepAlive();

  // 2) 15ë¶„ë§ˆë‹¤ ì¬ê³„ì‚°
  final timer = Timer.periodic(const Duration(minutes: 15), (_) {
    ref.invalidateSelf();
  });

  // 3) ì•± ë³µê·€ ì‹œ ì¬ê³„ì‚°
  ref.onResume(() {
    ref.invalidateSelf();
  });

  // 4) ì¢…ë£Œ ì‹œ ì •ë¦¬
  ref.onDispose(() {
    timer.cancel();
    link.close();
  });

  // ê¸°ì¡´ ë¡œì§
  final moodAsync = ref.watch(marketMoodProvider);
  final exchangeAsync = ref.watch(exchangeRateProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (marketData) async {
      final exchangeRate = exchangeAsync.asData?.value ?? 1400.0;
      try {
        final results = await Future.wait(
          [
            usecase.calculateCurrentMood(marketData.totalVolumeUsd),
            usecase.calculateVolumeComparison(marketData.totalVolumeUsd),
          ],
          eagerError: false,
        );
        final currentMood = results[0] as MarketMood;
        final volumeComparison = results[1] as ComparisonData;
        final moodSummary = usecase.generateMoodSummary(currentMood);

        return MarketMoodComputedData(
          marketData: marketData,
          currentMood: currentMood,
          volumeComparison: volumeComparison,
          moodSummary: moodSummary,
          exchangeRate: exchangeRate,
          computedAt: DateTime.now(),
        );
      } catch (e, st) {
        // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
        log.e('ë°°ì¹˜ ê³„ì‚° ì˜¤ë¥˜: $e', e, st);
        return MarketMoodComputedData.error();
      }
    },
    loading: () async => MarketMoodComputedData.loading(),
    error: (error, stack) async {
      // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
      log.e('ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ì˜¤ë¥˜: $error', error, stack);
      return MarketMoodComputedData.error();
    },
  );
});

/// ğŸ¯ ê°œë³„ ë°ì´í„° ì ‘ê·¼ Providerë“¤ - ë©”ëª¨ì´ì œì´ì…˜ëœ ê²°ê³¼ì—ì„œ ì¶”ì¶œ
final currentMarketMoodProvider = Provider<MarketMood>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.currentMood,
    loading: () => MarketMood.sideways,
    error: (_, __) => MarketMood.sideways,
  );
});

final volumeComparisonProvider = Provider<ComparisonData>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.volumeComparison,
    loading: () => ComparisonData.loading(),
    error: (_, __) => ComparisonData.error(),
  );
});

final marketMoodSummaryProvider = Provider<String>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.moodSummary,
    loading: () => 'ë¡œë”©ì¤‘...',
    error: (_, __) => 'ì˜¤ë¥˜ ë°œìƒ',
  );
});

/// ğŸŒ ìµœì í™”ëœ ì‹œìŠ¤í…œ ìƒíƒœ Provider
final marketMoodSystemProvider = Provider<MarketMoodSystemState>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return computedAsync.when(
    data: (computed) => usecase.createSystemState(
      marketData: computed.marketData,
      comparisonData: computed.volumeComparison,
      currentMood: computed.currentMood,
      exchangeRate: computed.exchangeRate,
      isLoading: false,
      hasError: false,
    ),
    loading: () => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.loading(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: true,
      hasError: false,
    ),
    error: (_, __) => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.error(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: false,
      hasError: true,
    ),
  );
});

/// ğŸ® ìµœì í™”ëœ ë§ˆì¼“ ë¬´ë“œ ì»¨íŠ¸ë¡¤ëŸ¬
final marketMoodControllerProvider = Provider((ref) => OptimizedMarketMoodController(ref));

class OptimizedMarketMoodController {
  final Ref ref;
  DateTime? _lastRefresh;
  static const _refreshCooldown = Duration(seconds: 30);

  OptimizedMarketMoodController(this.ref);

  /// ğŸš€ ìŠ¤ë§ˆíŠ¸ ìƒˆë¡œê³ ì¹¨ - ì¿¨ë‹¤ìš´ ì ìš©
  void refresh() {
    final now = DateTime.now();
    if (_lastRefresh != null && now.difference(_lastRefresh!) < _refreshCooldown) {
      // [ìˆ˜ì •ë¨] + ì—°ì‚°ì ëŒ€ì‹  ì¸ì ‘ ë¬¸ìì—´ ì—°ê²° ì‚¬ìš©
      log.d('ìƒˆë¡œê³ ì¹¨ ì¿¨ë‹¤ìš´ ì¤‘... '
          '${_refreshCooldown.inSeconds - now.difference(_lastRefresh!).inSeconds}ì´ˆ í›„ ê°€ëŠ¥');
      return;
    }

    _lastRefresh = now;
    ref.invalidate(marketMoodProvider);
    ref.invalidate(exchangeRateProvider);
    log.d('ë§ˆì¼“ë¬´ë“œ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ìºì‹œëœ í˜„ì¬ ë¬´ë“œ ì¡°íšŒ
  MarketMood getCurrentMood() => ref.read(currentMarketMoodProvider);

  /// ğŸš€ ìºì‹œëœ ë¹„êµ ë°ì´í„° ì¡°íšŒ
  ComparisonData getComparisonData() => ref.read(volumeComparisonProvider);

  /// ğŸš€ í™˜ìœ¨ë§Œ ì„ íƒì  ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.refreshExchangeRate();
    ref.invalidate(exchangeRateProvider);
    log.d('í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ìºì‹œ í™œìš©)
  Future<Map<String, dynamic>> getSystemHealth() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final state = ref.read(marketMoodSystemProvider);
    return {
      ...await usecase.getSystemHealth(),
      'cached_state': {
        'is_loading': state.isLoading,
        'has_error': state.hasError,
        'last_update': state.marketData?.updatedAt.toIso8601String(),
      }
    };
  }

  /// ğŸš€ ì„±ëŠ¥ í†µê³„ ë¡œê¹…
  Future<void> logSystemStatus() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final computedAsync = ref.read(marketMoodComputedDataProvider);
    await usecase.logSystemStatus();
    computedAsync.whenData((computed) {
      log.i('ì„±ëŠ¥ í†µê³„ - ê³„ì‚° ì‹œê°„: ${DateTime.now().difference(computed.computedAt).inMilliseconds}ms');
    });
  }

  /// ğŸš€ ë©”ëª¨ë¦¬ ì •ë¦¬ (í•„ìš” ì‹œ í˜¸ì¶œ)
  void clearCache() {
    ref.invalidate(marketMoodComputedDataProvider);
    ref.invalidate(exchangeRateProvider);
    ref.invalidate(marketMoodProvider);
    log.d('ìºì‹œ ì •ë¦¬ ì™„ë£Œ');
  }
}

/// ğŸš€ í†µí•© ê³„ì‚° ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤
class MarketMoodComputedData {
  final MarketMoodData? marketData;
  final MarketMood currentMood;
  final ComparisonData volumeComparison;
  final String moodSummary;
  final double exchangeRate;
  final DateTime computedAt;

  const MarketMoodComputedData({
    this.marketData,
    required this.currentMood,
    required this.volumeComparison,
    required this.moodSummary,
    required this.exchangeRate,
    required this.computedAt,
  });

  factory MarketMoodComputedData.loading() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.loading(),
        moodSummary: 'ë¡œë”©ì¤‘...',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  factory MarketMoodComputedData.error() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.error(),
        moodSummary: 'ì˜¤ë¥˜ ë°œìƒ',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  /// ğŸš€ ë°ì´í„° ì‹ ì„ ë„ ì²´í¬ (15ë¶„ ì´ìƒ ì˜¤ë˜ë˜ë©´ ê°±ì‹  í•„ìš”)
  bool get isStale => DateTime.now().difference(computedAt) > const Duration(minutes: 15);

  /// ğŸš€ ì„±ëŠ¥ ë©”íŠ¸ë¦­
  Duration get age => DateTime.now().difference(computedAt);
}\n\n// ====== lib/core/di/settings_provider.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // SystemChromeìš©
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../data/datasources/settings_local_ds.dart';
import '../../data/repositories/settings_repository_impl.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../../domain/usecases/settings_usecase.dart';
import '../utils/logger.dart';

/// 1) SharedPreferences ì¸ìŠ¤í„´ìŠ¤ (main.dartì—ì„œ override)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'main.dartì—ì„œ SharedPreferences.getInstance() í›„ overridesë¡œ ì£¼ì…í•˜ì„¸ìš”.'
  );
});

/// 2) Local DataSource
final settingsLocalDSProvider = Provider<SettingsLocalDataSource>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return SettingsLocalDataSource(prefs);
});

/// 3) Repository
final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
  final ds = ref.watch(settingsLocalDSProvider);
  return SettingsRepositoryImpl(ds);
});

/// 4) UseCase
final settingsUsecaseProvider = Provider<SettingsUsecase>((ref) {
  final repo = ref.watch(settingsRepositoryProvider);
  return SettingsUsecase(repo);
});

/// 5) í†µí•© ì„¤ì • Provider
final appSettingsProvider = StateNotifierProvider<AppSettingsNotifier, AppSettings>((ref) {
  final usecase = ref.watch(settingsUsecaseProvider);
  return AppSettingsNotifier(usecase);
});

/// í†µí•© ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤
class AppSettingsNotifier extends StateNotifier<AppSettings> {
  final SettingsUsecase _usecase;

  AppSettingsNotifier(this._usecase) : super(const AppSettings()) {
    _loadSettings();
  }

  /// ì´ˆê¸° ì„¤ì • ë¡œë“œ
  Future<void> _loadSettings() async {
    try {
      final settings = await _usecase.getSettings();
      state = settings;
      _applyKeepScreen(settings.keepScreenOn);
      _applyOrientationLock(settings.isPortraitLocked);
      log.i('âš™ï¸ ì„¤ì • ë¡œë“œ ì™„ë£Œ: ${settings.toString()}');
    } catch (e, st) {
      log.e('ì„¤ì • ë¡œë“œ ì‹¤íŒ¨', e, st);
    }
  }

  /// í…Œë§ˆ ëª¨ë“œ ë³€ê²½
  Future<void> setThemeMode(ThemeMode mode) async {
    try {
      await _usecase.updateThemeMode(mode);
      state = state.copyWith(themeMode: mode);
      log.i('ğŸ¨ í…Œë§ˆ ëª¨ë“œ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('í…Œë§ˆ ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì •
  Future<void> setKeepScreenOn(bool keep) async {
    try {
      await _usecase.updateKeepScreenOn(keep);
      state = state.copyWith(keepScreenOn: keep);
      _applyKeepScreen(keep);
      log.i('ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°: $keep');
    } catch (e, st) {
      log.e('í™”ë©´ ì¼œê¸° ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½
  Future<void> setSliderPosition(SliderPosition position) async {
    try {
      await _usecase.updateSliderPosition(position);
      state = state.copyWith(sliderPosition: position);
      log.i('ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜: ${position.name}');
    } catch (e, st) {
      log.e('ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setDisplayMode(DisplayMode mode) async {
    try {
      await _usecase.updateDisplayMode(mode);
      state = state.copyWith(displayMode: mode);
      log.i('ğŸ’° ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setAmountDisplayMode(AmountDisplayMode mode) async {
    try {
      await _usecase.updateAmountDisplayMode(mode);
      state = state.copyWith(amountDisplayMode: mode);
      log.i('ğŸ’µ ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ë°˜ì§ì„ íš¨ê³¼ ì„¤ì •
  Future<void> setBlinkEnabled(bool enabled) async {
    try {
      await _usecase.updateBlinkEnabled(enabled);
      state = state.copyWith(blinkEnabled: enabled);
      log.i('âœ¨ ë°˜ì§ì„ íš¨ê³¼: $enabled');
    } catch (e, st) {
      log.e('ë°˜ì§ì„ íš¨ê³¼ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í°íŠ¸ íŒ¨ë°€ë¦¬ ë³€ê²½
  Future<void> setFontFamily(FontFamily font) async {
    try {
      await _usecase.updateFontFamily(font);
      state = state.copyWith(fontFamily: font);
      log.i('ğŸ”¤ í°íŠ¸ ì„¤ì •: ${font.fontName}');
    } catch (e, st) {
      log.e('í°íŠ¸ ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// í–…í‹± í”¼ë“œë°± ì„¤ì •
  Future<void> setHapticEnabled(bool enabled) async {
    try {
      await _usecase.updateHapticEnabled(enabled);
      state = state.copyWith(isHapticEnabled: enabled);
      log.i('ğŸ“³ í–…í‹± í”¼ë“œë°±: $enabled');
    } catch (e, st) {
      log.e('í–…í‹± í”¼ë“œë°± ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì •
  Future<void> setPortraitLocked(bool locked) async {
    try {
      await _usecase.updatePortraitLocked(locked);
      state = state.copyWith(isPortraitLocked: locked);
      _applyOrientationLock(locked);
      log.i('ğŸ”’ í™”ë©´ íšŒì „ ì ê¸ˆ: $locked');
    } catch (e, st) {
      log.e('í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// ìºì‹œ ë¹„ìš°ê¸°
  Future<void> clearCache() async {
    try {
      await _usecase.clearCache();
      log.i('ğŸ—‚ï¸ ìºì‹œ ë¹„ìš°ê¸° ì™„ë£Œ');
      await refresh();
    } catch (e, st) {
      log.e('ìºì‹œ ë¹„ìš°ê¸° ì‹¤íŒ¨', e, st);
    }
  }

  /// ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
  Future<void> resetAllSettings() async {
    try {
      await _usecase.resetSettings();
      state = const AppSettings();
      _applyKeepScreen(false);
      _applyOrientationLock(false);
      log.i('ğŸ”„ ëª¨ë“  ì„¤ì • ì´ˆê¸°í™” ì™„ë£Œ');
    } catch (e, st) {
      log.e('ì„¤ì • ì´ˆê¸°í™” ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ ì¼œê¸° ì‹¤ì œ ì ìš©
  void _applyKeepScreen(bool keep) {
    if (keep) {
      WakelockPlus.enable();
    } else {
      WakelockPlus.disable();
    }
  }

  /// í™”ë©´ íšŒì „ ì ê¸ˆ ì‹¤ì œ ì ìš©
  void _applyOrientationLock(bool locked) {
    if (locked) {
      // ì„¸ë¡œ ëª¨ë“œë§Œ í—ˆìš©
      SystemChrome.setPreferredOrientations([
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
    } else {
      // ëª¨ë“  ë°©í–¥ í—ˆìš©
      SystemChrome.setPreferredOrientations([
        DeviceOrientation.landscapeRight,
        DeviceOrientation.landscapeLeft,
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
    }
  }

  /// ì„¤ì • ìƒˆë¡œê³ ì¹¨
  Future<void> refresh() async {
    await _loadSettings();
  }
}\n\n// ====== lib/core/di/momentary_provider.dart ======\n
\n\n// ====== lib/core/config/app_config.dart ======\n
// lib/core/config/app_config.dart

import 'dart:collection';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import '../utils/logger.dart';

/// Application-wide configuration and constants,
/// optimized per Upbit REST & WebSocket specifications.
class AppConfig {
  AppConfig._();

  /// Call once at startup to initialize dynamic config (env variables)
  static Future<void> init({String? envPath}) async {
    // Load .env (optional custom path) + validate
    try {
      if (envPath != null && envPath.isNotEmpty) {
        await dotenv.load(fileName: envPath);
      } else {
        await dotenv.load();
      }
      log.i('[AppConfig] .env loaded');
      _loadEnv();
    } catch (e, st) {
      log.e('[AppConfig] âš ï¸ Failed to load required env vars', e, st);
      throw Exception('[AppConfig] âš ï¸ Failed to load required env vars: $e');
    }

    log.i('[AppConfig] initialized (debug=$isDebugMode)');
  }

  static void _loadEnv() {
    const requiredKeys = ['UPBIT_API_KEY', 'UPBIT_API_SECRET'];
    for (final key in requiredKeys) {
      final value = dotenv.env[key];
      if (value == null || value.isEmpty) {
        throw Exception('[AppConfig] Missing required env var: $key');
      }
    }

    _upbitRestBase = dotenv.env['UPBIT_REST_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_REST_URL']!
        : _upbitRestBase;
    _upbitWsUrl = dotenv.env['UPBIT_WS_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_WS_URL']!
        : _upbitWsUrl;

    _apiKey = dotenv.env['UPBIT_API_KEY']!;
    _apiSecret = dotenv.env['UPBIT_API_SECRET']!;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ†• í†µì¼ëœ Bool í•´ì„ ìœ í‹¸ë¦¬í‹° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// í™˜ê²½ë³€ìˆ˜ì—ì„œ boolean ê°’ì„ ì•ˆì „í•˜ê³  ì¼ê´€ë˜ê²Œ íŒŒì‹±
  /// ì§€ì›í•˜ëŠ” true ê°’: 'true', '1', 'yes', 'on'
  /// ì§€ì›í•˜ëŠ” false ê°’: 'false', '0', 'no', 'off', null, ë¹ˆ ë¬¸ìì—´
  static bool _getBool(String key, {bool fallback = false}) {
    final value = dotenv.env[key]?.toLowerCase().trim();
    if (value == null || value.isEmpty) return fallback;
    
    // true ê°’ë“¤
    if (value == 'true' || value == '1' || value == 'yes' || value == 'on') {
      return true;
    }
    
    // false ê°’ë“¤
    if (value == 'false' || value == '0' || value == 'no' || value == 'off') {
      return false;
    }
    
    // ì•Œ ìˆ˜ ì—†ëŠ” ê°’ì´ë©´ fallback ì‚¬ìš©
    return fallback;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ API Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _apiKey = '';
  static String _apiSecret = '';
  static String get apiKey => _apiKey;
  static String get apiSecret => _apiSecret;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Environment Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// `true` when not in Dart VM product mode.
  static const bool isDebugMode = !bool.fromEnvironment('dart.vm.product');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ê°œë°œ ì¤‘ ì¡°ì ˆ ê°€ëŠ¥)
  static Level get logLevel {
    if (!isDebugMode) return Level.warning;
    final envLevel = dotenv.env['LOG_LEVEL']?.toLowerCase();
    switch (envLevel) {
      case 'verbose':
        return Level.verbose;
      case 'debug':
        return Level.debug;
      case 'info':
        return Level.info;
      case 'warning':
        return Level.warning;
      case 'error':
        return Level.error;
      default:
        return Level.debug;
    }
  }

  /// ğŸ”§ íŠ¹ì • ëª¨ë“ˆ ë¡œê·¸ on/off (í†µì¼ëœ ë°©ì‹ ì ìš©)
  static bool get enableSignalBusLog =>
      _getBool('ENABLE_SIGNAL_BUS_LOG', fallback: true);
  static bool get enableWebSocketLog =>
      _getBool('ENABLE_WEBSOCKET_LOG', fallback: true);
  static bool get enableTradeLog =>
      _getBool('ENABLE_TRADE_LOG', fallback: true);
  static bool get enableAdaptiveBackoffLog =>
      _getBool('ENABLE_ADAPTIVE_BACKOFF_LOG', fallback: true);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REST Configuration (ì—…ë¹„íŠ¸ 2025 ìŠ¤í™) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitRestBase = 'https://api.upbit.com/v1';
  static String get upbitRestBase => _upbitRestBase;
  
  /// ğŸ†• ì—…ë¹„íŠ¸ ë°±ì„œ 2025 ê¸°ì¤€ ë ˆì´íŠ¸ë¦¬ë°‹ (ê·¸ë£¹ë³„)
  /// ê³µê°œ API: ì´ˆë‹¹ 30íšŒ / ì‚¬ì  API: ì´ˆë‹¹ 8íšŒ
  static const Map<String, int> rateLimitByGroup = {
    'market': 30,      // ê³µê°œ API: /market/all, /ticker ë“±
    'candles': 30,     // ê³µê°œ API: /candles ë“±  
    'trades': 30,      // ê³µê°œ API: /trades ë“±
    'orderbook': 30,   // ê³µê°œ API: /orderbook ë“±
    'orders': 8,       // ì‚¬ì  API: ì£¼ë¬¸ ê´€ë ¨
    'accounts': 8,     // ì‚¬ì  API: ê³„ì • ê´€ë ¨
    'withdraws': 8,    // ì‚¬ì  API: ì¶œê¸ˆ ê´€ë ¨
    'deposits': 8,     // ì‚¬ì  API: ì…ê¸ˆ ê´€ë ¨
    'default': 8,      // ê¸°ë³¸ê°’: ì‚¬ì  API ê¸°ì¤€
  };
  
  /// ğŸ†• ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì¡°íšŒ
  static int getRateLimitForGroup(String group) {
    return rateLimitByGroup[group] ?? rateLimitByGroup['default']!;
  }
  
  /// ğŸ†• ê²½ë¡œ ê¸°ë°˜ ê·¸ë£¹ ìë™ íŒë³„
  static String getGroupFromPath(String path) {
    final normalizedPath = path.toLowerCase();
    
    // ê³µê°œ API ê·¸ë£¹ë“¤
    if (normalizedPath.contains('/market/')) return 'market';
    if (normalizedPath.contains('/ticker')) return 'market';
    if (normalizedPath.contains('/candles/')) return 'candles';
    if (normalizedPath.contains('/trades')) return 'trades';  
    if (normalizedPath.contains('/orderbook')) return 'orderbook';
    
    // ì‚¬ì  API ê·¸ë£¹ë“¤
    if (normalizedPath.contains('/orders')) return 'orders';
    if (normalizedPath.contains('/accounts')) return 'accounts';
    if (normalizedPath.contains('/withdraws')) return 'withdraws';
    if (normalizedPath.contains('/deposits')) return 'deposits';
    
    // ê¸°ë³¸ê°’ (ì‚¬ì  API)
    return 'default';
  }
  
  /// ë ˆê±°ì‹œ í˜¸í™˜ìš© (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±)
  @Deprecated('Use rateLimitByGroup instead')
  static const int restRateLimitCount = 8; // ì‚¬ì  API ê¸°ì¤€ìœ¼ë¡œ ë³´ìˆ˜ì  ì„¤ì •
  static const Duration restRateLimitPeriod = Duration(seconds: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WebSocket Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitWsUrl = 'wss://api.upbit.com/websocket/v1';
  static String get upbitWsUrl => _upbitWsUrl;
  static const int wsMaxSubscriptionCount = 200;

  // Upbit ê¶Œì¥ íƒ€ì´ë°ìœ¼ë¡œ ë³€ê²½ (30s Ping / 60s Pong):
  static const Duration wsPingInterval = Duration(seconds: 30);
  static const Duration wsPongTimeout = Duration(seconds: 60);

  static const int wsMaxRetryCount = 5;
  static const Duration wsInitialBackoff = Duration(seconds: 1);
  static const Duration wsMaxBackoff = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Aggregation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const int mergeWindowMs = 1000;
  static const Duration globalResetInterval = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dev/Test Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static bool useTestDataInDev = false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trade Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static final List<double> _filters = [
    2e6, 5e6, 1e7, 2e7, 5e7,
    1e8, 2e8, 3e8, 4e8, 5e8,
    1e9,
  ];
  static UnmodifiableListView<double> get tradeFilters =>
      UnmodifiableListView(_filters);

  /// Human-readable labels always in sync with `_filters`
  static Map<double, String> get filterNames => Map.unmodifiable({
        for (final f in _filters) f: _formatFilterLabel(f),
      });

  /// Update the trade filters at runtime (ensures positive & sorted)
  static void updateFilters(List<double> newFilters) {
    _filters
      ..clear()
      ..addAll(newFilters.where((f) => f > 0))
      ..sort();
    log.i('[AppConfig] filters updated â†’ $_filters');
  }

  static String _formatFilterLabel(double f) {
    if (f >= 1e8 && f % 1e8 == 0) return '${(f / 1e8).toInt()}ì–µ';
    if (f >= 1e7 && f % 1e7 == 0) return '${(f / 1e7).toInt()}ì²œë§Œ';
    if (f >= 1e6 && f % 1e6 == 0) return '${(f / 1e6).toInt()}ë°±ë§Œ';
    return f.toStringAsFixed(0);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candle Timeframes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const List<int> timeFrames = [
    1, 5, 15, 30, 60, 120, 240, 480, 720, 1440
  ];
  static final Map<int, String> timeFrameNames = Map.unmodifiable({
    1: '1ë¶„',
    5: '5ë¶„',
    15: '15ë¶„',
    30: '30ë¶„',
    60: '1ì‹œê°„',
    120: '2ì‹œê°„',
    240: '4ì‹œê°„',
    480: '8ì‹œê°„',
    720: '12ì‹œê°„',
    1440: '1ì¼',
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Surge Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const double surgeThresholdPercent = 1.1;
  static const Duration surgeWindowDuration = Duration(minutes: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Signal Detection Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  /// Signal íŒ¨í„´ ëª©ë¡ (ìŠ¬ë¼ì´ë” ìˆœì„œì™€ ë™ì¼)
  static const List<String> signalPatterns = [
    'surge', 'flashFire', 'stackUp', 'stealthIn', 'blackHole', 'reboundShot'
  ];

  /// Signal íŒ¨í„´ í‘œì‹œëª…
  static const Map<String, String> signalPatternNames = {
    'surge': 'ê¸‰ë“±',
    'flashFire': 'ë¶ˆí‹°ğŸ”¥',
    'stackUp': 'ìŠ¤íƒì—…ğŸ’°',
    'stealthIn': 'ì¹¨íˆ¬ìğŸ‘£',
    'blackHole': 'ë¸”ë™í™€ğŸ•³ï¸',
    'reboundShot': 'ì‡¼íŠ¸í„°ì¹˜âš¡',
  };

  /// Signal íŒ¨í„´ ì„¤ëª…
  static const Map<String, String> signalPatternDescriptions = {
    'surge': '1ë¶„ ì „ ëŒ€ë¹„ 1.1% ì´ìƒ ìƒìŠ¹',
    'flashFire': '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ ê°ì§€',
    'stackUp': 'ì—°ì† ë§¤ì§‘ íŒ¨í„´ ê°ì§€',
    'stealthIn': 'ì€ë°€í•œ ìœ ì… ê°ì§€',
    'blackHole': 'ì´ìƒ ì²´ê²° íŒ¨í„´ ê°ì§€',
    'reboundShot': 'ë°˜ë“± íƒ€ì´ë° ê°ì§€',
  };

  /// íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’
  static const Map<String, double> signalThresholds = {
    'surge': 1.1,           // 1.1% ìƒìŠ¹ (ê¸°ì¡´ surgeThresholdPercentì™€ ë™ì¼)
    'flashFire': 2.0,       // 2ë°° ê¸‰ì¦
    'stackUp': 3.0,         // 3ì—°ì†
    'stealthIn': 5000000.0, // 500ë§Œì›
    'blackHole': 0.1,       // 0.1% ë³€ë™
    'reboundShot': 1.5,     // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
  };

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  static const Map<String, int> signalTimeWindows = {
    'surge': 1,       // 1ë¶„
    'flashFire': 3,   // 3ë¶„
    'stackUp': 3,     // 3ë¶„ (1ë¶„ì”© 3ë²ˆ)
    'stealthIn': 5,   // 5ë¶„
    'blackHole': 3,   // 3ë¶„
    'reboundShot': 2, // 2ë¶„ (ê¸‰ë½ 1ë¶„ + ë°˜ë“± 1ë¶„)
  };

  /// Signal ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int maxSignalsPerPattern = 100;
  static const int signalHistorySize = 200;
  static const int signalCacheSize = 1000;
  static const Duration signalHistoryRetention = Duration(minutes: 10);
  static const Duration signalBatchInterval = Duration(milliseconds: 100); // Tradeì™€ ë™ì¼

  /// Signal ë¶„ì„ìš© ìµœì†Œê°’ë“¤
  static const int minTradeCountForAnalysis = 10;
  static const int avgIntervalThreshold = 30; // ì´ˆ
  static const double blackHoleMinAmount = 50000000.0; // 5ì²œë§Œì›

  /// Signal íŒ¨í„´ ì¸ë±ìŠ¤ë¡œ íŒ¨í„´ëª… ì¡°íšŒ
  static String getSignalPatternByIndex(int index) {
    if (index < 0 || index >= signalPatterns.length) {
      return signalPatterns.first; // ê¸°ë³¸ê°’
    }
    return signalPatterns[index];
  }

  /// Signal íŒ¨í„´ëª…ìœ¼ë¡œ ì¸ë±ìŠ¤ ì¡°íšŒ
  static int getSignalPatternIndex(String pattern) {
    final index = signalPatterns.indexOf(pattern);
    return index >= 0 ? index : 0; // ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ íŒ¨í„´
  }

  /// Signal íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  static double getSignalThreshold(String pattern) {
    return signalThresholds[pattern] ?? signalThresholds['surge']!;
  }

  /// Signal íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° ì¡°íšŒ
  static int getSignalTimeWindow(String pattern) {
    return signalTimeWindows[pattern] ?? signalTimeWindows['surge']!;
  }

  /// Signal íŒ¨í„´ í‘œì‹œëª… ì¡°íšŒ
  static String getSignalPatternName(String pattern) {
    return signalPatternNames[pattern] ?? pattern;
  }

  /// Signal íŒ¨í„´ ì„¤ëª… ì¡°íšŒ
  static String getSignalPatternDescription(String pattern) {
    return signalPatternDescriptions[pattern] ?? '';
  }
}\n\n// ====== lib/core/config/trade_config.dart ======\n
\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ì œë„¤ë¦­)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ í”Œë«í¼ë³„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} â†’ $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} â†’ ${msg.substring(0, 100)}â€¦');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/core/network/websocket/ticker_ws_client.dart ======\n
// lib/core/network/websocket/ticker_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜„ì¬ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TickerWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TickerWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'ticker-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'ticker',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/candle_ws_client.dart ======\n
// lib/core/network/websocket/candle_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œìº”ë“¤â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
/// [timeFrame]: e.g. "1m", "5m", "15m", ...
class CandleWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  CandleWsClient({
    required String timeFrame,
    void Function(WsStatus)? onStatusChange,
  }) : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'candle-$timeFrame-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'candles_$timeFrame',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œì²´ê²°â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
// lib/core/network/websocket/base_ws_client.dart

import 'dart:async';
import 'dart:convert';

import 'package:web_socket_channel/web_socket_channel.dart';

import '../../config/app_config.dart';
import '../../error/app_exception.dart';
import '../adaptive_backoff.dart';               // AdaptiveBackoff ì—°ë™
import '../ws_rate_limiter_interceptor.dart';
import '../../utils/logger.dart';                // â† logger import

typedef DecodeFn<T> = T Function(dynamic json);
typedef EncodeFn = String Function(List<String> symbols);

/// WebSocket connection status notifications.
enum WsStatus {
  connecting,
  connected,
  failed,
  disconnected,
  error,
  reconnecting,
  pongTimeout,
  maxRetryExceeded,
}

/// Common WebSocket client: connect, subscribe, reconnect, emit
class BaseWsClient<T> {
  /// Helper to decode a JSON list (or single object) into a List<Map<String, dynamic>>.
  static List<Map<String, dynamic>> decodeJsonList(dynamic raw) {
    final jsonObj = raw is String ? jsonDecode(raw) : raw;
    final list = jsonObj is List ? jsonObj : [jsonObj];
    return list
        .cast<Map<String, dynamic>>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final void Function(WsStatus)? onStatusChange;
  final WsRateLimiter _rateLimiter;
  final AdaptiveBackoffCalculator _backoffCalculator =
      AdaptiveBackoffCalculator();
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  WebSocketChannel? _channel;
  final _controller = StreamController<T>.broadcast();
  List<String> _symbols = [];
  Timer? _pingTimer;
  Timer? _pongTimer;
  bool _disposed = false;
  bool _reconnecting = false;
  int _retryCount = 0;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    WsRateLimiter? rateLimiter,
  }) : _rateLimiter = rateLimiter ?? WsRateLimiter() {
    _startMemoryCleanup();
  }

  /// Start periodic cleanup of inactive subscriptions.
  void _startMemoryCleanup() {
    _memoryCleanupTimer =
        Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
    });
  }

  /// Clean up paused subscriptions to prevent memory leaks.
  void _cleanupInactiveSubscriptions() {
    final toRemove =
        _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      sub.cancel();
      _activeSubscriptions.remove(sub);
    }
    if (toRemove.isNotEmpty) {
      log.d('WSClient: Cleaned up ${toRemove.length} inactive subscriptions');
    }
  }

  /// ğŸ”¥ ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì•ˆì „í•˜ê²Œ ì •ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
  void _cleanupActiveSubscriptions() {
    if (_activeSubscriptions.isNotEmpty) {
      log.d('ğŸ§¹ ê¸°ì¡´ êµ¬ë… ${_activeSubscriptions.length}ê°œ ì •ë¦¬ ì¤‘...');
      
      for (final subscription in _activeSubscriptions) {
        try {
          subscription.cancel();
        } catch (e) {
          log.w('âš ï¸ êµ¬ë… ì·¨ì†Œ ì¤‘ ì—ëŸ¬: $e');
        }
      }
      
      _activeSubscriptions.clear();
      log.d('âœ… êµ¬ë… ì •ë¦¬ ì™„ë£Œ');
    }
  }

  /// Exposed stream of decoded messages.
  Stream<T> get stream => _controller.stream;

  /// Connect or reconnect with a new set of symbols.
  Future<void> connect(List<String> symbols) async {
    _notify(WsStatus.connecting);
    if (_disposed) return;
    _symbols = List.from(symbols);
    
    // ğŸ”¥ ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì •ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
    _cleanupActiveSubscriptions();
    
    await _channel?.sink.close();

    try {
      if (_symbols.length > AppConfig.wsMaxSubscriptionCount) {
        throw const WebSocketException('Subscribe limit exceeded');
      }
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _setupPing();
      _send(encodeSubscribe(_symbols));

      final subscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _retryCount = 0;
      _backoffCalculator.recordSuccess();
      _notify(WsStatus.connected);
      log.i('WS connected to $url (subscriptions: ${_symbols.length})');
    } catch (e, st) {
      log.w('WS connect failed: $e', e, st);
      _backoffCalculator.recordFailure();
      _notify(WsStatus.failed);
      _scheduleReconnect();
    }
  }

  void _handleData(dynamic raw) {
    _pongTimer?.cancel();
    try {
      final text = raw is List<int> ? utf8.decode(raw) : raw.toString();
      final jsonObj = jsonDecode(text);
      final data = decode(jsonObj);
      _controller.add(data);
    } catch (e, st) {
      log.e('WS processing error', e, st);
    }
  }

  void _handleDone() {
    log.i('WS closed by server');
    _notify(WsStatus.disconnected);
    _scheduleReconnect();
  }

  void _handleError(dynamic e) {
    log.e('WS error', e);
    _backoffCalculator.recordFailure();
    _notify(WsStatus.error);
    _scheduleReconnect();
  }

  void _send(String msg) => _rateLimiter.enqueue(() {
        try {
          _channel?.sink.add(msg);
          log.d('WS â–¶ $msg');
        } catch (e, st) {
          log.e('WS send error', e, st);
        }
      });

  void _setupPing() {
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _pingTimer =
        Timer.periodic(AppConfig.wsPingInterval, (_) {
      _send(jsonEncode({'type': 'ping'}));
      _pongTimer = Timer(AppConfig.wsPongTimeout, () {
        log.w('Pong timeout, reconnecting');
        _notify(WsStatus.pongTimeout);
        _scheduleReconnect();
      });
    });
    log.d('WS ping/pong timers set');
  }

  /// Schedule reconnection with adaptive backoff.
  void _scheduleReconnect() {
    if (_disposed || _reconnecting) return;
    _reconnecting = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();

    _backoffCalculator
        .calculateBackoff(
          _retryCount,
          AppConfig.wsInitialBackoff,
          AppConfig.wsMaxBackoff,
        )
        .then((delay) {
      if (_disposed) return;
      Future.delayed(delay, () {
        if (_disposed) return;
        if (_retryCount < AppConfig.wsMaxRetryCount) {
          _retryCount++;
          log.i(
            'Reconnect attempt #$_retryCount after ${delay.inMilliseconds}ms',
          );
          _notify(WsStatus.reconnecting);
          connect(_symbols).whenComplete(() => _reconnecting = false);
        } else {
          log.w('Max WS retries exceeded');
          _notify(WsStatus.maxRetryExceeded);
          _retryCount = 0;
          _reconnecting = false;
        }
      });
    });
  }

  void _notify(WsStatus status) => onStatusChange?.call(status);

  /// Dispose resources: timers, subscriptions, channel, controller, and backoff state.
  Future<void> dispose() async {
    _disposed = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _memoryCleanupTimer?.cancel();

    // ğŸ”¥ dispose ì‹œì—ë„ ì•ˆì „í•˜ê²Œ ì •ë¦¬
    _cleanupActiveSubscriptions();

    _rateLimiter.dispose();
    await _channel?.sink.close();
    await _controller.close();
    _backoffCalculator.recordSuccess(); // reset
    log.i('WSClient disposed');
  }
}\n\n// ====== lib/core/network/websocket/orderbook_ws_client.dart ======\n
// lib/core/network/websocket/orderbook_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜¸ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class OrderbookWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  OrderbookWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'orderbook-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'orderbook',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/api_client_coingecko.dart ======\n
// lib/core/network/api_client_coingecko.dart

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../../data/models/market_mood_dto.dart';
import '../error/app_exception.dart';
import '../utils/logger.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸
class CoinGeckoApiClient {
  static const String _baseUrl = 'https://api.coingecko.com/api/v3';
  static const String _pathGlobal = '/global';
  static const String _exchangeRateUrl = 'https://api.exchangerate-api.com/v4/latest/USD';
  static const String _keyRates = 'rates';
  static const String _keyKrw = 'KRW';

  static const Duration _timeout = Duration(seconds: 10);
  
  final Dio _dio;
  
  CoinGeckoApiClient({Dio? dio}) : _dio = dio ?? _createDio();
  
  static Dio _createDio() {
    final dio = Dio(BaseOptions(
      baseUrl: _baseUrl,
      connectTimeout: _timeout,
      receiveTimeout: _timeout,
      sendTimeout: _timeout,
      headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
    ));
    
    if (kDebugMode) {
      dio.interceptors.add(LogInterceptor(
        requestBody: false,
        responseBody: false,
        logPrint: (object) => log.d('[CoinGecko API] $object'),
      ));
    }
    
    return dio;
  }
  
  /// ğŸ¯ ì „ì²´ ì‹œì¥ ë°ì´í„° ì¡°íšŒ
  Future<CoinGeckoGlobalResponseDto> getGlobalMarketData() async {
    try {
      final response = await _dio.get(_pathGlobal);
      if (response.statusCode == 200 && response.data != null) {
        return CoinGeckoGlobalResponseDto.fromJson(response.data);
      } else {
        throw NetworkException(
          'Invalid response from CoinGecko API: ${response.statusCode}',
          statusCode: response.statusCode,
        );
      }
    } on DioException catch (e) {
      log.e('[CoinGecko] DioException: ${e.message}', e);
      throw NetworkException.fromDio(e);
    } catch (e, stackTrace) {
      log.e('[CoinGecko] Unexpected error: $e', e, stackTrace);
      throw AppException('Failed to fetch market data: $e');
    }
  }

  /// ğŸ’± USD â†’ KRW í™˜ìœ¨ ì¡°íšŒ
  Future<double> getUsdToKrwRate() async {
    try {
      final response = await _dio.get(_exchangeRateUrl);
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data as Map<String, dynamic>;
        final rates = data[_keyRates] as Map<String, dynamic>;
        final krwRate = (rates[_keyKrw] ?? 1400.0).toDouble();
        return krwRate;
      } else {
        throw NetworkException('Invalid response from Exchange Rate API: ${response.statusCode}',
          statusCode: response.statusCode,
        );
      }
    } on DioException {
      log.w('[ExchangeRate] DioException, using fallback rate 1400.0');
      return 1400.0;
    } catch (e) {
      log.w('[ExchangeRate] Unexpected error: $e, using fallback rate 1400.0');
      return 1400.0;
    }
  }
}\n\n// ====== lib/core/network/auth_interceptor.dart ======\n
// lib/core/network/auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// Upbit REST API í˜¸ì¶œ ì‹œ JWT ë°©ì‹ì˜ ì¸ì¦ í—¤ë”ë¥¼ ë¶™ì—¬ì¤ë‹ˆë‹¤.
/// - payloadì— access_key, nonce, (query_hash, query_hash_alg)ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.
/// - ì•Œê³ ë¦¬ì¦˜: HS256
class AuthInterceptor extends Interceptor {
  final String apiKey;
  final String apiSecret;

  AuthInterceptor({required this.apiKey, required this.apiSecret});

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    try {
      final nonce = DateTime.now().millisecondsSinceEpoch.toString();
      final payload = <String, dynamic>{
        'access_key': apiKey,
        'nonce': nonce,
      };

      if (options.queryParameters.isNotEmpty || _hasRequestBody(options)) {
        final raw = options.queryParameters.isNotEmpty
            ? Uri(queryParameters: options.queryParameters).query
            : jsonEncode(options.data);
        payload['query_hash'] = sha512.convert(utf8.encode(raw)).toString();
        payload['query_hash_alg'] = 'SHA512';
      }

      // JWT Header and Payload
      const headerMap = {'alg': 'HS256', 'typ': 'JWT'};
      final headerJson = jsonEncode(headerMap);
      final payloadJson = jsonEncode(payload);
      final headerSeg = _base64UrlEncode(headerJson);
      final payloadSeg = _base64UrlEncode(payloadJson);

      // Signature
      final sigBytes = Hmac(sha256, utf8.encode(apiSecret))
          .convert(utf8.encode('$headerSeg.$payloadSeg'))
          .bytes;
      final sigSeg = base64Url.encode(sigBytes).replaceAll('=', '');

      options.headers['Authorization'] =
          'Bearer $headerSeg.$payloadSeg.$sigSeg';
    } catch (e, st) {
      log.e('AuthInterceptor error', e, st);
      return handler.reject(
        DioException(requestOptions: options, error: e),
      );
    }

    handler.next(options);
  }

  bool _hasRequestBody(RequestOptions options) {
    final data = options.data;
    if (data == null) return false;
    if (data is String) return data.isNotEmpty;
    if (data is Iterable || data is Map) return data.isNotEmpty;
    if (data is FormData) return data.fields.isNotEmpty || data.files.isNotEmpty;
    return true;
  }

  String _base64UrlEncode(String input) =>
      base64Url.encode(utf8.encode(input)).replaceAll('=', '');
}
\n\n// ====== lib/core/network/adaptive_backoff.dart ======\n
// lib/core/network/adaptive_backoff.dart

import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../utils/logger.dart';

class AdaptiveBackoffCalculator {
  final Connectivity _connectivity = Connectivity();
  int _consecutiveFailures = 0;
  DateTime? _lastFailureTime;
  
  // ë„¤íŠ¸ì›Œí¬ë³„ ê¸°ë³¸ ì§€í„° ê³„ìˆ˜ (connectivity_plus ì—°ë™)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.8,      // WiFiëŠ” ë¹ ë¥¸ ì¬ì—°ê²°
    ConnectivityResult.mobile: 1.2,    // ëª¨ë°”ì¼ì€ ë³´ìˆ˜ì 
    ConnectivityResult.ethernet: 0.6,  // ìœ ì„ ì€ ê°€ì¥ ë¹ ë¦„
    ConnectivityResult.none: 2.0,      // ì—°ê²° ì—†ìŒì€ ë§¤ìš° ë³´ìˆ˜ì 
  };

  Future<Duration> calculateBackoff(int attempt, Duration baseDelay, Duration maxDelay) async {
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0; // ê¸°ë³¸ê°’
    
    final failurePenalty = _calculateFailurePenalty();
    
    final exponentialMs = baseDelay.inMilliseconds * (1 << attempt);
    final cappedMs = math.min(exponentialMs, maxDelay.inMilliseconds);
    
    // ì§€í„° ë²”ìœ„ 20%ë¡œ ë¹ ë¥¸ ì¬ì—°ê²° ë³´ì¥
    final jitterRange = cappedMs * 0.2;
    final random = math.Random();
    final adaptiveJitter = random.nextDouble() * jitterRange * networkMultiplier * failurePenalty;
    
    final finalMs = math.max(0, cappedMs + adaptiveJitter.round());
    
    log.d('AdaptiveBackoff: attempt=$attempt, network=$connectivityResult, '
          'base=${cappedMs}ms, jitter=${adaptiveJitter.round()}ms, final=${finalMs}ms');
    
    return Duration(milliseconds: finalMs);
  }

  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;
    
    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      _consecutiveFailures = 0;
      return 1.0;
    }
    
    // í˜ë„í‹° ìƒí•œ 1.5ë°°ë¡œ ì¡°ì • (ê·¸ë¡ì˜ ìˆ˜ì •ì‚¬í•­ ìœ ì§€)
    return math.min(1.5, 1.0 + (_consecutiveFailures * 0.2));
  }

  void recordFailure() {
    _consecutiveFailures++;
    _lastFailureTime = DateTime.now();
  }

  void recordSuccess() {
    _consecutiveFailures = 0;
    _lastFailureTime = null;
  }
}\n\n// ====== lib/core/network/retry_interceptor.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 429 í˜¹ì€ 5xx ì—ëŸ¬ì— ëŒ€í•´ ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„° ë°©ì‹ìœ¼ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤.
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialBackoff;
  final Duration maxBackoff;
  final double jitterFactor;

  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialBackoff = const Duration(milliseconds: 500),
    this.maxBackoff = const Duration(seconds: 5),
    this.jitterFactor = 0.2,
  });

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    final options = err.requestOptions;
    final retryCount = (options.extra['retry_count'] as int?) ?? 0;
    final status = err.response?.statusCode;

    if (_shouldRetry(err) && retryCount < maxRetries) {
      final next = retryCount + 1;
      options.extra['retry_count'] = next;

      // 429 ì‘ë‹µì¼ ê²½ìš° ì„œë²„ê°€ ì œê³µí•˜ëŠ” í—¤ë” ìš°ì„  ì‚¬ìš©
      Duration delay;
      if (status == 429) {
        final retryAfter = err.response?.headers.value('Retry-After');
        if (retryAfter != null) {
          final secs = int.tryParse(retryAfter) ?? 0;
          delay = Duration(seconds: secs);
          log.i('Retry #$next after Retry-After header: ${delay.inSeconds}s');
        } else {
          final remaining = err.response?.headers.value('Remaining-Req');
          if (remaining != null) {
            log.d('Remaining-Req header: $remaining');
          }
          delay = _computeBackoff(next);
        }
      } else {
        // 5xx ì—ëŸ¬ëŠ” ê¸°ë³¸ ë°±ì˜¤í”„ ì‚¬ìš©
        delay = _computeBackoff(next);
      }

      log.i('Retry #$next for [${options.method} ${options.path}] in ${delay.inMilliseconds}ms');
      await Future.delayed(delay);

      try {
        final response = await dio.fetch(options);
        return handler.resolve(response);
      } on DioException catch (e) {
        return handler.next(e);
      }
    }

    handler.next(err);
  }

  bool _shouldRetry(DioException err) {
    final status = err.response?.statusCode;
    return err.type == DioExceptionType.badResponse &&
        (status == 429 || (status != null && status >= 500 && status < 600));
  }

  Duration _computeBackoff(int attempt) {
    final expMs = initialBackoff.inMilliseconds * (1 << (attempt - 1));
    final cap = min(expMs, maxBackoff.inMilliseconds);
    final jitter = ((Random().nextDouble() * 2 - 1) * jitterFactor * cap).round();
    final finalMs = max(0, cap + jitter);
    return Duration(milliseconds: finalMs);
  }
}
\n\n// ====== lib/core/network/ws_rate_limiter_interceptor.dart ======\n
// lib/core/network/ws_rate_limiter_interceptor.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../utils/logger.dart';

/// Upbit WebSocket êµ¬ë… ë©”ì‹œì§€ ë°œí–‰ ê°„ ìµœì†Œ ê°„ê²© ë³´ì¥ ìœ í‹¸
class WsRateLimiter {
  final Duration minInterval;
  final Queue<VoidCallback> _queue = Queue<VoidCallback>();
  bool _isFlushing = false;
  DateTime _lastSent = DateTime.fromMillisecondsSinceEpoch(0);

  WsRateLimiter({this.minInterval = const Duration(milliseconds: 500)});

  /// ë©”ì‹œì§€ë¥¼ íì— ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ì „ì†¡ ì‹œë„
  void enqueue(VoidCallback send) {
    _queue.add(send);
    _flushNext();
  }

  void _flushNext() {
    if (_isFlushing || _queue.isEmpty) return;
    _isFlushing = true;

    final now = DateTime.now();
    final elapsed = now.difference(_lastSent);
    final delay = elapsed >= minInterval ? Duration.zero : minInterval - elapsed;

    Timer(delay, () {
      final send = _queue.removeFirst();
      try {
        send();
        _lastSent = DateTime.now();
        log.d('WsRateLimiter sent, next after \${minInterval.inMilliseconds}ms');
      } catch (e, st) {
        log.e('WsRateLimiter send error', e, st);
      } finally {
        _isFlushing = false;
        if (_queue.isNotEmpty) _flushNext();
      }
    });
  }

  /// íë¥¼ ë¹„ìš°ê³  ì‚¬ìš© ì¤‘ì§€
  void dispose() {
    _queue.clear();
  }
}
\n\n// ====== lib/core/network/api_client.dart ======\n
// lib/core/network/api_client.dart

import 'dart:async';
import 'dart:collection';
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';
import 'auth_interceptor.dart';
import 'retry_interceptor.dart';
import 'logging_interceptor.dart';

typedef Json = Map<String, dynamic>;

/// ğŸ†• ì—…ë¹„íŠ¸ ë°±ì„œ 2025 ê¸°ì¤€ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ê´€ë¦¬ì
/// Remaining-Req í—¤ë”ë¥¼ íŒŒì‹±í•˜ì—¬ ê·¸ë£¹ë³„ ì‹¤ì‹œê°„ ìŠ¬ë¡¯ ê³„ì‚°
class _UpbitDynamicRateLimiter {
  final Map<String, _GroupRateLimiter> _groupLimiters = {};
  final Duration _defaultPeriod = const Duration(seconds: 1);
  
  /// ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ ì—…ë°ì´íŠ¸
  /// í˜•ì‹: "Remaining-Req: group=market; min=900; sec=29"
  void updateFromHeaders(Map<String, List<String>> headers) {
    try {
      final remainingReq = headers['remaining-req']?.first ?? 
                          headers['Remaining-Req']?.first;
      if (remainingReq == null) return;
      
      // í—¤ë” íŒŒì‹±: group=market; min=900; sec=29
      final parsedInfo = _parseRemainingReqHeader(remainingReq);
      if (parsedInfo != null) {
        _updateGroupLimiter(
          parsedInfo.group, 
          parsedInfo.remaining, 
          Duration(seconds: parsedInfo.windowSec)
        );
        
        if (AppConfig.enableTradeLog) {
          log.i('Rate limit updated: ${parsedInfo.group}=${parsedInfo.remaining} req in ${parsedInfo.windowSec}s');
        }
      }
      
      // Req-Group í—¤ë”ë„ í™•ì¸ (ê·¸ë£¹ ì •ë³´ë§Œ)
      final reqGroup = headers['req-group']?.first ?? 
                      headers['Req-Group']?.first;
      if (reqGroup != null && _groupLimiters[reqGroup] == null) {
        _initializeGroupLimiter(reqGroup);
      }
      
    } catch (e, st) {
      log.w('Failed to parse rate limit headers: $e', e, st);
    }
  }
  
  /// Remaining-Req í—¤ë” íŒŒì‹±
  _RemainingReqInfo? _parseRemainingReqHeader(String header) {
    try {
      final parts = header.split(';').map((p) => p.trim()).toList();
      String? group;
      int? remaining;
      int? windowSec;
      
      for (final part in parts) {
        final kv = part.split('=');
        if (kv.length != 2) continue;
        
        final key = kv[0].trim().toLowerCase();
        final value = kv[1].trim();
        
        switch (key) {
          case 'group':
            group = value;
            break;
          case 'min':
          case 'remaining':
            remaining = int.tryParse(value);
            break;
          case 'sec':
          case 'window':
            windowSec = int.tryParse(value);
            break;
        }
      }
      
      if (group != null && remaining != null && windowSec != null) {
        return _RemainingReqInfo(group, remaining, windowSec);
      }
    } catch (e) {
      log.w('Failed to parse Remaining-Req header: $header, error: $e');
    }
    return null;
  }
  
  /// ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì´ˆê¸°í™”
  void _initializeGroupLimiter(String group) {
    final maxRequests = AppConfig.getRateLimitForGroup(group);
    _groupLimiters[group] = _GroupRateLimiter(
      group: group,
      maxRequests: maxRequests,
      period: _defaultPeriod,
    );
    
    if (AppConfig.enableTradeLog) {
      log.d('Initialized rate limiter for group: $group ($maxRequests rps)');
    }
  }
  
  /// ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì—…ë°ì´íŠ¸ (ì„œë²„ ì‘ë‹µ ê¸°ë°˜)
  void _updateGroupLimiter(String group, int remaining, Duration window) {
    var limiter = _groupLimiters[group];
    if (limiter == null) {
      _initializeGroupLimiter(group);
      limiter = _groupLimiters[group]!;
    }
    
    // ì„œë²„ì—ì„œ ë°›ì€ ì •ë³´ë¡œ ë™ì  ì—…ë°ì´íŠ¸
    limiter.updateFromServer(remaining, window);
  }
  
  /// íŠ¹ì • ê·¸ë£¹ì˜ throttle ì‹¤í–‰
  Future<void> throttle(String group, String path) async {
    // ê·¸ë£¹ ë¦¬ë°‹ì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
    if (!_groupLimiters.containsKey(group)) {
      _initializeGroupLimiter(group);
    }
    
    final limiter = _groupLimiters[group]!;
    await limiter.throttle(path);
  }
  
  /// ë””ë²„ê·¸ ì •ë³´ ì œê³µ
  Map<String, dynamic> getDebugInfo() {
    return {
      'activeGroups': _groupLimiters.keys.toList(),
      'groupStats': {
        for (final entry in _groupLimiters.entries)
          entry.key: entry.value.getStats(),
      },
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    for (final limiter in _groupLimiters.values) {
      limiter.dispose();
    }
    _groupLimiters.clear();
  }
}

/// í—¤ë” íŒŒì‹± ê²°ê³¼ ì •ë³´
class _RemainingReqInfo {
  final String group;
  final int remaining;
  final int windowSec;
  
  _RemainingReqInfo(this.group, this.remaining, this.windowSec);
}

/// ê°œë³„ ê·¸ë£¹ì˜ ë ˆì´íŠ¸ë¦¬ë°‹ ê´€ë¦¬ì
class _GroupRateLimiter {
  final String group;
  int _maxRequests;
  final Duration _period;
  final Queue<DateTime> _timestamps = Queue<DateTime>();
  
  // ì„œë²„ ê¸°ë°˜ ë™ì  ì •ë³´
  int? _serverRemaining;
  DateTime? _serverUpdateTime;
  Duration? _serverWindow;
  
  _GroupRateLimiter({
    required this.group,
    required int maxRequests,
    required Duration period,
  }) : _maxRequests = maxRequests, _period = period;
  
  /// ì„œë²„ ì‘ë‹µ ê¸°ë°˜ ì—…ë°ì´íŠ¸
  void updateFromServer(int remaining, Duration window) {
    _serverRemaining = remaining;
    _serverUpdateTime = DateTime.now();
    _serverWindow = window;
    
    // ì„œë²„ ì •ë³´ê°€ ë” ì œí•œì ì´ë©´ í´ë¼ì´ì–¸íŠ¸ ì œí•œë„ ì¡°ì •
    if (remaining < _maxRequests) {
      final adjustedMax = (remaining * 0.9).floor(); // 10% ì—¬ìœ 
      if (adjustedMax > 0 && adjustedMax < _maxRequests) {
        log.i('Adjusting rate limit for $group: $_maxRequests â†’ $adjustedMax (server: $remaining)');
        _maxRequests = adjustedMax;
      }
    }
  }
  
  /// throttle ì‹¤í–‰
  Future<void> throttle(String path) async {
    final now = DateTime.now();
    
    // ì„œë²„ ì •ë³´ ê¸°ë°˜ ì¶”ê°€ ì²´í¬
    if (_shouldWaitForServerLimit(now)) {
      final waitTime = _calculateServerWaitTime(now);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for server rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
      }
    }
    
    // í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ë ˆì´íŠ¸ë¦¬ë°‹
    _cleanOldTimestamps(now);
    
    if (_timestamps.length >= _maxRequests) {
      final oldestTime = _timestamps.first;
      final waitTime = _period - now.difference(oldestTime);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for client rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
        _cleanOldTimestamps(DateTime.now());
      }
    }
    
    _timestamps.addLast(DateTime.now());
  }
  
  /// ì„œë²„ ì œí•œ ëŒ€ê¸° í•„ìš” ì—¬ë¶€
  bool _shouldWaitForServerLimit(DateTime now) {
    if (_serverRemaining == null || _serverUpdateTime == null || _serverWindow == null) {
      return false;
    }
    
    // ì„œë²„ ì •ë³´ê°€ 5ë¶„ ì´ìƒ ì˜¤ë˜ëìœ¼ë©´ ë¬´ì‹œ
    if (now.difference(_serverUpdateTime!).inMinutes > 5) {
      return false;
    }
    
    return _serverRemaining! <= 5; // ì„œë²„ ì”ì—¬ ìš”ì²­ì´ 5ê°œ ì´í•˜
  }
  
  /// ì„œë²„ ê¸°ë°˜ ëŒ€ê¸° ì‹œê°„ ê³„ì‚°
  Duration _calculateServerWaitTime(DateTime now) {
    if (_serverUpdateTime == null || _serverWindow == null) {
      return Duration.zero;
    }
    
    final elapsed = now.difference(_serverUpdateTime!);
    final remaining = _serverWindow! - elapsed;
    
    return remaining > Duration.zero ? remaining : Duration.zero;
  }
  
  /// ì˜¤ë˜ëœ íƒ€ì„ìŠ¤íƒ¬í”„ ì •ë¦¬
  void _cleanOldTimestamps(DateTime now) {
    while (_timestamps.isNotEmpty && 
           now.difference(_timestamps.first) > _period) {
      _timestamps.removeFirst();
    }
  }
  
  /// í†µê³„ ì •ë³´
  Map<String, dynamic> getStats() {
    return {
      'group': group,
      'maxRequests': _maxRequests,
      'period': _period.inSeconds,
      'currentRequests': _timestamps.length,
      'serverRemaining': _serverRemaining,
      'serverLastUpdate': _serverUpdateTime?.toIso8601String(),
      'availableSlots': _maxRequests - _timestamps.length,
    };
  }
  
  void dispose() {
    _timestamps.clear();
  }
}

/// In-memory cache entry with timestamp.
class _MemCacheEntry<T> {
  final T data;
  final DateTime ts;
  _MemCacheEntry(this.data) : ts = DateTime.now();

  bool fresh(Duration dur) => DateTime.now().difference(ts) < dur;
}

/// Simple LRU cache based on insertion order, with a maxEntries limit.
class _MemCache {
  final int maxEntries;
  final Map<String, _MemCacheEntry<dynamic>> _box;

  _MemCache({this.maxEntries = 100}) : _box = <String, _MemCacheEntry<dynamic>>{};

  T? get<T>(String key, Duration dur) {
    final entry = _box[key];
    if (entry == null || !entry.fresh(dur)) return null;
    return entry.data as T;
  }

  void put<T>(String key, T data) {
    if (_box.length >= maxEntries) {
      final oldestKey = _box.keys.first;
      _box.remove(oldestKey);
    }
    _box[key] = _MemCacheEntry<T>(data);
  }

  void invalidate(String key) => _box.remove(key);

  void clear() => _box.clear();
}

/// Converts a query map into a stable, sorted query string.
/// Silently skips values that cannot be represented.
String _stableQueryString(Json? query) {
  if (query == null || query.isEmpty) return '';
  try {
    final entries = query.entries
      .where((e) => e.value != null)
      .toList()
      ..sort((a, b) => a.key.compareTo(b.key));
    final params = <String, String>{};
    for (final e in entries) {
      final v = e.value;
      if (v is List) {
        params[e.key] = v.join(',');
      } else {
        params[e.key] = v.toString();
      }
    }
    return Uri(queryParameters: params).query;
  } catch (e, st) {
    log.e('StableQueryString failed', e, st);
    return '';
  }
}

/// ğŸ†• ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ë¥¼ íŒŒì‹±í•˜ëŠ” ì¸í„°ì…‰í„°
class _RateLimitResponseInterceptor extends Interceptor {
  final _UpbitDynamicRateLimiter rateLimiter;
  
  _RateLimitResponseInterceptor(this.rateLimiter);
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // ì—…ë¹„íŠ¸ ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ ì—…ë°ì´íŠ¸
    rateLimiter.updateFromHeaders(response.headers.map);
    handler.next(response);
  }
}

/// ğŸ”¥ ì™„ì „íˆ ì¬êµ¬í˜„ëœ ApiClient - ì—…ë¹„íŠ¸ ë°±ì„œ 100% ì¤€ìˆ˜
/// - ê·¸ë£¹ë³„ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ (ê³µê°œ 30rps / ì‚¬ì  8rps)
/// - Remaining-Req í—¤ë” ì‹¤ì‹œê°„ íŒŒì‹±
/// - ì„œë²„ ì‘ë‹µ ê¸°ë°˜ ë™ì  ìŠ¬ë¡¯ ì¡°ì •
class ApiClient {
  final Dio _dio;
  final _MemCache _cache;
  final _UpbitDynamicRateLimiter _rateLimiter;

  /// [apiKey], [apiSecret] ëŠ” Upbit Open API ìê²©ì¦ëª…
  ApiClient({
    Dio? dio,
    required String apiKey,
    required String apiSecret,
    int cacheSize = 100,
  })  : _dio = dio ?? Dio(),
        _cache = _MemCache(maxEntries: cacheSize),
        _rateLimiter = _UpbitDynamicRateLimiter() {
    _dio.interceptors.addAll([
      AuthInterceptor(apiKey: apiKey, apiSecret: apiSecret),
      RetryInterceptor(dio: _dio),
      LoggingInterceptor(),
      _RateLimitResponseInterceptor(_rateLimiter), // ğŸ†• ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ì¸í„°ì…‰í„°
    ]);
  }

  /// [method]: GET, POST ë“±
  /// [path]: ì „ì²´ URL ë˜ëŠ” baseUrl ì´í›„ ê²½ë¡œ
  /// [query]: URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
  /// [body]: JSON ë°”ë””
  /// [cacheDur]: nullì´ ì•„ë‹ ë•Œ ìºì‹œ ì‚¬ìš© (ê¸°ê°„ ì§€ì •)
  /// [rateLimitGroup]: ìˆ˜ë™ ê·¸ë£¹ ì§€ì • (ì„ íƒì )
  Future<Result<R, NetworkException>> request<R>({
    required String method,
    required String path,
    Json? query,
    Json? body,
    Duration? cacheDur,
    String? rateLimitGroup,
  }) async {
    // ğŸ”¥ ì—…ë¹„íŠ¸ ë°±ì„œ ê¸°ì¤€ ê·¸ë£¹ë³„ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ì ìš©
    final group = rateLimitGroup ?? AppConfig.getGroupFromPath(path);
    await _rateLimiter.throttle(group, path);

    String? cacheKey;
    if (cacheDur != null) {
      final qstr = _stableQueryString(query);
      cacheKey = '$method|$path|$qstr';
      final cached = _cache.get<R>(cacheKey, cacheDur);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      final response = await _dio.request<R>(
        path,
        queryParameters: query,
        data: body,
        options: Options(method: method),
      );

      final data = response.data;
      if (cacheKey != null && data != null) {
        _cache.put<R>(cacheKey, data as R);
      }

      return Ok(data as R);
    } on DioException catch (dioErr) {
      return Err(NetworkException.fromDio(dioErr));
    } catch (e, st) {
      log.e('ApiClient unexpected error', e, st);
      final ex = e is Exception ? e : Exception(e.toString());
      return Err(NetworkException(e.toString(), originalException: ex));
    }
  }
  
  /// ğŸ†• ë ˆì´íŠ¸ë¦¬ë°‹ ë””ë²„ê·¸ ì •ë³´ ì¡°íšŒ
  Map<String, dynamic> getRateLimitDebugInfo() {
    return _rateLimiter.getDebugInfo();
  }
  
  /// ğŸ†• ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _rateLimiter.dispose();
    _cache.clear();
  }
}\n\n// ====== lib/core/network/logging_interceptor.dart ======\n
// lib/core/network/logging_interceptor.dart

import 'dart:convert';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// ëª¨ë“  REST ìš”ì²­ê³¼ ì‘ë‹µ, ì˜¤ë¥˜ë¥¼ ë¡œê¹…í•©ë‹ˆë‹¤.
/// ğŸ”’ ë³´ì•ˆ: access_key, signature ë“± ë¯¼ê° ì •ë³´ ìë™ ë§ˆìŠ¤í‚¹
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(options.uri);
    log.i('--> ${options.method} $secureUri');
    
    // ğŸ”’ í—¤ë” ë³´ì•ˆ ë§ˆìŠ¤í‚¹ (Authorization í—¤ë”)
    if (options.headers.containsKey('Authorization')) {
      log.d('Headers: Authorization: Bearer ***[MASKED]***');
    }
    
    if (options.data != null && options.data is! String) {
      try {
        final sanitizedData = _sanitizeRequestData(options.data);
        log.d('Request Data:\n${const JsonEncoder.withIndent('  ').convert(sanitizedData)}');
      } catch (e, st) {
        log.d('Request Data serialization failed', e, st);
      }
    }
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(response.requestOptions.uri);
    log.i('<-- ${response.statusCode} $secureUri');
    
    final text = response.data is String
        ? response.data as String
        : response.data.toString();
    if (text.isNotEmpty) {
      log.d(text.length > 500 ? '${text.substring(0, 500)}...' : text);
    }
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(err.requestOptions.uri);
    log.e('<-- Error ${err.response?.statusCode} $secureUri', err, err.stackTrace);
    handler.next(err);
  }

  /// ğŸ”’ URIì—ì„œ ë¯¼ê° ì •ë³´ ë§ˆìŠ¤í‚¹
  String _sanitizeUri(Uri uri) {
    final uriString = uri.toString();
    return uriString
        .replaceAll(RegExp(r'access_key=[^&?#]+'), 'access_key=***')
        .replaceAll(RegExp(r'signature=[^&?#]+'), 'signature=***')
        .replaceAll(RegExp(r'nonce=[^&?#]+'), 'nonce=***')
        .replaceAll(RegExp(r'api_key=[^&?#]+'), 'api_key=***')
        .replaceAll(RegExp(r'secret=[^&?#]+'), 'secret=***');
  }

  /// ğŸ”’ ìš”ì²­ ë°ì´í„°ì—ì„œ ë¯¼ê° ì •ë³´ ë§ˆìŠ¤í‚¹
  dynamic _sanitizeRequestData(dynamic data) {
    if (data is Map<String, dynamic>) {
      final sanitized = <String, dynamic>{};
      for (final entry in data.entries) {
        final key = entry.key.toLowerCase();
        if (_isSensitiveKey(key)) {
          sanitized[entry.key] = '***[MASKED]***';
        } else {
          sanitized[entry.key] = _sanitizeRequestData(entry.value);
        }
      }
      return sanitized;
    } else if (data is List) {
      return data.map((item) => _sanitizeRequestData(item)).toList();
    }
    return data;
  }

  /// ğŸ”’ ë¯¼ê°í•œ í‚¤ íŒë³„
  bool _isSensitiveKey(String key) {
    const sensitiveKeys = {
      'access_key', 'accesskey', 'api_key', 'apikey',
      'secret', 'signature', 'nonce', 'password', 
      'token', 'auth', 'authorization'
    };
    return sensitiveKeys.contains(key);
  }
}\n\n// ====== lib/core/navigation/app_router.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../config/app_config.dart';
import '../../shared/widgets/notification_service.dart';
import '../../presentation/pages/main_page.dart'; // ğŸ†• MainPage ì‚¬ìš©

/// ğŸ—‘ï¸ ê°œë³„ ë¼ìš°íŠ¸ enum ì œê±° (ì´ì œ MainPageì—ì„œ ê´€ë¦¬)
// enum AppRouteëŠ” ë” ì´ìƒ í•„ìš” ì—†ìŒ

class AppRouter {
  final WidgetRef ref;
  final GlobalKey<NavigatorState> navigatorKey;
  late final GoRouter router;

  AppRouter(this.ref, this.navigatorKey) {
    router = GoRouter(
      navigatorKey: navigatorKey,
      initialLocation: '/', // ë©”ì¸ í˜ì´ì§€ë¡œ ì‹œì‘
      debugLogDiagnostics: AppConfig.isDebugMode,
      routes: [
        // ğŸ†• ë‹¨ì¼ ë©”ì¸ ë¼ìš°íŠ¸ (PageView ê¸°ë°˜)
        GoRoute(
          path: '/',
          name: 'main',
          builder: (context, state) => const MainPage(),
        ),
        
        // ğŸ”§ í•„ìš”ì‹œ ì¶”ê°€ ë¼ìš°íŠ¸ë“¤ (ì„¤ì •, ìƒì„¸ í˜ì´ì§€ ë“±)
        // GoRoute(
        //   path: '/detail/:id',
        //   name: 'detail',
        //   builder: (context, state) => DetailPage(id: state.params['id']!),
        // ),
      ],
    );
  }

  /// ğŸ”§ Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (NotificationServiceì— ìœ„ì„)
  void setupFCMListeners() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.setupFirebaseListeners(navigatorKey);
  }

  /// ğŸ”§ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (NotificationServiceì— ìœ„ì„)
  void dispose() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.dispose();
  }
}\n\n// ====== lib/core/utils/pattern_config.dart ======\n
import '../../domain/entities/signal.dart';

/// ğŸ¯ PatternConfig - íŒ¨í„´ë³„ ì„¤ì •ê°’ ê´€ë¦¬
/// 
/// ê°œì„ ì‚¬í•­:
/// - 4,5ë²ˆ íŒ¨í„´ ì™„í™”ëœ ì„¤ì •ê°’ ì ìš©
/// - íŒ¨í„´ë³„ ê°œë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ê´€ë¦¬
/// - ì„¤ì •ê°’ ìœ íš¨ì„± ê²€ì‚¬
/// - ëŸ°íƒ€ì„ ì„¤ì • ë³€ê²½ ì§€ì›
class PatternConfig {
  
  /// ğŸ“Š íŒ¨í„´ë³„ ê¸°ë³¸ ì„¤ì •ê°’ (4,5ë²ˆ íŒ¨í„´ ì™„í™”ë¨)
  static const Map<PatternType, Map<String, double>> _defaultConfig = {
    PatternType.surge: {
      'priceChangePercent': 0.4,       // ê°€ê²© ë³€ë™ë¥  0.4%
      'zScoreThreshold': 1.7,          // Z-score ì„ê³„ê°’
      'minTradeAmount': 2500000,       // ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ (250ë§Œ)
      'lvThreshold': 500,              // Liquidity Vortex
    },
    
    PatternType.flashFire: {
      'zScoreThreshold': 2.2,          // Z-score ì„ê³„ê°’
      'minTradeAmount': 10000000,      // ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ (1000ë§Œ)
      'buyRatioMin': 0.7,              // ë§¤ìˆ˜ ë¹„ìœ¨
      'volumeMultiplier': 2.0,         // ê±°ë˜ëŸ‰ ë°°ìˆ˜
      'mbrThreshold': 0.12,            // Micro Burst Radar
      'mrThreshold': 0.15,             // Machine Rush
    },
    
    PatternType.stackUp: {
      'consecutiveMin': 2,             // ìµœì†Œ ì—°ì† íšŸìˆ˜
      'minVolume': 5000000,            // ìµœì†Œ ê±°ë˜ëŸ‰ (500ë§Œ)
      'zScoreThreshold': 1.0,          // Z-score ì„ê³„ê°’
      'volumeMultiplier': 1.5,         // ê±°ë˜ëŸ‰ ë°°ìˆ˜
      'rSquaredMin': 0.35,             // RÂ² ìµœì†Œê°’
    },
    
    // ğŸ†• StealthIn íŒ¨í„´ - ì™„í™”ëœ ì„¤ì • (ê°ì§€ìœ¨ í–¥ìƒ)
    PatternType.stealthIn: {
      'minTradeAmount': 5000000,       // 2000ë§Œ â†’ 500ë§Œ (ëŒ€í­ ì™„í™”)
      'intervalVarianceMax': 900,      // ê±°ë˜ ê°„ê²© ë¶„ì‚° ìµœëŒ€ê°’
      'buyRatioMin': 0.6,              // 0.7 â†’ 0.6 (ì™„í™”)
      'avgTradeSizeRatio': 0.4,        // í‰ê·  ê±°ë˜ í¬ê¸° ë¹„ìœ¨
      'minTradeCount': 20,             // ìµœì†Œ ê±°ë˜ íšŸìˆ˜
      'cvThreshold': 0.05,             // ë³€ë™ê³„ìˆ˜ ì„ê³„ê°’ (5%)
    },
    
    // ğŸ†• BlackHole íŒ¨í„´ - ì™„í™”ëœ ì„¤ì • (ê°ì§€ìœ¨ í–¥ìƒ)
    PatternType.blackHole: {
      'minTradeAmount': 10000000,      // 5000ë§Œ â†’ 1000ë§Œ (ëŒ€í­ ì™„í™”)
      'cvThreshold': 0.02,             // 0.01 â†’ 0.02 (ì™„í™”)
      'buyRatioMin': 0.35,             // 0.4 â†’ 0.35 (ì™„í™”)
      'buyRatioMax': 0.65,             // 0.6 â†’ 0.65 (ì™„í™”)
      'priceZScoreMax': 1.0,           // ê°€ê²© Z-score ìµœëŒ€ê°’
      'stdDevRatio': 0.02,             // í‘œì¤€í¸ì°¨ ë¹„ìœ¨ (2%)
    },
    
    PatternType.reboundShot: {
      'minVolume': 1000000,            // ìµœì†Œ ê±°ë˜ëŸ‰ (100ë§Œ)
      'priceRangeMin': 0.005,          // ìµœì†Œ ê°€ê²© ë²”ìœ„ (0.5%)
      'jumpThreshold': 0,              // Jump Gate ì„ê³„ê°’
    },
  };

  /// ğŸ”’ íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ (ì„±ëŠ¥ ìµœì í™”)
  static const Map<PatternType, Duration> _cooldownPeriods = {
    PatternType.surge: Duration(seconds: 2),        // ë¹ ë¥¸ íŒ¨í„´
    PatternType.flashFire: Duration(seconds: 3),    // ì¤‘ê°„ íŒ¨í„´
    PatternType.stackUp: Duration(seconds: 4),      // ì¤‘ê°„ íŒ¨í„´
    PatternType.stealthIn: Duration(seconds: 8),    // ëŠë¦° íŒ¨í„´ (ë§¤ì§‘ íŠ¹ì„±ìƒ)
    PatternType.blackHole: Duration(seconds: 10),   // ê°€ì¥ ëŠë¦° íŒ¨í„´ (ê°‡í˜ íŠ¹ì„±ìƒ)
    PatternType.reboundShot: Duration(seconds: 3),  // ì¤‘ê°„ íŒ¨í„´
  };

  /// í˜„ì¬ ì„¤ì •ê°’ (ëŸ°íƒ€ì„ ë³€ê²½ ê°€ëŠ¥)
  final Map<PatternType, Map<String, double>> _currentConfig;
  
  /// ìƒì„±ì
  PatternConfig({Map<PatternType, Map<String, double>>? customConfig}) 
    : _currentConfig = customConfig != null 
        ? Map.from(customConfig)
        : _deepCopyConfig(_defaultConfig);

  /// íŒ¨í„´ë³„ ì„¤ì •ê°’ ì¡°íšŒ
  Map<String, double> getPatternConfig(PatternType pattern) {
    return Map.from(_currentConfig[pattern] ?? <String, double>{});
  }

  /// íŠ¹ì • ì„¤ì •ê°’ ì¡°íšŒ
  double getConfigValue(PatternType pattern, String key) {
    return _currentConfig[pattern]?[key] ?? 0.0;
  }

  /// íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ì¡°íšŒ
  Duration getCooldownDuration(PatternType pattern) {
    return _cooldownPeriods[pattern] ?? const Duration(seconds: 5);
  }

  /// ğŸ› ï¸ ëŸ°íƒ€ì„ ì„¤ì • ë³€ê²½
  
  /// íŠ¹ì • íŒ¨í„´ì˜ ì„¤ì •ê°’ ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    if (_isValidConfigValue(pattern, key, value)) {
      _currentConfig[pattern] ??= <String, double>{};
      _currentConfig[pattern]![key] = value;
    } else {
      throw ArgumentError('Invalid config value: $key = $value for pattern ${pattern.name}');
    }
  }

  /// íŒ¨í„´ì˜ ì „ì²´ ì„¤ì • ì—…ë°ì´íŠ¸
  void updateFullPatternConfig(PatternType pattern, Map<String, double> config) {
    // ìœ íš¨ì„± ê²€ì‚¬
    for (final entry in config.entries) {
      if (!_isValidConfigValue(pattern, entry.key, entry.value)) {
        throw ArgumentError('Invalid config value: ${entry.key} = ${entry.value} for pattern ${pattern.name}');
      }
    }
    
    _currentConfig[pattern] = Map.from(config);
  }

  /// ì„¤ì •ê°’ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  void resetToDefault(PatternType? pattern) {
    if (pattern != null) {
      _currentConfig[pattern] = Map.from(_defaultConfig[pattern] ?? <String, double>{});
    } else {
      _currentConfig.clear();
      _currentConfig.addAll(_deepCopyConfig(_defaultConfig));
    }
  }

  /// ğŸ” ì„¤ì •ê°’ ìœ íš¨ì„± ê²€ì‚¬
  bool _isValidConfigValue(PatternType pattern, String key, double value) {
    // ìŒìˆ˜ ê°’ ë°©ì§€
    if (value < 0) return false;
    
    // íŒ¨í„´ë³„ íŠ¹ìˆ˜ ê²€ì‚¬
    switch (pattern) {
      case PatternType.surge:
        if (key == 'priceChangePercent' && (value < 0.1 || value > 10.0)) return false;
        if (key == 'zScoreThreshold' && (value < 0.5 || value > 5.0)) return false;
        break;
        
      case PatternType.flashFire:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'volumeMultiplier' && (value < 1.0 || value > 10.0)) return false;
        break;
        
      case PatternType.stackUp:
        if (key == 'consecutiveMin' && (value < 1 || value > 10)) return false;
        if (key == 'rSquaredMin' && (value < 0.0 || value > 1.0)) return false;
        break;
        
      case PatternType.stealthIn:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'cvThreshold' && (value < 0.001 || value > 0.5)) return false;
        break;
        
      case PatternType.blackHole:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'buyRatioMax' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'cvThreshold' && (value < 0.001 || value > 0.5)) return false;
        break;
        
      case PatternType.reboundShot:
        if (key == 'priceRangeMin' && (value < 0.001 || value > 0.5)) return false;
        break;
    }
    
    return true;
  }

  /// ì„¤ì • ê¹Šì€ ë³µì‚¬
  static Map<PatternType, Map<String, double>> _deepCopyConfig(
    Map<PatternType, Map<String, double>> source
  ) {
    final result = <PatternType, Map<String, double>>{};
    for (final entry in source.entries) {
      result[entry.key] = Map.from(entry.value);
    }
    return result;
  }

  /// ğŸ“Š ì„¤ì •ê°’ ì •ë³´ ì¡°íšŒ
  
  /// ëª¨ë“  íŒ¨í„´ì˜ ì„¤ì •ê°’ ì¡°íšŒ
  Map<PatternType, Map<String, double>> getAllPatternConfigs() {
    return _deepCopyConfig(_currentConfig);
  }

  /// ê¸°ë³¸ê°’ê³¼ í˜„ì¬ê°’ ë¹„êµ
  Map<String, dynamic> getConfigComparison(PatternType pattern) {
    final current = _currentConfig[pattern] ?? <String, double>{};
    final defaultValues = _defaultConfig[pattern] ?? <String, double>{};
    
    final comparison = <String, Map<String, double>>{};
    final allKeys = <String>{...current.keys, ...defaultValues.keys};
    
    for (final key in allKeys) {
      comparison[key] = {
        'current': current[key] ?? 0.0,
        'default': defaultValues[key] ?? 0.0,
        'isModified': (current[key] ?? 0.0) != (defaultValues[key] ?? 0.0) ? 1.0 : 0.0,
      };
    }
    
    return {
      'pattern': pattern.name,
      'cooldownSeconds': getCooldownDuration(pattern).inSeconds,
      'configs': comparison,
      'totalModified': comparison.values
          .where((v) => v['isModified'] == 1.0)
          .length,
    };
  }

  /// ì„¤ì • ìš”ì•½ ì •ë³´
  Map<String, dynamic> getConfigSummary() {
    final summary = <String, dynamic>{
      'version': '4.0',
      'totalPatterns': PatternType.values.length,
      'enhancedPatterns': ['stealthIn', 'blackHole'], // ì™„í™”ëœ íŒ¨í„´ë“¤
    };
    
    // íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„
    final cooldowns = <String, String>{};
    for (final pattern in PatternType.values) {
      cooldowns[pattern.name] = '${getCooldownDuration(pattern).inSeconds}s';
    }
    summary['cooldownPeriods'] = cooldowns;
    
    // ë³€ê²½ëœ ì„¤ì •ê°’ ê°œìˆ˜
    int totalModified = 0;
    for (final pattern in PatternType.values) {
      final current = _currentConfig[pattern] ?? <String, double>{};
      final defaultValues = _defaultConfig[pattern] ?? <String, double>{};
      
      for (final key in current.keys) {
        if (current[key] != defaultValues[key]) {
          totalModified++;
        }
      }
    }
    summary['totalModifiedConfigs'] = totalModified;
    
    // ì™„í™”ëœ ì„¤ì •ê°’ë“¤ (4,5ë²ˆ íŒ¨í„´)
    summary['relaxedSettings'] = {
      'stealthIn': {
        'minTradeAmount': '2000ë§Œ â†’ 500ë§Œ (75% ì™„í™”)',
        'buyRatioMin': '0.7 â†’ 0.6 (14% ì™„í™”)',
        'cvThreshold': 'ì¶”ê°€ë¨ (5%)',
      },
      'blackHole': {
        'minTradeAmount': '5000ë§Œ â†’ 1000ë§Œ (80% ì™„í™”)',
        'cvThreshold': '1% â†’ 2% (100% ì™„í™”)',
        'buyRatioRange': '40-60% â†’ 35-65% (25% í™•ëŒ€)',
      },
    };
    
    return summary;
  }

  /// ğŸ¯ í”„ë¦¬ì…‹ ì„¤ì •

  /// ë³´ìˆ˜ì  ì„¤ì • (False Positive ìµœì†Œí™”)
  void applyConservativePreset() {
    // Surge íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.surge, 'priceChangePercent', 0.6);
    updatePatternConfig(PatternType.surge, 'zScoreThreshold', 2.0);
    
    // FlashFire íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.flashFire, 'zScoreThreshold', 2.5);
    updatePatternConfig(PatternType.flashFire, 'buyRatioMin', 0.75);
    
    // StackUp íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.stackUp, 'consecutiveMin', 3);
    updatePatternConfig(PatternType.stackUp, 'rSquaredMin', 0.5);
    
    // StealthIn íŒ¨í„´ ê°•í™” (í•˜ì§€ë§Œ ì—¬ì „íˆ ê¸°ì¡´ë³´ë‹¤ëŠ” ì™„í™”)
    updatePatternConfig(PatternType.stealthIn, 'minTradeAmount', 8000000); // 800ë§Œ
    updatePatternConfig(PatternType.stealthIn, 'buyRatioMin', 0.65);
    
    // BlackHole íŒ¨í„´ ê°•í™” (í•˜ì§€ë§Œ ì—¬ì „íˆ ê¸°ì¡´ë³´ë‹¤ëŠ” ì™„í™”)
    updatePatternConfig(PatternType.blackHole, 'minTradeAmount', 15000000); // 1500ë§Œ
    updatePatternConfig(PatternType.blackHole, 'cvThreshold', 0.015);
  }

  /// ê³µê²©ì  ì„¤ì • (ê°ì§€ìœ¨ ìµœëŒ€í™”)
  void applyAggressivePreset() {
    // Surge íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.surge, 'priceChangePercent', 0.3);
    updatePatternConfig(PatternType.surge, 'zScoreThreshold', 1.5);
    
    // FlashFire íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.flashFire, 'zScoreThreshold', 2.0);
    updatePatternConfig(PatternType.flashFire, 'buyRatioMin', 0.65);
    
    // StackUp íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.stackUp, 'consecutiveMin', 2);
    updatePatternConfig(PatternType.stackUp, 'rSquaredMin', 0.25);
    
    // StealthIn íŒ¨í„´ ìµœëŒ€ ì™„í™”
    updatePatternConfig(PatternType.stealthIn, 'minTradeAmount', 3000000); // 300ë§Œ
    updatePatternConfig(PatternType.stealthIn, 'buyRatioMin', 0.55);
    
    // BlackHole íŒ¨í„´ ìµœëŒ€ ì™„í™”
    updatePatternConfig(PatternType.blackHole, 'minTradeAmount', 5000000); // 500ë§Œ
    updatePatternConfig(PatternType.blackHole, 'cvThreshold', 0.03);
    updatePatternConfig(PatternType.blackHole, 'buyRatioMin', 0.3);
    updatePatternConfig(PatternType.blackHole, 'buyRatioMax', 0.7);
  }

  /// ê· í˜• ì„¤ì • (ê¸°ë³¸ê°’)
  void applyBalancedPreset() {
    resetToDefault(null); // ëª¨ë“  íŒ¨í„´ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  }

  /// ğŸ§ª ë°±í…ŒìŠ¤íŒ…ìš© ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  
  /// ì„¤ì •ì„ JSON í˜•íƒœë¡œ ë‚´ë³´ë‚´ê¸°
  Map<String, dynamic> exportConfig() {
    final export = <String, dynamic>{
      'version': '4.0',
      'timestamp': DateTime.now().toIso8601String(),
      'patterns': <String, dynamic>{},
    };
    
    for (final pattern in PatternType.values) {
      export['patterns'][pattern.name] = {
        'config': getPatternConfig(pattern),
        'cooldownSeconds': getCooldownDuration(pattern).inSeconds,
      };
    }
    
    return export;
  }

  /// JSONì—ì„œ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  void importConfig(Map<String, dynamic> configData) {
    if (configData['version'] != '4.0') {
      throw ArgumentError('Unsupported config version: ${configData['version']}');
    }
    
    final patterns = configData['patterns'] as Map<String, dynamic>?;
    if (patterns == null) return;
    
    for (final pattern in PatternType.values) {
      final patternData = patterns[pattern.name] as Map<String, dynamic>?;
      if (patternData == null) continue;
      
      final config = patternData['config'] as Map<String, dynamic>?;
      if (config == null) continue;
      
      // double íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì„¤ì • ì ìš©
      final doubleConfig = <String, double>{};
      for (final entry in config.entries) {
        if (entry.value is num) {
          doubleConfig[entry.key] = (entry.value as num).toDouble();
        }
      }
      
      if (doubleConfig.isNotEmpty) {
        updateFullPatternConfig(pattern, doubleConfig);
      }
    }
  }

  /// ğŸ¯ A/B í…ŒìŠ¤íŠ¸ìš© ì„¤ì • ë³€í˜•
  
  /// íŠ¹ì • íŒ¨í„´ë§Œ ì¡°ì •í•œ ë³€í˜• ìƒì„±
  PatternConfig createVariant({
    PatternType? targetPattern,
    String? targetKey,
    double? multiplier,
  }) {
    if (targetPattern == null || targetKey == null || multiplier == null) {
      return PatternConfig(customConfig: getAllPatternConfigs());
    }
    
    final variantConfig = getAllPatternConfigs();
    final currentValue = getConfigValue(targetPattern, targetKey);
    
    if (currentValue > 0) {
      variantConfig[targetPattern] ??= <String, double>{};
      variantConfig[targetPattern]![targetKey] = currentValue * multiplier;
    }
    
    return PatternConfig(customConfig: variantConfig);
  }
}\n\n// ====== lib/core/utils/pattern_strategies.dart ======\n
\n\n// ====== lib/core/utils/date_time.dart ======\n
import 'package:intl/intl.dart';

/// DateTime extension utilities for formatting and comparison.
extension DateTimeX on DateTime {
  /// `2024-05-17 22:05:01` â†’ `22:05:01`
  String hhmmss() => DateFormat('HH:mm:ss').format(this);

  /// `2024-05-17` í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMdd() => DateFormat('yyyy-MM-dd').format(this);

  /// `22:05` í˜•ì‹ì˜ ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String hhmm() => DateFormat('HH:mm').format(this);

  /// `2024-05-17 22:05` í˜•ì‹ì˜ ë‚ ì§œ+ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMddhhmm() => DateFormat('yyyy-MM-dd HH:mm').format(this);

  /// í˜„ì¬ ì‹œê°„ê³¼ì˜ ì°¨ì´ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ í‘œì‹œ
  /// ì˜ˆ: 'ë°©ê¸ˆ ì „', '3ë¶„ ì „', '2ì‹œê°„ ì „', 'ì–´ì œ', '3ì¼ ì „', '2ì£¼ ì „', '5ê°œì›” ì „', '1ë…„ ì „'
  String timeAgo() {
    final now = DateTime.now();
    final diff = now.difference(this);

    if (diff.inSeconds < 60) return 'ë°©ê¸ˆ ì „';
    if (diff.inMinutes < 60) return '${diff.inMinutes}ë¶„ ì „';
    if (diff.inHours < 24) return '${diff.inHours}ì‹œê°„ ì „';
    if (diff.inDays < 2) return 'ì–´ì œ';
    if (diff.inDays < 7) return '${diff.inDays}ì¼ ì „';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}ì£¼ ì „';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}ê°œì›” ì „';
    return '${(diff.inDays / 365).floor()}ë…„ ì „';
  }

  /// UTC ë°€ë¦¬ì´ˆ(ms)ë¥¼ ë¡œì»¬ DateTimeìœ¼ë¡œ ë³€í™˜
  static DateTime fromEpochMs(int ms) =>
      DateTime.fromMillisecondsSinceEpoch(ms, isUtc: true).toLocal();

  /// ISO 8601 ë¬¸ìì—´ì„ ë¡œì»¬ DateTimeìœ¼ë¡œ íŒŒì‹±
  static DateTime parseIso8601(String iso) =>
      DateTime.parse(iso).toLocal();

  /// ë™ì¼í•œ ë‚ ì§œì¸ì§€ í™•ì¸
  bool isSameDay(DateTime other) =>
      year == other.year && month == other.month && day == other.day;

  /// ì˜¤ëŠ˜ì¸ì§€ í™•ì¸
  bool get isToday => isSameDay(DateTime.now());

  /// ì–´ì œì¸ì§€ í™•ì¸
  bool get isYesterday =>
      isSameDay(DateTime.now().subtract(const Duration(days: 1)));
}
\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';
import '../config/app_config.dart';

/// ê¸€ë¡œë²Œ Logger ì¸ìŠ¤í„´ìŠ¤
/// - ê°œë°œ ëª¨ë“œ: AppConfig.logLevelì— ë”°ë¼ ë™ì  ì¡°ì ˆ
/// - í”„ë¡œë•ì…˜ëª¨ë“œ: warning ì´ìƒ ìë™
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 0,      // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    errorMethodCount: 5, // ì˜¤ë¥˜ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120,     // ë¡œê·¸ í•œ ì¤„ ìµœëŒ€ ê¸¸ì´
    colors: true,        // ì»¬ëŸ¬ ì¶œë ¥ (í„°ë¯¸ë„)
    printTime: true,     // íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
  ),
  level: AppConfig.logLevel, // ğŸ”¥ í™˜ê²½ë³€ìˆ˜ë¡œ ë™ì  ì¡°ì ˆ ê°€ëŠ¥
);\n\n// ====== lib/core/utils/pattern_detector copy.dart ======\n
\n\n// ====== lib/core/utils/pattern_detector.dart ======\n
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import 'advanced_metrics.dart';
import 'pattern_config.dart';
import 'market_data_context.dart';

/// ğŸš€ PatternDetector V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// 1. âœ… OnlineAdvancedMetrics ì‚¬ìš©ìœ¼ë¡œ O(1) ì§€í‘œ ê³„ì‚°
/// 2. âœ… ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë³µêµ¬
/// 3. âœ… ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚°
/// 4. âœ… ì‹œí•œí­íƒ„ ë¬¸ì œ ì™„ì „ í•´ê²°
/// 5. âœ… ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜ì„± ìœ ì§€
class PatternDetector {
  final PatternConfig _config;
  final AdvancedMetrics _metrics;
  
  // ğŸ”’ ì¿¨ë‹¤ìš´ ì‹œìŠ¤í…œ (ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë³€ê²½)
  final Map<String, DateTime> _lastSignalTime = {};
  
  PatternDetector({
    PatternConfig? config,
    AdvancedMetrics? metrics,
  }) : _config = config ?? PatternConfig(),
        _metrics = metrics ?? AdvancedMetrics();

  /// ğŸ¯ ë©”ì¸ ê°ì§€ í•¨ìˆ˜ - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
  Signal? detectPattern({
    required PatternType patternType,
    required Trade trade,
    required DateTime timestamp,
    required MarketDataContext context,
  }) {
    // ğŸ”¥ ë¨¼ì € ì˜¨ë¼ì¸ ì§€í‘œ ì—…ë°ì´íŠ¸ (O(1))
    _metrics.updatePrice(
      market: trade.market,
      price: trade.price,
      timestamp: timestamp,
    );
    
    // ğŸ”’ ì¿¨ë‹¤ìš´ ì²´í¬
    if (_isInCooldown(trade.market, patternType, timestamp)) {
      return null;
    }
    
    Signal? signal;
    
    // íŒ¨í„´ë³„ ê°ì§€ ë¡œì§
    switch (patternType) {
      case PatternType.surge:
        signal = _detectSurge(trade, timestamp, context);
        break;
      case PatternType.flashFire:
        signal = _detectFlashFire(trade, timestamp, context);
        break;
      case PatternType.stackUp:
        signal = _detectStackUp(trade, timestamp, context);
        break;
      case PatternType.stealthIn:
        signal = _detectStealthIn(trade, timestamp, context);
        break;
      case PatternType.blackHole:
        signal = _detectBlackHole(trade, timestamp, context);
        break;
      case PatternType.reboundShot:
        signal = _detectReboundShot(trade, timestamp, context);
        break;
    }
    
    if (signal != null) {
      // ğŸ”’ ì¿¨ë‹¤ìš´ ë“±ë¡
      _updateCooldown(trade.market, patternType, timestamp);
      
      // ğŸ†• ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
      signal = _adjustSignalConfidence(signal, context);
    }
    
    return signal;
  }

  /// ğŸ”’ ì¿¨ë‹¤ìš´ ì²´í¬ (íŒ¨í„´ë³„ ê°œë³„ ì¿¨ë‹¤ìš´)
  bool _isInCooldown(String market, PatternType pattern, DateTime timestamp) {
    final cooldownKey = '$market-${pattern.name}';
    final lastTime = _lastSignalTime[cooldownKey];
    if (lastTime == null) return false;
    
    final cooldownDuration = _config.getCooldownDuration(pattern);
    return timestamp.difference(lastTime) < cooldownDuration;
  }
  
  /// ğŸ”’ ì¿¨ë‹¤ìš´ ë“±ë¡
  void _updateCooldown(String market, PatternType pattern, DateTime timestamp) {
    final cooldownKey = '$market-${pattern.name}';
    _lastSignalTime[cooldownKey] = timestamp;
  }

  /// ğŸ¯ 1. Surge íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectSurge(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 60));
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (priceWindow.length < 2 || volumeWindow.isEmpty) return null;

    final config = _config.getPatternConfig(PatternType.surge);
    final currentPrice = trade.price;
    final prevPrice = priceWindow.values[1];
    final changePercent = prevPrice == 0 ? 0.0 : ((currentPrice - prevPrice) / prevPrice) * 100;
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final zScore = priceWindow.zScore(currentPrice);
    final conditions = [
      changePercent.abs() >= config['priceChangePercent']!,
      zScore.abs() >= config['zScoreThreshold']!,
      volumeWindow.sum >= config['minTradeAmount']!,
    ];
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œ ì‚¬ìš© (O(1) ë³µì¡ë„)
    final rsi = _metrics.calculateRSI(market: trade.market);
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ê³ ê¸‰ ì§€í‘œ
    final lv = _metrics.calculateLiquidityVortex(priceWindow, volumeWindow);
    final flashPulse = _metrics.calculateFlashPulse(trade.total, volumeWindow);
    
    final advancedConditions = [
      lv >= config['lvThreshold']!,
      flashPulse > 0,
      // ğŸ†• ì˜¨ë¼ì¸ RSI/MACD ì¡°ê±´ ì¶”ê°€
      _isValidRSIForDirection(rsi, changePercent),
      macd.histogram.abs() > 0.1, // MACD ëª¨ë©˜í…€ ì²´í¬
    ];
    
    if (!conditions.every((c) => c) || !advancedConditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: currentPrice,
      changePercent: changePercent,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.surge,
      patternDetails: {
        'changePercent': changePercent,
        'zScore': zScore,
        'liquidityVortex': lv,
        'flashPulse': flashPulse,
        'rsi': rsi,
        'macd': macd.macd,
        'macdSignal': macd.signal,
        'macdHistogram': macd.histogram,
        'confidence': 0.8,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 2. FlashFire íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectFlashFire(Trade trade, DateTime timestamp, MarketDataContext context) {
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    final buyRatioWindow = context.buyRatioWindow;
    
    if (volumeWindow.length < 10 || buyRatioWindow == null) return null;
    
    final config = _config.getPatternConfig(PatternType.flashFire);
    final volumeZScore = volumeWindow.zScore(trade.total);
    final buyRatio = buyRatioWindow.mean;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final conditions = [
      volumeZScore >= config['zScoreThreshold']!,
      volumeWindow.sum >= config['minTradeAmount']!,
      buyRatio >= config['buyRatioMin']!,
      // ğŸ†• RSI ì˜¤ë²„ë°”ì‰/ì˜¤ë²„ì…€ë§ ë°©ì§€
      rsi > 20 && rsi < 80,
    ];
    
    // ê³ ê¸‰ ì§€í‘œ
    final microBurst = _metrics.calculateMicroBurstRadar(trade.total, volumeWindow);
    final machineRush = _metrics.calculateMachineRush(trade.total, volumeWindow.sum);
    
    final advancedConditions = [
      microBurst >= config['mbrThreshold']!,
      machineRush >= config['mrThreshold']!,
    ];
    
    if (!conditions.every((c) => c) || !advancedConditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.flashFire,
      patternDetails: {
        'volumeZScore': volumeZScore,
        'buyRatio': buyRatio,
        'microBurstRadar': microBurst,
        'machineRush': machineRush,
        'rsi': rsi,
        'confidence': 0.85,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 3. StackUp íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectStackUp(Trade trade, DateTime timestamp, MarketDataContext context) {
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (volumeWindow.length < 4) return null;
    
    final config = _config.getPatternConfig(PatternType.stackUp);
    final consecutiveCount = volumeWindow.consecutiveIncreases;
    final volumeZScore = volumeWindow.zScore(trade.total);
    
    // ğŸ”¥ ì˜¨ë¼ì¸ MACD ì²´í¬
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final conditions = [
      consecutiveCount >= config['consecutiveMin']!,
      volumeWindow.sum >= config['minVolume']!,
      volumeZScore >= config['zScoreThreshold']!,
      // ğŸ†• MACD ìƒìŠ¹ ëª¨ë©˜í…€ ì²´í¬
      macd.histogram > 0, // MACD íˆìŠ¤í† ê·¸ë¨ ìƒìŠ¹
    ];
    
    // ì¶”ì„¸ ë¶„ì„
    final slope = volumeWindow.slope;
    final rSquared = volumeWindow.rSquared;
    final trendOk = slope > 0 && rSquared > config['rSquaredMin']!;
    
    if (!conditions.every((c) => c) || !trendOk) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.stackUp,
      patternDetails: {
        'consecutiveCount': consecutiveCount,
        'slope': slope,
        'rSquared': rSquared,
        'volumeZScore': volumeZScore,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.75,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 4. StealthIn íŒ¨í„´ ê°ì§€ (ì™„í™”ëœ ì„¤ì • + ì˜¨ë¼ì¸ ì§€í‘œ)
  Signal? _detectStealthIn(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 300)); // ì¥ê¸° ìœˆë„ìš° ì‚¬ìš©
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 300));
    final buyRatioWindow = context.buyRatioWindow;
    final intervalWindow = context.intervalWindow;
    
    if (volumeWindow.length < 15 || buyRatioWindow == null || intervalWindow == null) {
      return null;
    }
    
    final config = _config.getPatternConfig(PatternType.stealthIn);
    final totalAmount = volumeWindow.sum;
    final buyRatio = buyRatioWindow.mean;
    final priceStability = 1.0 - priceWindow.cv; // ë³€ë™ê³„ìˆ˜ì˜ ì—­ìˆ˜
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI - ì¤‘ë¦½ êµ¬ê°„ ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    
    // ğŸ†• ì™„í™”ëœ ì¡°ê±´ë“¤ + RSI ì²´í¬
    final conditions = [
      // "ì¡°ìš©íˆ ë§¤ì§‘" - ê°€ê²© ì•ˆì •ì„±
      priceStability >= 0.95, // CVê°€ 5% ì´í•˜
      priceWindow.zScore(trade.price).abs() <= 1.0,
      
      // "ê¾¸ì¤€í•œ ë§¤ìˆ˜" - ì™„í™”ëœ ì„ê³„ê°’ë“¤  
      buyRatio >= config['buyRatioMin']!, // 0.6 (ê¸°ì¡´ 0.7ì—ì„œ ì™„í™”)
      totalAmount >= config['minTradeAmount']!, // 500ë§Œ (ê¸°ì¡´ 2000ë§Œì—ì„œ ì™„í™”)
      volumeWindow.length >= config['minTradeCount']!,
      
      // "ê±°ë˜ ê°„ê²© ì¼ì •"
      intervalWindow.variance <= config['intervalVarianceMax']!,
      
      // ğŸ†• RSI ì¤‘ë¦½ êµ¬ê°„ (ì¡°ìš©í•œ ë§¤ì§‘ì‹œ ê·¹ë‹¨ê°’ íšŒí”¼)
      rsi >= 30 && rsi <= 70,
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: totalAmount,
      detectedAt: timestamp,
      patternType: PatternType.stealthIn,
      patternDetails: {
        'totalAmount': totalAmount,
        'buyRatio': buyRatio,
        'priceStability': priceStability,
        'tradeCount': volumeWindow.length,
        'rsi': rsi,
        'confidence': 0.7,
        'enhancement': 'V4.1 - Online + Relaxed Thresholds',
      },
    );
  }

  /// ğŸ¯ 5. BlackHole íŒ¨í„´ ê°ì§€ (ì™„í™”ëœ ì„¤ì • + ì˜¨ë¼ì¸ ì§€í‘œ)
  Signal? _detectBlackHole(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 300)); // ì¥ê¸° ìœˆë„ìš° ì‚¬ìš©
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 300));
    final buyRatioWindow = context.buyRatioWindow;
    
    if (priceWindow.length < 10 || volumeWindow.length < 10 || buyRatioWindow == null) {
      return null;
    }
    
    final config = _config.getPatternConfig(PatternType.blackHole);
    final totalVolume = volumeWindow.sum;
    final cv = priceWindow.cv;
    final buyRatio = buyRatioWindow.mean;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ MACD - íš¡ë³´ êµ¬ê°„ ì²´í¬
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ğŸ†• ì™„í™”ëœ ì¡°ê±´ë“¤ + MACD ì²´í¬
    final conditions = [
      // "ì—„ì²­ë‚œ ê±°ë˜ëŸ‰" - ì™„í™”ëœ ì„ê³„ê°’
      totalVolume >= config['minTradeAmount']!, // 1000ë§Œ (ê¸°ì¡´ 5000ë§Œì—ì„œ ì™„í™”)
      
      // "ê°€ê²© ê°‡í˜" - ì™„í™”ëœ ë³€ë™ì„± ê¸°ì¤€
      cv <= config['cvThreshold']!, // 2% (ê¸°ì¡´ 1%ì—ì„œ ì™„í™”)
      priceWindow.zScore(trade.price).abs() <= config['priceZScoreMax']!,
      
      // "ë§¤ìˆ˜/ë§¤ë„ ê· í˜•" - ì™„í™”ëœ ë²”ìœ„
      buyRatio >= config['buyRatioMin']! && buyRatio <= config['buyRatioMax']!, // 35-65% (ê¸°ì¡´ 40-60%ì—ì„œ ì™„í™”)
      
      // ğŸ†• MACD íš¡ë³´ êµ¬ê°„ (ê°‡í˜ íŒ¨í„´ íŠ¹ì„±)
      macd.histogram.abs() < 50, // ì‘ì€ MACD íˆìŠ¤í† ê·¸ë¨
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: totalVolume,
      detectedAt: timestamp,
      patternType: PatternType.blackHole,
      patternDetails: {
        'cv': cv,
        'buyRatio': buyRatio,
        'totalVolume': totalVolume,
        'stabilityIndex': 1.0 - cv,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.8,
        'enhancement': 'V4.1 - Online + Relaxed Thresholds',
      },
    );
  }

  /// ğŸ¯ 6. ReboundShot íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectReboundShot(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 60));
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (priceWindow.length < 5) return null;
    
    final config = _config.getPatternConfig(PatternType.reboundShot);
    final prices = priceWindow.values;
    final low = prices.reduce(min);
    final high = prices.reduce(max);
    final recentVolume = volumeWindow.sum;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI - ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // Jump Gate ê³„ì‚°
    final jumpScore = _metrics.calculateJumpGate(trade.price, low, high, trade.total);
    final priceRange = (high - low) / low;
    
    final conditions = [
      // "ì˜ë¯¸ìˆëŠ” ë°˜ë“± ë²”ìœ„"
      priceRange >= config['priceRangeMin']!,
      
      // "ì í”„í•˜ëŠ” ì›€ì§ì„"
      jumpScore > 0,
      
      // "ê°•ë ¥í•œ ë§¤ìˆ˜ì„¸"
      recentVolume >= config['minVolume']!,
      
      // ğŸ†• RSI ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± or MACD ê³¨ë“ í¬ë¡œìŠ¤
      (rsi < 35 && trade.price > low * 1.01) || // ê³¼ë§¤ë„ ë°˜ë“±
      (macd.histogram > 0 && macd.macd > macd.signal), // MACD ìƒìŠ¹
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: ((trade.price - low) / low) * 100,
      volume: trade.volume,
      tradeAmount: recentVolume,
      detectedAt: timestamp,
      patternType: PatternType.reboundShot,
      patternDetails: {
        'jumpScore': jumpScore,
        'priceRange': priceRange,
        'lowPrice': low,
        'highPrice': high,
        'rsi': rsi,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.9,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ†• ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
  Signal _adjustSignalConfidence(Signal signal, MarketDataContext context) {
    try {
      final priceWindow = context.getPriceWindow(const Duration(seconds: 300));
      if (priceWindow.length < 5) return signal; // ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚° ë¶ˆê°€
      
      // ğŸ”¥ ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ì‚¬ìš©í•œ ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
      final divergence = _metrics.detectDivergence(
        market: signal.market,
        prices: priceWindow.values,
        indicator: [], // ì‚¬ìš© ì•ˆí•¨ (ì˜¨ë¼ì¸ RSI ì‚¬ìš©)
      );
      
      // ì‹ ë¢°ë„ ì¡°ì •
      double confidenceMultiplier = 1.0;
      
      if (signal.changePercent > 0 && divergence.isBearish) {
        // ìƒìŠ¹ ì‹ í˜¸ì¸ë° Bearish ë‹¤ì´ë²„ì „ìŠ¤ â†’ ì‹ ë¢°ë„ í•˜ë½
        confidenceMultiplier = max(0.3, 1.0 - (divergence.strength * 0.5));
      } else if (signal.changePercent < 0 && divergence.isBullish) {
        // í•˜ë½ ì‹ í˜¸ì¸ë° Bullish ë‹¤ì´ë²„ì „ìŠ¤ â†’ ì‹ ë¢°ë„ í•˜ë½
        confidenceMultiplier = max(0.3, 1.0 - (divergence.strength * 0.5));
      } else if ((signal.changePercent > 0 && divergence.isBullish) ||
                 (signal.changePercent < 0 && divergence.isBearish)) {
        // ì‹ í˜¸ì™€ ë‹¤ì´ë²„ì „ìŠ¤ ë°©í–¥ ì¼ì¹˜ â†’ ì‹ ë¢°ë„ ìƒìŠ¹
        confidenceMultiplier = min(1.5, 1.0 + (divergence.strength * 0.3));
      }
      
      // ì¡°ì •ëœ ì‹ ë¢°ë„ë¡œ ì‹ í˜¸ ì—…ë°ì´íŠ¸
      final adjustedDetails = Map<String, dynamic>.from(signal.patternDetails);
      adjustedDetails['originalConfidence'] = adjustedDetails['confidence'];
      adjustedDetails['confidenceMultiplier'] = confidenceMultiplier;
      adjustedDetails['finalConfidence'] = 
          (adjustedDetails['confidence'] as double) * confidenceMultiplier;
      adjustedDetails['divergence'] = {
        'isBullish': divergence.isBullish,
        'isBearish': divergence.isBearish,
        'strength': divergence.strength,
        'source': 'online-rsi', // ì˜¨ë¼ì¸ RSI ê¸°ë°˜ì„ì„ ëª…ì‹œ
      };
      
      return Signal(
        market: signal.market,
        name: signal.name,
        currentPrice: signal.currentPrice,
        changePercent: signal.changePercent,
        volume: signal.volume,
        tradeAmount: signal.tradeAmount,
        detectedAt: signal.detectedAt,
        patternType: signal.patternType,
        patternDetails: adjustedDetails,
      );
      
    } catch (e) {
      if (kDebugMode) {
        print('Confidence adjustment failed: $e');
      }
      return signal; // ì‹¤íŒ¨ì‹œ ì›ë³¸ ë°˜í™˜
    }
  }

  /// ğŸ› ï¸ í—¬í¼ í•¨ìˆ˜ë“¤

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì ‘ê·¼ì (Repositoryì—ì„œ ì‚¬ìš©)
  AdvancedMetrics get metrics => _metrics;

  /// RSI ë°©í–¥ì„± ê²€ì¦
  bool _isValidRSIForDirection(double rsi, double changePercent) {
    if (changePercent > 0) {
      // ìƒìŠ¹ì‹œ RSI 80 ì´í•˜ (ê³¼ë§¤ìˆ˜ íšŒí”¼)
      return rsi <= 80;
    } else if (changePercent < 0) {
      // í•˜ë½ì‹œ RSI 20 ì´ìƒ (ê³¼ë§¤ë„ íšŒí”¼)
      return rsi >= 20;
    }
    return true; // ë³€í™” ì—†ìœ¼ë©´ í†µê³¼
  }

  /// ì¿¨ë‹¤ìš´ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getCooldownStatus() {
    final now = DateTime.now();
    final status = <String, dynamic>{};
    
    for (final entry in _lastSignalTime.entries) {
      final parts = entry.key.split('-');
      final market = parts[0];
      final patternName = parts[1];
      
      final pattern = PatternType.values.firstWhere(
        (p) => p.name == patternName,
        orElse: () => PatternType.surge,
      );
      
      final cooldownDuration = _config.getCooldownDuration(pattern);
      final remainingMs = cooldownDuration.inMilliseconds - 
                         now.difference(entry.value).inMilliseconds;
      
      status[entry.key] = {
        'market': market,
        'pattern': patternName,
        'isInCooldown': remainingMs > 0,
        'remainingMs': max(0, remainingMs),
        'cooldownDurationSeconds': cooldownDuration.inSeconds,
      };
    }
    
    return status;
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì¿¨ë‹¤ìš´ í•´ì œ (ë””ë²„ê¹…ìš©)
  void clearCooldown(String market, PatternType pattern) {
    final cooldownKey = '$market-${pattern.name}';
    _lastSignalTime.remove(cooldownKey);
  }

  /// ëª¨ë“  ì¿¨ë‹¤ìš´ í•´ì œ (ë””ë²„ê¹…ìš©)
  void clearAllCooldowns() {
    _lastSignalTime.clear();
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Map<String, dynamic> getSystemHealth() {
    final metricsHealth = _metrics.getSystemHealth();
    
    return {
      'version': 'V4.1-Online',
      'patternDetector': {
        'activeCooldowns': _lastSignalTime.length,
        'cooldownEntries': getCooldownStatus(),
      },
      'onlineMetrics': metricsHealth,
      'improvements': [
        'Online RSI/MACD Integration',
        'Stream Gap Auto-Recovery',
        'O(1) Indicator Calculation',
        'Real Divergence Detection',
        'Stale Data Prevention',
      ],
    };
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _lastSignalTime.clear();
    _metrics.dispose();
  }
}\n\n// ====== lib/core/utils/advanced_metrics.dart ======\n
import 'dart:math';
import 'dart:developer' as developer;
import 'rolling_window.dart';

// ==========================================================================
// ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ë™ê¸°í™”ëœ ì˜¨ë¼ì¸ ê³„ì‚°ê¸°ë“¤
// ==========================================================================

/// ìŠ¤íŠ¸ë¦¼ ìƒëª…ì£¼ê¸°ì™€ ë™ê¸°í™”ëœ OnlineRSI
class StreamAwareOnlineRSI {
  final int period;
  final Duration maxGap; // í—ˆìš© ê°€ëŠ¥í•œ ìµœëŒ€ ë°ì´í„° ê°„ê²©
  
  final List<double> _prices = [];
  double _avgGain = 0.0;
  double _avgLoss = 0.0;
  bool _isInitialized = false;
  DateTime? _lastUpdate;
  
  StreamAwareOnlineRSI({
    required this.period, 
    this.maxGap = const Duration(seconds: 10),
  });
  
  void update(double price, DateTime timestamp) {
    // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë¦¬ì…‹
    if (_lastUpdate != null && 
        timestamp.difference(_lastUpdate!).abs() > maxGap) {
      reset();
      if (_prices.isNotEmpty) {
        developer.log('RSI Reset: Stream gap detected (${timestamp.difference(_lastUpdate!).inSeconds}s)', name: 'StreamAwareOnlineRSI');
      }
    }
    
    _lastUpdate = timestamp;
    _prices.add(price);
    
    if (_prices.length < 2) return;
    
    final change = _prices.last - _prices[_prices.length - 2];
    final gain = change > 0 ? change : 0.0;
    final loss = change < 0 ? change.abs() : 0.0;
    
    if (!_isInitialized && _prices.length >= period + 1) {
      // ì´ˆê¸° í‰ê·  ê³„ì‚°
      double gainSum = 0.0;
      double lossSum = 0.0;
      
      for (int i = 1; i <= period; i++) {
        final ch = _prices[i] - _prices[i - 1];
        if (ch > 0) {
          gainSum += ch;
        } else {
          lossSum += ch.abs();
        }
      }
      
      _avgGain = gainSum / period;
      _avgLoss = lossSum / period;
      _isInitialized = true;
    } else if (_isInitialized) {
      // ì§€ìˆ˜ì´ë™í‰ê·  ì—…ë°ì´íŠ¸
      _avgGain = ((_avgGain * (period - 1)) + gain) / period;
      _avgLoss = ((_avgLoss * (period - 1)) + loss) / period;
    }
    
    // ë©”ëª¨ë¦¬ ê´€ë¦¬: ìµœëŒ€ period * 2 ê°œì˜ ê°€ê²©ë§Œ ìœ ì§€
    if (_prices.length > period * 2) {
      _prices.removeAt(0);
    }
  }
  
  double get current {
    if (!_isInitialized || _avgLoss == 0) return 50.0;
    
    final rs = _avgGain / _avgLoss;
    return 100.0 - (100.0 / (1.0 + rs));
  }
  
  bool get isReady => _isInitialized;
  bool get isStale => _lastUpdate != null && 
      DateTime.now().difference(_lastUpdate!).abs() > maxGap;
  
  void reset() {
    _prices.clear();
    _avgGain = 0.0;
    _avgLoss = 0.0;
    _isInitialized = false;
    _lastUpdate = null;
  }
  
  /// ê±´ê°• ìƒíƒœ ì²´í¬
  Map<String, dynamic> getHealthStatus() {
    return {
      'isReady': isReady,
      'isStale': isStale,
      'dataPoints': _prices.length,
      'lastUpdate': _lastUpdate?.toIso8601String(),
      'timeSinceLastUpdate': _lastUpdate != null 
          ? DateTime.now().difference(_lastUpdate!).inSeconds 
          : null,
    };
  }
}

/// ìŠ¤íŠ¸ë¦¼ ë™ê¸°í™”ëœ OnlineMACD
class StreamAwareOnlineMACD {
  final int fastPeriod;
  final int slowPeriod;
  final int signalPeriod;
  final Duration maxGap;
  
  double _fastEMA = 0.0;
  double _slowEMA = 0.0;
  double _signalEMA = 0.0;
  
  final List<double> _macdHistory = [];
  bool _isInitialized = false;
  int _count = 0;
  DateTime? _lastUpdate;
  
  StreamAwareOnlineMACD({
    this.fastPeriod = 12,
    this.slowPeriod = 26,
    this.signalPeriod = 9,
    this.maxGap = const Duration(seconds: 10),
  });
  
  void update(double price, DateTime timestamp) {
    // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë¦¬ì…‹
    if (_lastUpdate != null && 
        timestamp.difference(_lastUpdate!).abs() > maxGap) {
      reset();
      developer.log('MACD Reset: Stream gap detected (${timestamp.difference(_lastUpdate!).inSeconds}s)', name: 'StreamAwareOnlineMACD');
    }
    
    _lastUpdate = timestamp;
    _count++;
    
    final fastAlpha = 2.0 / (fastPeriod + 1);
    final slowAlpha = 2.0 / (slowPeriod + 1);
    final signalAlpha = 2.0 / (signalPeriod + 1);
    
    if (_count == 1) {
      _fastEMA = price;
      _slowEMA = price;
    } else {
      _fastEMA = (price * fastAlpha) + (_fastEMA * (1 - fastAlpha));
      _slowEMA = (price * slowAlpha) + (_slowEMA * (1 - slowAlpha));
    }
    
    if (_count >= slowPeriod) {
      final macd = _fastEMA - _slowEMA;
      _macdHistory.add(macd);
      
      if (_macdHistory.length == 1) {
        _signalEMA = macd;
      } else {
        _signalEMA = (macd * signalAlpha) + (_signalEMA * (1 - signalAlpha));
      }
      
      _isInitialized = _macdHistory.length >= signalPeriod;
      
      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_macdHistory.length > signalPeriod * 2) {
        _macdHistory.removeAt(0);
      }
    }
  }
  
  double get macd => _count >= slowPeriod ? _fastEMA - _slowEMA : 0.0;
  double get signal => _signalEMA;
  double get histogram => macd - signal;
  bool get isReady => _isInitialized;
  bool get isStale => _lastUpdate != null && 
      DateTime.now().difference(_lastUpdate!).abs() > maxGap;
  
  MACDResult get current => MACDResult(
    macd: macd, 
    signal: signal, 
    histogram: histogram
  );
  
  void reset() {
    _fastEMA = 0.0;
    _slowEMA = 0.0;
    _signalEMA = 0.0;
    _macdHistory.clear();
    _isInitialized = false;
    _count = 0;
    _lastUpdate = null;
  }
  
  /// ê±´ê°• ìƒíƒœ ì²´í¬
  Map<String, dynamic> getHealthStatus() {
    return {
      'isReady': isReady,
      'isStale': isStale,
      'dataPoints': _count,
      'macdHistoryLength': _macdHistory.length,
      'lastUpdate': _lastUpdate?.toIso8601String(),
      'timeSinceLastUpdate': _lastUpdate != null 
          ? DateTime.now().difference(_lastUpdate!).inSeconds 
          : null,
    };
  }
}

// ==========================================================================
// ğŸ”¥ ì™„ì „íˆ ì˜¨ë¼ì¸í™”ëœ AdvancedMetrics (ë©”ì¸ í´ë˜ìŠ¤)
// ==========================================================================

/// ì™„ì „íˆ ì˜¨ë¼ì¸í™”ëœ AdvancedMetrics
/// 
/// ê¸°ì¡´ ë¬¸ì œì ë“¤ í•´ê²°:
/// 1. âŒ ìºì‹œ í‚¤ê°€ ë¶€ì •í™• â†’ âœ… ìºì‹œ ì œê±°, ì˜¨ë¼ì¸ ê³„ì‚°
/// 2. âŒ calculateMACD O(nÂ²) â†’ âœ… O(1) ì˜¨ë¼ì¸ ì—…ë°ì´íŠ¸
/// 3. âŒ ë§¤ë²ˆ ì „ì²´ ì¬ê³„ì‚° â†’ âœ… ìƒˆ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸
/// 4. âŒ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ì‹œ ì˜¤ì—¼ â†’ âœ… ìë™ ê°ì§€ ë° ë¦¬ì…‹
class AdvancedMetrics {
  
  // ğŸ¯ ë§ˆì¼“ë³„ ì˜¨ë¼ì¸ ê³„ì‚°ê¸°ë“¤
  final Map<String, StreamAwareOnlineRSI> _rsiCalculators = {};
  final Map<String, StreamAwareOnlineMACD> _macdCalculators = {};
  final Map<String, DateTime> _lastUpdates = {};
  
  // ğŸ”’ ìŠ¤íŠ¸ë¦¼ ê±´ê°•ì„± ê´€ë¦¬
  final Duration maxGap;
  final Duration staleThreshold;
  
  AdvancedMetrics({
    this.maxGap = const Duration(seconds: 10),
    this.staleThreshold = const Duration(seconds: 30),
  });

  // ==========================================================================
  // ğŸ”¥ ë©”ì¸ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ (ìƒˆ ë°ì´í„°ë§Œ ë°›ì•„ì„œ O(1) ì—…ë°ì´íŠ¸)
  // ==========================================================================
  
  /// ìƒˆë¡œìš´ ê°€ê²© ë°ì´í„°ë¡œ ëª¨ë“  ì§€í‘œ ì—…ë°ì´íŠ¸
  void updatePrice({
    required String market,
    required double price,
    required DateTime timestamp,
  }) {
    _lastUpdates[market] = timestamp;
    
    // RSI ì—…ë°ì´íŠ¸ (O(1))
    _getRSICalculator(market).update(price, timestamp);
    
    // MACD ì—…ë°ì´íŠ¸ (O(1))
    _getMACDCalculator(market).update(price, timestamp);
  }
  
  /// RSI ê³„ì‚°ê¸° ì¡°íšŒ/ìƒì„±
  StreamAwareOnlineRSI _getRSICalculator(String market) {
    return _rsiCalculators.putIfAbsent(
      market, 
      () => StreamAwareOnlineRSI(period: 14, maxGap: maxGap)
    );
  }
  
  /// MACD ê³„ì‚°ê¸° ì¡°íšŒ/ìƒì„±
  StreamAwareOnlineMACD _getMACDCalculator(String market) {
    return _macdCalculators.putIfAbsent(
      market,
      () => StreamAwareOnlineMACD(maxGap: maxGap)
    );
  }

  // ==========================================================================
  // ğŸ“Š ì˜¨ë¼ì¸ ì§€í‘œ ì¡°íšŒ (O(1) ë³µì¡ë„ - ì¦‰ì‹œ ë°˜í™˜)
  // ==========================================================================
  
  /// RSI ì¡°íšŒ (ì¦‰ì‹œ ë°˜í™˜)
  double calculateRSI({
    required String market,
    List<double>? prices, // í•˜ìœ„ í˜¸í™˜ì„±ìš© (ì‚¬ìš© ì•ˆí•¨)
    int period = 14,
  }) {
    final calculator = _rsiCalculators[market];
    if (calculator == null || !calculator.isReady || calculator.isStale) {
      return 50.0; // ê¸°ë³¸ê°’
    }
    return calculator.current;
  }
  
  /// MACD ì¡°íšŒ (ì¦‰ì‹œ ë°˜í™˜)
  MACDResult calculateMACD({
    required String market,
    List<double>? prices, // í•˜ìœ„ í˜¸í™˜ì„±ìš© (ì‚¬ìš© ì•ˆí•¨)
    int fastPeriod = 12,
    int slowPeriod = 26,
    int signalPeriod = 9,
  }) {
    final calculator = _macdCalculators[market];
    if (calculator == null || !calculator.isReady || calculator.isStale) {
      return const MACDResult(macd: 0.0, signal: 0.0, histogram: 0.0);
    }
    return calculator.current;
  }
  
  /// ğŸ†• ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ (ì˜¨ë¼ì¸ RSI ê¸°ë°˜)
  DivergenceResult detectDivergence({
    required String market,
    required List<double> prices,
    required List<double> indicator, // ì‚¬ìš© ì•ˆí•¨ (ì˜¨ë¼ì¸ RSI ì‚¬ìš©)
    int lookback = 5,
  }) {
    final rsiCalculator = _rsiCalculators[market];
    
    if (rsiCalculator == null || 
        !rsiCalculator.isReady || 
        prices.length < lookback) {
      return const DivergenceResult(
        isBullish: false,
        isBearish: false,
        strength: 0.0,
      );
    }
    
    // ğŸ”¥ ì‹¤ì œ ì˜¨ë¼ì¸ RSI ì‚¬ìš©
    final currentRSI = rsiCalculator.current;
    final recentPrices = prices.take(lookback).toList();
    
    return _calculateDivergence(recentPrices, currentRSI);
  }
  
  /// ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚° (ë‹¨ìˆœí™”ëœ ë²„ì „)
  DivergenceResult _calculateDivergence(List<double> prices, double currentRSI) {
    if (prices.length < 2) {
      return const DivergenceResult(
        isBullish: false,
        isBearish: false, 
        strength: 0.0,
      );
    }
    
    final priceSlope = _calculateSlope(prices);
    
    bool isBullish = false;
    bool isBearish = false;
    double strength = 0.0;
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
    if (priceSlope < -0.1 && currentRSI > 50) {
      // ê°€ê²© í•˜ë½ + RSI ë†’ìŒ â†’ Bullish Divergence ê°€ëŠ¥ì„±
      isBullish = true;
      strength = min(1.0, (currentRSI - 50) / 50);
    } else if (priceSlope > 0.1 && currentRSI < 50) {
      // ê°€ê²© ìƒìŠ¹ + RSI ë‚®ìŒ â†’ Bearish Divergence ê°€ëŠ¥ì„±
      isBearish = true;
      strength = min(1.0, (50 - currentRSI) / 50);
    }
    
    return DivergenceResult(
      isBullish: isBullish,
      isBearish: isBearish,
      strength: strength,
    );
  }

  // ==========================================================================
  // ğŸ¯ ì»¤ìŠ¤í…€ ì§€í‘œë“¤ (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  // ==========================================================================
  
  /// Liquidity Vortex ê³„ì‚°
  double calculateLiquidityVortex(
    RollingWindow<double> priceWindow,
    RollingWindow<double> volumeWindow,
  ) {
    if (priceWindow.length < 3 || volumeWindow.length < 3) return 0.0;
    
    final priceAccel = _calculateSecondDerivative(priceWindow.values);
    final volumeAccel = _calculateSecondDerivative(volumeWindow.values);
    final cps = priceWindow.length / priceWindow.span.inSeconds;
    
    return (priceAccel * volumeAccel * cps).abs();
  }
  
  /// Flash Pulse ê³„ì‚°
  double calculateFlashPulse(double currentVolume, RollingWindow<double> volumeWindow) {
    if (volumeWindow.length < 10) return 0.0;
    
    final recentVolumes = volumeWindow.values.take(10).toList();
    final ema = _calculateEMA(recentVolumes, 10);
    
    return currentVolume / max(ema, 1.0) - 1.0;
  }
  
  /// Micro Burst Radar ê³„ì‚°
  double calculateMicroBurstRadar(double currentVolume, RollingWindow<double> volumeWindow) {
    if (volumeWindow.length < 3) return 0.0;
    
    final recentVolumes = volumeWindow.values.take(3).toList();
    final mean = recentVolumes.reduce((a, b) => a + b) / recentVolumes.length;
    final variance = recentVolumes
        .map((v) => pow(v - mean, 2))
        .reduce((a, b) => a + b) / recentVolumes.length;
    final stdDev = sqrt(variance);
    
    if (stdDev == 0) return 0.0;
    
    return (currentVolume - mean) / stdDev;
  }
  
  /// Machine Rush ê³„ì‚°
  double calculateMachineRush(double currentVolume, double totalVolume) {
    if (totalVolume == 0) return 0.0;
    return currentVolume / totalVolume;
  }
  
  /// Jump Gate ê³„ì‚°
  double calculateJumpGate(double currentPrice, double low, double high, double volume) {
    if (high <= low) return 0.0;
    
    final pricePosition = (currentPrice - low) / (high - low);
    final volumeWeight = log(volume + 1) / 10.0;
    
    return pricePosition * volumeWeight;
  }

  /// ATR ê³„ì‚° (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  double calculateATR({
    required List<double> highs,
    required List<double> lows,
    required List<double> closes,
    int period = 14,
  }) {
    if (highs.length < period || lows.length < period || closes.length < period) {
      return 0.0;
    }
    
    final trueRanges = <double>[];
    
    for (int i = 1; i < closes.length; i++) {
      final high = highs[i];
      final low = lows[i];
      final prevClose = closes[i - 1];
      
      final tr1 = high - low;
      final tr2 = (high - prevClose).abs();
      final tr3 = (low - prevClose).abs();
      
      trueRanges.add(max(tr1, max(tr2, tr3)));
    }
    
    if (trueRanges.length < period) return 0.0;
    
    // ì²« ë²ˆì§¸ ATRì€ ë‹¨ìˆœ í‰ê· 
    double atr = trueRanges.take(period).reduce((a, b) => a + b) / period;
    
    // ì´í›„ëŠ” ì§€ìˆ˜ì´ë™í‰ê· 
    for (int i = period; i < trueRanges.length; i++) {
      atr = ((atr * (period - 1)) + trueRanges[i]) / period;
    }
    
    return atr;
  }

  // ==========================================================================
  // ğŸ› ï¸ í—¬í¼ í•¨ìˆ˜ë“¤
  // ==========================================================================
  
  /// EMA ê³„ì‚°
  double _calculateEMA(List<double> values, int period) {
    if (values.isEmpty) return 0.0;
    if (values.length == 1) return values.first;
    
    final alpha = 2.0 / (period + 1);
    double ema = values.first;
    
    for (int i = 1; i < values.length; i++) {
      ema = (values[i] * alpha) + (ema * (1 - alpha));
    }
    
    return ema;
  }
  
  /// 2ì°¨ ë¯¸ë¶„ ê³„ì‚°
  double _calculateSecondDerivative(List<double> values) {
    if (values.length < 3) return 0.0;
    
    final recent = values.take(3).toList();
    return recent[0] - (2 * recent[1]) + recent[2];
  }
  
  /// ì„ í˜• íšŒê·€ ê¸°ìš¸ê¸° ê³„ì‚°
  double _calculateSlope(List<double> values) {
    if (values.length < 2) return 0.0;
    
    final n = values.length;
    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    
    for (int i = 0; i < n; i++) {
      sumX += i;
      sumY += values[i];
      sumXY += i * values[i];
      sumX2 += i * i;
    }
    
    final denominator = n * sumX2 - sumX * sumX;
    if (denominator == 0) return 0.0;
    
    return (n * sumXY - sumX * sumY) / denominator;
  }

  /// ë™ì  ì„ê³„ê°’ ê³„ì‚° (ATR ê¸°ë°˜)
  double calculateDynamicThreshold({
    required double baseThreshold,
    required double atr,
    required double priceAverage,
    double multiplier = 1.0,
  }) {
    if (priceAverage == 0) return baseThreshold;
    
    final atrPercent = (atr / priceAverage) * 100;
    final volatilityFactor = max(0.5, min(2.0, atrPercent / baseThreshold));
    
    return baseThreshold * volatilityFactor * multiplier;
  }

  // ==========================================================================
  // ğŸ” ì‹œìŠ¤í…œ í—¬ìŠ¤ ë° ê´€ë¦¬
  // ==========================================================================
  
  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Map<String, dynamic> getSystemHealth() {
    final now = DateTime.now();
    final healthStatus = <String, dynamic>{
      'totalMarkets': _rsiCalculators.length,
      'staleMarkets': 0,
      'healthyMarkets': 0,
      'markets': <String, dynamic>{},
    };
    
    for (final market in _rsiCalculators.keys) {
      final rsiHealth = _rsiCalculators[market]?.getHealthStatus();
      final macdHealth = _macdCalculators[market]?.getHealthStatus();
      final lastUpdate = _lastUpdates[market];
      
      final isStale = lastUpdate != null && 
          now.difference(lastUpdate).abs() > staleThreshold;
      
      if (isStale) {
        healthStatus['staleMarkets']++;
      } else {
        healthStatus['healthyMarkets']++;
      }
      
      healthStatus['markets'][market] = {
        'rsi': rsiHealth,
        'macd': macdHealth,
        'isStale': isStale,
        'lastUpdate': lastUpdate?.toIso8601String(),
      };
    }
    
    return healthStatus;
  }
  
  /// ì˜¤ë˜ëœ ê³„ì‚°ê¸°ë“¤ ì •ë¦¬
  void cleanup() {
    final now = DateTime.now();
    final marketsToRemove = <String>[];
    
    for (final entry in _lastUpdates.entries) {
      if (now.difference(entry.value).abs() > const Duration(hours: 1)) {
        marketsToRemove.add(entry.key);
      }
    }
    
    for (final market in marketsToRemove) {
      _rsiCalculators.remove(market);
      _macdCalculators.remove(market);
      _lastUpdates.remove(market);
    }
    
    if (marketsToRemove.isNotEmpty) {
      developer.log('AdvancedMetrics: Cleaned up ${marketsToRemove.length} stale market calculators', name: 'AdvancedMetrics');
    }
  }
  
  /// íŠ¹ì • ë§ˆì¼“ ë¦¬ì…‹
  void resetMarket(String market) {
    _rsiCalculators[market]?.reset();
    _macdCalculators[market]?.reset();
    _lastUpdates.remove(market);
  }
  
  /// ì „ì²´ ë¦¬ì…‹
  void resetAll() {
    for (final calculator in _rsiCalculators.values) {
      calculator.reset();
    }
    for (final calculator in _macdCalculators.values) {
      calculator.reset();
    }
    _lastUpdates.clear();
  }
  
  /// ìºì‹œ ì •ë¦¬ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” ë¹ˆ êµ¬í˜„)
  void clearCache() {
    // ì˜¨ë¼ì¸ ê³„ì‚°ì—ì„œëŠ” ìºì‹œê°€ ì—†ìœ¼ë¯€ë¡œ ë¹ˆ êµ¬í˜„
  }
  
  /// ë§Œë£Œëœ ìºì‹œ ì •ë¦¬ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” cleanup í˜¸ì¶œ)
  void cleanupExpiredCache() {
    cleanup();
  }
  
  /// ìºì‹œ í†µê³„ (í•˜ìœ„ í˜¸í™˜ì„±ìš©)
  Map<String, dynamic> getCacheStats() {
    return {
      'mode': 'online',
      'totalMarkets': _rsiCalculators.length,
      'healthyMarkets': getSystemHealth()['healthyMarkets'],
      'staleMarkets': getSystemHealth()['staleMarkets'],
    };
  }
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _rsiCalculators.clear();
    _macdCalculators.clear();
    _lastUpdates.clear();
  }
}

// ==========================================================================
// ğŸ“Š ê²°ê³¼ í´ë˜ìŠ¤ë“¤
// ==========================================================================

/// MACD ê³„ì‚° ê²°ê³¼
class MACDResult {
  final double macd;
  final double signal;
  final double histogram;
  
  const MACDResult({
    required this.macd,
    required this.signal,
    required this.histogram,
  });
  
  @override
  String toString() => 'MACD(macd: $macd, signal: $signal, histogram: $histogram)';
}

/// ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ ê²°ê³¼
class DivergenceResult {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  
  const DivergenceResult({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
  });
  
  bool get hasAnyDivergence => isBullish || isBearish;
  
  @override
  String toString() => 'Divergence(bullish: $isBullish, bearish: $isBearish, strength: $strength)';
}

// ==========================================================================
// ğŸ”¢ ì˜¨ë¼ì¸ ì§€í‘œ ê³„ì‚°ê¸°ë“¤ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” ìœ„ì˜ StreamAware ë²„ì „ ì‚¬ìš©)
// ==========================================================================

/// ì˜¨ë¼ì¸ RSI ê³„ì‚°ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
typedef OnlineRSI = StreamAwareOnlineRSI;

/// ì˜¨ë¼ì¸ MACD ê³„ì‚°ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
typedef OnlineMACD = StreamAwareOnlineMACD;\n\n// ====== lib/core/utils/rolling_window.dart ======\n
import 'dart:collection';
import 'dart:math' as math;

/// íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ë°ì´í„° ì—”íŠ¸ë¦¬
class _Item<T extends num> {
  final T value;
  final DateTime timestamp;
  
  _Item(this.value, this.timestamp);
}

/// ğŸš€ O(1) ì‹œê°„ ë³µì¡ë„ë¡œ ì™„ì „ ìµœì í™”ëœ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
/// ëª¨ë“  í†µê³„ ì§€í‘œë¥¼ O(1)ë¡œ ê³„ì‚° (rSquared í¬í•¨)
class RollingWindow<T extends num> {
  final Duration span;
  final Queue<_Item<T>> _queue = Queue<_Item<T>>();
  
  // ==========================================================================
  // ğŸ“Š O(1) ê³„ì‚°ì„ ìœ„í•œ ëˆ„ì  ë³€ìˆ˜ë“¤ (Complete Set)
  // ==========================================================================
  
  // ê¸°ë³¸ í†µê³„ìš©
  double _sum = 0.0;          // Î£y
  double _sumSq = 0.0;        // Î£yÂ² (ë¶„ì‚°ìš©)
  
  // ì—°ì† ì¦ê°€ ì¶”ì ìš©
  int _incStreak = 0;
  T? _lastValue;
  
  // ì„ í˜• íšŒê·€ + rSquared O(1) ê³„ì‚°ì„ ìœ„í•œ ì™„ì „í•œ 5ë³€ìˆ˜ ì„¸íŠ¸
  double _sx = 0.0;           // Î£x (ì‹œê°„)
  double _sy = 0.0;           // Î£y (ê°’) - _sumê³¼ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´ ìœ ì§€
  double _sxx = 0.0;          // Î£xÂ²
  double _sxy = 0.0;          // Î£xy
  double _syy = 0.0;          // Î£yÂ² - _sumSqì™€ ë™ì¼í•˜ì§€ë§Œ íšŒê·€ìš©ìœ¼ë¡œ ëª…ì‹œì  ê´€ë¦¬
  
  RollingWindow({required this.span});

  // ==========================================================================
  // ğŸ“¥ ë°ì´í„° ì¶”ê°€ (ëª¨ë“  ëˆ„ì ê°’ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
  // ==========================================================================
  
  /// ìƒˆ ë°ì´í„° ì¶”ê°€ (ëª¨ë“  ëˆ„ì ê°’ ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
  void add(T value, {DateTime? timestamp}) {
    final now = timestamp ?? DateTime.now();
    _evictOld(now); // ì˜¤ë˜ëœ ë°ì´í„° ë¨¼ì € ì œê±°
    
    // ìƒˆ ë°ì´í„° ì¶”ê°€
    _queue.addLast(_Item(value, now));
    
    // ğŸ”¥ í•µì‹¬: ëª¨ë“  ëˆ„ì ê°’ì„ O(1)ìœ¼ë¡œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
    final x = now.millisecondsSinceEpoch.toDouble();
    final y = value.toDouble();
    
    _sum += y;
    _sumSq += y * y;
    
    // ì„ í˜• íšŒê·€ + rSquaredìš© ì™„ì „í•œ 5ë³€ìˆ˜ ì—…ë°ì´íŠ¸
    _sx += x;
    _sy += y;      // _sumê³¼ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´
    _sxx += x * x;
    _sxy += x * y;
    _syy += y * y; // _sumSqì™€ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´
    
    // ì—°ì† ì¦ê°€ ì¶”ì  (ê°œì„ ëœ ë¡œì§)
    if (length > 1 && _lastValue != null && value > _lastValue!) {
      _incStreak++;
    } else {
      _incStreak = (length == 1) ? 1 : 0; // ì²« ë²ˆì§¸ ë°ì´í„°ë©´ 1, ì•„ë‹ˆë©´ ì´ˆê¸°í™”
    }
    _lastValue = value;
  }

  // ==========================================================================
  // ğŸ—‘ï¸ ë°ì´í„° ì œê±° (ëª¨ë“  ëˆ„ì ê°’ ì‹¤ì‹œê°„ ì°¨ê°)
  // ==========================================================================
  
  /// ì˜¤ë˜ëœ ë°ì´í„° ì œê±° (ëª¨ë“  ëˆ„ì ê°’ ì¦‰ì‹œ ì°¨ê°)
  void _evictOld(DateTime now) {
    final cutoff = now.subtract(span);
    
    while (_queue.isNotEmpty && _queue.first.timestamp.isBefore(cutoff)) {
      final old = _queue.removeFirst();
      
      // ğŸ”¥ í•µì‹¬: ëª¨ë“  ëˆ„ì ê°’ì„ O(1)ìœ¼ë¡œ ì‹¤ì‹œê°„ ì°¨ê°
      final oldX = old.timestamp.millisecondsSinceEpoch.toDouble();
      final oldY = old.value.toDouble();
      
      _sum -= oldY;
      _sumSq -= oldY * oldY;
      
      // ì„ í˜• íšŒê·€ + rSquaredìš© ì™„ì „í•œ 5ë³€ìˆ˜ ì°¨ê°
      _sx -= oldX;
      _sy -= oldY;
      _sxx -= oldX * oldX;
      _sxy -= oldX * oldY;
      _syy -= oldY * oldY;
    }
    
    // ì—°ì† ì¦ê°€ ì¹´ìš´íŠ¸ ì¬ê³„ì‚° (ì œê±° í›„ í•„ìš”ì‹œ)
    _recalculateConsecutiveIncreases();
  }
  
  /// ì—°ì† ì¦ê°€ ì¹´ìš´íŠ¸ ì¬ê³„ì‚° (ë°ì´í„° ì œê±° í›„ í•„ìš”ì‹œ)
  void _recalculateConsecutiveIncreases() {
    if (_queue.length < 2) {
      _incStreak = _queue.length;
      return;
    }
    
    _incStreak = 1;
    final values = _queue.map((item) => item.value).toList();
    
    for (int i = values.length - 2; i >= 0; i--) {
      if (values[i + 1] > values[i]) {
        _incStreak++;
      } else {
        break;
      }
    }
  }

  // ==========================================================================
  // ğŸ“Š O(1)ìœ¼ë¡œ ê³„ì‚°ë˜ëŠ” ëª¨ë“  í†µê³„ ì§€í‘œë“¤
  // ==========================================================================
  
  // ê¸°ë³¸ ì •ë³´
  int get length => _queue.length;
  bool get isEmpty => _queue.isEmpty;
  bool get isNotEmpty => _queue.isNotEmpty;
  
  // ê¸°ë³¸ í†µê³„ (O(1))
  double get sum => _sum;
  double get mean => isEmpty ? 0.0 : _sum / length;
  
  double get variance {
    if (length < 2) return 0.0;
    // ë² ì…€ ë³´ì •ëœ í‘œë³¸ ë¶„ì‚°: sÂ² = (Î£yÂ² - n*Î¼Â²) / (n-1)
    final meanVal = mean;
    final sampleVariance = (_sumSq - length * meanVal * meanVal) / (length - 1);
    return math.max(0.0, sampleVariance); // ìŒìˆ˜ ë°©ì§€
  }
  
  double get stdev => math.sqrt(variance);
  
  int get consecutiveIncreases => _incStreak;
  
  double zScore(num x) {
    final sd = stdev;
    return sd == 0 ? 0.0 : (x - mean) / sd;
  }
  
  double get cv {
    final meanVal = mean;
    return meanVal == 0 ? 0.0 : stdev / meanVal.abs();
  }
  
  // ==========================================================================
  // ğŸš€ ì„ í˜• íšŒê·€ ì§€í‘œë“¤ (O(1) - 5ë³€ìˆ˜ ê³µì‹ í™œìš©)
  // ==========================================================================
  
  /// ì„ í˜• íšŒê·€ ê¸°ìš¸ê¸° (O(1))
  double get slope {
    final n = length;
    if (n < 2) return 0.0;
    
    final denominator = n * _sxx - _sx * _sx;
    return denominator == 0 ? 0.0 : (n * _sxy - _sx * _sy) / denominator;
  }
  
  /// ğŸ¯ ê²°ì •ê³„ìˆ˜ RÂ² (O(1) ì™„ì „ ìµœì í™”!)
  /// ê³µì‹: RÂ² = (n*Î£xy - Î£x*Î£y)Â² / [(n*Î£xÂ² - (Î£x)Â²) * (n*Î£yÂ² - (Î£y)Â²)]
  double get rSquared {
    final n = length;
    if (n < 2) return 0.0;
    
    try {
      final numerator = n * _sxy - _sx * _sy;
      final denomX = n * _sxx - _sx * _sx;
      final denomY = n * _syy - _sy * _sy;
      final denominator = denomX * denomY;
      
      if (denominator <= 0) return 0.0;
      
      final rSquaredValue = (numerator * numerator) / denominator;
      return math.max(0.0, math.min(1.0, rSquaredValue)); // [0, 1] ë²”ìœ„ ë³´ì¥
    } catch (e) {
      return 0.0; // ê³„ì‚° ì˜¤ë¥˜ ì‹œ ì•ˆì „ê°’ ë°˜í™˜
    }
  }
  
  /// ì„ í˜• íšŒê·€ ì ˆí¸ (O(1))
  double get intercept {
    final n = length;
    if (n < 2) return mean;
    
    final xMean = _sx / n;
    final yMean = _sy / n;
    return yMean - slope * xMean;
  }
  
  /// ì„ í˜• íšŒê·€ ìƒê´€ê³„ìˆ˜ (O(1))
  double get correlation {
    return math.sqrt(rSquared) * (slope >= 0 ? 1 : -1);
  }

  // ==========================================================================
  // ğŸ“‹ ë°ì´í„° ì ‘ê·¼ (í•„ìš”ì‹œ ì‚¬ìš©, O(n)ì¼ ìˆ˜ ìˆìŒ)
  // ==========================================================================
  
  List<T> get values => _queue.map((e) => e.value).toList();
  Iterable<DateTime> get timestamps => _queue.map((e) => e.timestamp);
  
  /// ìµœì‹  ê°’
  T? get latest => _queue.isNotEmpty ? _queue.last.value : null;
  
  /// ê°€ì¥ ì˜¤ë˜ëœ ê°’
  T? get oldest => _queue.isNotEmpty ? _queue.first.value : null;
  
  /// ìµœëŒ€ê°’ (O(n) - ìºì‹± ê°€ëŠ¥í•˜ì§€ë§Œ ë³µì¡ë„ ì¦ê°€ë¡œ í˜„ì¬ëŠ” ë‹¨ìˆœ êµ¬í˜„)
  T get max => _queue.isEmpty ? 0 as T : _queue.map((e) => e.value).reduce(math.max);
  
  /// ìµœì†Œê°’ (O(n) - ìºì‹± ê°€ëŠ¥í•˜ì§€ë§Œ ë³µì¡ë„ ì¦ê°€ë¡œ í˜„ì¬ëŠ” ë‹¨ìˆœ êµ¬í˜„)
  T get min => _queue.isEmpty ? 0 as T : _queue.map((e) => e.value).reduce(math.min);

  // ==========================================================================
  // ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ==========================================================================
  
  /// ìœˆë„ìš° ë°ì´í„° ëª¨ë‘ ì œê±°
  void clear() {
    _queue.clear();
    _sum = 0.0;
    _sumSq = 0.0;
    _incStreak = 0;
    _lastValue = null;
    _sx = 0.0;
    _sy = 0.0;
    _sxx = 0.0;
    _sxy = 0.0;
    _syy = 0.0;
  }
  
  /// íŠ¹ì • ì‹œì ê¹Œì§€ì˜ ë°ì´í„° ê°•ì œ ì œê±°
  void evictBefore(DateTime cutoff) {
    while (_queue.isNotEmpty && _queue.first.timestamp.isBefore(cutoff)) {
      final old = _queue.removeFirst();
      
      final oldX = old.timestamp.millisecondsSinceEpoch.toDouble();
      final oldY = old.value.toDouble();
      
      _sum -= oldY;
      _sumSq -= oldY * oldY;
      _sx -= oldX;
      _sy -= oldY;
      _sxx -= oldX * oldX;
      _sxy -= oldX * oldY;
      _syy -= oldY * oldY;
    }
    
    _recalculateConsecutiveIncreases();
  }
  
  /// ìœˆë„ìš° ìƒíƒœ ì •ë³´ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> get debugInfo => const <String, dynamic>{
    'performance': 'All O(1) optimized',
  }..addAll({
    'length': length,
    'span': '${span.inSeconds}s',
    'sum': _sum,
    'mean': mean,
    'stdev': stdev,
    'variance': variance,
    'cv': cv,
    'slope': slope,
    'rSquared': rSquared,
    'correlation': correlation,
    'consecutiveIncreases': consecutiveIncreases,
    'regressionVariables': <String, double>{
      'sx': _sx,
      'sy': _sy,
      'sxx': _sxx,
      'sxy': _sxy,
      'syy': _syy,
    },
  });
  
  /// ì„±ëŠ¥ ê²€ì¦ (ëª¨ë“  ì§€í‘œê°€ O(1)ì¸ì§€ í™•ì¸)
  Map<String, String> get performanceProfile => const <String, String>{
    'basic_stats': 'O(1) - sum, mean, variance, stdev, cv',
    'regression': 'O(1) - slope, rSquared, intercept, correlation',
    'streak': 'O(1) - consecutiveIncreases',
    'z_score': 'O(1) - zScore calculation',
    'data_access': 'O(n) - values, timestamps, min, max (acceptable)',
    'overall': 'Fully optimized for real-time streaming',
  };
  
  @override
  String toString() {
    return 'RollingWindow(length: $length, span: ${span.inSeconds}s, '
           'mean: ${mean.toStringAsFixed(2)}, RÂ²: ${rSquared.toStringAsFixed(3)})';
  }
}\n\n// ====== lib/core/utils/streaming_market_buffer.dart ======\n
\n\n// ====== lib/core/utils/app_life_cycle_manager.dart ======\n
// lib/core/utils/app_life_cycle_manager.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../utils/logger.dart';

/// ì•± ë¼ì´í”„ì‚¬ì´í´ê³¼ ì£¼ê¸°ì ì¸ ì‘ì—…ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
/// ğŸ¯ Hive BoxëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ í’€ ê¸°ëŠ¥ API ì œê³µ
class AppLifecycleManager extends WidgetsBindingObserver {
  final Ref ref;
  Timer? _globalTimer;
  
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ ìƒíƒœ ê´€ë¦¬
  DateTime? _appStartTime;
  DateTime? _lastResumeTime;
  DateTime? _lastPauseTime;
  int _resumeCount = 0;
  int _pauseCount = 0;
  Duration _totalForegroundTime = Duration.zero;
  Duration _totalBackgroundTime = Duration.zero;
  AppLifecycleState _currentState = AppLifecycleState.resumed;
  
  // ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤
  final List<void Function(AppLifecycleState)> _lifecycleListeners = [];
  
  // ğŸ†• ì„±ëŠ¥ í†µê³„
  final Map<String, dynamic> _performanceStats = {};

  AppLifecycleManager(this.ref) {
    _appStartTime = DateTime.now();
    _lastResumeTime = _appStartTime;
    WidgetsBinding.instance.addObserver(this);
    _startGlobalTimer();
    log.i('ğŸ¬ AppLifecycleManager ì´ˆê¸°í™” ì™„ë£Œ');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ APIë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ğŸ†• í˜„ì¬ ì•± ìƒíƒœ ì¡°íšŒ
  AppLifecycleState get currentState => _currentState;

  /// ğŸ†• ì•± ì‹œì‘ ì‹œê°„
  DateTime? get appStartTime => _appStartTime;

  /// ğŸ†• ì•± ê°€ë™ ì‹œê°„ (ì—…íƒ€ì„)
  Duration get uptime {
    if (_appStartTime == null) return Duration.zero;
    return DateTime.now().difference(_appStartTime!);
  }

  /// ğŸ†• í¬ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalForegroundTime {
    var total = _totalForegroundTime;
    if (_currentState == AppLifecycleState.resumed && _lastResumeTime != null) {
      total += DateTime.now().difference(_lastResumeTime!);
    }
    return total;
  }

  /// ğŸ†• ë°±ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalBackgroundTime {
    var total = _totalBackgroundTime;
    if (_currentState == AppLifecycleState.paused && _lastPauseTime != null) {
      total += DateTime.now().difference(_lastPauseTime!);
    }
    return total;
  }

  /// ğŸ†• ì´ë²¤íŠ¸ ì¹´ìš´í„°ë“¤
  int get resumeCount => _resumeCount;
  int get pauseCount => _pauseCount;

  /// ğŸ†• ë§ˆì§€ë§‰ ìƒíƒœ ë³€ê²½ ì‹œê°„
  DateTime? get lastStateChangeTime {
    switch (_currentState) {
      case AppLifecycleState.resumed:
        return _lastResumeTime;
      case AppLifecycleState.paused:
        return _lastPauseTime;
      default:
        return null;
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
  void addLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.add(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°
  void removeLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.remove(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨/ì •ë¦¬ ì‘ì—… ê°•ì œ ì‹¤í–‰
  void forceRefresh() {
    log.i('ğŸ”„ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
    _performPeriodicTasks();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ê°•ì œ ì‹¤í–‰
  void forceCleanup() {
    log.i('ğŸ§¹ ìˆ˜ë™ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    _performMemoryCleanup();
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
  void updatePerformanceStats(String key, dynamic value) {
    _performanceStats[key] = value;
    _performanceStats['lastUpdated'] = DateTime.now().toIso8601String();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getMemoryStats() {
    return {
      'uptime': uptime.toString(),
      'foregroundTime': totalForegroundTime.toString(),
      'backgroundTime': totalBackgroundTime.toString(),
      'resumeCount': resumeCount,
      'pauseCount': pauseCount,
      'currentState': _currentState.name,
      'lastStateChange': lastStateChangeTime?.toIso8601String(),
      'platformMemoryUsage': _getPlatformMemoryInfo(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì¡°íšŒ
  Map<String, dynamic> getPerformanceStats() {
    return Map.from(_performanceStats)
      ..addAll({
        'uptime': uptime.inSeconds,
        'foregroundTimeSeconds': totalForegroundTime.inSeconds,
        'backgroundTimeSeconds': totalBackgroundTime.inSeconds,
        'resumeCount': resumeCount,
        'pauseCount': pauseCount,
        'currentState': _currentState.name,
      });
  }

  /// ğŸ†• ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> getSystemStatus() {
    return {
      'app': getMemoryStats(),
      'performance': getPerformanceStats(),
      'platform': {
        'os': Platform.operatingSystem,
        'version': Platform.operatingSystemVersion,
        'locale': Platform.localeName,
      },
      'listeners': {
        'lifecycleListeners': _lifecycleListeners.length,
      },
      'timers': {
        'globalTimerActive': _globalTimer?.isActive ?? false,
      },
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ê¸°ì¡´ ë‚´ë¶€ ë¡œì§ë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final previousState = _currentState;
    _currentState = state;
    
    _updateStateTimes(previousState, state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        log.i('â¡ï¸ ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.');
        _resumeCount++;
        _lastResumeTime = DateTime.now();
        _startGlobalTimer();
        _onAppResumed();
        break;
        
      case AppLifecycleState.paused:
        log.i('â¸ï¸ ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.');
        _pauseCount++;
        _lastPauseTime = DateTime.now();
        _stopGlobalTimer();
        _onAppPaused();
        break;
        
      case AppLifecycleState.detached:
        log.i('ğŸ”š ì•±ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        _onAppDetached();
        break;
        
      case AppLifecycleState.inactive:
        log.d('ğŸ˜´ ì•±ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.');
        break;
        
      case AppLifecycleState.hidden:
        log.d('ğŸ«¥ ì•±ì´ ìˆ¨ê¹€ ìƒíƒœì…ë‹ˆë‹¤.');
        break;
    }
    
    // ğŸ†• ì™¸ë¶€ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
    _notifyLifecycleListeners(state);
  }

  /// ğŸ†• ìƒíƒœ ì „í™˜ ì‹œê°„ ì—…ë°ì´íŠ¸
  void _updateStateTimes(AppLifecycleState from, AppLifecycleState to) {
    final now = DateTime.now();
    
    if (from == AppLifecycleState.resumed && _lastResumeTime != null) {
      _totalForegroundTime += now.difference(_lastResumeTime!);
    } else if (from == AppLifecycleState.paused && _lastPauseTime != null) {
      _totalBackgroundTime += now.difference(_lastPauseTime!);
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
  void _notifyLifecycleListeners(AppLifecycleState state) {
    for (final listener in _lifecycleListeners) {
      try {
        listener(state);
      } catch (e, st) {
        log.e('ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜', e, st);
      }
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘
  void _startGlobalTimer() {
    if (_globalTimer == null || !_globalTimer!.isActive) {
      _globalTimer = Timer.periodic(const Duration(seconds: 30), (_) {
        _performPeriodicTasks();
      });
      log.i('â° ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘: 30ì´ˆ ê°„ê²©');
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€
  void _stopGlobalTimer() {
    _globalTimer?.cancel();
    _globalTimer = null;
    log.d('â¹ï¸ ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€');
  }

  /// ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰
  void _performPeriodicTasks() {
    log.d('ğŸ”„ ì „ì—­ íƒ€ì´ë¨¸: ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰');
    
    // ì—¬ê¸°ì— ì£¼ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•  ì‘ì—…ë“¤ ì¶”ê°€
    // ì˜ˆ: ë©”ëª¨ë¦¬ ì •ë¦¬, ìƒíƒœ ì²´í¬, ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ë“±
    
    // ì˜ˆì‹œ: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
    _checkMemoryUsage();
    
    // ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
    updatePerformanceStats('lastPeriodicTaskRun', DateTime.now().toIso8601String());
  }

  /// ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ì„ ë•Œ
  void _onAppResumed() {
    log.i('ğŸ“¦ Hive Box ìœ ì§€ - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ë°ì´í„° ë³´ì¡´ë¨');
    
    // í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì—°ê²° ìƒíƒœ í™•ì¸, ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ë“±
  }

  /// ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆì„ ë•Œ
  void _onAppPaused() {
    log.i('ğŸ’¾ ë°±ê·¸ë¼ìš´ë“œ ì§„ì… - ì¤‘ìš” ë°ì´í„° ë³´ì¡´ ì¤‘');
    
    // ë°±ê·¸ë¼ìš´ë“œ ì§„ì… ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì„ì‹œ ë°ì´í„° ì €ì¥, ì—°ê²° ì •ë¦¬ ë“±
  }

  /// ì•±ì´ ì™„ì „íˆ ì¢…ë£Œë  ë•Œ
  void _onAppDetached() {
    log.i('ğŸ§¹ ì•± ì¢…ë£Œ - ìµœì¢… ì •ë¦¬ ì‘ì—… ìˆ˜í–‰');
    dispose();
  }

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ìš©)
  void _checkMemoryUsage() {
    // ì‹¤ì œ êµ¬í˜„ì€ í”Œë«í¼ë³„ë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
    log.d('ğŸ§  ë©”ëª¨ë¦¬ ìƒíƒœ ì²´í¬ (ê°œë°œ ì¤‘)');
    
    // ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
    final memInfo = _getPlatformMemoryInfo();
    updatePerformanceStats('memoryInfo', memInfo);
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰
  void _performMemoryCleanup() {
    // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë¦¬ ë¡œì§
    log.i('ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    
    // ì˜ˆì‹œ: ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰ (Dartì—ì„œëŠ” ì œí•œì )
    // System.gc() ê°™ì€ ê²ƒì€ ì—†ì§€ë§Œ, ë¶ˆí•„ìš”í•œ ì°¸ì¡° ì •ë¦¬ ë“±ì„ í•  ìˆ˜ ìˆìŒ
  }

  /// ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
  Map<String, dynamic> _getPlatformMemoryInfo() {
    try {
      return {
        'platform': Platform.operatingSystem,
        'availableProcessors': Platform.numberOfProcessors,
        'timestamp': DateTime.now().toIso8601String(),
        // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë³´ëŠ” í”Œë«í¼ ì±„ë„ì„ í†µí•´ êµ¬í˜„ ê°€ëŠ¥
        'note': 'Platform memory info implementation needed'
      };
    } catch (e) {
      return {'error': e.toString()};
    }
  }

  /// ì •ë¦¬ ì‘ì—…
  void dispose() {
    _stopGlobalTimer();
    WidgetsBinding.instance.removeObserver(this);
    _lifecycleListeners.clear();
    log.i('ğŸ§¹ AppLifecycleManager ì •ë¦¬ ì™„ë£Œ');
  }
}

/// AppLifecycleManager í”„ë¡œë°”ì´ë”
final appLifecycleManagerProvider = Provider<AppLifecycleManager>((ref) {
  final manager = AppLifecycleManager(ref);
  ref.onDispose(() => manager.dispose());
  return manager;
});\n\n// ====== lib/core/utils/streaming_stats.dart ======\n
\n\n// ====== lib/core/utils/market_data_context.dart ======\n
import 'rolling_window.dart';
import 'advanced_metrics.dart';

/// ğŸ¯ MarketDataContext - ë§ˆì¼“ ë°ì´í„° í†µí•© ê´€ë¦¬
/// 
/// V4.1 ê°œì„ ì‚¬í•­:
/// - 9ê°œ íŒŒë¼ë¯¸í„° â†’ 1ê°œ ê°ì²´ë¡œ ë‹¨ìˆœí™”
/// - íƒ€ì„í”„ë ˆì„ë³„ ìœˆë„ìš° ê´€ë¦¬
/// - ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ ì§€ì›
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ìœˆë„ìš° ê´€ë¦¬
/// - ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
class MarketDataContext {
  final String market;
  
  // ğŸ“Š ë©€í‹° íƒ€ì„í”„ë ˆì„ ê°€ê²© ìœˆë„ìš°
  final Map<Duration, RollingWindow<double>> _priceWindows = {};
  
  // ğŸ“Š ë©€í‹° íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš°
  final Map<Duration, RollingWindow<double>> _volumeWindows = {};
  
  // ğŸ“Š ë³´ì¡° ì§€í‘œ ìœˆë„ìš°ë“¤
  final RollingWindow<double>? buyRatioWindow;
  final RollingWindow<double>? intervalWindow;
  
  /// ìƒì„±ì
  MarketDataContext({
    required this.market,
    required Map<Duration, RollingWindow<double>> priceWindows,
    required Map<Duration, RollingWindow<double>> volumeWindows,
    this.buyRatioWindow,
    this.intervalWindow,
  }) {
    _priceWindows.addAll(priceWindows);
    _volumeWindows.addAll(volumeWindows);
    
    // ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
    _validateWindows();
  }

  /// ğŸ—ï¸ íŒ©í† ë¦¬ ìƒì„±ì - í‘œì¤€ íƒ€ì„í”„ë ˆì„ìœ¼ë¡œ ìƒì„±
  factory MarketDataContext.standard({
    required String market,
    required RollingWindow<double> priceWindow30s,
    required RollingWindow<double> priceWindow60s,
    required RollingWindow<double> priceWindow300s,
    required RollingWindow<double> volumeWindow30s,
    required RollingWindow<double> volumeWindow60s,
    required RollingWindow<double> volumeWindow300s,
    RollingWindow<double>? buyRatioWindow,
    RollingWindow<double>? intervalWindow,
  }) {
    return MarketDataContext(
      market: market,
      priceWindows: {
        const Duration(seconds: 30): priceWindow30s,
        const Duration(seconds: 60): priceWindow60s,
        const Duration(seconds: 300): priceWindow300s,
      },
      volumeWindows: {
        const Duration(seconds: 30): volumeWindow30s,
        const Duration(seconds: 60): volumeWindow60s,
        const Duration(seconds: 300): volumeWindow300s,
      },
      buyRatioWindow: buyRatioWindow,
      intervalWindow: intervalWindow,
    );
  }

  /// ğŸ—ï¸ íŒ©í† ë¦¬ ìƒì„±ì - ë¹ˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
  factory MarketDataContext.empty(String market) {
    return MarketDataContext(
      market: market,
      priceWindows: {
        const Duration(seconds: 30): RollingWindow<double>(span: const Duration(seconds: 30)),
        const Duration(seconds: 60): RollingWindow<double>(span: const Duration(seconds: 60)),
        const Duration(seconds: 300): RollingWindow<double>(span: const Duration(seconds: 300)),
      },
      volumeWindows: {
        const Duration(seconds: 30): RollingWindow<double>(span: const Duration(seconds: 30)),
        const Duration(seconds: 60): RollingWindow<double>(span: const Duration(seconds: 60)),
        const Duration(seconds: 300): RollingWindow<double>(span: const Duration(seconds: 300)),
      },
      buyRatioWindow: RollingWindow<double>(span: const Duration(seconds: 180)),
      intervalWindow: RollingWindow<double>(span: const Duration(seconds: 600)),
    );
  }

  /// ğŸ“Š ê°€ê²© ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> getPriceWindow(Duration timeframe) {
    final window = _priceWindows[timeframe];
    if (window == null) {
      throw ArgumentError('Price window not found for timeframe: ${timeframe.inSeconds}s');
    }
    return window;
  }

  /// ğŸ“Š ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> getVolumeWindow(Duration timeframe) {
    final window = _volumeWindows[timeframe];
    if (window == null) {
      throw ArgumentError('Volume window not found for timeframe: ${timeframe.inSeconds}s');
    }
    return window;
  }

  /// ğŸ“Š ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì„í”„ë ˆì„ ëª©ë¡
  List<Duration> get availableTimeframes {
    final timeframes = <Duration>{..._priceWindows.keys, ..._volumeWindows.keys}.toList();
    timeframes.sort((a, b) => a.inSeconds.compareTo(b.inSeconds));
    return timeframes;
  }

  /// ğŸ“Š ê°€ì¥ ê¸´ íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get longestPriceWindow {
    if (_priceWindows.isEmpty) {
      throw StateError('No price windows available');
    }
    
    final longestTimeframe = _priceWindows.keys.reduce(
      (a, b) => a.inSeconds > b.inSeconds ? a : b
    );
    return _priceWindows[longestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ê¸´ íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get longestVolumeWindow {
    if (_volumeWindows.isEmpty) {
      throw StateError('No volume windows available');
    }
    
    final longestTimeframe = _volumeWindows.keys.reduce(
      (a, b) => a.inSeconds > b.inSeconds ? a : b
    );
    return _volumeWindows[longestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ì§§ì€ íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get shortestPriceWindow {
    if (_priceWindows.isEmpty) {
      throw StateError('No price windows available');
    }
    
    final shortestTimeframe = _priceWindows.keys.reduce(
      (a, b) => a.inSeconds < b.inSeconds ? a : b
    );
    return _priceWindows[shortestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ì§§ì€ íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get shortestVolumeWindow {
    if (_volumeWindows.isEmpty) {
      throw StateError('No volume windows available');
    }
    
    final shortestTimeframe = _volumeWindows.keys.reduce(
      (a, b) => a.inSeconds < b.inSeconds ? a : b
    );
    return _volumeWindows[shortestTimeframe]!;
  }

  /// ğŸ”„ ë°ì´í„° ì—…ë°ì´íŠ¸
  void updateAllWindows({
    required double price,
    required double volume,
    required DateTime timestamp,
    double? buyRatio,
    double? interval,
  }) {
    // ëª¨ë“  ê°€ê²© ìœˆë„ìš° ì—…ë°ì´íŠ¸
    for (final window in _priceWindows.values) {
      window.add(price, timestamp: timestamp);
    }
    
    // ëª¨ë“  ê±°ë˜ëŸ‰ ìœˆë„ìš° ì—…ë°ì´íŠ¸
    for (final window in _volumeWindows.values) {
      window.add(volume, timestamp: timestamp);
    }
    
    // ë³´ì¡° ìœˆë„ìš° ì—…ë°ì´íŠ¸
    if (buyRatio != null && buyRatioWindow != null) {
      buyRatioWindow!.add(buyRatio, timestamp: timestamp);
    }
    
    if (interval != null && intervalWindow != null) {
      intervalWindow!.add(interval, timestamp: timestamp);
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ë©”ì„œë“œ
  void updateWithOnlineMetrics({
    required double price,
    required double volume,
    required DateTime timestamp,
    double? buyRatio,
    double? interval,
    required AdvancedMetrics onlineMetrics,
  }) {
    // ê¸°ë³¸ ìœˆë„ìš° ì—…ë°ì´íŠ¸
    updateAllWindows(
      price: price,
      volume: volume,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: interval,
    );
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œë„ ë™ì‹œ ì—…ë°ì´íŠ¸
    onlineMetrics.updatePrice(
      market: market,
      price: price,
      timestamp: timestamp,
    );
  }

  /// ğŸ“Š ë‹¤ì¤‘ íƒ€ì„í”„ë ˆì„ íŠ¸ë Œë“œ ë¶„ì„
  Map<String, dynamic> getMultiTimeframeTrend() {
    final trends = <String, Map<String, dynamic>>{};
    
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      if (window.length >= 2) {
        final currentPrice = window.values.first;
        final previousPrice = window.values[1];
        final changePercent = ((currentPrice - previousPrice) / previousPrice) * 100;
        
        trends[timeframe] = {
          'changePercent': changePercent,
          'trend': changePercent > 0.1 ? 'UP' : 
                   changePercent < -0.1 ? 'DOWN' : 'FLAT',
          'volatility': window.cv,
          'dataPoints': window.length,
        };
      }
    }
    
    return {
      'market': market,
      'trends': trends,
      'consensus': _calculateTrendConsensus(trends),
    };
  }

  /// ğŸ¯ íŠ¸ë Œë“œ í•©ì˜ ê³„ì‚°
  String _calculateTrendConsensus(Map<String, Map<String, dynamic>> trends) {
    if (trends.isEmpty) return 'UNKNOWN';
    
    final upCount = trends.values.where((t) => t['trend'] == 'UP').length;
    final downCount = trends.values.where((t) => t['trend'] == 'DOWN').length;
    final flatCount = trends.values.where((t) => t['trend'] == 'FLAT').length;
    
    if (upCount > downCount && upCount > flatCount) return 'BULLISH';
    if (downCount > upCount && downCount > flatCount) return 'BEARISH';
    return 'NEUTRAL';
  }

  /// ğŸ“Š ìœˆë„ìš° ìƒíƒœ ì •ë³´
  Map<String, dynamic> getWindowStats() {
    final stats = <String, dynamic>{
      'market': market,
      'priceWindows': <String, dynamic>{},
      'volumeWindows': <String, dynamic>{},
      'auxWindows': <String, dynamic>{},
    };
    
    // ê°€ê²© ìœˆë„ìš° í†µê³„
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      stats['priceWindows'][timeframe] = {
        'length': window.length,
        'mean': window.length > 0 ? window.mean : 0.0,
        'stdev': window.length > 0 ? window.stdev : 0.0,
        'cv': window.length > 0 ? window.cv : 0.0,
        'min': window.length > 0 ? window.min : 0.0,
        'max': window.length > 0 ? window.max : 0.0,
      };
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° í†µê³„
    for (final entry in _volumeWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      stats['volumeWindows'][timeframe] = {
        'length': window.length,
        'sum': window.length > 0 ? window.sum : 0.0,
        'mean': window.length > 0 ? window.mean : 0.0,
        'stdev': window.length > 0 ? window.stdev : 0.0,
      };
    }
    
    // ë³´ì¡° ìœˆë„ìš° í†µê³„
    if (buyRatioWindow != null) {
      stats['auxWindows']['buyRatio'] = {
        'length': buyRatioWindow!.length,
        'mean': buyRatioWindow!.length > 0 ? buyRatioWindow!.mean : 0.5,
      };
    }
    
    if (intervalWindow != null) {
      stats['auxWindows']['interval'] = {
        'length': intervalWindow!.length,
        'mean': intervalWindow!.length > 0 ? intervalWindow!.mean : 0.0,
        'variance': intervalWindow!.length > 0 ? intervalWindow!.variance : 0.0,
      };
    }
    
    return stats;
  }

  /// ğŸ” ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Map<String, dynamic> getDataQuality({AdvancedMetrics? onlineMetrics}) {
    final quality = <String, dynamic>{
      'market': market,
      'overall': 'GOOD',
      'issues': <String>[],
      'scores': <String, double>{},
    };
    
    double totalScore = 0.0;
    int windowCount = 0;
    
    // ê°€ê²© ìœˆë„ìš° í’ˆì§ˆ ê²€ì‚¬
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      double score = 1.0;
      
      if (window.isEmpty) {
        quality['issues'].add('Empty price window: $timeframe');
        score = 0.0;
      } else if (window.length < entry.key.inSeconds / 10) {
        quality['issues'].add('Insufficient data in price window: $timeframe');
        score = 0.5;
      } else if (window.stdev == 0) {
        quality['issues'].add('No price variance in window: $timeframe');
        score = 0.3;
      }
      
      quality['scores']['price_$timeframe'] = score;
      totalScore += score;
      windowCount++;
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° í’ˆì§ˆ ê²€ì‚¬
    for (final entry in _volumeWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      double score = 1.0;
      
      if (window.isEmpty) {
        quality['issues'].add('Empty volume window: $timeframe');
        score = 0.0;
      } else if (window.sum == 0) {
        quality['issues'].add('No volume in window: $timeframe');
        score = 0.0;
      }
      
      quality['scores']['volume_$timeframe'] = score;
      totalScore += score;
      windowCount++;
    }
    
    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í’ˆì§ˆ ê²€ì‚¬
    if (onlineMetrics != null) {
      final metricsHealth = onlineMetrics.getSystemHealth();
      final marketHealth = metricsHealth['markets']?[market];
      
      if (marketHealth != null) {
        double metricsScore = 1.0;
        
        if (marketHealth['isStale'] == true) {
          quality['issues'].add('Online metrics are stale');
          metricsScore = 0.3;
        } else if (marketHealth['rsi']?['isReady'] != true) {
          quality['issues'].add('RSI calculator not ready');
          metricsScore = 0.5;
        } else if (marketHealth['macd']?['isReady'] != true) {
          quality['issues'].add('MACD calculator not ready');
          metricsScore = 0.5;
        }
        
        quality['scores']['online_metrics'] = metricsScore;
        totalScore += metricsScore;
        windowCount++;
        
        // ì˜¨ë¼ì¸ ì§€í‘œ ìƒì„¸ ì •ë³´ ì¶”ê°€
        quality['onlineMetrics'] = {
          'rsi': marketHealth['rsi'],
          'macd': marketHealth['macd'],
          'lastUpdate': marketHealth['lastUpdate'],
        };
      }
    }
    
    // ì „ì²´ í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°
    final overallScore = windowCount > 0 ? totalScore / windowCount : 0.0;
    quality['overallScore'] = overallScore;
    
    if (overallScore >= 0.8) {
      quality['overall'] = 'EXCELLENT';
    } else if (overallScore >= 0.6) {
      quality['overall'] = 'GOOD';
    } else if (overallScore >= 0.4) {
      quality['overall'] = 'FAIR';
    } else {
      quality['overall'] = 'POOR';
    }
    
    return quality;
  }

  /// ğŸ§¹ ìœˆë„ìš° ì •ë¦¬ (ë©”ëª¨ë¦¬ ìµœì í™” + ì˜¨ë¼ì¸ ì§€í‘œ)
  void cleanup({bool force = false, AdvancedMetrics? onlineMetrics}) {
    final now = DateTime.now();
    
    for (final window in _priceWindows.values) {
      if (force || (window.timestamps.isNotEmpty && 
          now.difference(window.timestamps.last).inMinutes > 30)) {
        // ì˜¤ë˜ëœ ë°ì´í„°ë‚˜ force í”Œë˜ê·¸ì‹œ ì •ë¦¬
        window.clear();
      }
    }
    
    for (final window in _volumeWindows.values) {
      if (force || (window.timestamps.isNotEmpty && 
          now.difference(window.timestamps.last).inMinutes > 30)) {
        window.clear();
      }
    }
    
    buyRatioWindow?.clear();
    intervalWindow?.clear();
    
    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œë„ í•¨ê»˜ ì •ë¦¬
    if (onlineMetrics != null && force) {
      onlineMetrics.resetMarket(market);
    }
  }

  /// ğŸ” ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
  void _validateWindows() {
    // ê°€ê²© ìœˆë„ìš° ê²€ì‚¬
    for (final entry in _priceWindows.entries) {
      final timeframe = entry.key;
      final window = entry.value;
      
      if (window.span != timeframe) {
        throw ArgumentError(
          'Price window span mismatch: expected ${timeframe.inSeconds}s, '
          'got ${window.span.inSeconds}s'
        );
      }
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° ê²€ì‚¬
    for (final entry in _volumeWindows.entries) {
      final timeframe = entry.key;
      final window = entry.value;
      
      if (window.span != timeframe) {
        throw ArgumentError(
          'Volume window span mismatch: expected ${timeframe.inSeconds}s, '
          'got ${window.span.inSeconds}s'
        );
      }
    }
  }
}\n\n// ====== lib/core/utils/circular_buffer.dart ======\n
\n\n// ====== lib/core/utils/analysis_isolate_manager.dart ======\n
\n\n// ====== lib/core/extensions/result.dart ======\n
import 'package:meta/meta.dart';
import '../error/app_exception.dart';

/// Either ìŠ¤íƒ€ì¼ì˜ ê²°ê³¼ íƒ€ì….
///
/// - `Ok<T, E>`: ì„±ê³µ ì‹œ ë°ì´í„°ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
/// - `Err<T, E>`: ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
@immutable
sealed class Result<T, E extends AppException> {
  const Result();

  /// ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
  R when<R>({
    required R Function(T value) ok,
    required R Function(E error) err,
  }) {
    if (this is Ok<T, E>) {
      return ok((this as Ok<T, E>).value);
    } else {
      return err((this as Err<T, E>).error);
    }
  }

  /// ì„±ê³µ ì—¬ë¶€
  bool get isOk => this is Ok<T, E>;

  /// ì‹¤íŒ¨ ì—¬ë¶€
  bool get isErr => this is Err<T, E>;

  /// ì„±ê³µ ê°’ (ì—†ìœ¼ë©´ null)
  T? get valueOrNull => isOk ? (this as Ok<T, E>).value : null;

  /// ì‹¤íŒ¨ ì˜ˆì™¸ (ì—†ìœ¼ë©´ null)
  E? get errorOrNull => isErr ? (this as Err<T, E>).error : null;

  /// ì„±ê³µ ê°’ì„ ë§¤í•‘í•©ë‹ˆë‹¤.
  Result<U, E> map<U>(U Function(T value) f) {
    if (this is Ok<T, E>) {
      return Ok<U, E>(f((this as Ok<T, E>).value));
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  /// ì‹¤íŒ¨ ì˜ˆì™¸ë¥¼ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
  /// ì„±ê³µ ì‹œì—ë„ ìƒˆë¡œìš´ ì—ëŸ¬ íƒ€ì… F ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤.
  Result<T, F> mapErr<F extends AppException>(F Function(E error) f) {
    if (this is Err<T, E>) {
      final err = (this as Err<T, E>).error;
      return Err<T, F>(f(err));
    }
    return Ok<T, F>((this as Ok<T, E>).value);
  }

  /// ì„±ê³µ ì‹œ ë¹„ë™ê¸° í›„ì† ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  Future<Result<U, E>> thenAsync<U>(Future<U> Function(T value) f) async {
    if (this is Ok<T, E>) {
      final T value = (this as Ok<T, E>).value;
      try {
        final u = await f(value);
        return Ok<U, E>(u);
      } on AppException catch (e) {
        final E errVal = e is E ? e : AppException(e.message) as E;
        return Err<U, E>(errVal);
      } catch (e) {
        final E errVal = AppException(e.toString()) as E;
        return Err<U, E>(errVal);
      }
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  @override
  String toString() {
    if (this is Ok<T, E>) {
      return 'Ok(${(this as Ok<T, E>).value})';
    } else {
      return 'Err(${(this as Err<T, E>).error})';
    }
  }
}

/// ì„±ê³µ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Ok<T, E extends AppException> extends Result<T, E> {
  final T value;
  const Ok(this.value);
}

/// ì‹¤íŒ¨ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Err<T, E extends AppException> extends Result<T, E> {
  final E error;
  const Err(this.error);
}
\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

import 'package:dio/dio.dart';

/// ìµœìƒìœ„ ì•± ì˜ˆì™¸
/// - ëª¨ë“  ì»¤ìŠ¤í…€ ì˜ˆì™¸ëŠ” ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†í•´ì£¼ì„¸ìš”.
class AppException implements Exception {
  /// ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  ë©”ì‹œì§€
  final String message;

  /// ë‚´ë¶€ ë¡œê¹… ë˜ëŠ” ì‹ë³„ìš© ì½”ë“œ (nullable)
  final String? code;

  /// HTTP ìƒíƒœ ì½”ë“œ ë“± ì¶”ê°€ ìƒíƒœ ì •ë³´
  final int? statusCode;

  /// ì›ë³¸ ì˜ˆì™¸(ìˆëŠ” ê²½ìš°)
  final Exception? originalException;

  const AppException(
    this.message, {
    this.code,
    this.statusCode,
    this.originalException,
  });

  @override
  String toString() {
    final parts = <String>[];
    if (code != null) parts.add('code: $code');
    if (statusCode != null) parts.add('status: $statusCode');
    parts.add('message: $message');
    return 'AppException(${parts.join(', ')})';
  }
}

/// REST/HTTP í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class NetworkException extends AppException {
  const NetworkException(
    String message, {
    String? code,
    int? statusCode,
    Exception? originalException,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
          originalException: originalException,
        );

  /// DioException â†’ NetworkException ë³€í™˜ í—¬í¼
  factory NetworkException.fromDio(DioException dioError) {
    final msg = dioError.message ?? dioError.toString();
    return NetworkException(
      msg,
      code: dioError.response?.statusMessage,
      statusCode: dioError.response?.statusCode,
      originalException: dioError,
    );
  }
}

/// WebSocket ì—°ê²°/í†µì‹  ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class WebSocketException extends AppException {
  /// WS ì„œë²„ê°€ ë³´ë‚¸ ì´ìœ  ë¬¸ìì—´ (nullable)
  final String? reason;

  const WebSocketException(
    String message, {
    this.reason,
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );

  @override
  String toString() {
    final parts = <String>[];
    if (reason != null) parts.add('reason: $reason');
    parts.add('message: $message');
    return 'WebSocketException(${parts.join(', ')})';
  }
}

/// ì„œë²„ë¡œë¶€í„° Rate Limit(HTTP 429 ë“±) ì‘ë‹µì„ ë°›ì•˜ì„ ë•Œ
class RateLimitException extends AppException {
  /// ì¬ì‹œë„ê¹Œì§€ ëŒ€ê¸°í•´ì•¼ í•  ì‹œê°„
  final Duration retryAfter;

  const RateLimitException(
    String message, {
    required this.retryAfter,
    String? code,
    int? statusCode,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
        );

  @override
  String toString() =>
      'RateLimitException(retryAfter: ${retryAfter.inSeconds}s, message: $message)';
}

/// JSON íŒŒì‹± ë˜ëŠ” ë°ì´í„° ë³€í™˜ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class DataParsingException extends AppException {
  const DataParsingException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ì¸ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ í‚¤ë¥¼ ì°¾ì§€ ëª»í–ˆì„ ë•Œ
class CacheMissException extends AppException {
  const CacheMissException([String message = 'Cache miss'])
      : super(message);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ë„ë©”ì¸ íŠ¹í™” ì˜ˆì™¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// ì²´ê²°(Trade) ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜
class TradeException extends AppException {
  const TradeException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜¸ê°€(Order Book) ë°ì´í„° ì˜¤ë¥˜
class OrderBookException extends AppException {
  const OrderBookException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ìº”ë“¤(Candle) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class CandleException extends DataParsingException {
  const CandleException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜„ì¬ê°€(Ticker) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class TickerException extends DataParsingException {
  const TickerException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}
\n\n// ====== lib/core/event/app_event.dart ======\n
// lib/core/event/app_event.dart

import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';

typedef Json = Map<String, dynamic>;

/// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì´ë²¤íŠ¸ì˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤
/// - id     : UUID v4
/// - ts     : UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
/// - payload: ììœ  í˜•íƒœ JSON
class AppEvent extends Equatable {
  /// ê³ ìœ  ID (UUID v4)
  final String id;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int ts;

  /// í˜ì´ë¡œë“œ ë°ì´í„° (ë¶ˆë³€)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// í˜„ì¬ ì‹œê°ì„ ê¸°ì¤€ìœ¼ë¡œ idÂ·tsë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: const Uuid().v4(),
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // ë°©ì–´ì  ë³µì‚¬
    );
  }

  /// UTC ms â†’ ë¡œì»¬ DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON ì§ë ¬í™” (payloadë„ ë³µì‚¬í•˜ì—¬ ë…¸ì¶œ)
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON ì—­ì§ë ¬í™”
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  /// ë³µì‚¬ë³¸ ìƒì„± (immutable ìœ ì§€)
  AppEvent copyWith({
    String? id,
    int? ts,
    Json? payload,
  }) =>
      AppEvent(
        id: id ?? this.id,
        ts: ts ?? this.ts,
        payload: payload != null ? Map<String, dynamic>.of(payload) : this.payload,
      );

  @override
  List<Object?> get props => [id, ts, payload];
}
\n\n// ====== lib/core/services/hive_service.dart ======\n
// lib/core/services/hive_service.dart

import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../utils/logger.dart';
import '../../data/models/trade_dto.dart';
import '../../data/models/market_mood_dto.dart'; // ğŸ”¥ MarketMood DTO ì¶”ê°€

/// ğŸ¯ Hive ì „ì—­ ê´€ë¦¬ ì„œë¹„ìŠ¤ (ì‹±ê¸€í†¤)
/// - ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ì´ˆê¸°í™”
/// - ëª¨ë“  TypeAdapter ë“±ë¡ ë° Box ê´€ë¦¬
/// - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ Box ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// - AppConfigì— ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ì™„ì „ ë…ë¦½ ì„œë¹„ìŠ¤
class HiveService {
  // ì‹±ê¸€í†¤ íŒ¨í„´
  HiveService._();
  static final HiveService _instance = HiveService._();
  factory HiveService() => _instance;

  // ğŸ·ï¸ Box ì´ë¦„ ìƒìˆ˜ (HiveService ìì²´ ê´€ë¦¬)
  static const String _tradeBoxName = 'trades';
  static const String _marketMoodVolumeBoxName = 'market_mood_volume'; // ğŸ”¥ ì¶”ê°€
  static const String _marketMoodCacheBoxName = 'market_mood_cache';   // ğŸ”¥ ì¶”ê°€

  // Box ì¸ìŠ¤í„´ìŠ¤ ìºì‹±
  late final Box<TradeDto> _tradeBox;
  late final Box<TimestampedVolume> _marketMoodVolumeBox; // ğŸ”¥ ì¶”ê°€
  late final Box _marketMoodCacheBox; // ğŸ”¥ ì¶”ê°€ (dynamic)
  
  // ì´ˆê¸°í™” ìƒíƒœ ê´€ë¦¬
  bool _initialized = false;
  Future<void>? _initFuture;

  /// ğŸ¯ Trade Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box<TradeDto> get tradeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using tradeBox.'
      );
    }
    return _tradeBox;
  }

  /// ğŸ”¥ MarketMood Volume Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box<TimestampedVolume> get marketMoodVolumeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using marketMoodVolumeBox.'
      );
    }
    return _marketMoodVolumeBox;
  }

  /// ğŸ”¥ MarketMood Cache Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box get marketMoodCacheBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using marketMoodCacheBox.'
      );
    }
    return _marketMoodCacheBox;
  }

  /// ğŸš€ Hive ì´ˆê¸°í™” (ì•± ì‹œì‘ ì‹œ ë‹¨ í•œ ë²ˆë§Œ í˜¸ì¶œ)
  Future<void> init() async {
    if (_initialized) {
      log.i('[HiveService] already initialized, skipping');
      return;
    }

    // ë™ì‹œ í˜¸ì¶œ ë°©ì–´ - race condition ì™„ì „ ì°¨ë‹¨
    if (_initFuture != null) {
      log.d('[HiveService] init already in progress, waiting...');
      return _initFuture;
    }

    _initFuture = _doInit();
    await _initFuture;
  }

  /// ğŸ”§ ì‹¤ì œ ì´ˆê¸°í™” ë¡œì§
  Future<void> _doInit() async {
    try {
      // 1. Hive í”Œë«í¼ ì´ˆê¸°í™”
      await Hive.initFlutter();
      log.i('[HiveService] Hive.initFlutter() completed');

      // 2. TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
      _registerAdapters();

      // 3. ëª¨ë“  Box ì—´ê¸° ë° ìºì‹±
      _tradeBox = await Hive.openBox<TradeDto>(_tradeBoxName);
      log.i('[HiveService] "$_tradeBoxName" box opened and cached');

      _marketMoodVolumeBox = await Hive.openBox<TimestampedVolume>(_marketMoodVolumeBoxName); // ğŸ”¥ ì¶”ê°€
      log.i('[HiveService] "$_marketMoodVolumeBoxName" box opened and cached');

      _marketMoodCacheBox = await Hive.openBox(_marketMoodCacheBoxName); // ğŸ”¥ ì¶”ê°€
      log.i('[HiveService] "$_marketMoodCacheBoxName" box opened and cached');

      _initialized = true;
      log.i('[HiveService] âœ… initialized successfully');
      
    } catch (e, st) {
      log.e('[HiveService] âŒ init failed', e, st);
      _initialized = false;
      rethrow; // ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ìƒìœ„ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡
    } finally {
      // ì´ˆê¸°í™” ì™„ë£Œ í›„ Future í•´ì œ (ì¬ì‹œë„ ê°€ëŠ¥í•˜ë„ë¡)
      _initFuture = null;
    }
  }

  /// ğŸ“‹ ëª¨ë“  TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
  void _registerAdapters() {
    // Trade Adapter
    final tradeAdapter = TradeDtoAdapter();
    if (!Hive.isAdapterRegistered(tradeAdapter.typeId)) {
      Hive.registerAdapter(tradeAdapter);
      log.i('[HiveService] TradeDtoAdapter registered (typeId: ${tradeAdapter.typeId})');
    } else {
      log.d('[HiveService] TradeDtoAdapter already registered');
    }
    
    // ğŸ”¥ TimestampedVolume Adapter ì¶”ê°€
    final volumeAdapter = TimestampedVolumeAdapter();
    if (!Hive.isAdapterRegistered(volumeAdapter.typeId)) {
      Hive.registerAdapter(volumeAdapter);
      log.i('[HiveService] TimestampedVolumeAdapter registered (typeId: ${volumeAdapter.typeId})');
    } else {
      log.d('[HiveService] TimestampedVolumeAdapter already registered');
    }
    
    // ğŸ“ í–¥í›„ ë‹¤ë¥¸ ì–´ëŒ‘í„° ì¶”ê°€ ì‹œ ì—¬ê¸°ì— ì¶”ê°€
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ ì‹¤í–‰)
  /// ì¼ë°˜ì ìœ¼ë¡œ ëª¨ë°”ì¼ ì•±ì—ì„œëŠ” OSê°€ ìë™ ì •ë¦¬í•˜ë¯€ë¡œ í˜¸ì¶œ ë¶ˆí•„ìš”
  Future<void> dispose() async {
    if (!kDebugMode) {
      log.d('[HiveService] dispose skipped in production mode');
      return;
    }
    
    if (!_initialized) {
      log.d('[HiveService] not initialized, skip dispose');
      return;
    }

    try {
      if (_tradeBox.isOpen) {
        await _tradeBox.close();
        log.i('[HiveService] "$_tradeBoxName" box closed');
      }

      // ğŸ”¥ MarketMood Boxë“¤ ì •ë¦¬ ì¶”ê°€
      if (_marketMoodVolumeBox.isOpen) {
        await _marketMoodVolumeBox.close();
        log.i('[HiveService] "$_marketMoodVolumeBoxName" box closed');
      }

      if (_marketMoodCacheBox.isOpen) {
        await _marketMoodCacheBox.close();
        log.i('[HiveService] "$_marketMoodCacheBoxName" box closed');
      }

      await Hive.close();
      log.i('[HiveService] ğŸ§¹ all Hive resources disposed');
      
    } catch (e, st) {
      log.e('[HiveService] dispose failed', e, st);
    } finally {
      _initialized = false;
    }
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: í˜„ì¬ ìƒíƒœ ì •ë³´
  Map<String, Object> get debugInfo => {
    'initialized': _initialized,
    'tradeBox': {
      'name': _tradeBoxName,
      'open': _initialized ? _tradeBox.isOpen : false,
      'length': _initialized ? _tradeBox.length : 0,
    },
    'marketMoodVolumeBox': { // ğŸ”¥ ì¶”ê°€
      'name': _marketMoodVolumeBoxName,
      'open': _initialized ? _marketMoodVolumeBox.isOpen : false,
      'length': _initialized ? _marketMoodVolumeBox.length : 0,
    },
    'marketMoodCacheBox': { // ğŸ”¥ ì¶”ê°€
      'name': _marketMoodCacheBoxName,
      'open': _initialized ? _marketMoodCacheBox.isOpen : false,
      'length': _initialized ? _marketMoodCacheBox.length : 0,
    },
    'initInProgress': _initFuture != null,
  };

  /// ğŸ” ë””ë²„ê¹…ìš©: ìƒíƒœ ë¡œê¹…
  void logStatus() {
    log.d('[HiveService] Status: $debugInfo');
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: Box ìƒì„¸ ì •ë³´ (ê°œë°œ ì‹œ ìœ ìš©)
  void logBoxDetails() {
    if (!_initialized) {
      log.w('[HiveService] Cannot log box details - not initialized');
      return;
    }
    
    log.d('[HiveService] Box Details:');
    log.d('  Trade Box:');
    log.d('    - Name: $_tradeBoxName');
    log.d('    - Length: ${_tradeBox.length}');
    log.d('    - Keys sample: ${_tradeBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_tradeBox.isOpen}');
    
    // ğŸ”¥ MarketMood Box ì •ë³´ ì¶”ê°€
    log.d('  MarketMood Volume Box:');
    log.d('    - Name: $_marketMoodVolumeBoxName');
    log.d('    - Length: ${_marketMoodVolumeBox.length}');
    log.d('    - Keys sample: ${_marketMoodVolumeBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_marketMoodVolumeBox.isOpen}');
    
    log.d('  MarketMood Cache Box:');
    log.d('    - Name: $_marketMoodCacheBoxName');
    log.d('    - Length: ${_marketMoodCacheBox.length}');
    log.d('    - Keys sample: ${_marketMoodCacheBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_marketMoodCacheBox.isOpen}');
  }
}\n\n// ====== lib/firebase_options.dart ======\n
// File generated by FlutterFire CLI and modified for .env
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'package:flutter_dotenv/flutter_dotenv.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static FirebaseOptions get web {
    _checkEnvKeys([
      'FIREBASE_WEB_API_KEY',
      'FIREBASE_WEB_APP_ID',
      'FIREBASE_WEB_MESSAGING_SENDER_ID',
      'FIREBASE_WEB_PROJECT_ID',
      'FIREBASE_WEB_AUTH_DOMAIN',
      'FIREBASE_WEB_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_WEB_API_KEY']!,
      appId: dotenv.env['FIREBASE_WEB_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_WEB_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_WEB_PROJECT_ID']!,
      authDomain: dotenv.env['FIREBASE_WEB_AUTH_DOMAIN']!,
      storageBucket: dotenv.env['FIREBASE_WEB_STORAGE_BUCKET']!,
    );
  }

  static FirebaseOptions get android {
    _checkEnvKeys([
      'FIREBASE_ANDROID_API_KEY',
      'FIREBASE_ANDROID_APP_ID',
      'FIREBASE_ANDROID_MESSAGING_SENDER_ID',
      'FIREBASE_ANDROID_PROJECT_ID',
      'FIREBASE_ANDROID_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_ANDROID_API_KEY']!,
      appId: dotenv.env['FIREBASE_ANDROID_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_ANDROID_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_ANDROID_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_ANDROID_STORAGE_BUCKET']!,
    );
  }

  static FirebaseOptions get ios {
    _checkEnvKeys([
      'FIREBASE_IOS_API_KEY',
      'FIREBASE_IOS_APP_ID',
      'FIREBASE_IOS_MESSAGING_SENDER_ID',
      'FIREBASE_IOS_PROJECT_ID',
      'FIREBASE_IOS_STORAGE_BUCKET',
      'FIREBASE_IOS_BUNDLE_ID',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_IOS_API_KEY']!,
      appId: dotenv.env['FIREBASE_IOS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_IOS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_IOS_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_IOS_STORAGE_BUCKET']!,
      iosBundleId: dotenv.env['FIREBASE_IOS_BUNDLE_ID']!,
    );
  }

  static FirebaseOptions get macos {
    _checkEnvKeys([
      'FIREBASE_MACOS_API_KEY',
      'FIREBASE_MACOS_APP_ID',
      'FIREBASE_MACOS_MESSAGING_SENDER_ID',
      'FIREBASE_MACOS_PROJECT_ID',
      'FIREBASE_MACOS_STORAGE_BUCKET',
      'FIREBASE_MACOS_BUNDLE_ID',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_MACOS_API_KEY']!,
      appId: dotenv.env['FIREBASE_MACOS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_MACOS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_MACOS_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_MACOS_STORAGE_BUCKET']!,
      iosBundleId: dotenv.env['FIREBASE_MACOS_BUNDLE_ID']!,
    );
  }

  static FirebaseOptions get windows {
    _checkEnvKeys([
      'FIREBASE_WINDOWS_API_KEY',
      'FIREBASE_WINDOWS_APP_ID',
      'FIREBASE_WINDOWS_MESSAGING_SENDER_ID',
      'FIREBASE_WINDOWS_PROJECT_ID',
      'FIREBASE_WINDOWS_AUTH_DOMAIN',
      'FIREBASE_WINDOWS_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_WINDOWS_API_KEY']!,
      appId: dotenv.env['FIREBASE_WINDOWS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_WINDOWS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_WINDOWS_PROJECT_ID']!,
      authDomain: dotenv.env['FIREBASE_WINDOWS_AUTH_DOMAIN']!,
      storageBucket: dotenv.env['FIREBASE_WINDOWS_STORAGE_BUCKET']!,
    );
  }

  static void _checkEnvKeys(List<String> keys) {
    for (var key in keys) {
      if (dotenv.env[key] == null) {
        throw Exception('$key is missing in .env file');
      }
    }
  }
}\n\n// ====== lib/shared/information/app_information_modal.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:package_info_plus/package_info_plus.dart';

class AppInformationModal {
  /// ì•± ì •ë³´ ëª¨ë‹¬ í‘œì‹œ
  static void show(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: true,
      barrierColor: Colors.black54,
      builder: (context) => const _AppInformationContent(),
    );
  }
}

class _AppInformationContent extends StatefulWidget {
  const _AppInformationContent();

  @override
  State<_AppInformationContent> createState() => _AppInformationContentState();
}

class _AppInformationContentState extends State<_AppInformationContent> {
  PackageInfo? _packageInfo;

  @override
  void initState() {
    super.initState();
    _loadPackageInfo();
  }

  Future<void> _loadPackageInfo() async {
    try {
      final packageInfo = await PackageInfo.fromPlatform();
      if (mounted) {
        setState(() {
          _packageInfo = packageInfo;
        });
      }
    } catch (e) {
      // íŒ¨í‚¤ì§€ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
      if (mounted) {
        setState(() {
          _packageInfo = null;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final screenWidth = MediaQuery.of(context).size.width;
    final isLandscape = MediaQuery.of(context).orientation == Orientation.landscape;
    
    // ì„¤ì • ëª¨ë‹¬ë³´ë‹¤ ì¡°ê¸ˆ ì‘ì€ í¬ê¸°ë¡œ ì„¤ì •
    final dialogHeight = isLandscape 
        ? (screenHeight * 0.6).clamp(250.0, 300.0)
        : 450.0;
    final dialogWidth = screenWidth * 0.85;

    return Dialog(
      backgroundColor: Colors.transparent,
      child: Container(
        width: dialogWidth,
        height: dialogHeight,
        decoration: BoxDecoration(
          color: Theme.of(context).scaffoldBackgroundColor,
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withAlpha(26),
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Column(
          children: [
            _buildHeader(context),
            Divider(color: Colors.grey.shade300, height: 1),
            Expanded(child: _buildContent(context)),
            _buildFooter(context),
          ],
        ),
      ),
    );
  }

  /// í—¤ë” (ì œëª©ë§Œ, Xë²„íŠ¼ ì œê±°)
  Widget _buildHeader(BuildContext context) {
    return const Padding(
      padding: EdgeInsets.all(16),
      child: Row(
        children: [
          Icon(Icons.info_outline, color: Colors.orange, size: 24),
          SizedBox(width: 8),
          Text(
            'ì•± ì •ë³´',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  /// ì•± ì •ë³´ ë‚´ìš©
  Widget _buildContent(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: Column(
        children: [
          const SizedBox(height: 8),
          
          // ì•± ì•„ì´ì½˜ ë° ì´ë¦„
          _buildAppIcon(),
          const SizedBox(height: 20),
          
          // ì•± ì •ë³´ ì¹´ë“œë“¤
          _buildInfoCard(
            icon: Icons.smartphone,
            title: 'ì•± ì´ë¦„',
            value: _packageInfo?.appName ?? 'Crypto Tracker',
          ),
          const SizedBox(height: 12),
          
          _buildInfoCard(
            icon: Icons.numbers,
            title: 'ë²„ì „',
            value: _packageInfo?.version ?? '1.0.0',
          ),
          const SizedBox(height: 12),
          
          _buildInfoCard(
            icon: Icons.code,
            title: 'ë¹Œë“œ ë²ˆí˜¸',
            value: _packageInfo?.buildNumber ?? '1',
          ),
          const SizedBox(height: 12),
          
          _buildInfoCard(
            icon: Icons.business,
            title: 'íŒ¨í‚¤ì§€ëª…',
            value: _packageInfo?.packageName ?? 'com.example.crypto_tracker',
            isLongText: true,
          ),
          const SizedBox(height: 12),
          
          _buildInfoCard(
            icon: Icons.person,
            title: 'ê°œë°œì',
            value: 'hd cho',
          ),
          const SizedBox(height: 12),
          
          _buildInfoCard(
            icon: Icons.calendar_today,
            title: 'ë¹Œë“œ ë‚ ì§œ',
            value: _getBuildDate(),
          ),
        ],
      ),
    );
  }

/// ì•± ì•„ì´ì½˜ ìœ„ì ¯ (ì´ë¯¸ì§€ë¡œ ë³€ê²½)
Widget _buildAppIcon() {
  return Container(
    width: 80,
    height: 80,
    decoration: const BoxDecoration(
      borderRadius: BorderRadius.all(Radius.circular(16)),
      boxShadow: [
        BoxShadow(
          color: Colors.orange,
          blurRadius: 8,
          offset: Offset(0, 4),
        ),
      ],
    ),
    child: ClipRRect(
      borderRadius: BorderRadius.circular(16),
      child: Center(
        child: Image.asset(
          'assets/app_information_icon.webp',
          width: 64,  // 80ì˜ 80% = 64
          height: 64, // 80ì˜ 80% = 64
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) {
            // ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì•„ì´ì½˜ í‘œì‹œ
            return Container(
              width: 80,
              height: 80,
              decoration: const BoxDecoration(
                borderRadius: BorderRadius.all(Radius.circular(16)),
                gradient: LinearGradient(
                  colors: [Colors.grey, Colors.deepOrange],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
              ),
              child: const Icon(
                Icons.trending_up,
                color: Colors.white,
                size: 40,
              ),
            );
          },
        ),
      ),
    ),
  );
}

  /// ë¹Œë“œ ë‚ ì§œ ìë™ ìƒì„±
  String _getBuildDate() {
    final now = DateTime.now();
    return '${now.year}.${now.month.toString().padLeft(2, '0')}.${now.day.toString().padLeft(2, '0')}';
  }

  /// ì •ë³´ ì¹´ë“œ ìœ„ì ¯
  Widget _buildInfoCard({
    required IconData icon,
    required String title,
    required String value,
    bool isLongText = false,
  }) {
    return Card(
      elevation: 1,
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Icon(icon, color: Colors.orange, size: 20),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: const TextStyle(
                      fontSize: 12,
                      color: Colors.grey,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  const SizedBox(height: 2),
                  GestureDetector(
                    onTap: isLongText ? () => _copyToClipboard(context, value) : null,
                    child: Text(
                      value,
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w600,
                        color: isLongText ? Colors.orange : null,
                        decoration: isLongText ? TextDecoration.underline : null,
                      ),
                      maxLines: isLongText ? 2 : 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
            if (isLongText)
              const Icon(
                Icons.copy,
                color: Colors.grey,
                size: 16,
              ),
          ],
        ),
      ),
    );
  }

  /// í‘¸í„° (ì €ì‘ê¶Œ ì •ë³´ë§Œ)
  Widget _buildFooter(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Text(
        'Â© 2025 Noonchit',
        style: TextStyle(
          fontSize: 12,
          color: Colors.grey.shade600,
        ),
      ),
    );
  }

  /// í´ë¦½ë³´ë“œì— ë³µì‚¬
  void _copyToClipboard(BuildContext context, String text) {
    Clipboard.setData(ClipboardData(text: text));
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('$textê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤'),
        duration: const Duration(seconds: 2),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
}\n\n// ====== lib/shared/utils/blink_animation_mixin.dart ======\n
// lib/shared/utils/blink_animation_mixin.dart
import 'package:flutter/material.dart';

/// âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ í—¬í¼ í´ë˜ìŠ¤
/// ë³µì¡í•œ Mixin ëŒ€ì‹  ê°„ë‹¨í•œ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ë¡œ ì œê³µ
class BlinkAnimationHelper {
  
  /// ë°˜ì§ì„ íš¨ê³¼ê°€ ì ìš©ëœ ìœ„ì ¯ ë˜í•‘
  static Widget wrapWithBlinkEffect({
    required Widget child,
    required bool shouldBlink,
    required Animation<double> blinkAnimation,
    Color blinkColor = Colors.orange,
    double blurRadius = 15.0,
    double spreadRadius = 4.0,
    BorderRadius? borderRadius,
  }) {
    if (!shouldBlink) return child;
    
    return AnimatedBuilder(
      animation: blinkAnimation,
      builder: (context, _) {
        return Container(
          decoration: BoxDecoration(
            borderRadius: borderRadius ?? BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: blinkColor.withValues(
                  alpha: (1.0 - blinkAnimation.value) * 0.8,
                ),
                blurRadius: blurRadius,
                spreadRadius: spreadRadius,
              ),
            ],
          ),
          child: child,
        );
      },
    );
  }
  
  /// ì¡°ê±´ë¶€ ê¹œë¹¡ì„ íš¨ê³¼
  static Widget wrapWithConditionalBlink({
    required Widget child,
    required bool enableBlinkAnimation,
    required ThemeData theme,
    BorderRadius? borderRadius,
  }) {
    if (!enableBlinkAnimation) return child;
    
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 1.0, end: 0.7),
      duration: const Duration(milliseconds: 300),
      builder: (context, value, _) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          decoration: BoxDecoration(
            borderRadius: borderRadius ?? BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: theme.colorScheme.primary.withValues(alpha: 1.0 - value),
                blurRadius: 8,
                spreadRadius: 2,
              ),
            ],
          ),
          child: child,
        );
      },
    );
  }
  
  /// ìˆœìœ„ ë³€í™” ê°ì§€ ë° ë°˜ì§ì„ ì²˜ë¦¬
  static bool checkRankChange({
    required Map<String, int> previousRanksMap,
    required String key,
    required int currentRank,
  }) {
    final previousRank = previousRanksMap[key];
    final shouldBlink = previousRank != null && currentRank < previousRank;
    
    // í˜„ì¬ ìˆœìœ„ë¥¼ ì €ì¥
    previousRanksMap[key] = currentRank;
    
    return shouldBlink;
  }
  
  /// ìƒˆë¡œìš´ ì‹œê·¸ë„ ê°ì§€
  static bool checkNewSignal({
    required Set<String> blinkedSignalsSet,
    required DateTime detectedAt,
    required String signalKey,
    int maxAgeSeconds = 10,
  }) {
    final now = DateTime.now();
    final signalAge = now.difference(detectedAt).inSeconds;
    
    if (signalAge <= maxAgeSeconds && !blinkedSignalsSet.contains(signalKey)) {
      blinkedSignalsSet.add(signalKey);
      return true;
    }
    
    return false;
  }
}\n\n// ====== lib/shared/utils/tile_common.dart ======\n
// lib/shared/utils/tile_common.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
// import '../../domain/entities/app_settings.dart'; // ë¶ˆí•„ìš”í•œ import ì œê±°

/// ğŸ¯ íƒ€ì¼ ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
/// SignalTile, TradeTile, VolumeTile, SectorTileì—ì„œ ì¤‘ë³µë˜ëŠ” ë¡œì§ë“¤ì„ í†µí•© ê´€ë¦¬
class TileCommon {
  
  // ==================== ì½”ì¸ëª… í‘œì‹œ ê´€ë ¨ ====================
  
  /// ğŸª™ ë™ì  ì½”ì¸ëª… í‘œì‹œ (ticker/korean/english ì „í™˜)
  /// SignalTile, TradeTile, VolumeTileì—ì„œ ê³µí†µ ì‚¬ìš©
  static String getDisplayName(WidgetRef ref, String market) {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final marketInfoAsync = ref.watch(marketInfoProvider);
    
    // ê¸°ë³¸ í‹°ì»¤ (fallback)
    final ticker = market.replaceFirst('KRW-', '');
    
    // marketInfoê°€ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì—ëŸ¬ì¸ ê²½ìš° í‹°ì»¤ ë°˜í™˜
    return marketInfoAsync.when(
      data: (marketInfoMap) {
        final marketInfo = marketInfoMap[market];
        
        switch (displayMode) {
          case DisplayMode.ticker:
            return ticker;
          case DisplayMode.korean:
            return marketInfo?.koreanName ?? ticker;
          case DisplayMode.english:
            return marketInfo?.englishName ?? ticker;
        }
      },
      loading: () => ticker, // ë¡œë”© ì¤‘ì—ëŠ” í‹°ì»¤ í‘œì‹œ
      error: (_, __) => ticker, // ì—ëŸ¬ ì‹œì—ë„ í‹°ì»¤ í‘œì‹œ
    );
  }
  
  // ==================== ìˆœìœ„ ê´€ë ¨ ====================
  
  /// ğŸ† ìˆœìœ„ì— ë”°ë¥¸ ìƒ‰ìƒ ê²°ì •
  /// VolumeTile, SectorTileì—ì„œ ê³µí†µ ì‚¬ìš©
  static Color getRankColor(BuildContext context, int rank) {
    final theme = Theme.of(context);
    switch (rank) {
      case 1:
        return Colors.amber; // ğŸ¥‡ 1ìœ„ - ê¸ˆìƒ‰
      case 2:
        return Colors.grey.shade400; // ğŸ¥ˆ 2ìœ„ - ì€ìƒ‰
      case 3:
        return Colors.orange.shade300; // ğŸ¥‰ 3ìœ„ - ë™ìƒ‰
      default:
        return theme.colorScheme.onSurface.withValues(alpha: 0.6); // ê¸°ë³¸
    }
  }
  
  /// ğŸ¯ ìˆœìœ„ ìœ„ì ¯ ìƒì„±
  /// VolumeTile, SectorTileì—ì„œ ê³µí†µ ì‚¬ìš©
  static Widget buildRankWidget(BuildContext context, int rank) {
    final rankColor = getRankColor(context, rank);
    final isTopThree = rank <= 3;
    
    return Container(
      width: 32,
      height: 32,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        color: isTopThree ? rankColor.withValues(alpha: 0.2) : Colors.transparent,
        border: isTopThree ? Border.all(color: rankColor, width: 2) : null,
      ),
      child: Center(
        child: Text(
          '$rank',
          style: TextStyle(
            fontSize: 14,
            fontWeight: isTopThree ? FontWeight.bold : FontWeight.normal,
            color: rankColor,
          ),
        ),
      ),
    );
  }
  
  // ==================== ìƒíƒœ ì•„ì´ì½˜ ê´€ë ¨ ====================
  
  /// ğŸ”¥ HOT ì•„ì´ì½˜ (ê¸‰ìƒìŠ¹ í‘œì‹œ) - ê¹”ë”í•œ í…ìŠ¤íŠ¸ ë””ìì¸
  /// SignalTile, VolumeTile, SectorTileì—ì„œ ê³µí†µ ì‚¬ìš©
  static Widget? buildHotIcon(bool showHotIcon) {
    if (!showHotIcon) return null;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: Colors.red,
        borderRadius: BorderRadius.circular(12), // âœ… Volume í† ê¸€ê³¼ ì¼ì¹˜
      ),
      child: const Text(
        'HOT', // âœ… ì´ëª¨ì§€ ì œê±°, í…ìŠ¤íŠ¸ë§Œ
        style: TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  /// ğŸ†• NEW ë±ƒì§€ (ìµœê·¼ ê°ì§€ëœ ì‹œê·¸ë„ìš©)
  /// SignalTileì—ì„œ ì‚¬ìš©
  static Widget? buildNewBadge(DateTime detectedAt, {int maxAgeSeconds = 30}) {
    final signalAge = DateTime.now().difference(detectedAt).inSeconds;
    if (signalAge > maxAgeSeconds) return null;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        color: Colors.red,
        borderRadius: BorderRadius.circular(6),
      ),
      child: const Text(
        'NEW',
        style: TextStyle(
          color: Colors.white,
          fontSize: 9,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
  
  // ==================== ë³€í™”ìœ¨/ê°€ê²© ê´€ë ¨ ====================
  
  /// ğŸ“ˆ ë³€í™”ìœ¨ í¬ë§·íŒ…
  /// SignalTileì—ì„œ ì‚¬ìš©
  static String formatChangePercent(double changePercent) {
    final absChange = changePercent.abs();
    if (absChange >= 10) {
      return '${changePercent >= 0 ? '+' : ''}${changePercent.toStringAsFixed(1)}%';
    } else {
      return '${changePercent >= 0 ? '+' : ''}${changePercent.toStringAsFixed(2)}%';
    }
  }
  
  /// ğŸ¨ ë³€í™”ìœ¨ì— ë”°ë¥¸ ìƒ‰ìƒ
  /// SignalTileì—ì„œ ì‚¬ìš©
  static Color getChangeColor(double changePercent) {
    if (changePercent > 0) {
      return Colors.red; // ìƒìŠ¹: ë¹¨ê°•
    } else if (changePercent < 0) {
      return Colors.blue; // í•˜ë½: íŒŒë‘
    } else {
      return Colors.grey; // ë³€ë™ ì—†ìŒ: íšŒìƒ‰
    }
  }
  
  // ==================== ë°˜ì§ì„ íš¨ê³¼ ê´€ë ¨ ====================
  
  /// âœ¨ ë°˜ì§ì„ íš¨ê³¼ê°€ ì ìš©ëœ ìœ„ì ¯ ë˜í•‘
  /// ëª¨ë“  íƒ€ì¼ì—ì„œ ê³µí†µ ì‚¬ìš©
  static Widget wrapWithBlinkEffect({
    required Widget child,
    required bool shouldBlink,
    required Animation<double> blinkAnimation,
    Color blinkColor = Colors.orange,
    double blurRadius = 15.0,
    double spreadRadius = 4.0,
    BorderRadius? borderRadius,
  }) {
    if (!shouldBlink) return child;
    
    return AnimatedBuilder(
      animation: blinkAnimation,
      builder: (context, _) {
        return Container(
          decoration: BoxDecoration(
            borderRadius: borderRadius ?? BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: blinkColor.withValues(
                  alpha: (1.0 - blinkAnimation.value) * 0.8,
                ),
                blurRadius: blurRadius,
                spreadRadius: spreadRadius,
              ),
            ],
          ),
          child: child,
        );
      },
    );
  }
  
  /// ğŸ¯ ì¡°ê±´ë¶€ ê¹œë¹¡ì„ íš¨ê³¼ (enableBlinkAnimationìš©)
  /// ëª¨ë“  íƒ€ì¼ì—ì„œ ê³µí†µ ì‚¬ìš©
  static Widget wrapWithConditionalBlink({
    required Widget child,
    required bool enableBlinkAnimation,
    required ThemeData theme,
    BorderRadius? borderRadius,
  }) {
    if (!enableBlinkAnimation) return child;
    
    return TweenAnimationBuilder<double>(
      tween: Tween(begin: 1.0, end: 0.7),
      duration: const Duration(milliseconds: 300),
      builder: (context, value, _) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          decoration: BoxDecoration(
            borderRadius: borderRadius ?? BorderRadius.circular(12),
            boxShadow: [
              BoxShadow(
                color: theme.colorScheme.primary.withValues(alpha: 1.0 - value),
                blurRadius: 8,
                spreadRadius: 2,
              ),
            ],
          ),
          child: child,
        );
      },
    );
  }
  
  // ==================== ê³µí†µ ë ˆì´ì•„ì›ƒ í—¬í¼ ====================
  
  /// ğŸ“± í‘œì¤€ ì¹´ë“œ ë˜í¼
  static Widget buildStandardCard({
    required Widget child,
    EdgeInsetsGeometry? margin,
    EdgeInsetsGeometry? padding,
    BorderRadius? borderRadius,
    double? elevation,
  }) {
    return Card(
      elevation: elevation ?? 2,
      margin: margin ?? const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? BorderRadius.circular(12),
      ),
      child: Padding(
        padding: padding ?? const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: child,
      ),
    );
  }
  
  /// ğŸ”§ Flex ê¸°ë°˜ Row ë ˆì´ì•„ì›ƒ í—¬í¼
  static Widget buildFlexRow({
    required List<FlexChild> children,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
  }) {
    return Row(
      mainAxisAlignment: mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment,
      children: children.map((flexChild) {
        if (flexChild.flex > 0) {
          return Expanded(
            flex: flexChild.flex,
            child: flexChild.child,
          );
        } else {
          return flexChild.child;
        }
      }).toList(),
    );
  }
}

/// ğŸ”§ Flex ë ˆì´ì•„ì›ƒìš© í—¬í¼ í´ë˜ìŠ¤
class FlexChild {
  final Widget child;
  final int flex; // 0ì´ë©´ Expanded ì‚¬ìš© ì•ˆí•¨
  
  const FlexChild(this.child, {this.flex = 0});
  
  /// ê³ ì • í¬ê¸° ìœ„ì ¯
  const FlexChild.fixed(this.child) : flex = 0;
  
  /// í™•ì¥ ê°€ëŠ¥í•œ ìœ„ì ¯
  const FlexChild.expanded(this.child, {this.flex = 1});
}\n\n// ====== lib/shared/utils/amount_formatter.dart ======\n
// lib/shared/utils/amount_formatter.dart
import 'package:intl/intl.dart';

/// ğŸ’° ê¸ˆì•¡ í¬ë§·íŒ… ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
/// ëª¨ë“  íƒ€ì¼ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê¸ˆì•¡/ê°€ê²©/ê±°ë˜ëŸ‰ í¬ë§·íŒ…ì„ í†µí•© ê´€ë¦¬
class AmountFormatter {
  // í¬ë§·í„° ìºì‹± (ì„±ëŠ¥ ìµœì í™”)
  static final _integerFormat = NumberFormat('#,###');
  static final _decimalFormat = NumberFormat('#,##0.##');
  static final _decimal3Format = NumberFormat('#,##0.###');
  static final _decimal6Format = NumberFormat('#,##0.######');
  static final _decimal1Format = NumberFormat('#,##0.#');
  
  // ==================== ê±°ë˜ëŸ‰ í¬ë§·íŒ… ====================
  
  /// ğŸ“Š ê±°ë˜ëŸ‰ í¬ë§·íŒ… (VolumeTile, SectorTileì—ì„œ ì‚¬ìš©)
  /// í†µí•©ëœ ê±°ë˜ëŸ‰ í‘œì‹œ ê·œì¹™
  static String formatVolume(double totalVolume) {
    if (totalVolume < 0) return '0ì›';
    
    // 1ë§Œì› ë¯¸ë§Œ: 1ì› ~ 9,999ì› (ì½¤ë§ˆ í¬í•¨)
    if (totalVolume < 10000) {
      return '${_integerFormat.format(totalVolume.toInt())}ì›';
    }
    // 1ë§Œì› ~ 9999ë§Œì›: x,xxxë§Œì› (ì½¤ë§ˆ í¬í•¨)
    else if (totalVolume < 100000000) {
      final man = (totalVolume / 10000).toInt();
      return '${_integerFormat.format(man)}ë§Œì›';
    }
    // 1ì–µ ~ 9999ì–µ: x.xxì–µì› (ì†Œìˆ˜ì  2ìë¦¬)
    else if (totalVolume < 1000000000000) {
      final eok = totalVolume / 100000000;
      return '${_decimalFormat.format(eok)}ì–µì›';
    }
    // 1ì¡° ~ 9999ì¡°: x.xxì¡°ì› (ì†Œìˆ˜ì  2ìë¦¬)
    else if (totalVolume < 10000000000000000) {
      final jo = totalVolume / 1000000000000;
      return '${_decimalFormat.format(jo)}ì¡°ì›';
    }
    // 1ê²½ ì´ìƒ: x,xxxê²½ì› (ì½¤ë§ˆ í¬í•¨)
    else {
      final gyeong = (totalVolume / 10000000000000000).toInt();
      return '${_integerFormat.format(gyeong)}ê²½ì›';
    }
  }
  
  // ==================== ê°€ê²© í¬ë§·íŒ… ====================
  
  /// ğŸ’µ ì¡°ê±´ë¶€ ê°€ê²© í¬ë§·íŒ… (TradeTile, SignalTileì—ì„œ ì‚¬ìš©)
  /// ê°€ê²© í¬ê¸°ì— ë”°ë¼ ì†Œìˆ˜ì  ìë¦¿ìˆ˜ë¥¼ ë™ì  ì¡°ì ˆ
  static String formatPrice(double price) {
    if (price <= 1.0) {
      return _decimal6Format.format(price); // 1 ì´í•˜: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else if (price < 10.0) {
      return _decimal3Format.format(price); // 1 ì´ˆê³¼ ~ 10 ë¯¸ë§Œ: ì†Œìˆ˜ì  3ìë¦¬
    } else if (price < 100.0) {
      return _decimalFormat.format(price); // 10 ì´ˆê³¼ ~ 100 ë¯¸ë§Œ: ì†Œìˆ˜ì  2ìë¦¬
    } else if (price < 1000.0) {
      return _decimal1Format.format(price); // 100 ì´ˆê³¼ ~ 1000 ë¯¸ë§Œ: ì†Œìˆ˜ì  1ìë¦¬
    } else {
      return _integerFormat.format(price); // 1000 ì´ìƒ: ì •ìˆ˜
    }
  }
  
  /// ğŸ“ˆ ê±°ë˜ëŸ‰ ê°œìˆ˜ í¬ë§·íŒ… (TradeTileì—ì„œ ì‚¬ìš©)
  /// ì½”ì¸ ê±°ë˜ëŸ‰(ê°œìˆ˜) ì „ìš© í¬ë§·í„°
  static String formatTradeVolume(double volume) {
    if (volume < 1.0) {
      return _decimal6Format.format(volume); // 1ê°œ ë¯¸ë§Œ: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else {
      return _integerFormat.format(volume); // 1ê°œ ì´ìƒ: ì •ìˆ˜ í‘œì‹œ
    }
  }
  
  // ==================== ê°„ë‹¨ í¬ë§·íŒ… ====================
  
  /// ğŸ”¢ ê°„ë‹¨í•œ ì •ìˆ˜ í¬ë§·íŒ… (ì½¤ë§ˆë§Œ ì¶”ê°€)
  static String formatInteger(int number) {
    return _integerFormat.format(number);
  }
  
  /// ğŸ“‰ ì†Œìˆ˜ì  2ìë¦¬ í¬ë§·íŒ…
  static String formatDecimal2(double number) {
    return _decimalFormat.format(number);
  }
  
  /// ğŸ“Š ì†Œìˆ˜ì  3ìë¦¬ í¬ë§·íŒ…
  static String formatDecimal3(double number) {
    return _decimal3Format.format(number);
  }
  
  // ==================== íŠ¹ìˆ˜ í¬ë§·íŒ… ====================
  
  /// ğŸ’¯ í¼ì„¼íŠ¸ í¬ë§·íŒ… (ë³€í™”ìœ¨ ë“±)
  static String formatPercent(double percent, {int decimals = 2}) {
    final formatter = decimals == 1 ? _decimal1Format : _decimalFormat;
    return '${formatter.format(percent)}%';
  }
  
  /// ğŸ“ í¬ê¸°ì— ë”°ë¥¸ ë™ì  í¬ë§·íŒ…
  static String formatDynamic(double value) {
    if (value.abs() < 1) {
      return _decimal6Format.format(value);
    } else if (value.abs() < 100) {
      return _decimalFormat.format(value);
    } else {
      return _integerFormat.format(value);
    }
  }
  
  // ==================== ë‹¨ìœ„ ë³€í™˜ í¬ë§·íŒ… ====================
  
  /// ğŸ’° ë§Œì› ë‹¨ìœ„ë¡œ ë³€í™˜ (AmountDisplayWidget í˜¸í™˜)
  static String formatToManWon(double amount) {
    final manWon = amount / 10000;
    return '${_integerFormat.format(manWon)}ë§Œ';
  }
  
  /// ğŸ“Š ì–µì› ë‹¨ìœ„ë¡œ ë³€í™˜
  static String formatToEokWon(double amount) {
    final eokWon = amount / 100000000;
    return '${_decimalFormat.format(eokWon)}ì–µ';
  }
  
  /// ğŸ“ˆ ì¡°ì› ë‹¨ìœ„ë¡œ ë³€í™˜
  static String formatToJoWon(double amount) {
    final joWon = amount / 1000000000000;
    return '${_decimalFormat.format(joWon)}ì¡°';
  }
  
  // ==================== í—¬í¼ ë©”ì„œë“œ ====================
  
  /// ğŸ¯ ê¸ˆì•¡ í¬ê¸° íŒë³„
  static String getAmountUnit(double amount) {
    if (amount < 10000) {
      return 'ì›';
    } else if (amount < 100000000) {
      return 'ë§Œì›';
    } else if (amount < 1000000000000) {
      return 'ì–µì›';
    } else if (amount < 10000000000000000) {
      return 'ì¡°ì›';
    } else {
      return 'ê²½ì›';
    }
  }
  
  /// ğŸ“ ì†Œìˆ˜ì  ìë¦¿ìˆ˜ ê²°ì •
  static int getDecimalPlaces(double value) {
    if (value <= 1.0) return 6;
    if (value < 10.0) return 3;
    if (value < 100.0) return 2;
    if (value < 1000.0) return 1;
    return 0;
  }
  
  /// ğŸ”„ í¬ë§·í„° ì„ íƒ
  static NumberFormat getFormatter(double value) {
    final decimals = getDecimalPlaces(value);
    switch (decimals) {
      case 6: return _decimal6Format;
      case 3: return _decimal3Format;
      case 2: return _decimalFormat;
      case 1: return _decimal1Format;
      default: return _integerFormat;
    }
  }
}\n\n// ====== lib/shared/theme/app_theme.dart ======\n
import 'package:flutter/material.dart';
import '../../core/bridge/signal_bus.dart'; // ExchangePlatform ì„í¬íŠ¸

/// ì•±ì˜ í…Œë§ˆ ì„¤ì •ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
class AppTheme {
  AppTheme._(); // private ìƒì„±ì
  
  // ê³µí†µ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸
  static const Color neutralWhite = Colors.white;
  static const Color neutralBlack = Colors.black;
  static const Color neutralGrey = Colors.grey;
  static const Color accentOrange = Colors.orange;
  
  // í”Œë«í¼ë³„ í¬ì¸íŠ¸ ì»¬ëŸ¬
  static Color getPrimaryColor(ExchangePlatform platform) {
    switch (platform) {
      case ExchangePlatform.upbit:
        return accentOrange;
      case ExchangePlatform.binance:
        return const Color(0xFFF0B90B); // ë°”ì´ë‚¸ìŠ¤ ë…¸ë‘
      case ExchangePlatform.bybit:
        return const Color(0xFF00C087); // ë°”ì´ë¹— ì´ˆë¡
      case ExchangePlatform.bithumb:
        return const Color(0xFF1A3C34); // ë¹—ì¸ ì´ˆë¡
    }
  }

  static Color getSecondaryColor(ExchangePlatform platform) {
    switch (platform) {
      case ExchangePlatform.upbit:
        return Colors.orangeAccent;
      case ExchangePlatform.binance:
        return const Color(0xFFF3BA2F); // ë°”ì´ë‚¸ìŠ¤ ë°ì€ ë…¸ë‘
      case ExchangePlatform.bybit:
        return const Color(0xFF00D4B1); // ë°”ì´ë¹— ë°ì€ ì´ˆë¡
      case ExchangePlatform.bithumb:
        return const Color(0xFF2A5D52); // ë¹—ì¸ ë°ì€ ì´ˆë¡
    }
  }
  
  // ê¸°ë³¸ í…Œë§ˆ ì„¤ì • (ì‹œìŠ¤í…œ ëª¨ë“œ ë˜ëŠ” ê¸°ë³¸ê°’ìš©)
  static ThemeData light({ExchangePlatform platform = ExchangePlatform.upbit}) {
    final primaryColor = getPrimaryColor(platform);
    final secondaryColor = getSecondaryColor(platform);
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.light,
        primary: primaryColor,
        secondary: secondaryColor,
      ),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
      ),
      cardTheme: const CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        selectedItemColor: primaryColor,
        unselectedItemColor: neutralGrey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
      textTheme: const TextTheme(
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
        titleLarge: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          foregroundColor: neutralWhite,
          backgroundColor: primaryColor,
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
  
  // ë‹¤í¬ í…Œë§ˆ
  static ThemeData dark({ExchangePlatform platform = ExchangePlatform.upbit}) {
    final primaryColor = getPrimaryColor(platform);
    final secondaryColor = getSecondaryColor(platform);
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.dark,
        primary: primaryColor,
        secondary: secondaryColor,
      ),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
      ),
      cardTheme: const CardThemeData(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        selectedItemColor: primaryColor,
        unselectedItemColor: neutralGrey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
      textTheme: const TextTheme(
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
        titleLarge: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          foregroundColor: neutralBlack,
          backgroundColor: primaryColor,
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
  
  // ì‹œìŠ¤í…œ í…Œë§ˆ (ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ ë¼ì´íŠ¸/ë‹¤í¬ ê²°ì •)
  static ThemeData system(BuildContext context, {ExchangePlatform platform = ExchangePlatform.upbit}) {
    final brightness = MediaQuery.of(context).platformBrightness;
    return brightness == Brightness.light
        ? light(platform: platform)
        : dark(platform: platform);
  }
}\n\n// ====== lib/shared/widgets/settings/slider_position_segment.dart ======\n
import 'package:flutter/material.dart';
import '../../../domain/entities/app_settings.dart'; // SliderPosition enum

/// ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯ (ê°ì§„ ìŠ¤íƒ€ì¼)
class SliderPositionSegment extends StatelessWidget {
  final SliderPosition value;
  final ValueChanged<SliderPosition> onChanged;

  const SliderPositionSegment({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    // ë‹¤ë¥¸ ì„¸ê·¸ë¨¼íŠ¸ ì»¨íŠ¸ë¡¤ê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼ì„ ìœ„í•œ ì»¨í…Œì´ë„ˆ
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // 'ìƒë‹¨' ë²„íŠ¼
          _buildSegmentButton(
            context: context,
            position: SliderPosition.top,
            label: 'ìœ„',
          ),
          // êµ¬ë¶„ì„ 
          _buildDivider(),
          // 'í•˜ë‹¨' ë²„íŠ¼
          _buildSegmentButton(
            context: context,
            position: SliderPosition.bottom,
            label: 'ì•„ë˜',
          ),
        ],
      ),
    );
  }

  /// ê° ì„¸ê·¸ë¨¼íŠ¸ ë²„íŠ¼ì„ ìƒì„±í•˜ëŠ” í—¬í¼ ë©”ì„œë“œ
  Widget _buildSegmentButton({
    required BuildContext context,
    required SliderPosition position,
    required String label,
  }) {
    final isSelected = value == position;
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    // âœ¨ Deprecation ê²½ê³  ìˆ˜ì •: withOpacity(0.1) -> withAlpha(26)
    final backgroundColor = isSelected ? Colors.orange.withAlpha(26) : Colors.transparent;

    return GestureDetector(
      onTap: () => onChanged(position),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë¥¼ ì‹œê°ì ìœ¼ë¡œ ë³´ì—¬ì£¼ëŠ” ì•„ì´ì½˜
            _buildSliderIcon(isTop: position == SliderPosition.top, isSelected: isSelected),
            const SizedBox(height: 2),
            // 'ìœ„' ë˜ëŠ” 'ì•„ë˜' í…ìŠ¤íŠ¸
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  /// ë²„íŠ¼ ì‚¬ì´ì— í‘œì‹œë  êµ¬ë¶„ì„ 
  Widget _buildDivider() {
    return Container(
      width: 1,
      height: 40, // ì•„ì´ì½˜ê³¼ í…ìŠ¤íŠ¸ ë†’ì´ì— ë§ê²Œ ì¡°ì •
      color: Colors.grey.shade300,
    );
  }
  
  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë¥¼ í‘œí˜„í•˜ëŠ” ì•„ì´ì½˜ ìœ„ì ¯ (ê¸°ì¡´ ë¡œì§ í™œìš©)
  Widget _buildSliderIcon({required bool isTop, required bool isSelected}) {
    final activeColor = isSelected ? Colors.orange : Colors.grey.shade600;
    final inactiveColor = Colors.grey.shade400;

    final sliderHandle = Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Container(
          width: 6,
          height: 6,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: activeColor,
          ),
        ),
        const SizedBox(width: 1),
        Container(
          width: 12,
          height: 1.5,
          color: activeColor,
        ),
      ],
    );

    final dummyItems = Row(
      mainAxisSize: MainAxisSize.min,
      children: List.generate(
        4,
        (i) => Padding(
          padding: const EdgeInsets.symmetric(horizontal: 0.5),
          child: Container(
            width: 3,
            height: 1.5,
            color: inactiveColor,
          ),
        ),
      ),
    );

    // isTop í”Œë˜ê·¸ì— ë”°ë¼ ìœ„ì ¯ ìˆœì„œ ë³€ê²½
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: isTop
          ? [sliderHandle, const SizedBox(height: 2), dummyItems]
          : [dummyItems, const SizedBox(height: 2), sliderHandle],
    );
  }
}
\n\n// ====== lib/shared/widgets/settings/font_segment.dart ======\n
import 'package:flutter/material.dart';
import '../../../domain/entities/app_settings.dart';

/// ğŸ”¤ í°íŠ¸ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯ (ë””ë°”ìš´ì‹± ë° ê³ ì • í¬ê¸° ì ìš©)
class FontSegment extends StatefulWidget {
  final FontFamily value;
  final ValueChanged<FontFamily> onChanged;

  const FontSegment({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  State<FontSegment> createState() => _FontSegmentState();
}

class _FontSegmentState extends State<FontSegment> {
  bool _isTapped = false;

  void _handleTap() {
    if (_isTapped) return;
    
    setState(() {
      _isTapped = true;
    });

    final currentIndex = FontFamily.values.indexOf(widget.value);
    final nextIndex = (currentIndex + 1) % FontFamily.values.length;
    final nextFont = FontFamily.values[nextIndex];

    widget.onChanged(nextFont);

    Future.delayed(const Duration(milliseconds: 500), () {
      if (mounted) {
        setState(() {
          _isTapped = false;
        });
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    // SizedBoxë¡œ ê°ì‹¸ ë²„íŠ¼ì˜ í¬ê¸°ë¥¼ ê³ ì •ì‹œí‚µë‹ˆë‹¤.
    return SizedBox(
      width: 70, // ê³ ì • ë„ˆë¹„
      height: 40, // ê³ ì • ë†’ì´
      child: GestureDetector(
        onTap: _handleTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          alignment: Alignment.center, // í…ìŠ¤íŠ¸ë¥¼ ì¤‘ì•™ì— ì •ë ¬
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.grey.shade300), // íšŒìƒ‰ í…Œë‘ë¦¬ë¡œ ë³€ê²½
            color: _isTapped
                ? Colors.grey.withAlpha(50)
                : Colors.orange.withAlpha(26),
          ),
          child: Text(
            'Abc',
            style: TextStyle(
              fontFamily: widget.value.fontName,
              fontSize: 16,
              color: Colors.orange,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }
}\n\n// ====== lib/shared/widgets/settings/theme_mode_segment.dart ======\n
import 'package:flutter/material.dart';

/// ğŸ¨ í…Œë§ˆ ëª¨ë“œ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯ (3ê°œ í† ê¸€)
class ThemeModeSegment extends StatelessWidget {
  final ThemeMode themeMode;
  final ValueChanged<ThemeMode> onChanged;

  const ThemeModeSegment({
    super.key,
    required this.themeMode,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentButton(
            context: context,
            label: 'ì‹œìŠ¤í…œ',
            icon: Icons.phone_iphone,
            isSelected: themeMode == ThemeMode.system,
            onTap: () => onChanged(ThemeMode.system),
          ),
          _buildDivider(),
          _buildSegmentButton(
            context: context,
            label: 'ë¼ì´íŠ¸',
            icon: Icons.wb_sunny,
            isSelected: themeMode == ThemeMode.light,
            onTap: () => onChanged(ThemeMode.light),
          ),
          _buildDivider(),
          _buildSegmentButton(
            context: context,
            label: 'ë‹¤í¬',
            icon: Icons.nightlight_round,
            isSelected: themeMode == ThemeMode.dark,
            onTap: () => onChanged(ThemeMode.dark),
          ),
        ],
      ),
    );
  }

  /// ê°œë³„ ì„¸ê·¸ë¨¼íŠ¸ ë²„íŠ¼ ìƒì„±
  Widget _buildSegmentButton({
    required BuildContext context,
    required String label,
    required IconData icon,
    required bool isSelected,
    required VoidCallback onTap,
  }) {
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    final backgroundColor = isSelected ? Colors.orange.withAlpha(26) : Colors.transparent;

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, size: 16, color: color),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ë²„íŠ¼ ì‚¬ì´ êµ¬ë¶„ì„ 
  Widget _buildDivider() {
    return Container(
      width: 1,
      height: 40,
      color: Colors.grey.shade300,
    );
  }
}\n\n// ====== lib/shared/widgets/market_mood_modal.dart ======\n
\n\n// ====== lib/shared/widgets/amount_display_widget.dart ======\n
// lib/shared/widgets/amount_display_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/settings_provider.dart';
import '../../domain/entities/app_settings.dart';

/// ê±°ë˜ ê¸ˆì•¡ í‘œì‹œ ìœ„ì ¯ (ìˆ«ì â†” ì•„ì´ì½˜)
class AmountDisplayWidget extends ConsumerWidget {
  final double totalAmount; // ì´ ê±°ë˜ ê¸ˆì•¡ (ì› ë‹¨ìœ„)
  final bool isBuy; // ë§¤ìˆ˜/ë§¤ë„ êµ¬ë¶„ (ìƒ‰ìƒìš©)
  final double fontSize;
  final FontWeight fontWeight;
  
  // í¬ë§·í„° ìºì‹±
  static final _integerFormat = NumberFormat('#,###');
  
  const AmountDisplayWidget({
    Key? key,
    required this.totalAmount,
    required this.isBuy,
    this.fontSize = 16,
    this.fontWeight = FontWeight.bold,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
    
    return amountDisplayMode == AmountDisplayMode.icon
        ? _buildAmountIcon(context)
        : _buildAmountText(context);
  }

  /// ìˆ«ìë¡œ ê¸ˆì•¡ í‘œì‹œ
  Widget _buildAmountText(BuildContext context) {
    return Text(
      '${_integerFormat.format(totalAmount / 10000)}ë§Œ',
      style: TextStyle(
        fontWeight: fontWeight,
        color: isBuy ? Colors.green : Colors.red,
        fontSize: fontSize,
      ),
      overflow: TextOverflow.ellipsis,
      maxLines: 1,
    );
  }

  /// ì•„ì´ì½˜ìœ¼ë¡œ ê¸ˆì•¡ í‘œì‹œ (1000ë§Œ ~ 100ì–µì›)
  Widget _buildAmountIcon(BuildContext context) {
    final amountInMan = (totalAmount / 10000).round(); // ë§Œì› ë‹¨ìœ„
    
    // 1000ë§Œì› ë¯¸ë§Œì´ë©´ ìˆ«ìë¡œ í‘œì‹œ
    if (amountInMan < 1000) {
      return _buildAmountText(context);
    }
    
    final assetPath = _getIconPath(amountInMan);
    
    return Image.asset(
      assetPath,
      width: 64,
      height: 40,
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) {
        // ì•„ì´ì½˜ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ìˆ«ìë¡œ fallback
        return _buildAmountText(context);
      },
    );
  }

  /// ê¸ˆì•¡ì— ë”°ë¥¸ ì•„ì´ì½˜ ê²½ë¡œ ê²°ì •
  String _getIconPath(int amountInMan) {
    if (amountInMan >= 1000 && amountInMan < 5000) {
      return _get1000SeriesPath(amountInMan);
    } else if (amountInMan >= 5000 && amountInMan < 100000) {
      return _get5000SeriesPath(amountInMan);
    } else if (amountInMan >= 100000 && amountInMan <= 1000000) {
      return _get10000SeriesPath(amountInMan);
    } else {
      // 100ì–µ ì´ˆê³¼ì‹œ ìµœëŒ€ê°’ìœ¼ë¡œ
      return 'assets/icons/money/money_10000_10.png';
    }
  }

  /// ğŸ”§ 1000 ì‹œë¦¬ì¦ˆ (1000ë§Œ ~ 4999ë§Œ) - ì„¸ë ¨ëœ ê³„ì‚°ì‹
  String _get1000SeriesPath(int amountInMan) {
    // 1000ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”í•˜ê³  1000ë§Œì› ë‹¨ìœ„ë¡œ ë ˆë²¨ ê²°ì •
    final normalizedAmount = amountInMan - 1000; // 1000ë§Œì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    final level = (normalizedAmount / 1000).floor() + 1; // 1000ë§Œì› ë‹¨ìœ„ë¡œ ë ˆë²¨ ê³„ì‚°
    final clampedLevel = level.clamp(1, 4); // 1~4 ë²”ìœ„ë¡œ ì œí•œ
    
    return 'assets/icons/money/money_1000_$clampedLevel.png';
    
    // ìˆ˜í•™ì  ë§¤í•‘:
    // 1000~1999ë§Œ â†’ (0~999)/1000 + 1 = 1 â†’ money_1000_1.png
    // 2000~2999ë§Œ â†’ (1000~1999)/1000 + 1 = 2 â†’ money_1000_2.png
    // 3000~3999ë§Œ â†’ (2000~2999)/1000 + 1 = 3 â†’ money_1000_3.png
    // 4000~4999ë§Œ â†’ (3000~3999)/1000 + 1 = 4 â†’ money_1000_4.png
  }

  /// ğŸ”§ 5000 ì‹œë¦¬ì¦ˆ (5000ë§Œ ~ 9ì–µ9999ë§Œ) - ì •í™•í•œ êµ¬ê°„ ë§¤í•‘
  String _get5000SeriesPath(int amountInMan) {
    // 5000ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
    final normalizedAmount = amountInMan - 5000; // 5000ë§Œì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    
    // 5000ë§Œì› ë‹¨ìœ„ì™€ 1000ë§Œì› ë‚˜ë¨¸ì§€ ê³„ì‚°
    final fiveThousandUnits = (normalizedAmount / 5000).floor(); // 5ì²œë§Œ ì¶”ê°€ ê°œìˆ˜
    final remainder = normalizedAmount % 5000; // 1000ë§Œì› ë‹¨ìœ„ ë‚˜ë¨¸ì§€
    
    // ì´ 5ì²œë§Œ ê°œìˆ˜ (ê¸°ë³¸ 1ê°œ + ì¶”ê°€ ê°œìˆ˜)
    final totalFiveThousands = fiveThousandUnits + 1;
    
    if (remainder == 0) {
      // ì •í™•íˆ 5ì²œë§Œ ë°°ìˆ˜: 5000ë§Œ, 1ì–µ, 1ì–µ5ì²œë§Œ, 2ì–µ...
      final clampedCount = totalFiveThousands.clamp(1, 19);
      return 'assets/icons/money/money_5000_$clampedCount.png';
    } else {
      // 5ì²œë§Œ + ì²œë§Œ ì¡°í•©
      final thousandLevel = _getThousandLevel(remainder); // ğŸ”§ ì •í™•í•œ êµ¬ê°„ ë§¤í•‘
      
      if (totalFiveThousands <= 3) {
        // ì¡°í•© ì§€ì›: 1~3ì¥ê¹Œì§€
        return 'assets/icons/money/money_5000_${totalFiveThousands}_1000_$thousandLevel.png';
      } else {
        // 4ì¥ ì´ìƒì€ ì¡°í•© ë¯¸ì§€ì›, ìŠ¤ë§ˆíŠ¸ ë°˜ì˜¬ë¦¼
        final roundedFiveThousands = remainder >= 2500 
          ? (totalFiveThousands + 1).clamp(4, 19)  // 2500ë§Œ ì´ìƒì´ë©´ ì˜¬ë¦¼
          : totalFiveThousands.clamp(4, 19);       // ë¯¸ë§Œì´ë©´ ë²„ë¦¼
        return 'assets/icons/money/money_5000_$roundedFiveThousands.png';
      }
    }
    
    // ì •í™•í•œ ë§¤í•‘ ì˜ˆì‹œ:
    // 5000ë§Œ â†’ money_5000_1.png
    // 6200ë§Œ â†’ remainder=1200 â†’ level=1 â†’ money_5000_1_1000_1.png âœ…
    // 7800ë§Œ â†’ remainder=2800 â†’ level=2 â†’ money_5000_1_1000_2.png âœ…
    // 8300ë§Œ â†’ remainder=3300 â†’ level=3 â†’ money_5000_1_1000_3.png âœ…
    // 8560ë§Œ â†’ remainder=3560 â†’ level=3 â†’ money_5000_1_1000_3.png âœ…
    // 9200ë§Œ â†’ remainder=4200 â†’ level=4 â†’ money_5000_1_1000_4.png âœ…
  }
  
  /// ğŸ”§ ì²œë§Œì› ë‚˜ë¨¸ì§€ë¥¼ ì •í™•í•œ ë ˆë²¨ë¡œ ë§¤í•‘
  int _getThousandLevel(int remainder) {
    if (remainder >= 1000 && remainder < 2000) return 1; // 1000~1999ë§Œ â†’ level 1
    if (remainder >= 2000 && remainder < 3000) return 2; // 2000~2999ë§Œ â†’ level 2  
    if (remainder >= 3000 && remainder < 4000) return 3; // 3000~3999ë§Œ â†’ level 3
    return 4; // 4000ë§Œ ì´ìƒ â†’ level 4
  }

  /// ğŸ”§ 10000 ì‹œë¦¬ì¦ˆ (10ì–µ ~ 100ì–µì›) - ì„¸ë ¨ëœ ê³„ì‚°ì‹
  String _get10000SeriesPath(int amountInMan) {
    // 10ì–µì›(100000ë§Œ) ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
    final normalizedAmount = amountInMan - 100000; // 10ì–µì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    
    // 10ì–µì› ë‹¨ìœ„ì™€ ë‚˜ë¨¸ì§€ ê³„ì‚°
    final tenBillionUnits = (normalizedAmount / 100000).floor(); // 10ì–µ ì¶”ê°€ ê°œìˆ˜
    final remainder = normalizedAmount % 100000; // 10ì–µ ë¯¸ë§Œ ë‚˜ë¨¸ì§€
    
    // ì´ 10ì–µ ê°œìˆ˜ (ê¸°ë³¸ 1ê°œ + ì¶”ê°€ ê°œìˆ˜)
    final totalTenBillions = tenBillionUnits + 1;
    
    if (remainder == 0) {
      // ì •í™•íˆ 10ì–µ ë°°ìˆ˜: 10ì–µ, 20ì–µ, 30ì–µ...
      final clampedCount = totalTenBillions.clamp(1, 10);
      return 'assets/icons/money/money_10000_$clampedCount.png';
    } else {
      // 10ì–µ + ë‚˜ë¨¸ì§€ ì¡°í•©
      if (totalTenBillions <= 2) {
        // ì¡°í•© ì§€ì›: 1~2ì¥ê¹Œì§€
        // ë‚˜ë¨¸ì§€ë¥¼ 5ì²œë§Œ ë‹¨ìœ„ë¡œ ë³€í™˜ (ì •ë°€í•œ ë§¤í•‘)
        final fiveThousandCount = _calculateFiveThousandLevel(remainder);
        final clampedFiveThousand = fiveThousandCount.clamp(1, 19);
        return 'assets/icons/money/money_10000_${totalTenBillions}_5000_$clampedFiveThousand.png';
      } else {
        // 3ì¥ ì´ìƒì€ ì¡°í•© ë¯¸ì§€ì›, ìŠ¤ë§ˆíŠ¸ ë°˜ì˜¬ë¦¼
        final roundedTenBillions = remainder >= 50000 
          ? (totalTenBillions + 1).clamp(3, 10)  // 5ì–µ ì´ìƒì´ë©´ ì˜¬ë¦¼
          : totalTenBillions.clamp(3, 10);       // ë¯¸ë§Œì´ë©´ ë²„ë¦¼
        return 'assets/icons/money/money_10000_$roundedTenBillions.png';
      }
    }
    
    // ìˆ˜í•™ì  ë§¤í•‘ ì˜ˆì‹œ:
    // 10ì–µ â†’ normalized=0, total=1 â†’ money_10000_1.png
    // 15ì–µ â†’ normalized=50000, total=1, fiveThousand=10 â†’ money_10000_1_5000_10.png
    // 23ì–µ â†’ normalized=130000, total=2, remainder=30000, fiveThousand=6 â†’ money_10000_2_5000_6.png
    // 35ì–µ â†’ normalized=250000, total=3, remainder>=50000 â†’ money_10000_4.png (ì˜¬ë¦¼)
  }
  
  /// ë‚˜ë¨¸ì§€ ê¸ˆì•¡ì„ 5ì²œë§Œ ë ˆë²¨ë¡œ ì •ë°€ ë³€í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
  int _calculateFiveThousandLevel(int remainder) {
    // 5ì²œë§Œì› ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê³ , 2500ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ë°˜ì˜¬ë¦¼
    final exactLevel = remainder / 5000; // ì •í™•í•œ 5ì²œë§Œ ë ˆë²¨
    return exactLevel.round(); // ë°˜ì˜¬ë¦¼ìœ¼ë¡œ ê°€ì¥ ê°€ê¹Œìš´ ì •ìˆ˜
    
    // ì˜ˆì‹œ:
    // 2500ë§Œì› â†’ 2500/5000 = 0.5 â†’ round() = 1 â†’ 5ì²œë§Œ 1ì¥
    // 7500ë§Œì› â†’ 7500/5000 = 1.5 â†’ round() = 2 â†’ 5ì²œë§Œ 2ì¥
    // 12000ë§Œì› â†’ 12000/5000 = 2.4 â†’ round() = 2 â†’ 5ì²œë§Œ 2ì¥
    // 13000ë§Œì› â†’ 13000/5000 = 2.6 â†’ round() = 3 â†’ 5ì²œë§Œ 3ì¥
  }
}\n\n// ====== lib/shared/widgets/ws_status_indicator.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedback import ì¶”ê°€
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart'; // ğŸ”§ ìˆ˜ì •: app_providersë¡œ í†µí•©
import '../../core/network/websocket/base_ws_client.dart';
import 'websocket_modal.dart'; // ğŸ†• WebSocket ëª¨ë‹¬ import

class WsStatusIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const WsStatusIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false, // ğŸ”§ ê¸°ë³¸ê°’ì„ falseë¡œ ë³€ê²½ (ë¡±í”„ë ˆìŠ¤ ëª¨ë‹¬ê³¼ ì¶©ëŒ ë°©ì§€)
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final status = ref.watch(wsStatusProvider);
    
    Widget indicator = _buildStatusIcon(context, ref, status);
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildStatusIcon(BuildContext context, WidgetRef ref, WsStatus status) {
    Widget statusIcon = _getStatusIcon(status);
    
    // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜ ì¶”ê°€
    return GestureDetector(
      onLongPressStart: (details) => _showWebSocketModal(context, ref, details.globalPosition),
      onLongPressEnd: (_) => _hideWebSocketModal(),
      onLongPressCancel: () => _hideWebSocketModal(),
      child: statusIcon,
    );
  }

  /// WebSocket ìƒì„¸ ëª¨ë‹¬ í‘œì‹œ
void _showWebSocketModal(BuildContext context, WidgetRef ref, Offset globalPosition) {
  // ğŸ¯ í–…í‹± í”¼ë“œë°± ì¶”ê°€ (í†¡~ ì†Œë¦¬ ë³µêµ¬!)
  if (ref.read(appSettingsProvider).isHapticEnabled) {
    HapticFeedback.mediumImpact();
  }
  // ê¸°ì¡´ íˆ´íŒ ìˆ¨ê¸°ê¸°
  Tooltip.dismissAllToolTips();
    
    // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = size * 4.2 * 2.5; // ğŸ”§ ìœ„ì¹˜ ê³„ì‚°ìš© í¬ê¸°ë„ ì›ë˜ëŒ€ë¡œ
    
    // í™”ë©´ ê²½ê³„ ê³ ë ¤í•œ ìœ„ì¹˜ ê³„ì‚°
    double adjustedX = globalPosition.dx - (modalWidth / 2); // ì¤‘ì•™ ì •ë ¬
    double adjustedY = globalPosition.dy - (size * 3); // ìœ„ìª½ìœ¼ë¡œ
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16; // ìµœì†Œ ì—¬ë°±
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16; // ìš°ì¸¡ ì—¬ë°± í™•ë³´
    }
    
    // ìƒë‹¨ ê²½ê³„ ì²´í¬
    if (adjustedY < 50) {
      adjustedY = globalPosition.dy + size + 8; // ì•„ë˜ìª½ìœ¼ë¡œ ì´ë™
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    WebSocketStatsOverlay.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
    );
  }

  /// WebSocket ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  void _hideWebSocketModal() {
    WebSocketStatsOverlay.hide();
  }

  Widget _getStatusIcon(WsStatus status) {
    switch (status) {
      case WsStatus.connected:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.green,
          tooltip: showTooltip ? 'ì‹¤ì‹œê°„ ì—°ê²°ë¨ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.pulse,
          size: size,
        );
        
      case WsStatus.connecting:
        return _AnimatedStatusIcon(
          icon: Icons.refresh,
          color: Colors.blue,
          tooltip: showTooltip ? 'ì—°ê²° ì¤‘... (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.rotate,
          size: size,
        );
        
      case WsStatus.reconnecting:
        return _AnimatedStatusIcon(
          icon: Icons.refresh,
          color: Colors.orange,
          tooltip: showTooltip ? 'ì¬ì—°ê²° ì¤‘... (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.rotate,
          size: size,
        );
        
      case WsStatus.disconnected:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.grey,
          tooltip: showTooltip ? 'ì—°ê²° ëŠê¹€ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.none,
          size: size,
        );
        
      case WsStatus.pongTimeout:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.red,
          tooltip: showTooltip ? 'ping íƒ€ì„ì•„ì›ƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.blink,
          size: size,
        );
        
      case WsStatus.failed:
      case WsStatus.error:
        return _AnimatedStatusIcon(
          icon: Icons.error_outline,
          color: Colors.red,
          tooltip: showTooltip ? (status == WsStatus.failed ? 'ì—°ê²° ì‹¤íŒ¨ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : 'ì—ëŸ¬ ë°œìƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)') : null,
          animationType: AnimationType.blink,
          size: size,
        );
        
      case WsStatus.maxRetryExceeded:
        return _AnimatedStatusIcon(
          icon: Icons.warning,
          color: Colors.deepOrange,
          tooltip: showTooltip ? 'ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.blink,
          size: size,
        );
    }
  }
}

enum AnimationType { none, pulse, rotate, blink }

class _AnimatedStatusIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final AnimationType animationType;
  final double size;

  const _AnimatedStatusIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedStatusIcon> createState() => _AnimatedStatusIconState();
}

class _AnimatedStatusIconState extends State<_AnimatedStatusIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case AnimationType.pulse:
        _controller = AnimationController(
          duration: const Duration(seconds: 2),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case AnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case AnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case AnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedStatusIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case AnimationType.pulse:
          case AnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value,
                child: icon,
              ),
            );
            
          case AnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case AnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/shared/widgets/market_mood_indicator.dart ======\n
// lib/shared/widgets/market_mood_indicator.dart
// ğŸ¨ Shared Widget: Market Mood ì¸ë””ì¼€ì´í„° (í´ë¦° ì•„í‚¤í…ì²˜ ì™„ì „ ëŒ€ì‘)

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/controllers/market_mood_controller.dart';

/// ğŸ¨ ë©”ì¸ ë§ˆì¼“ë¬´ë“œ ì¸ë””ì¼€ì´í„° ìœ„ì ¯
class MarketMoodIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const MarketMoodIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false,
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // [ìˆ˜ì •] ì¤‘ì•™ ê³„ì‚° Providerë¥¼ watchí•˜ì—¬ ë¡œë”©/ì—ëŸ¬/ë°ì´í„° ìƒíƒœë¥¼ í•œ ë²ˆì— ì²˜ë¦¬í•©ë‹ˆë‹¤.
    final computedAsync = ref.watch(marketMoodComputedDataProvider);
    
    Widget indicator = computedAsync.when(
      data: (computed) {
        // [ìˆ˜ì •] marketDataê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ì´ˆê¸° ìƒíƒœì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ null ì²´í¬ ì¶”ê°€
        if (computed.marketData == null) {
          return _buildLoadingIcon();
        }
        // [ìˆ˜ì •] computed ê°ì²´ì—ì„œ í•„ìš”í•œ marketDataì™€ currentMoodë¥¼ ì§ì ‘ ê°€ì ¸ì˜µë‹ˆë‹¤.
        return _buildMoodIcon(context, ref, computed.marketData!, computed.currentMood);
      },
      loading: () => _buildLoadingIcon(),
      error: (_, __) => _buildErrorIcon(),
    );
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildMoodIcon(BuildContext context, WidgetRef ref, MarketMoodData data, MarketMood mood) {
    Widget moodIcon = _getMoodIcon(mood);
    
    // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜ ì¶”ê°€
    return GestureDetector(
      onLongPressStart: (details) => _showMarketMoodModal(context, ref, details.globalPosition, data),
      onLongPressEnd: (_) => _hideMarketMoodModal(),
      onLongPressCancel: () => _hideMarketMoodModal(),
      child: moodIcon,
    );
  }

  Widget _buildLoadingIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.refresh,
      color: Colors.grey,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë”© ì¤‘...' : null,
      animationType: MoodAnimationType.rotate,
      size: size,
    );
  }

  Widget _buildErrorIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.error_outline,
      color: Colors.red,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨' : null,
      animationType: MoodAnimationType.blink,
      size: size,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ í‘œì‹œ - ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
void _showMarketMoodModal(BuildContext context, WidgetRef ref, Offset globalPosition, MarketMoodData data) {
  if (ref.read(appSettingsProvider).isHapticEnabled) {
    HapticFeedback.mediumImpact();
  }
  Tooltip.dismissAllToolTips();
    
    // í™”ë©´ í¬ê¸°ì™€ ëª¨ë‹¬ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = screenSize.width * 0.9; // 90% ë„ˆë¹„ ì‚¬ìš©
    
    // í™”ë©´ ê²½ê³„ ê³ ë ¤í•œ ìœ„ì¹˜ ê³„ì‚°
    double adjustedX = globalPosition.dx - (modalWidth / 2); // ì¤‘ì•™ ì •ë ¬
    double adjustedY = globalPosition.dy + size + 40; // ğŸ”¥ ë¬´ì¡°ê±´ ì•„ë˜ìª½ìœ¼ë¡œ (ìœ„ìª½ ê³„ì‚° ì œê±°)
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16;
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16;
    }
    
    // í•˜ë‹¨ ê²½ê³„ ì²´í¬ - í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ìœ„ë¡œ ì¡°ì •
    final bottomSafeArea = MediaQuery.of(context).padding.bottom;
    final maxY = screenSize.height - bottomSafeArea - 300; // ëª¨ë‹¬ ìµœì†Œ ë†’ì´ ê³ ë ¤
    if (adjustedY > maxY) {
      adjustedY = globalPosition.dy - 250; // ì¶©ë¶„íˆ ìœ„ë¡œ ì˜¬ë ¤ì„œ í‘œì‹œ
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
    MarketMoodModalManager.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
      data: data,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  void _hideMarketMoodModal() {
    MarketMoodModalManager.hide();
  }

  Widget _getMoodIcon(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull:
        return _AnimatedMoodIcon(
          icon: Icons.rocket_launch,
          color: const Color(0xFFFF6B35), // ğŸš€ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸš€ ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +15% ì´ìƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fastPulse,
          size: size,
        );
        
      case MarketMood.weakBull:
        return _AnimatedMoodIcon(
          icon: Icons.local_fire_department,
          color: const Color(0xFFFF6B35), // ğŸ”¥ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸ”¥ ì•½ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +5~15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fireFlicker,
          size: size,
        );
        
      case MarketMood.sideways:
        return _AnimatedMoodIcon(
          icon: Icons.balance,
          color: const Color(0xFF757575), // âš–ï¸ ì¤‘ì„± íšŒìƒ‰
          tooltip: showTooltip ? 'âš–ï¸ ì¤‘ê°„ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~+5% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.wiggle,
          size: size,
        );
        
      case MarketMood.bear:
        return _AnimatedMoodIcon(
          icon: Icons.water_drop,
          color: const Color(0xFF4A90E2), // ğŸ’§ ë¬¼ë°©ìš¸ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ’§ ë¬¼ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~-15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.waterDrop,
          size: size,
        );
        
      case MarketMood.deepBear:
        return _AnimatedMoodIcon(
          icon: Icons.ac_unit,
          color: const Color(0xFF4A90E2), // ğŸ§Š ì–¼ìŒì¥ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ§Š ì–¼ìŒì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -15% ì´í•˜ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.coldShiver,
          size: size,
        );
    }
  }
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… enum
enum MoodAnimationType { 
  none, 
  fastPulse, 
  fireFlicker, 
  wiggle, 
  waterDrop, 
  coldShiver, 
  rotate, 
  blink 
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ ì•„ì´ì½˜ ìœ„ì ¯
class _AnimatedMoodIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final MoodAnimationType animationType;
  final double size;

  const _AnimatedMoodIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedMoodIcon> createState() => _AnimatedMoodIconState();
}

class _AnimatedMoodIconState extends State<_AnimatedMoodIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case MoodAnimationType.fastPulse:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.6, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.fireFlicker:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 600),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.elasticOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.wiggle:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2000),
          vsync: this,
        );
        _animation = Tween<double>(begin: -0.15, end: 0.15).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.waterDrop:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2500),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.85, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.coldShiver:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 150),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.95, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.linear),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case MoodAnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedMoodIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case MoodAnimationType.fastPulse:
            return Transform.translate(
              offset: Offset(0, (_animation.value - 1) * 2),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.5, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.fireFlicker:
            return Transform.scale(
              scale: _animation.value,
              child: Transform.rotate(
                angle: (_animation.value - 1) * 0.1,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.4, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.wiggle:
            return Transform.rotate(
              angle: _animation.value,
              child: Transform.scale(
                scale: 0.95 + (_animation.value.abs() * 0.1),
                child: icon,
              ),
            );
            
          case MoodAnimationType.waterDrop:
            return Transform.translate(
              offset: Offset(0, (1 - _animation.value) * 1.5),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.6, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.coldShiver:
            return Transform.translate(
              offset: Offset(
                (_animation.value - 0.975) * 40,
                (_animation.value - 0.975) * 20,
              ),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.8, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case MoodAnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value.clamp(0.3, 1.0),
                child: icon,
              ),
            );
            
          case MoodAnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        preferBelow: false,
        verticalOffset: 20,
        waitDuration: const Duration(milliseconds: 500),
        showDuration: const Duration(seconds: 3),
        decoration: BoxDecoration(
          color: Colors.black87,
          borderRadius: BorderRadius.circular(8),
        ),
        textStyle: const TextStyle(
          fontSize: 11,
          color: Colors.white,
        ),
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/shared/widgets/sector_logo_provider.dart ======\n
// lib/shared/widgets/sector_logo_provider.dart
// ğŸš€ ìºì‹œ ì‹œìŠ¤í…œì´ ì ìš©ëœ ì„¹í„° ë¡œê³  í”„ë¡œë°”ì´ë”

import 'package:flutter/material.dart';

/// ğŸ¨ ì„¹í„° ë¡œê³  ê´€ë¦¬ ì „ìš© Provider
/// ìºì‹œ ì‹œìŠ¤í…œ + WebP ì§€ì›
class SectorLogoProvider {
  
  /// ğŸ†• ë©”ëª¨ë¦¬ ìºì‹œ (ìœ„ì ¯ ë ˆë²¨ ìºì‹±)
  static final Map<String, Widget> _widgetCache = {};
  
  /// ğŸ†• ìºì‹œ ì„¤ì •
  static const int _maxCacheObjects = 50; // ìµœëŒ€ 50ê°œ ì•„ì´ì½˜ ìºì‹œ
  
  /// ğŸš€ ìºì‹œëœ ì„¹í„° ë¡œê³  ìœ„ì ¯ ìƒì„± (ë©”ì¸ í•¨ìˆ˜)
  static Widget buildSectorIcon({
    required int sectorNumber,
    double size = 40.0,
  }) {
    final cacheKey = 'sector_${sectorNumber}_${size.toInt()}';
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
    if (_widgetCache.containsKey(cacheKey)) {
      return _widgetCache[cacheKey]!;
    }
    
    // ìƒˆë¡œìš´ ìœ„ì ¯ ìƒì„±
    final logoWidget = _buildSectorIconWidget(
      sectorNumber: sectorNumber,
      size: size,
    );
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì— ì €ì¥ (ìš©ëŸ‰ ì œí•œ)
    if (_widgetCache.length < _maxCacheObjects) {
      _widgetCache[cacheKey] = logoWidget;
    }
    
    return logoWidget;
  }

  /// ğŸ¯ ì‹¤ì œ ì„¹í„° ì•„ì´ì½˜ ìœ„ì ¯ ìƒì„±
  static Widget _buildSectorIconWidget({
    required int sectorNumber,
    required double size,
  }) {
    return SizedBox(
      width: size,
      height: size,
      child: Image.asset(
        'assets/icons/sector/sector$sectorNumber.webp',
        width: size,
        height: size,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return Container(
            width: size,
            height: size,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.grey.shade300,
            ),
            child: Center(
              child: Text(
                'ğŸ“Š',
                style: TextStyle(fontSize: size * 0.5),
              ),
            ),
          );
        },
      ),
    );
  }

  /// ğŸ§¹ ìºì‹œ ì •ë¦¬ í•¨ìˆ˜ë“¤
  static void clearCache() {
    _widgetCache.clear();
  }
  
  static void clearSpecificCache(int sectorNumber) {
    _widgetCache.removeWhere((key, value) => key.startsWith('sector_$sectorNumber'));
  }
  
  static int getCacheSize() {
    return _widgetCache.length;
  }

  /// ğŸ¯ ì„¹í„° ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì‚¬
  static bool isValidSectorNumber(int sectorNumber) {
    return sectorNumber >= 1 && sectorNumber <= 46;
  }

  /// ğŸ”§ ë””ë²„ê¹…ìš©: ìºì‹œ ìƒíƒœ ì •ë³´
  static Map<String, dynamic> getCacheStatus() {
    return {
      'totalCached': _widgetCache.length,
      'maxCapacity': _maxCacheObjects,
      'cacheKeys': _widgetCache.keys.toList(),
      'memoryUsage': '${(_widgetCache.length / _maxCacheObjects * 100).toStringAsFixed(1)}%',
    };
  }
}\n\n// ====== lib/shared/widgets/notification_service.dart ======\n
// lib/shared/widgets/notification_service.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../../core/utils/logger.dart';
import '../../core/di/app_providers.dart';
import '../../core/di/notification_provider.dart'; // ğŸ†• Provider ë¶„ë¦¬

/// ğŸ”” Firebase + ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ì•Œë¦¼ ì„œë¹„ìŠ¤
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì •
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // ì•±ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // ğŸ¯ Providerë¥¼ í†µí•´ ì•Œë¦¼ ì¶”ê°€
        _addNotificationToProvider(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBarë¡œë„ í‘œì‹œ
        _showNotificationSnackBar(messenger, n, msg.data);
      }
    });
    
    // ì•±ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ ì•Œë¦¼ í´ë¦­í•´ì„œ ì•± ì‹œì‘
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          _addNotificationToProvider(
            title: n.title ?? 'ì•Œë¦¼',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
      }
    });
    
    // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆì„ ë•Œ ì•Œë¦¼ í´ë¦­
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        _addNotificationToProvider(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
      }
    });
    
    log.i('ğŸ”” Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
  }

  /// Providerë¥¼ í†µí•œ ì•Œë¦¼ ì¶”ê°€ (ë‚´ë¶€ ë©”ì„œë“œ)
  void _addNotificationToProvider({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('ğŸ”” ì•Œë¦¼ ì¶”ê°€: $title (${type.name})');
  }

  /// SnackBar í‘œì‹œ
  void _showNotificationSnackBar(
    ScaffoldMessengerState? messenger,
    RemoteNotification notification,
    Map<String, dynamic>? data,
  ) {
    if (messenger == null) return;
    
    final type = _getNotificationType(data);
    messenger
      ..hideCurrentSnackBar()
      ..showSnackBar(SnackBar(
        content: Row(
          children: [
            Icon(_getIconForType(type), color: Colors.white, size: 20),
            const SizedBox(width: 8),
            Expanded(child: Text('${notification.title}: ${notification.body}')),
          ],
        ),
        backgroundColor: _getColorForType(type),
        duration: const Duration(seconds: 3),
        action: SnackBarAction(
          label: 'ë³´ê¸°',
          textColor: Colors.white,
          onPressed: () {
            // TODO: ì•Œë¦¼ ëª¨ë‹¬ ì—´ê¸°
            log.i('ğŸ“± ì•Œë¦¼ ìƒì„¸ë³´ê¸° ìš”ì²­');
          },
        ),
      ));
  }

  /// Firebase ë©”ì‹œì§€ ë°ì´í„°ë¡œë¶€í„° ì•Œë¦¼ íƒ€ì… ì¶”ë¡ 
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }

  /// ğŸ†• íƒ€ì…ë³„ ì•„ì´ì½˜ ë°˜í™˜ (NotificationService ë‚´ë¶€ ë©”ì„œë“œ)
  IconData _getIconForType(NotificationType type) {
    switch (type) {
      case NotificationType.trade:
        return Icons.show_chart;
      case NotificationType.priceAlert:
        return Icons.attach_money;
      case NotificationType.volume:
        return Icons.bar_chart;
      case NotificationType.surge:
        return Icons.trending_up;
      case NotificationType.system:
        return Icons.settings;
    }
  }

  /// ğŸ†• íƒ€ì…ë³„ ìƒ‰ìƒ ë°˜í™˜ (NotificationService ë‚´ë¶€ ë©”ì„œë“œ)  
  Color _getColorForType(NotificationType type) {
    switch (type) {
      case NotificationType.trade:
        return Colors.blue;
      case NotificationType.priceAlert:
        return Colors.green;
      case NotificationType.volume:
        return Colors.purple;
      case NotificationType.surge:
        return Colors.red;
      case NotificationType.system:
        return Colors.grey;
    }
  }

  /// ğŸ¯ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ ì•Œë¦¼ ì¶”ê°€ (ê³µê°œ ë©”ì„œë“œ)
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    _addNotificationToProvider(
      title: title,
      message: message,
      type: type,
      extra: extra,
    );
  }
  
  /// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ì•Œë¦¼ ì½ìŒ: $notificationId');
  }
  
  /// ì•Œë¦¼ ì œê±°
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ—‘ï¸ ì•Œë¦¼ ì œê±°: $notificationId');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì œê±°
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('ğŸ§¹ ëª¨ë“  ì•Œë¦¼ ì œê±°');
  }
  
  /// í•„í„° ì„¤ì •
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('ğŸ” ì•Œë¦¼ í•„í„°: ${type?.name ?? "ì „ì²´"}');
  }
  
  /// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }

  /// Firebase ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('ğŸ§¹ Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¨');
  }
}

/// ğŸ”” ì•Œë¦¼ ì„œë¹„ìŠ¤ Provider
final notificationServiceProvider = Provider((ref) => NotificationService(ref));\n\n// ====== lib/shared/widgets/common_app_bar.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/settings_provider.dart';
import 'ws_status_indicator.dart';
import 'market_mood_indicator.dart';
import 'notification_modal.dart';
import 'settings_modal.dart';
import 'slide_indicator.dart';
import '../../presentation/pages/main_page.dart';

/// ê³µí†µ ìƒë‹¨ë°” + ì•Œë¦¼/ì„¤ì • ì•„ì´ì½˜ + ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°
class CommonAppBar extends ConsumerWidget implements PreferredSizeWidget {
 const CommonAppBar({
   super.key,
   required this.title,
   this.leading,
   this.actions,
   this.centerTitle = true,
   this.elevation = 0,
   // ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°ìš© íŒŒë¼ë¯¸í„°ë“¤
   this.pages,
   this.pageController,
   this.animationController,
 });

 final String title;
 final Widget? leading;
 final List<Widget>? actions;
 final bool centerTitle;
 final double elevation;

 // ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° ê´€ë ¨
 final List<PageInfo>? pages;
 final PageController? pageController;
 final AnimationController? animationController;

 @override
 Size get preferredSize => const Size.fromHeight(kToolbarHeight);

 @override
 Widget build(BuildContext context, WidgetRef ref) {
   final screenWidth = MediaQuery.of(context).size.width;
   final leadingWidth = screenWidth * 0.2; // í™”ë©´ ë„ˆë¹„ì˜ 20%

   return AppBar(
     title: _buildTitle(),
     centerTitle: centerTitle,
     elevation: elevation,
     leadingWidth: leadingWidth,
     leading: leading ?? SizedBox(
       width: leadingWidth,
       child: Row(
         children: [
           // ì•Œë¦¼ ë²„íŠ¼ (ê·¸ë¼ë””ì–¸íŠ¸ íš¨ê³¼ ì ìš©)
           Padding(
             padding: const EdgeInsets.only(left: 8),
             child: IconButton(
               icon: ShaderMask(
                 shaderCallback: (bounds) => const LinearGradient(
                   colors: [
                     Color(0xFF9E9E9E), // ë°ì€ íšŒìƒ‰
                     Color(0xFF616161), // ì¤‘ê°„ íšŒìƒ‰
                     Color(0xFF424242), // ì–´ë‘ìš´ íšŒìƒ‰
                   ],
                   begin: Alignment.topLeft,
                   end: Alignment.bottomRight,
                 ).createShader(bounds),
                 child: const Icon(
                   Icons.notifications,
                   size: 22,
                   color: Colors.white, // ê·¸ë¼ë””ì–¸íŠ¸ê°€ ì ìš©ë  ë² ì´ìŠ¤
                 ),
               ),
               onPressed: () {
                 if (ref.read(appSettingsProvider).isHapticEnabled) {
                   HapticFeedback.lightImpact();
                 }
                 NotificationModal.show(context);
               },
             ),
           ),
           // ì„ì‹œ ì´ë¯¸ì§€ (ì£¼ì„ ì²˜ë¦¬)
           // Padding(
           //   padding: const EdgeInsets.only(left: 8),
           //   child: IconButton(
           //     icon: Image.asset(
           //       'assets/common_app_bar_icon.webp',
           //       width: 22,
           //       height: 22,
           //       fit: BoxFit.contain,
           //     ),
           //     onPressed: () {
           //       if (ref.read(settingsProvider).isHapticEnabled) {
           //         HapticFeedback.lightImpact();
           //       }
           //       // TODO: ì„ì‹œë¡œ ë…¸í‹°í”¼ì¼€ì´ì…˜ ê°œë°œ ì „ê¹Œì§€ ë¹„í™œì„±í™”
           //       // NotificationModal.show(context);
           //     },
           //   ),
           // ),
           // Market Mood ì•„ì´ì½˜
           const MarketMoodIndicator(
             size: 18,
             padding: EdgeInsets.only(right: 4),
           ),
         ],
       ),
     ),
     actions: actions ?? [
       // WebSocket ìƒíƒœ ì•„ì´ì½˜
       const WsStatusIndicator(
         size: 16,
         padding: EdgeInsets.only(right: 4),
       ),
       // ì„¤ì • ë²„íŠ¼ (ì˜ˆìœ ê·¸ë¼ë””ì–¸íŠ¸ ì ìš©)
       Padding(
         padding: const EdgeInsets.only(right: 8),
         child: IconButton(
           icon: ShaderMask(
             shaderCallback: (bounds) => const LinearGradient(
               colors: [
                 Color(0xFF9E9E9E), // ë°ì€ íšŒìƒ‰
                 Color(0xFF616161), // ì¤‘ê°„ íšŒìƒ‰
                 Color(0xFF424242), // ì–´ë‘ìš´ íšŒìƒ‰
               ],
               begin: Alignment.topLeft,
               end: Alignment.bottomRight,
             ).createShader(bounds),
             child: const Icon(
               Icons.settings,
               size: 22,
               color: Colors.white, // ê·¸ë¼ë””ì–¸íŠ¸ê°€ ì ìš©ë  ë² ì´ìŠ¤
             ),
           ),
           onPressed: () {
             if (ref.read(appSettingsProvider).isHapticEnabled) {
               HapticFeedback.lightImpact();
             }
             SettingsModal.show(context);
           },
         ),
       ),
     ],
   );
 }

 /// íƒ€ì´í‹€ ë¶€ë¶„ êµ¬ì„± (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° ë˜ëŠ” í…ìŠ¤íŠ¸)
 Widget _buildTitle() {
   // ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° íŒŒë¼ë¯¸í„°ë“¤ì´ ëª¨ë‘ ìˆìœ¼ë©´ ì¸ë””ì¼€ì´í„° í‘œì‹œ
   if (pages != null && pageController != null && animationController != null) {
     return SlideIndicator(
       pages: pages!,
       pageController: pageController!,
       animationController: animationController!,
     );
   }

   // íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ í…ìŠ¤íŠ¸ í‘œì‹œ
   return Text(title);
 }
}\n\n// ====== lib/shared/widgets/notification_modal.dart ======\n
// lib/shared/widgets/notification_modal.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class NotificationModal {
  /// ì•Œë¦¼ ëª¨ë‹¬ í‘œì‹œ
  static void show(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black54,
      builder: (context) => const _NotificationModalContent(),
    );
  }
}

class _NotificationModalContent extends ConsumerWidget {
  const _NotificationModalContent();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Container(
      margin: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.1),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // ğŸ¨ ì•Œë¦¼ ëª¨ë‹¬ í—¤ë”
          _buildHeader(context, ref),
          
          // êµ¬ë¶„ì„ 
          Divider(color: Colors.grey.shade300, height: 1),
          
          // ğŸ¯ ì•Œë¦¼ placeholder ë‚´ìš©
          _buildContent(context),
          
          // í•˜ë‹¨ ì—¬ë°±
          SizedBox(height: MediaQuery.of(context).padding.bottom + 20),
        ],
      ),
    );
  }

  /// í—¤ë” (ì œëª©ë§Œ, X ë²„íŠ¼ ì œê±°)
  Widget _buildHeader(BuildContext context, WidgetRef ref) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Column(
        children: [
          // ë‹¹ê¹€ í•¸ë“¤
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey.shade400,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(height: 12),
          // ì œëª© (X ë²„íŠ¼ ì œê±°)
          const Row(
            children: [
              SizedBox(width: 16),
              Icon(Icons.notifications, color: Colors.orange),
              SizedBox(width: 8),
              Text(
                'ì•Œë¦¼',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ì•Œë¦¼ ì»¨í…ì¸  (placeholder) - ê°€ë¡œ/ì„¸ë¡œ ëª¨ë“œ ëŒ€ì‘
  Widget _buildContent(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;
    final isLandscape = MediaQuery.of(context).orientation == Orientation.landscape;
    final bottomPadding = MediaQuery.of(context).padding.bottom;
    
    // ê°€ë¡œ ëª¨ë“œì¼ ë•Œ ë” ì‘ì€ ë†’ì´ ì‚¬ìš© + Safe Area ê³ ë ¤
    final maxHeight = isLandscape 
        ? (screenHeight * 0.65 - bottomPadding).clamp(200.0, 250.0) // ê°€ë¡œ: Safe Area ì œì™¸
        : 400.0; // ì„¸ë¡œ ëª¨ë“œ: ê¸°ì¡´ 400

    return Container(
      constraints: BoxConstraints(maxHeight: maxHeight),
      child: SingleChildScrollView(
        physics: const BouncingScrollPhysics(
          parent: AlwaysScrollableScrollPhysics(),
        ),
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // ì•Œë¦¼ ì•„ì´ì½˜
            Icon(
              Icons.notifications_outlined,
              size: isLandscape ? 60 : 80, // ê°€ë¡œ ëª¨ë“œì—ì„œ ì•„ì´ì½˜ í¬ê¸° ì¶•ì†Œ
              color: Colors.orange.withValues(alpha: 0.5),
            ),
            SizedBox(height: isLandscape ? 16 : 24), // ê°€ë¡œ ëª¨ë“œì—ì„œ ê°„ê²© ì¶•ì†Œ
            
            // ì œëª©
            Text(
              'ì•Œë¦¼ ê¸°ëŠ¥',
              style: TextStyle(
                fontSize: isLandscape ? 20 : 24, // ê°€ë¡œ ëª¨ë“œì—ì„œ í°íŠ¸ í¬ê¸° ì¶•ì†Œ
                fontWeight: FontWeight.bold,
                color: Colors.orange,
              ),
            ),
            SizedBox(height: isLandscape ? 8 : 12), // ê°€ë¡œ ëª¨ë“œì—ì„œ ê°„ê²© ì¶•ì†Œ
            
            // ì„¤ëª…
            Text(
              'ì‹¤ì‹œê°„ ì²´ê²° ì•Œë¦¼ê³¼\nê°€ê²© ë³€ë™ ì•Œë¦¼ì„ ë°›ì•„ë³´ì„¸ìš”',
              style: TextStyle(
                fontSize: isLandscape ? 14 : 16, // ê°€ë¡œ ëª¨ë“œì—ì„œ í°íŠ¸ í¬ê¸° ì¶•ì†Œ
                color: Colors.grey.shade600,
                height: 1.4,
              ),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: isLandscape ? 20 : 32), // ê°€ë¡œ ëª¨ë“œì—ì„œ ê°„ê²© ì¶•ì†Œ
            
            // ì¤€ë¹„ ì¤‘ ë°°ì§€
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
              decoration: BoxDecoration(
                color: Colors.orange.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(20),
                border: Border.all(color: Colors.orange.withValues(alpha: 0.3)),
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.construction,
                    size: 16,
                    color: Colors.orange.shade700,
                  ),
                  const SizedBox(width: 6),
                  Text(
                    'ê³§ ì¶œì‹œ ì˜ˆì •!',
                    style: TextStyle(
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      color: Colors.orange.shade700,
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(height: isLandscape ? 12 : 16), // ê°€ë¡œ ëª¨ë“œì—ì„œ ê°„ê²© ì¶•ì†Œ
            
            // ê¸°ëŠ¥ ë¯¸ë¦¬ë³´ê¸°
            Text(
              'â€¢ ì‹¤ì‹œê°„ ì²´ê²° ì•Œë¦¼\nâ€¢ ê¸‰ë“±ë½ ì•Œë¦¼\nâ€¢ ê±°ë˜ëŸ‰ ê¸‰ì¦ ì•Œë¦¼\nâ€¢ ë§ì¶¤ ê°€ê²© ì•Œë¦¼',
              style: TextStyle(
                fontSize: isLandscape ? 12 : 13, // ê°€ë¡œ ëª¨ë“œì—ì„œ í°íŠ¸ í¬ê¸° ì¶•ì†Œ
                color: Colors.grey.shade500,
                height: 1.6,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/shared/widgets/settings_modal.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
// ğŸ¨ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯ë“¤ Import
import 'settings/theme_mode_segment.dart';
import 'settings/slider_position_segment.dart';
import 'settings/font_segment.dart';
// ğŸ“± ì•± ì •ë³´ ëª¨ë‹¬ Import
import '../information/app_information_modal.dart';

class SettingsModal {
  /// ì„¤ì • ëª¨ë‹¬ í‘œì‹œ
  static void show(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black54,
      builder: (context) => const _SettingsModalContent(),
    );
  }
}

class _SettingsModalContent extends ConsumerWidget {
  const _SettingsModalContent();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(appSettingsProvider);
    final controller = ref.read(appSettingsProvider.notifier);

    return Container(
      margin: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withAlpha(26),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildHeader(context, ref),
          Divider(color: Colors.grey.shade300, height: 1),
          _buildContent(context, settings, controller, ref),
          SizedBox(height: MediaQuery.of(context).padding.bottom + 20),
        ],
      ),
    );
  }

  /// í—¤ë” (ì œëª© + ë‹«ê¸° ë²„íŠ¼)
  Widget _buildHeader(BuildContext context, WidgetRef ref) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Column(
        children: [
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey.shade400,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(height: 12),
          const Row(
            children: [
              SizedBox(width: 16),
              Icon(Icons.settings, color: Colors.orange),
              SizedBox(width: 8),
              Text(
                'ì„¤ì •',
                style: TextStyle(
                  fontSize: 19,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ì„¤ì • ì»¨í…ì¸  (ìŠ¤í¬ë¡¤ ê°€ëŠ¥)
  Widget _buildContent(BuildContext context, AppSettings settings, dynamic controller, WidgetRef ref) {
    final scrollController = ScrollController();
    final screenHeight = MediaQuery.of(context).size.height;
    final isLandscape = MediaQuery.of(context).orientation == Orientation.landscape;
    final bottomPadding = MediaQuery.of(context).padding.bottom; // Safe Area í•˜ë‹¨ íŒ¨ë”©
    
    // ê°€ë¡œ ëª¨ë“œì¼ ë•Œ ë” ì‘ì€ ë†’ì´ ì‚¬ìš© + Safe Area ê³ ë ¤
    final maxHeight = isLandscape 
        ? (screenHeight * 0.65 - bottomPadding).clamp(250.0, 300.0) // Safe Area ì œì™¸
        : 420.0; // ì„¸ë¡œ ëª¨ë“œ: ê¸°ì¡´ 420
    
    return Container(
      constraints: BoxConstraints(maxHeight: maxHeight),
      child: RawScrollbar(
        controller: scrollController,
        thumbVisibility: false,
        trackVisibility: false,
        thickness: 6.4,
        radius: const Radius.circular(3.2),
        thumbColor: Colors.orange.withAlpha(128),
        trackColor: Colors.transparent,
        interactive: true,
        minThumbLength: 40,
        child: SingleChildScrollView(
          controller: scrollController,
          physics: const BouncingScrollPhysics(
            parent: AlwaysScrollableScrollPhysics(),
          ),
          padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
          child: Column(
            children: [
              // ğŸ¨ í…Œë§ˆ ì„¤ì • (3ê°œ í…Œë§ˆë§Œ)
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.palette, color: Colors.orange),
                    title: const Text('í…Œë§ˆ', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getThemeDescription(settings.themeMode),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: ThemeModeSegment(
                      themeMode: settings.themeMode,
                      onChanged: (ThemeMode mode) {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        controller.setThemeMode(mode);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // ğŸ’° ì½”ì¸ëª… í‘œì‹œ ë°©ì‹
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.monetization_on, color: Colors.orange),
                    title: const Text('ì½”ì¸ëª… í‘œì‹œ', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getDisplayModeDescription(settings.displayMode),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: _DisplayModeSegment(
                      value: settings.displayMode,
                      onChanged: (DisplayMode mode) {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        controller.setDisplayMode(mode);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ’µ ê¸ˆì•¡ í‘œì‹œ ë°©ì‹
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.account_balance_wallet, color: Colors.orange),
                    title: const Text('ê¸ˆì•¡ í‘œì‹œ', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getAmountDisplayModeDescription(settings.amountDisplayMode),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: _AmountDisplayModeSegment(
                      value: settings.amountDisplayMode,
                      onChanged: (AmountDisplayMode mode) {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        controller.setAmountDisplayMode(mode);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ”¤ í°íŠ¸ ì„¤ì •
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.font_download, color: Colors.orange),
                    title: const Text('í°íŠ¸', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getFontDescription(settings.fontFamily),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: FontSegment(
                      value: settings.fontFamily,
                      onChanged: (FontFamily font) {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        controller.setFontFamily(font);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.tune, color: Colors.orange),
                    title: const Text('ìŠ¬ë¼ì´ë” ìœ„ì¹˜', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getSliderPositionDescription(settings.sliderPosition),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: SliderPositionSegment(
                      value: settings.sliderPosition,
                      onChanged: (SliderPosition position) {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        controller.setSliderPosition(position);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // âœ¨ ë¸”ë§í¬ íš¨ê³¼
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: SwitchListTile(
                    secondary: const Icon(Icons.auto_awesome, color: Colors.orange),
                    title: const Text('ë¸”ë§í¬ íš¨ê³¼', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getBlinkDescription(settings.blinkEnabled),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    value: settings.blinkEnabled,
                    onChanged: (bool value) {
                      if (ref.read(appSettingsProvider).isHapticEnabled) {
                        HapticFeedback.lightImpact();
                      }
                      controller.setBlinkEnabled(value);
                    },
                    activeColor: Colors.orange,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: SwitchListTile(
                    secondary: const Icon(Icons.screen_lock_rotation, color: Colors.orange),
                    title: const Text('í™”ë©´ í•­ìƒ ì¼œê¸°', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getKeepScreenDescription(settings.keepScreenOn),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    value: settings.keepScreenOn,
                    onChanged: (bool value) {
                      if (ref.read(appSettingsProvider).isHapticEnabled) {
                        HapticFeedback.lightImpact();
                      }
                      controller.setKeepScreenOn(value);
                    },
                    activeColor: Colors.orange,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ“³ í–…í‹± í”¼ë“œë°± (ìƒˆë¡œ ì¶”ê°€)
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: SwitchListTile(
                    secondary: const Icon(Icons.vibration, color: Colors.orange),
                    title: const Text('í–…í‹± í”¼ë“œë°±', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getHapticDescription(settings.isHapticEnabled),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    value: settings.isHapticEnabled,
                    onChanged: (bool value) {
                      // í–…í‹± ì„¤ì • ë³€ê²½ ì‹œì—ëŠ” ì¼ë‹¨ í–…í‹± ì‹¤í–‰ í›„ ì„¤ì • ì ìš©
                      if (settings.isHapticEnabled) {
                        HapticFeedback.lightImpact();
                      }
                      controller.setHapticEnabled(value);
                    },
                    activeColor: Colors.orange,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ”’ í™”ë©´ íšŒì „ ì ê¸ˆ (ìƒˆë¡œ ì¶”ê°€)
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: SwitchListTile(
                    secondary: const Icon(Icons.screen_rotation_outlined, color: Colors.orange),
                    title: const Text('ì„¸ë¡œ ëª¨ë“œ ê³ ì •', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: Text(
                      _getPortraitLockDescription(settings.isPortraitLocked),
                      style: const TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    value: settings.isPortraitLocked,
                    onChanged: (bool value) {
                      if (ref.read(appSettingsProvider).isHapticEnabled) {
                        HapticFeedback.lightImpact();
                      }
                      controller.setPortraitLocked(value);
                    },
                    activeColor: Colors.orange,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ”§ ìºì‹œ ë¹„ìš°ê¸°
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.cleaning_services, color: Colors.orange),
                    title: const Text('ìºì‹œ ë¹„ìš°ê¸°', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: const Text(
                      'ì„ì‹œ ë°ì´í„°ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤',
                      style: TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: _CacheSegment(
                      onPressed: () {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        _showClearCacheDialog(context, controller, ref);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ”„ ì„¤ì • ì´ˆê¸°í™”
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.restore, color: Colors.orange),
                    title: const Text('ì„¤ì • ì´ˆê¸°í™”', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: const Text(
                      'ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦½ë‹ˆë‹¤',
                      style: TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: _ResetSegment(
                      onPressed: () {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        _showResetDialog(context, controller, ref);
                      },
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              
              // ğŸ“± ì•± ì •ë³´ (ìƒˆë¡œ ì¶”ê°€)
              SizedBox(
                height: 80,
                child: Card(
                  elevation: 2,
                  child: ListTile(
                    leading: const Icon(Icons.info_outline, color: Colors.orange),
                    title: const Text('ì•± ì •ë³´', style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold)),
                    subtitle: const Text(
                      'ë²„ì „ ì •ë³´ ë° ê°œë°œì ì •ë³´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                      style: TextStyle(fontSize: 11),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: _AppInfoSegment(
                      onPressed: () {
                        if (ref.read(appSettingsProvider).isHapticEnabled) {
                          HapticFeedback.lightImpact();
                        }
                        AppInformationModal.show(context);
                      },
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // ğŸ“ Helper ë©”ì„œë“œë“¤ (ì™„ì „ êµ¬í˜„)
  String _getThemeDescription(ThemeMode themeMode) {
    switch (themeMode) {
      case ThemeMode.system:
        return 'ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ í…Œë§ˆê°€ ê²°ì •ë©ë‹ˆë‹¤';
      case ThemeMode.light:
        return 'ë°ì€ í…Œë§ˆê°€ ì ìš©ë©ë‹ˆë‹¤';
      case ThemeMode.dark:
        return 'ì–´ë‘ìš´ í…Œë§ˆê°€ ì ìš©ë©ë‹ˆë‹¤';
    }
  }

  String _getDisplayModeDescription(DisplayMode mode) {
    switch (mode) {
      case DisplayMode.ticker:
        return 'BTC, ETH, XRP í˜•ì‹ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤';
      case DisplayMode.korean:
        return 'ë¹„íŠ¸ì½”ì¸, ì´ë”ë¦¬ì›€, ë¦¬í”Œ í˜•ì‹ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤';
      case DisplayMode.english:
        return 'Bitcoin, Ethereum, Ripple í˜•ì‹ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤';
    }
  }

  String _getAmountDisplayModeDescription(AmountDisplayMode mode) {
    switch (mode) {
      case AmountDisplayMode.number:
        return 'ê¸ˆì•¡ ìˆ«ìë¡œ í‘œì‹œë©ë‹ˆë‹¤';
      case AmountDisplayMode.icon:
        return 'ğŸ’µ ì•„ì´ì½˜ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤';
    }
  }

  String _getFontDescription(FontFamily fontFamily) {
    return '${fontFamily.fontName} í°íŠ¸ê°€ ì ìš©ë©ë‹ˆë‹¤';
  }

  String _getSliderPositionDescription(SliderPosition position) {
    return position == SliderPosition.top
        ? 'ìŠ¬ë¼ì´ë”ë¥¼ í™”ë©´ ìƒë‹¨ì— í‘œì‹œí•©ë‹ˆë‹¤'
        : 'ìŠ¬ë¼ì´ë”ë¥¼ í™”ë©´ í•˜ë‹¨ì— í‘œì‹œí•©ë‹ˆë‹¤';
  }

  String _getBlinkDescription(bool enabled) {
    return enabled
        ? 'ê°€ê²© ë³€ë™ ì‹œ ë¸”ë§í¬ íš¨ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤'
        : 'ë¸”ë§í¬ íš¨ê³¼ê°€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤';
  }

  String _getKeepScreenDescription(bool enabled) {
    return enabled
        ? 'í™”ë©´ì´ ìë™ìœ¼ë¡œ êº¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤'
        : 'ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ í™”ë©´ì´ êº¼ì§‘ë‹ˆë‹¤';
  }

  // ğŸ†• ìƒˆë¡œ ì¶”ê°€ëœ ì„¤ì •ë“¤ì˜ ì„¤ëª…
  String _getHapticDescription(bool enabled) {
    return enabled
        ? 'í„°ì¹˜ ì‹œ ì§„ë™ í”¼ë“œë°±ì´ í™œì„±í™”ë©ë‹ˆë‹¤'
        : 'ì§„ë™ í”¼ë“œë°±ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤';
  }

  String _getPortraitLockDescription(bool locked) {
    return locked
        ? 'í™”ë©´ì´ ì„¸ë¡œ ëª¨ë“œë¡œ ê³ ì •ë©ë‹ˆë‹¤'
        : 'í™”ë©´ íšŒì „ì´ ìë™ìœ¼ë¡œ ì „í™˜ë©ë‹ˆë‹¤';
  }

  // ğŸ—‚ï¸ ë‹¤ì´ì–¼ë¡œê·¸ ë©”ì„œë“œë“¤
  void _showClearCacheDialog(BuildContext context, dynamic controller, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ìºì‹œ ë¹„ìš°ê¸°'),
        content: const Text('ì„ì‹œ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nì•± ì„±ëŠ¥ì´ í–¥ìƒë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'),
        actions: [
          TextButton(
            onPressed: () {
              // ì·¨ì†Œ ë²„íŠ¼ì€ í–…í‹± ì—†ìŒ
              Navigator.of(context).pop();
            },
            child: const Text('ì·¨ì†Œ'),
          ),
          TextButton(
            onPressed: () async {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact();
              }
              Navigator.of(context).pop();
              await controller.clearCache();
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('ìºì‹œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤')),
                );
              }
            },
            child: const Text('ì‚­ì œ', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  void _showResetDialog(BuildContext context, dynamic controller, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ì„¤ì • ì´ˆê¸°í™”'),
        content: const Text('ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë˜ëŒë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?\nì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'),
        actions: [
          TextButton(
            onPressed: () {
              // ì·¨ì†Œ ë²„íŠ¼ì€ í–…í‹± ì—†ìŒ
              Navigator.of(context).pop();
            },
            child: const Text('ì·¨ì†Œ'),
          ),
          TextButton(
            onPressed: () async {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact();
              }
              Navigator.of(context).pop();
              await controller.resetAllSettings();
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤')),
                );
              }
            },
            child: const Text('ì´ˆê¸°í™”', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
}

/// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯ (ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ í†µì¼)
class _DisplayModeSegment extends StatelessWidget {
  final DisplayMode value;
  final ValueChanged<DisplayMode> onChanged;

  const _DisplayModeSegment({
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentButton(context: context, mode: DisplayMode.ticker, label: 'í‹°ì»¤', icon: Icons.code),
          _buildDivider(),
          _buildSegmentButton(context: context, mode: DisplayMode.korean, label: 'í•œê¸€', icon: Icons.language),
          _buildDivider(),
          _buildSegmentButton(context: context, mode: DisplayMode.english, label: 'ì˜ë¬¸', icon: Icons.translate),
        ],
      ),
    );
  }

  Widget _buildSegmentButton({
    required BuildContext context,
    required DisplayMode mode,
    required String label,
    required IconData icon,
  }) {
    final isSelected = value == mode;
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    final backgroundColor = isSelected ? Colors.orange.withAlpha(26) : Colors.transparent;

    return GestureDetector(
      onTap: () => onChanged(mode),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16, color: color),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDivider() {
    return Container(width: 1, height: 40, color: Colors.grey.shade300);
  }
}

/// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _AmountDisplayModeSegment extends StatelessWidget {
  final AmountDisplayMode value;
  final ValueChanged<AmountDisplayMode> onChanged;

  const _AmountDisplayModeSegment({
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentButton(context: context, mode: AmountDisplayMode.number, label: 'ìˆ«ì', icon: Icons.format_list_numbered),
          _buildDivider(),
          _buildSegmentButton(context: context, mode: AmountDisplayMode.icon, label: 'ì•„ì´ì½˜', icon: Icons.account_balance_wallet),
        ],
      ),
    );
  }

  Widget _buildSegmentButton({
    required BuildContext context,
    required AmountDisplayMode mode,
    required String label,
    required IconData icon,
  }) {
    final isSelected = value == mode;
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    final backgroundColor = isSelected ? Colors.orange.withAlpha(26) : Colors.transparent;

    return GestureDetector(
      onTap: () => onChanged(mode),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16, color: color),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDivider() {
    return Container(width: 1, height: 40, color: Colors.grey.shade300);
  }
}

/// ğŸ”§ ìºì‹œ ë¹„ìš°ê¸° ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _CacheSegment extends StatelessWidget {
  final VoidCallback onPressed;

  const _CacheSegment({
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: GestureDetector(
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: Colors.orange.withAlpha(26),
            borderRadius: BorderRadius.circular(6),
          ),
          child: const Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.cleaning_services, size: 16, color: Colors.orange),
              SizedBox(height: 2),
              Text(
                'ë¹„ìš°ê¸°',
                style: TextStyle(
                  fontSize: 11,
                  color: Colors.orange,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// ğŸ”„ ì„¤ì • ì´ˆê¸°í™” ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _ResetSegment extends StatelessWidget {
  final VoidCallback onPressed;

  const _ResetSegment({
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: GestureDetector(
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: Colors.orange.withAlpha(26),
            borderRadius: BorderRadius.circular(6),
          ),
          child: const Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.restore, size: 16, color: Colors.orange),
              SizedBox(height: 2),
              Text(
                'ì´ˆê¸°í™”',
                style: TextStyle(
                  fontSize: 11,
                  color: Colors.orange,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// ğŸ“± ì•± ì •ë³´ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _AppInfoSegment extends StatelessWidget {
  final VoidCallback onPressed;

  const _AppInfoSegment({
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: GestureDetector(
        onTap: onPressed,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: Colors.orange.withAlpha(26),
            borderRadius: BorderRadius.circular(6),
          ),
          child: const Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.info_outline, size: 16, color: Colors.orange),
              SizedBox(height: 2),
              Text(
                'ì •ë³´',
                style: TextStyle(
                  fontSize: 11,
                  color: Colors.orange,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}\n\n// ====== lib/shared/widgets/sector_names.dart ======\n
// lib/shared/widgets/sector_names.dart
// ğŸ†• ì‹¤ì œ ì„¹í„° ë¶„ë¥˜ì— ë§ì¶˜ ë„¤ì´ë° ë§¤í•‘

import '../../domain/entities/app_settings.dart';

class SectorNames {
  // ğŸ¯ ìƒì„¸ ë¶„ë¥˜ (28ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘
  static const Map<String, Map<String, String>> detailedSectorNaming = {
    // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
    'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': {
      'ticker': 'BTC-GRP',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹',
      'english': 'Bitcoin Group',
    },
    'ì´ë”ë¦¬ì›€ ê·¸ë£¹': {
      'ticker': 'ETH-GRP',
      'korean': 'ì´ë”ë¦¬ì›€ ê·¸ë£¹',
      'english': 'Ethereum Group',
    },
    'ìŠ¤í…Œì´í‚¹': {
      'ticker': 'STAKE',
      'korean': 'ìŠ¤í…Œì´í‚¹',
      'english': 'Staking',
    },

    // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
    'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MONO',
      'korean': 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸',
      'english': 'Monolithic Blockchain',
    },
    'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': {
      'ticker': 'MODU',
      'korean': 'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸',
      'english': 'Modular Blockchain',
    },

    // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
    'ìŠ¤í…Œì´ë¸” ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸” ì½”ì¸',
      'english': 'Stablecoin',
    },

    // ==================== DeFi ìƒíƒœê³„ ====================
    'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': {
      'ticker': 'DEX',
      'korean': 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°',
      'english': 'DEX/Aggregator',
    },
    'ëœë”©': {
      'ticker': 'LEND',
      'korean': 'ëœë”©',
      'english': 'Lending',
    },
    'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': {
      'ticker': 'LSTAKE',
      'korean': 'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹',
      'english': 'Liquid Staking/Restaking',
    },
    'RWA': {
      'ticker': 'RWA',
      'korean': 'RWA',
      'english': 'Real World Assets',
    },

    // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
    'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': {
      'ticker': 'PAY',
      'korean': 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼',
      'english': 'Payment Infrastructure',
    },
    'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': {
      'ticker': 'BRIDGE',
      'korean': 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€',
      'english': 'Interoperability/Bridge',
    },
    'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': {
      'ticker': 'ENTER',
      'korean': 'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸',
      'english': 'Enterprise Blockchain',
    },
    'ì˜¤ë¼í´': {
      'ticker': 'ORACLE',
      'korean': 'ì˜¤ë¼í´',
      'english': 'Oracle',
    },
    'ë°ì´í„° ì¸í”„ë¼': {
      'ticker': 'DATA',
      'korean': 'ë°ì´í„° ì¸í”„ë¼',
      'english': 'Data Infrastructure',
    },
    'ìŠ¤í† ë¦¬ì§€': {
      'ticker': 'STORAGE',
      'korean': 'ìŠ¤í† ë¦¬ì§€',
      'english': 'Storage',
    },
    'AI': {
      'ticker': 'AI',
      'korean': 'AI',
      'english': 'Artificial Intelligence',
    },

    // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
    'ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'META',
      'korean': 'ë©”íƒ€ë²„ìŠ¤',
      'english': 'Metaverse',
    },
    'NFT/ê²Œì„': {
      'ticker': 'NFT-GAME',
      'korean': 'NFT/ê²Œì„',
      'english': 'NFT/Gaming',
    },

    // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
    'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': {
      'ticker': 'MEDIA',
      'korean': 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°',
      'english': 'Media/Streaming',
    },
    'ê´‘ê³ ': {
      'ticker': 'AD',
      'korean': 'ê´‘ê³ ',
      'english': 'Advertising',
    },
    'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': {
      'ticker': 'EDU',
      'korean': 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ',
      'english': 'Education/Content',
    },

    // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
    'ì†Œì…œ/DAO': {
      'ticker': 'SOCIAL',
      'korean': 'ì†Œì…œ/DAO',
      'english': 'Social/DAO',
    },
    'íŒ¬í† í°': {
      'ticker': 'FAN',
      'korean': 'íŒ¬í† í°',
      'english': 'Fan Token',
    },
    'ë°ˆ': {
      'ticker': 'MEME',
      'korean': 'ë°ˆ',
      'english': 'Meme',
    },

    // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
    'DID': {
      'ticker': 'DID',
      'korean': 'DID',
      'english': 'Decentralized Identity',
    },
    'ì˜ë£Œ': {
      'ticker': 'MED',
      'korean': 'ì˜ë£Œ',
      'english': 'Medical',
    },
    'ì›”ë ›/ë©”ì„¸ì§•': {
      'ticker': 'WALLET',
      'korean': 'ì›”ë ›/ë©”ì„¸ì§•',
      'english': 'Wallet/Messaging',
    },
  };

  // ğŸ¯ ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) ë„¤ì´ë° ë§¤í•‘ - ğŸ†• ì‹ ê·œìƒì¥ 4ê°œ ì„¹í„° ì¶”ê°€
  static const Map<String, Map<String, String>> basicSectorNaming = {
    'ë©”ì´ì € ì½”ì¸': {
      'ticker': 'MAJOR',
      'korean': 'ë©”ì´ì € ì½”ì¸',
      'english': 'Major Coins',
    },
    'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': {
      'ticker': 'BTC-FAM',
      'korean': 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´',
      'english': 'Bitcoin Family',
    },
    'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': {
      'ticker': 'ETH-ECO',
      'korean': 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„',
      'english': 'Ethereum Ecosystem',
    },
    'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': {
      'ticker': 'L1',
      'korean': 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸',
      'english': 'Layer 1 Blockchain',
    },
    'ê³  ì‹œì´': {
      'ticker': 'LARGE-CAP',
      'korean': 'ê³  ì‹œì´',
      'english': 'Large Market Cap',
    },
    'ì¤‘ ì‹œì´': {
      'ticker': 'MID-CAP',
      'korean': 'ì¤‘ ì‹œì´',
      'english': 'Mid Market Cap',
    },
    'ì € ì‹œì´': {
      'ticker': 'SMALL-CAP',
      'korean': 'ì € ì‹œì´',
      'english': 'Small Market Cap',
    },
    'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': {
      'ticker': 'MINOR-ALT',
      'korean': 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸',
      'english': 'Minor Altcoins',
    },
    'DeFi í† í°': {
      'ticker': 'DEFI',
      'korean': 'DeFi í† í°',
      'english': 'DeFi Tokens',
    },
    'ìŠ¤í…Œì´ë¸”ì½”ì¸': {
      'ticker': 'STABLE',
      'korean': 'ìŠ¤í…Œì´ë¸”ì½”ì¸',
      'english': 'Stablecoins',
    },
    'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': {
      'ticker': 'GAMING',
      'korean': 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤',
      'english': 'Gaming/NFT/Metaverse',
    },
    'í•œêµ­ í”„ë¡œì íŠ¸': {
      'ticker': 'KOREA',
      'korean': 'í•œêµ­ í”„ë¡œì íŠ¸',
      'english': 'Korean Projects',
    },
    'ì†”ë¼ë‚˜ ìƒíƒœê³„': {
      'ticker': 'SOL-ECO',
      'korean': 'ì†”ë¼ë‚˜ ìƒíƒœê³„',
      'english': 'Solana Ecosystem',
    },
    'AI/ê¸°ìˆ  í† í°': {
      'ticker': 'AI-TECH',
      'korean': 'AI/ê¸°ìˆ  í† í°',
      'english': 'AI/Tech Tokens',
    },

    // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
    '2023ë…„ ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-23',
      'korean': '2023ë…„ ì‹ ê·œìƒì¥',
      'english': '2023 New Listings',
    },
    '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H1',
      'korean': '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H1 New Listings',
    },
    '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-24H2',
      'korean': '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2024 H2 New Listings',
    },
    '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': {
      'ticker': 'NEW-25H1',
      'korean': '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥',
      'english': '2025 H1 New Listings',
    },
  };

  /// ğŸ¯ ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ ë³€í™˜ (ê¸°ë³¸/ìƒì„¸ ë¶„ë¥˜ ìë™ ê°ì§€)
  static String getDisplayName(String sectorKey, DisplayMode displayMode, {bool isDetailed = false}) {
    // ì •ê·œí™” (ì…ë ¥ëœ ì„¹í„°ëª… ê·¸ëŒ€ë¡œ ë§¤í•‘ì—ì„œ ì°¾ê¸°)
    final normalizedKey = sectorKey.trim();
    
    // ìƒì„¸/ê¸°ë³¸ ë¶„ë¥˜ì— ë”°ë¼ ì ì ˆí•œ ë§¤í•‘ ì„ íƒ
    final sectorData = isDetailed 
        ? detailedSectorNaming[normalizedKey] 
        : basicSectorNaming[normalizedKey];
    
    // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ë‹¤ë¥¸ ë¶„ë¥˜ì—ì„œ ì°¾ê¸° ì‹œë„
    final fallbackData = isDetailed 
        ? basicSectorNaming[normalizedKey]
        : detailedSectorNaming[normalizedKey];
    
    final finalData = sectorData ?? fallbackData;
    
    if (finalData == null) {
      // ë§¤í•‘ì´ ì—†ìœ¼ë©´ ì›ë³¸ ë°˜í™˜ (fallback)
      return sectorKey;
    }

    switch (displayMode) {
      case DisplayMode.ticker:
        return finalData['ticker'] ?? sectorKey;
      case DisplayMode.korean:
        return finalData['korean'] ?? sectorKey;
      case DisplayMode.english:
        return finalData['english'] ?? sectorKey;
    }
  }

  /// ğŸ”§ ëª¨ë“  ì„¹í„° í‚¤ ëª©ë¡ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static List<String> getAllSectorKeys({bool isDetailed = false}) {
    return isDetailed 
        ? detailedSectorNaming.keys.toList()
        : basicSectorNaming.keys.toList();
  }

  /// ğŸ”§ íŠ¹ì • ì„¹í„°ê°€ ë§¤í•‘ì— ìˆëŠ”ì§€ í™•ì¸
  static bool hasSector(String sectorKey, {bool isDetailed = false}) {
    final normalizedKey = sectorKey.trim();
    
    return isDetailed 
        ? detailedSectorNaming.containsKey(normalizedKey)
        : basicSectorNaming.containsKey(normalizedKey);
  }

  /// ğŸ”§ ë””ë²„ê¹…ìš© - ë§¤í•‘ë˜ì§€ ì•Šì€ ì„¹í„° ì°¾ê¸°
  static List<String> findUnmappedSectors(List<String> actualSectorKeys, {bool isDetailed = false}) {
    final unmapped = <String>[];
    
    for (final sectorKey in actualSectorKeys) {
      if (!hasSector(sectorKey, isDetailed: isDetailed)) {
        unmapped.add(sectorKey);
      }
    }
    
    return unmapped;
  }

  /// ğŸ”§ ì „ì²´ ë§¤í•‘ ì •ë³´ ë°˜í™˜ (ë””ë²„ê¹…ìš©)
  static Map<String, Map<String, String>> getAllMappings({bool isDetailed = false}) {
    return isDetailed ? detailedSectorNaming : basicSectorNaming;
  }
}

// ğŸ†• SectorTileì—ì„œ ì‚¬ìš©í•  í—¬í¼ í™•ì¥
extension SectorDisplayExtension on String {
  /// ì„¹í„°ëª…ì„ DisplayModeì— ë”°ë¼ í‘œì‹œ
  String toDisplayName(DisplayMode displayMode, {bool isDetailed = false}) {
    return SectorNames.getDisplayName(this, displayMode, isDetailed: isDetailed);
  }
}\n\n// ====== lib/shared/widgets/slide_indicator.dart ======\n
// lib/shared/widgets/slide_indicator.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedbackìš© ì¶”ê°€
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/pages/main_page.dart';

/// ğŸ¨ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° - iOS ìŠ¤íƒ€ì¼ì˜ í˜ì´ì§€ ì¸ë””ì¼€ì´í„°
class SlideIndicator extends ConsumerStatefulWidget {
 final List<PageInfo> pages;
 final PageController pageController;
 final AnimationController animationController;

 const SlideIndicator({
   Key? key,
   required this.pages,
   required this.pageController,
   required this.animationController,
 }) : super(key: key);

 @override
 ConsumerState<SlideIndicator> createState() => _SlideIndicatorState();
}

class _SlideIndicatorState extends ConsumerState<SlideIndicator>
   with TickerProviderStateMixin {
 
 late List<AnimationController> _iconControllers;
 late List<Animation<double>> _scaleAnimations;
 late List<Animation<Color?>> _colorAnimations;

 @override
 void initState() {
   super.initState();
   _setupAnimations();
 }

 /// ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
 void _setupAnimations() {
   _iconControllers = List.generate(
     widget.pages.length,
     (index) => AnimationController(
       duration: const Duration(milliseconds: 250),
       vsync: this,
     ),
   );

   _scaleAnimations = _iconControllers.map((controller) {
     return Tween<double>(
       begin: 0.8, // ì‘ì€ í¬ê¸°
       end: 1.2,   // í° í¬ê¸°
     ).animate(CurvedAnimation(
       parent: controller,
       curve: Curves.easeOutBack, // í†µí†µ íŠ€ëŠ” ì• ë‹ˆë©”ì´ì…˜
     ));
   }).toList();

   _colorAnimations = _iconControllers.map((controller) {
     return ColorTween(
       begin: Colors.grey.shade400,     // ë¹„í™œì„± ìƒ‰ìƒ
       end: Colors.orange,              // í™œì„± ìƒ‰ìƒ
     ).animate(CurvedAnimation(
       parent: controller,
       curve: Curves.easeInOut,
     ));
   }).toList();

   // ì´ˆê¸° ì„ íƒëœ í˜ì´ì§€ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ì²´ê²° í˜ì´ì§€ = index 1)
   WidgetsBinding.instance.addPostFrameCallback((_) {
     _iconControllers[1].forward();
   });
 }

 @override
 void dispose() {
   for (final controller in _iconControllers) {
     controller.dispose();
   }
   super.dispose();
 }

 @override
 Widget build(BuildContext context) {
   final currentIndex = ref.watch(selectedTabProvider);
   
   // í˜ì´ì§€ ë³€ê²½ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
   _updateAnimations(currentIndex);

   return SizedBox( // âœ… Container â†’ SizedBox ë³€ê²½
     height: 40,
     child: Row(
       mainAxisSize: MainAxisSize.min,
       children: widget.pages.asMap().entries.map((entry) {
         final index = entry.key;
         final page = entry.value;
         
         return _buildAnimatedIcon(index, page, currentIndex);
       }).toList(),
     ),
   );
 }

 /// ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
 void _updateAnimations(int currentIndex) {
   for (int i = 0; i < _iconControllers.length; i++) {
     if (i == currentIndex) {
       _iconControllers[i].forward();
     } else {
       _iconControllers[i].reverse();
     }
   }
 }

 /// ì• ë‹ˆë©”ì´ì…˜ ì•„ì´ì½˜ ìƒì„±
 Widget _buildAnimatedIcon(int index, PageInfo page, int currentIndex) {
   final isSelected = index == currentIndex;
   
   return AnimatedBuilder(
     animation: Listenable.merge([
       _scaleAnimations[index],
       _colorAnimations[index],
     ]),
     builder: (context, child) {
       return GestureDetector(
         onTap: () => _onIconTap(index),
         child: Container(
           margin: const EdgeInsets.symmetric(horizontal: 1.8),
           padding: const EdgeInsets.all(8),
           child: Transform.scale(
             scale: _scaleAnimations[index].value,
             child: Container(
               width: 32,
               height: 32,
               decoration: BoxDecoration(
                 shape: BoxShape.circle,
                 color: isSelected 
                   ? Colors.orange.withValues(alpha: 0.1)
                   : Colors.transparent,
                 border: isSelected 
                   ? Border.all(color: Colors.orange.withValues(alpha: 0.3), width: 1)
                   : null,
               ),
               child: Icon(
                 page.icon,
                 size: isSelected ? 20 : 16,
                 color: _colorAnimations[index].value,
               ),
             ),
           ),
         ),
       );
     },
   );
 }

 /// ì•„ì´ì½˜ í´ë¦­ ì²˜ë¦¬
 void _onIconTap(int index) {
   // í–…í‹± í”¼ë“œë°± ë¨¼ì € ì‹¤í–‰
   if (ref.read(appSettingsProvider).isHapticEnabled) {
     HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± í™œì„±í™”!
   }
   
   // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
   ref.read(selectedTabProvider.notifier).state = index;
   
   // í˜ì´ì§€ ì´ë™
   widget.pageController.animateToPage(
     index,
     duration: const Duration(milliseconds: 300),
     curve: Curves.easeInOut,
   );
   
   debugPrint('ğŸ¯ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° í´ë¦­: ${widget.pages[index].title}');
 }
}

/// ğŸ¨ ê°„ë‹¨ ë²„ì „ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° (ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ)
class SimpleSlideIndicator extends ConsumerWidget {
 final List<PageInfo> pages;
 final PageController pageController;

 const SimpleSlideIndicator({
   Key? key,
   required this.pages,
   required this.pageController,
 }) : super(key: key);

 @override
 Widget build(BuildContext context, WidgetRef ref) {
   final currentIndex = ref.watch(selectedTabProvider);

   return SizedBox( // âœ… Container â†’ SizedBox ë³€ê²½
     height: 40,
     child: Row(
       mainAxisSize: MainAxisSize.min,
       children: pages.asMap().entries.map((entry) {
         final index = entry.key;
         final page = entry.value;
         final isSelected = index == currentIndex;
         
         return GestureDetector(
           onTap: () {
             if (ref.read(appSettingsProvider).isHapticEnabled) {
               HapticFeedback.lightImpact(); // ğŸ¯ ê°„ë‹¨ ë²„ì „ì—ë„ í–…í‹± ì¶”ê°€!
             }
             
             ref.read(selectedTabProvider.notifier).state = index;
             pageController.animateToPage(
               index,
               duration: const Duration(milliseconds: 300),
               curve: Curves.easeInOut,
             );
           },
           child: Container(
             margin: const EdgeInsets.symmetric(horizontal: 4),
             padding: const EdgeInsets.all(8),
             child: Container(
               width: 32,
               height: 32,
               decoration: BoxDecoration(
                 shape: BoxShape.circle,
                 color: isSelected 
                   ? Colors.orange.withValues(alpha: 0.1)
                   : Colors.transparent,
                 border: isSelected 
                   ? Border.all(color: Colors.orange.withValues(alpha: 0.3), width: 1)
                   : null,
               ),
               child: Icon(
                 page.icon,
                 size: isSelected ? 20 : 16,
                 color: isSelected ? Colors.orange : Colors.grey.shade400,
               ),
             ),
           ),
         );
       }).toList(),
     ),
   );
 }
}\n\n// ====== lib/shared/widgets/coin_logo_provider.dart ======\n
// lib/shared/widgets/coin_logo_provider.dart
// ğŸš€ ìºì‹œ ì‹œìŠ¤í…œì´ ì ìš©ëœ ì½”ì¸ ë¡œê³  í”„ë¡œë°”ì´ë”

import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';

/// ğŸ¨ ì—…ë¹„íŠ¸ KRW ë§ˆì¼“ â†’ CoinPaprika ID ë§¤í•‘ í…Œì´ë¸”
/// ì‹¤ì œ ì—…ë¹„íŠ¸ KRW ë§ˆì¼“ì˜ ëª¨ë“  ì½”ì¸ë“¤ ì™„ì „ ë§¤ì¹­ (2024ë…„ ê¸°ì¤€ ~250ê°œ)
class CoinLogoProvider {
  
  /// ğŸ†• ë©”ëª¨ë¦¬ ìºì‹œ (ìœ„ì ¯ ë ˆë²¨ ìºì‹±)
  static final Map<String, Widget> _widgetCache = {};
  
  /// ğŸ†• ìºì‹œ ì„¤ì •
  static const int _maxCacheObjects = 500; // ìµœëŒ€ 500ê°œ ì´ë¯¸ì§€ ìºì‹œ
  
  /// ì½”ì¸ ë¡œê³  URL ê°€ì ¸ì˜¤ê¸° (64x64 ì¸ë„¤ì¼)
  static String? getCoinLogoUrl(String ticker) {
    final paprikaId = _getCoinPaprikaId(ticker);
    if (paprikaId == null) return null;
    
    return 'https://coinpaprika.com/coin/$paprikaId/logo.png';
  }

  /// ì½”ì¸ ë¡œê³  URL ê°€ì ¸ì˜¤ê¸° (200x200 ì‘ì€ ì´ë¯¸ì§€)
  static String? getCoinLogoUrlSmall(String ticker) {
    // CoinPaprikaëŠ” ë™ì¼í•œ URL ì‚¬ìš© (ìë™ ë¦¬ì‚¬ì´ì¦ˆ)
    return getCoinLogoUrl(ticker);
  }

  /// ğŸš€ ìºì‹œëœ ì½”ì¸ ë¡œê³  ìœ„ì ¯ ìƒì„± (ë©”ì¸ í•¨ìˆ˜)
  static Widget buildCoinLogo({
    required String ticker,
    double radius = 16,
    Color? fallbackColor,
    Color? fallbackTextColor,
  }) {
    final cacheKey = '${ticker.toUpperCase()}_${radius}_${fallbackColor.hashCode}_${fallbackTextColor.hashCode}';
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
    if (_widgetCache.containsKey(cacheKey)) {
      return _widgetCache[cacheKey]!;
    }
    
    final logoUrl = getCoinLogoUrl(ticker);
    
    Widget logoWidget;
    
    if (logoUrl != null) {
      logoWidget = _buildCachedNetworkImage(
        ticker: ticker,
        logoUrl: logoUrl,
        radius: radius,
        fallbackColor: fallbackColor,
        fallbackTextColor: fallbackTextColor,
      );
    } else {
      logoWidget = _buildFallbackAvatar(ticker, radius, fallbackColor, fallbackTextColor);
    }
    
    // ğŸ¯ ë©”ëª¨ë¦¬ ìºì‹œì— ì €ì¥ (ìš©ëŸ‰ ì œí•œ)
    if (_widgetCache.length < _maxCacheObjects) {
      _widgetCache[cacheKey] = logoWidget;
    }
    
    return logoWidget;
  }

  /// ğŸš€ cached_network_imageë¥¼ ì‚¬ìš©í•œ ë„¤íŠ¸ì›Œí¬ ì´ë¯¸ì§€ ë¡œë”©
  static Widget _buildCachedNetworkImage({
    required String ticker,
    required String logoUrl,
    required double radius,
    Color? fallbackColor,
    Color? fallbackTextColor,
  }) {
    return CircleAvatar(
      radius: radius,
      backgroundColor: Colors.grey.shade200,
      child: ClipOval(
        child: CachedNetworkImage(
          imageUrl: logoUrl,
          width: radius * 2,
          height: radius * 2,
          fit: BoxFit.cover,
          
          // ğŸ¯ ìºì‹œ ì„¤ì • (ê¸°ë³¸ ìºì‹œ ë§¤ë‹ˆì € ì‚¬ìš©)
          // cacheManager: DefaultCacheManager(), // í•„ìš”ì‹œ ì»¤ìŠ¤í…€ ë§¤ë‹ˆì € ì„¤ì •
          
          // ğŸ¯ ë¡œë”© ì¤‘ ìœ„ì ¯
          placeholder: (context, url) => Container(
            width: radius * 2,
            height: radius * 2,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.grey.shade100,
            ),
            child: Center(
              child: SizedBox(
                width: radius * 0.6,
                height: radius * 0.6,
                child: CircularProgressIndicator(
                  strokeWidth: 1.5,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.grey.shade400,
                  ),
                ),
              ),
            ),
          ),
          
          // ğŸ¯ ì—ëŸ¬ ì‹œ fallback
          errorWidget: (context, url, error) {
            return _buildFallbackAvatar(ticker, radius, fallbackColor, fallbackTextColor);
          },
          
          // ğŸ¯ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ
          imageBuilder: (context, imageProvider) {
            return Container(
              width: radius * 2,
              height: radius * 2,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                image: DecorationImage(
                  image: imageProvider,
                  fit: BoxFit.cover,
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  /// ğŸ§¹ ìºì‹œ ì •ë¦¬ í•¨ìˆ˜ë“¤
  static void clearMemoryCache() {
    _widgetCache.clear();
  }
  
  static void clearSpecificCache(String ticker) {
    _widgetCache.removeWhere((key, value) => key.startsWith(ticker.toUpperCase()));
  }
  
  static Future<void> clearNetworkCache() async {
    // cached_network_imageì˜ ìºì‹œ ì •ë¦¬
    // await DefaultCacheManager().emptyCache();
  }
  
  static int getMemoryCacheSize() {
    return _widgetCache.length;
  }

  /// CoinPaprika ID ë§¤í•‘ (ì—…ë¹„íŠ¸ KRW ë§ˆì¼“ ì „ì²´ ì»¤ë²„ - 665ì¤„ ë²„ì „ ê¸°ë°˜)
  static String? _getCoinPaprikaId(String ticker) {
    const paprikaMappings = {
      // === ë©”ì´ì € ì½”ì¸ë“¤ ===
      'BTC': 'btc-bitcoin',
      'ETH': 'eth-ethereum',
      'XRP': 'xrp-xrp',
      'ADA': 'ada-cardano',
      'SOL': 'sol-solana',
      'DOT': 'dot-polkadot',
      'AVAX': 'avax-avalanche',
      'MATIC': 'matic-polygon',
      'POL': 'pol-polygon-ecosystem-token',
      'NEAR': 'near-near-protocol',
      'ATOM': 'atom-cosmos',
      'LINK': 'link-chainlink',
      'UNI': 'uni-uniswap',
      'ALGO': 'algo-algorand',
      'VET': 'vet-vechain',
      'SAND': 'sand-the-sandbox',
      'MANA': 'mana-decentraland',
      'AXS': 'axs-axie-infinity',
      'THETA': 'theta-theta-token',
      'FIL': 'fil-filecoin',
      'AAVE': 'aave-aave',
      'DOGE': 'doge-dogecoin',
      'SHIB': 'shib-shiba-inu',
      'PEPE': 'pepe-pepe',
      
      // === ë¹„íŠ¸ì½”ì¸ ê³„ì—´ ===
      'BCH': 'bch-bitcoin-cash',
      'BSV': 'bsv-bitcoin-sv',
      'BTT': 'btt-bittorrent',
      '1000SATS': 'sats-1000sats',
      'ORDI': 'ordi-ordinals',
      
      // === ì´ë”ë¦¬ì›€ ìƒíƒœê³„ ===
      'ETC': 'etc-ethereum-classic',
      'ENS': 'ens-ethereum-name-service',
      'LPT': 'lpt-livepeer',
      'COMP': 'comp-compound',
      'MKR': 'mkr-maker',
      'YFI': 'yfi-yearn-finance',
      'SUSHI': 'sushi-sushiswap',
      'BAL': 'bal-balancer',
      '1INCH': '1inch-1inch',
      'LRC': 'lrc-loopring',
      'ZRX': 'zrx-0x',
      'BAT': 'bat-basic-attention-token',
      'ENJ': 'enj-enjincoin',
      'CRV': 'crv-curve-dao-token',
      'SNX': 'snx-synthetix-network-token',
      'MASK': 'mask-mask-network',
      'BLUR': 'blur-blur',
      'GRT': 'grt-the-graph',
      
      // === ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸ë“¤ ===
      'EGLD': 'egld-elrond',
      'INJ': 'inj-injective-protocol',
      'APT': 'apt-aptos',
      'SUI': 'sui-sui',
      'ARB': 'arb-arbitrum',
      'OP': 'op-optimism',
      'STX': 'stx-stacks',
      'TIA': 'tia-celestia',
      'SEI': 'sei-sei',
      'PYTH': 'pyth-pyth-network',
      'JTO': 'jto-jito',
      'JUP': 'jup-jupiter',
      'TNSR': 'tnsr-tensor',
      'W': 'w-wormhole',
      'ENA': 'ena-ethena',
      'OMNI': 'omni-omni-network',
      'REZ': 'rez-renzo',
      'BB': 'bb-bouncbit',
      'NOT': 'not-notcoin',
      'IO': 'io-io-net',
      'ZK': 'zk-zksync',
      'LISTA': 'lista-lista-dao',
      'ZRO': 'zro-layerzero',
      'G': 'g-gravity',
      'BANANA': 'banana-banana-gun',
      'RENDER': 'rndr-render-token',
      'TON': 'ton-the-open-network',
      'NEO': 'neo-neo',
      'GAS': 'gas-gas',
      'ONT': 'ont-ontology',
      'ONG': 'ong-ontology-gas',
      'QTUM': 'qtum-qtum',
      'WAVES': 'waves-waves',
      'LSK': 'lsk-lisk',
      'STRAX': 'strax-stratis',
      'ARK': 'ark-ark',
      'STORJ': 'storj-storj',
      'SC': 'sc-siacoin',
      'ARDR': 'ardr-ardor',
      'KMD': 'kmd-komodo',
      'ZEC': 'zec-zcash',
      'DASH': 'dash-dash',
      'XMR': 'xmr-monero',
      'ICX': 'icx-icon',
      'ZIL': 'zil-zilliqa',
      'IOTA': 'miota-iota',
      'XTZ': 'xtz-tezos',
      'CELO': 'celo-celo',
      'FLOW': 'flow-flow',
      'MINA': 'mina-mina-protocol',
      'HBAR': 'hbar-hedera-hashgraph',
      'CKB': 'ckb-nervos-network',
      'BEAM': 'beam-beam',
      'ZETA': 'zeta-zetachain',
      'TAIKO': 'taiko-taiko',
      'AERGO': 'aergo-aergo',
      
      // === ì•ŒíŠ¸ì½”ì¸ë“¤ ===
      'LTC': 'ltc-litecoin',
      'A': 'a-vaulta', // VAULTA (ë³¼íƒ€)
      'TRX': 'trx-tron',
      'XLM': 'xlm-stellar',
      'STEEM': 'steem-steem',
      'IOST': 'iost-iost',
      'MTL': 'mtl-metal',
      'GRS': 'grs-groestlcoin',
      'POWR': 'powr-power-ledger',
      'XEM': 'xem-nem',
      'XEC': 'xec-ecash',
      'VTHO': 'vtho-vethor-token',
      'TFUEL': 'tfuel-theta-fuel',
      'HIVE': 'hive-hive',
      'CVC': 'cvc-civic',
      'SNT': 'snt-status',
      'SXP': 'sxp-swipe',
      'T': 't-threshold-network',
      'PUNDIX': 'pundix-pundi-x',
      
      // === DeFi í† í°ë“¤ ===
      'CAKE': 'cake-pancakeswap',
      'RUNE': 'rune-thorchain',
      'ALPHA': 'alpha-alpha-finance-lab',
      'DODO': 'dodo-dodo',
      'RAY': 'ray-raydium',
      'SRM': 'srm-serum',
      'KNC': 'knc-kyber-network-crystal',
      'ANKR': 'ankr-ankr',
      'CELR': 'celr-celer-network',
      'KAVA': 'kava-kava',
      'HARD': 'hard-kava-lend',
      'SWP': 'swp-kava-swap',
      'JST': 'jst-just',
      'SUN': 'sun-sun',
      'CRO': 'cro-cronos',
      'CHZ': 'chz-chiliz',
      'GLM': 'glm-golem',
      'AUCTION': 'auction-bounce',
      'PENDLE': 'pendle-pendle',
      'STG': 'stg-stargate-finance',
      'COW': 'cow-cow-protocol',
      'OM': 'om-mantra-dao',
      'ONDO': 'ondo-ondo',
      'SAFE': 'safe-safe',
      
      // === ìŠ¤í…Œì´ë¸”ì½”ì¸ ===
      'USDT': 'usdt-tether',
      'USDC': 'usdc-usd-coin',
      'BUSD': 'busd-binance-usd',
      'DAI': 'dai-dai',
      'TUSD': 'tusd-trueusd',
      'USDD': 'usdd-usdd',
      
      // === ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤ ===
      'GALA': 'gala-gala',
      'APE': 'ape-apecoin',
      'GMT': 'gmt-stepn',
      'GST': 'gst-green-satoshi-token',
      'LOOKS': 'looks-looksrare',
      'PLA': 'pla-playdapp',
      'WAXP': 'waxp-wax',
      'TLM': 'tlm-alien-worlds',
      'SLP': 'slp-smooth-love-potion',
      'IMX': 'imx-immutable-x',
      'BIGTIME': 'bigtime-big-time',
      'GAME2': 'game-gamebuild',
      'AGLD': 'agld-adventure-gold',
      'YGG': 'ygg-yield-guild-games',
      'ME': 'me-magic-eden',
      'VIRTUAL': 'virtual-virtual-protocol',
      'MOCA': 'moca-moca',
      'PENGU': 'pengu-pudgy-penguins',
      'MEW': 'mew-cat-in-a-dogs-world',
      'ANIME': 'anime-animecoin',
      'FLOKI': 'floki-floki',
      'BONK': 'bonk-bonk',
      'WIF': 'wif-dogwifcoin',
      'BOME': 'bome-book-of-meme',
      
      // === í•œêµ­ í”„ë¡œì íŠ¸ë“¤ ===
      'KLAY': 'klay-klaytn',
      'BORA': 'bora-bora',
      'META': 'meta-metadium',
      'WEMIX': 'wemix-wemix-token',
      'MBL': 'mbl-moviebloc',
      'HUNT': 'hunt-hunt',
      'TEMCO': 'temco-temco',
      'SOLVE': 'solve-solve-care',
      'PROM': 'prom-prometeus',
      'ORBS': 'orbs-orbs',
      'MIX': 'mix-mixmarvel',
      'CENNZ': 'cennz-centrality',
      'STPT': 'stpt-standard-tokenization-protocol',
      'MDT': 'mdt-measurable-data-token',
      'LAMB': 'lamb-lambda',
      'COTI': 'coti-coti',
      'WTC': 'wtc-waltonchain',
      'NPXS': 'npxs-pundi-x',
      'APIS': 'apis-apis',
      'DAC': 'dac-davinci-coin',
      'ELF': 'elf-aelf',
      'KARMA': 'karma-karma-dao',
      'MEET': 'meet-coinmeet',
      'QKC': 'qkc-quarkchain',
      'SSX': 'ssx-somesing',
      'UPP': 'upp-sentinel-protocol',
      'TOKAMAK': 'ton-tokamak-network',
      'MLK': 'mlk-milk-alliance',
      'DKA': 'dka-dkargo',
      'CBK': 'cbk-cobak-token',
      'MOC': 'moc-mossland',
      'HP': 'hp-hippo-protocol',
      'BOUNTY': 'bnty-bounty0x',
      'MED': 'med-medibloc',
      'MVL': 'mvl-mass-vehicle-ledger',
      'ASTR': 'astr-astar',
      'TT': 'tt-thunder-token',
      'MNT': 'mnt-mantle',
      'FCT2': 'fct-factom',
      'IQ': 'iq-everipedia',
      'AHT': 'aht-ahatoken',
      'AWE': 'awe-awe-network',
      'ATH': 'ath-aethir',
      'SOPH': 'soph-sophon',
      'SIGN': 'sign-sign',
      
      // === ì†”ë¼ë‚˜ ìƒíƒœê³„ ===
      'ORCA': 'orca-orca',
      'DRIFT': 'drift-drift-protocol',
      'SONIC': 's-sonic',
      'LAYER': 'layer-solayer',
      'DEEP': 'deep-deepbook-protocol',
      'MOVE': 'move-movement',
      
      // === AI/ê¸°ìˆ  í† í°ë“¤ ===
      'ARKM': 'arkm-arkham',
      'KAITO': 'kaito-kaito',
      'NXPC': 'nxpc-nexpace',
      'WCT': 'wct-walletconnect-token',
      'AKT': 'akt-akash-network',
      'AQT': 'aqt-alpha-quark-token',
      'CARV': 'carv-carv',
      'UXLINK': 'uxlink-uxlink',
      'WAL': 'wal-walrus',
      'CTC': 'ctc-creditcoin',
      'POLYX': 'polyx-polymesh',
      'ID': 'id-space-id',
      'VANA': 'vana-vana',
      'STRIKE': 'strike-strike',
      'BERA': 'bera-berachain',
      'TRUMP': 'trump-maga',
      'POKT': 'pokt-pocket-network',
      'STMX': 'stmx-stormx',
      'BLAST': 'blast-blast',
      
      // === ì‹ ê·œ ìƒì¥ ì½”ì¸ë“¤ ===
      'RVN': 'rvn-ravencoin',
      'AXL': 'axl-axelar',
      'ALT': 'alt-altlayer',
    };
    
    return paprikaMappings[ticker.toUpperCase()];
  }

  /// Fallback ì•„ë°”íƒ€ ìƒì„± (ì²« ê¸€ì ë˜ëŠ” ê¸°ë³¸ ì•„ì´ì½˜)
  static Widget _buildFallbackAvatar(
    String ticker, 
    double radius, 
    Color? fallbackColor, 
    Color? fallbackTextColor,
  ) {
    return CircleAvatar(
      radius: radius,
      backgroundColor: fallbackColor ?? Colors.grey.shade300,
      child: Text(
        ticker.isNotEmpty ? ticker[0].toUpperCase() : '?',
        style: TextStyle(
          color: fallbackTextColor ?? Colors.grey.shade700,
          fontWeight: FontWeight.bold,
          fontSize: radius * 0.6,
        ),
      ),
    );
  }

  /// íŠ¹ì • í‹°ì»¤ê°€ ì§€ì›ë˜ëŠ”ì§€ í™•ì¸
  static bool isSupported(String ticker) => _getCoinPaprikaId(ticker.toUpperCase()) != null;
}\n\n// ====== lib/shared/widgets/sector_classification.dart ======\n
// lib/shared/widgets/sector_classification.dart

import 'package:flutter/foundation.dart';

/// ì„¹í„° ë¶„ë¥˜ ê´€ë¦¬ ì „ìš© Provider (ê³µìœ  ìœ„ì ¯ ë ˆì´ì–´)
/// ìƒì„¸(28ê°œ) vs ê¸°ë³¸(18ê°œ) ë¶„ë¥˜ í† ê¸€ ë° ë§¤í•‘ ë°ì´í„° ì œê³µ
class SectorClassificationProvider extends ChangeNotifier {
 // í˜„ì¬ ì„ íƒëœ ë¶„ë¥˜ íƒ€ì… (true: ìƒì„¸, false: ê¸°ë³¸)
 bool _isDetailedClassification = true;
 
 // ğŸš€ ìºì‹œ ì‹œìŠ¤í…œ ì¶”ê°€
 Map<String, List<String>>? _cachedCurrentSectors;
 Map<String, List<String>>? _cachedCoinToSectorsMap;
 
 bool get isDetailedClassification => _isDetailedClassification;
 
 /// ë¶„ë¥˜ íƒ€ì… í† ê¸€
 void toggleClassificationType() {
   // ğŸš€ ìºì‹œ ë¬´íš¨í™”
   _cachedCurrentSectors = null;
   _cachedCoinToSectorsMap = null;
   
   _isDetailedClassification = !_isDetailedClassification;
   notifyListeners();
 }
 
 /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„°ë³„ ì½”ì¸ ë§¤í•‘ (28ê°œ ì„¹í„°)
 static const Map<String, List<String>> _detailedSectors = {
   // ==================== ê¸°ë³¸ ê·¸ë£¹ ====================
   'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': ['BTC', 'BCH', 'BSV', 'XEC'],
   'ì´ë”ë¦¬ì›€ ê·¸ë£¹': ['ETH', 'ETC'],
   'ìŠ¤í…Œì´í‚¹': ['ETH', 'SOL', 'ADA', 'POL', 'ATOM'],

   // ==================== ë¸”ë¡ì²´ì¸ ì•„í‚¤í…ì²˜ ====================
   'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': [
     'SOL', 'ADA', 'TRX', 'SUI', 'AVAX', 'NEAR', 'CRO', 'APT', 'ETC', 'VET',
     'ATOM', 'ALGO', 'INJ', 'A', 'SEI', 'IOTA', 'XTZ', 'FLOW', 'KAVA', 'EGLD',
     'NEO', 'MINA', 'BERA', 'ZIL', 'QTUM', 'ASTR', 'GAS', 'VTHO', 'VANA', 'ELF',
     'WAVES', 'ICX', 'ONT', 'HIVE', 'SXP', 'POWR', 'ARDR', 'XEM', 'IOST', 'ONG',
     'GLMR', 'ARK', 'AERGO', 'QKC', 'META', 'TT', 'FCT2'
   ],
   'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': [
     'ETH', 'DOT', 'MNT', 'POL', 'ARB', 'STX', 'SONIC', 'MOVE', 'CKB', 'CELO',
     'LSK', 'BLAST', 'TAIKO', 'MTL', 'TOKAMAK'
   ],

   // ==================== ìŠ¤í…Œì´ë¸”ì½”ì¸ ìƒíƒœê³„ ====================
   'ìŠ¤í…Œì´ë¸” ì½”ì¸': ['USDT', 'USDC'],

   // ==================== DeFi ìƒíƒœê³„ ====================
   'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': [
     'UNI', 'JUP', 'DEEP', '1INCH', 'ZRX', 'ORCA', 'COW', 'ORBS', 'AUCTION', 'KNC'
   ],
   'ëœë”©': ['AAVE', 'COMP', 'STRIKE'],
   'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': ['PENDLE', 'JTO', 'LAYER'],
   'RWA': ['ONDO', 'CTC'],

   // ==================== ì¸í”„ë¼ & ê¸°ìˆ  ====================
   'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': ['BTC', 'XRP', 'BCH', 'XLM', 'BSV', 'XEC', 'PUNDIX', 'GRS'],
   'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': ['ZRO', 'W', 'T', 'ZETA', 'STG'],
   'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': ['HBAR', 'POLYX', 'STRAX'],
   'ì˜¤ë¼í´': ['LINK', 'PYTH'],
   'ë°ì´í„° ì¸í”„ë¼': ['GRT', 'KAITO', 'ANKR', 'ARKM', 'MVL', 'CARV'],
   'ìŠ¤í† ë¦¬ì§€': ['FIL', 'THETA', 'BTT', 'WAL', 'AKT', 'LPT', 'GLM', 'TFUEL', 'SC', 'STORJ'],
   'AI': ['VIRTUAL', 'RENDER', 'ATH'],

   // ==================== ì—”í„°í…Œì¸ë¨¼íŠ¸ & ê²Œì„ ====================
   'ë©”íƒ€ë²„ìŠ¤': ['SAND', 'MANA', 'MOCA', 'MOC'],
   'NFT/ê²Œì„': [
     'IMX', 'AXS', 'BEAM', 'BLUR', 'ENJ', 'GMT', 'ANIME', 'ME', 'BORA',
     'BIGTIME', 'WAXP', 'AGLD', 'GAME2', 'AQT'
   ],

   // ==================== ë¯¸ë””ì–´ & ì½˜í…ì¸  ====================
   'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': ['MBL'],
   'ê´‘ê³ ': ['BAT', 'MLK', 'STMX'],
   'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': ['IQ', 'AHT'],

   // ==================== ì†Œì…œ & ì»¤ë®¤ë‹ˆí‹° ====================
   'ì†Œì…œ/DAO': ['G', 'UXLINK', 'STEEM', 'CBK'],
   'íŒ¬í† í°': ['CHZ'],
   'ë°ˆ': ['DOGE', 'SHIB', 'PEPE', 'TRUMP', 'BONK', 'MEW'],

   // ==================== íŠ¹ìˆ˜ ìš©ë„ ====================
   'DID': ['ENS', 'ID', 'CVC'],
   'ì˜ë£Œ': ['MED'],
   'ì›”ë ›/ë©”ì„¸ì§•': ['SAFE', 'MASK', 'WCT', 'SNT'],
 };

 /// ê¸°ë³¸ ë¶„ë¥˜ (18ê°œ ì„¹í„°) - ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
 static const Map<String, List<String>> _basicSectors = {
   'ë©”ì´ì € ì½”ì¸': [
     'BTC', 'ETH', 'XRP', 'ADA', 'SOL', 'DOT', 'AVAX', 'MATIC', 'POL', 'NEAR',
     'ATOM', 'LINK', 'UNI', 'ALGO', 'VET', 'SAND', 'MANA', 'AXS', 'THETA',
     'FIL', 'AAVE', 'DOGE', 'SHIB', 'PEPE'
   ],
   'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': [
     'BTC', 'BCH', 'BSV', 'BTT', '1000SATS', 'ORDI'
   ],
   'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': [
     'ETH', 'ETC', 'ENS', 'LPT', 'COMP', 'MKR', 'YFI', 'SUSHI', 'BAL',
     '1INCH', 'LRC', 'ZRX', 'BAT', 'ENJ', 'CRV', 'SNX', 'MASK', 'BLUR', 'GRT'
   ],
   'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': [
     'EGLD', 'INJ', 'APT', 'SUI', 'ARB', 'OP', 'STX', 'TIA', 'SEI', 'PYTH',
     'JTO', 'JUP', 'TNSR', 'W', 'ENA', 'OMNI', 'REZ', 'BB', 'NOT', 'IO',
     'ZK', 'LISTA', 'ZRO', 'G', 'BANANA', 'RENDER', 'TON', 'NEO', 'GAS',
     'ONT', 'ONG', 'QTUM', 'WAVES', 'LSK', 'STRAX', 'ARK', 'STORJ', 'SC',
     'ARDR', 'KMD', 'ZEC', 'DASH', 'XMR', 'ICX', 'ZIL', 'IOTA', 'XTZ',
     'CELO', 'FLOW', 'MINA', 'HBAR', 'CKB', 'BEAM', 'ZETA', 'TAIKO', 'AERGO'
   ],
   
   // ğŸ†• ì‹œì´ë³„ ë¶„ë¥˜ (í™˜ìœ¨ 1,400ì› ì ìš© ê¸°ì¤€)
   'ê³  ì‹œì´': [
     'BTC', 'ETH', 'XRP', 'SOL', 'DOGE', 'AVAX', 'TRUMP'
   ],
   'ì¤‘ ì‹œì´': [
     'SUI', 'APT', 'NEAR', 'UNI', 'LINK', 'AAVE', 'INJ', 'STX', 'AXS', 'FIL',
     'ATOM', 'DOT', 'PENDLE', 'RENDER', 'GAS', 'ORCA', 'BERA', 'ZRO', 'TIA',
     'MASK', 'VIRTUAL', 'KAITO', 'QTUM', 'JTO', 'OM', 'ONDO', 'ME', 'LAYER',
     'AGLD', 'THETA', 'MTL', 'MNT', 'ADA', 'TAIKO',      'VAULTA', 'DRIFT', 'CTC',
     'XTZ', 'IMX', 'ARKM', 'SAFE', 'JUP', 'WAL', 'LSK', 'KAVA', 'COW',
     'UXLINK', 'ARK', 'FLOW', 'CARV', 'ARB', 'CELO', 'PUNDIX', 'KNC',
     'MANA', 'TRX', 'SAND', 'STORJ', 'XLM', 'HUNT', 'SONIC', 'GLM', 'ZRX',
     'HIVE', 'ZETA', 'MINA', 'POL', '1INCH', 'ALGO', 'SEI', 'STG', 'IOTA',
     'ID', 'SXP', 'HBAR', 'POWR', 'DEEP', 'MOVE', 'POLYX', 'STEEM', 'ONT',
     'BAT', 'CVC', 'AERGO', 'ICX', 'PYTH', 'CRO', 'GRT', 'BLUR', 'ARDR',
     'BORA', 'W', 'MOCA', 'BIGTIME', 'GMT', 'STRAX', 'CHZ', 'SNT', 'TFUEL',
     'JST', 'VET', 'ANIME', 'WAXP', 'ORBS', 'ANKR', 'T', 'G', 'ZIL', 'PENGU',
     'XEM', 'BEAM', 'CKB', 'IQ', 'AHT', 'IOST'
   ],
   'ì € ì‹œì´': [
     'GAME2', 'MVL', 'SC', 'MEW', 'BLAST', 'STMX', 'TT', 'MBL', 'VTHO', 'XEC',
     'BONK', 'SHIB', 'PEPE', 'BTT', 'CBK', 'MLK', 'POKT', 'SIGN', 'MOC',
     'SOPH', 'AWE', 'ATH', 'BOUNTY', 'HP', 'FCT2', 'ASTR', 'META', 'DKA',
     'QKC', 'MED'
   ],
   
   // ğŸ†• ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸ (ê¸°ì¡´ ì•ŒíŠ¸ì½”ì¸ ë³µì›)
   'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': [
     'LTC', 'A', 'TRX', 'XLM', 'STEEM', 'IOST', 'MTL', 'GRS', 'POWR',
     'XEM', 'XEC', 'VTHO', 'TFUEL', 'HIVE', 'CVC', 'SNT', 'SXP', 'T', 'PUNDIX'
   ],
   
   'DeFi í† í°': [
     'CAKE', 'RUNE', 'ALPHA', 'DODO', 'RAY', 'SRM', 'KNC', 'ANKR', 'CELR',
     'KAVA', 'HARD', 'SWP', 'JST', 'SUN', 'CRO', 'CHZ', 'GLM', 'AUCTION',
     'PENDLE', 'STG', 'COW', 'OM', 'ONDO', 'SAFE'
   ],
   'ìŠ¤í…Œì´ë¸”ì½”ì¸': [
     'USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDD'
   ],
   'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': [
     'GALA', 'APE', 'GMT', 'GST', 'LOOKS', 'PLA', 'WAXP', 'TLM', 'SLP',
     'IMX', 'BIGTIME', 'GAME2', 'AGLD', 'YGG', 'ME', 'VIRTUAL', 'MOCA',
     'PENGU', 'MEW', 'ANIME', 'FLOKI', 'BONK', 'WIF', 'BOME'
   ],
   'í•œêµ­ í”„ë¡œì íŠ¸': [
     'KLAY', 'BORA', 'META', 'WEMIX', 'MBL', 'HUNT', 'TEMCO', 'SOLVE',
     'PROM', 'ORBS', 'MIX', 'CENNZ', 'STPT', 'MDT', 'LAMB', 'COTI',
     'WTC', 'NPXS', 'APIS', 'DAC', 'ELF', 'KARMA', 'MEET', 'QKC',
     'SSX', 'UPP', 'TOKAMAK', 'MLK', 'DKA', 'CBK', 'MOC', 'HP',
     'BOUNTY', 'MED', 'MVL', 'ASTR', 'TT', 'MNT', 'FCT2', 'IQ',
     'AHT', 'AWE', 'ATH', 'SOPH', 'SIGN'
   ],
   'ì†”ë¼ë‚˜ ìƒíƒœê³„': [
     'SOL', 'ORCA', 'DRIFT', 'SONIC', 'LAYER', 'DEEP', 'MOVE'
   ],
   'AI/ê¸°ìˆ  í† í°': [
     'ARKM', 'KAITO', 'NXPC', 'WCT', 'AKT', 'AQT', 'CARV', 'UXLINK',
     'WAL', 'CTC', 'POLYX', 'ID', 'VANA', 'STRIKE', 'BERA', 'TRUMP',
     'POKT', 'STMX', 'BLAST'
   ],

   // ğŸ†• ì‹ ê·œìƒì¥ ì„¹í„° 4ê°œ ì¶”ê°€
   '2023ë…„ ì‹ ê·œìƒì¥': [
     'SHIB', 'MASK', 'EGLD', 'SUI', 'GRT', 'BLUR', 'IMX', 'SEI', 'MINA', 'CTC', 'ASTR'
   ],
   '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
     'ID', 'PYTH', 'MNT', 'BIGTIME', 'AKT', 'ZETA', 'STG', 'BEAM', 'TAIKO', 'ONDO', 'ZRO', 'BLAST'
   ],
   '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': [
     'JUP', 'ENS', 'GAL', 'PENDLE', 'ATH', 'UXLINK', 'CKB', 'W', 'CARV', 'INJ', 'MEW', 'UNI', 
     'SAFE', 'DRIFT', 'AGLD', 'PEPE', 'BONK', 'RENDER', 'MOVE', 'ME', 'MOCA', 'VANA'
   ],
   '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': [
     'SONIC', 'VTHO', 'ANIME', 'VIRTUAL', 'BERA', 'LAYER', 'TRUMP', 'JTO', 'COW', 'KAITO', 
     'ARKM', 'ORCA', 'WAL', 'COMP', 'FIL', 'WCT', 'DEEP', 'SIGN', 'TIA', 'PENGU', 
     'NXPC', 'OM', 'SOPH', 'LPT', 'POKT', 'RVN', 'AXL', 'ALT', 'RAY'
   ],
 };

 /// ğŸš€ ìºì‹œëœ í˜„ì¬ í™œì„±í™”ëœ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get currentSectors {
   _cachedCurrentSectors ??= _isDetailedClassification ? _detailedSectors : _basicSectors;
   return _cachedCurrentSectors!;
 }

 /// ğŸš€ ìºì‹œëœ ì½”ì¸â†’ì„¹í„° ì—­ìƒ‰ì¸ ë§µ ë°˜í™˜ (O(1) ì¡°íšŒìš©)
 Map<String, List<String>> get coinToSectorsMap {
   if (_cachedCoinToSectorsMap == null) {
     _cachedCoinToSectorsMap = <String, List<String>>{};
     currentSectors.forEach((sector, coins) {
       for (final coin in coins) {
         _cachedCoinToSectorsMap!.putIfAbsent(coin, () => []).add(sector);
       }
     });
     
     if (kDebugMode) {
       debugPrint('ğŸš€ SectorClassification: coinToSectorsMap built with ${_cachedCoinToSectorsMap!.length} coins');
     }
   }
   return _cachedCoinToSectorsMap!;
 }

 /// ìƒì„¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get detailedSectors => _detailedSectors;

 /// ê¸°ë³¸ ë¶„ë¥˜ ì„¹í„° ë§¤í•‘ ë°˜í™˜
 Map<String, List<String>> get basicSectors => _basicSectors;

 /// ì„¹í„° ëª©ë¡ ë°˜í™˜
 List<String> get sectorNames => currentSectors.keys.toList();

 /// íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ë°˜í™˜
 List<String> getCoinsInSector(String sectorName) {
   return currentSectors[sectorName] ?? [];
 }

 /// ğŸš€ ìµœì í™”ëœ íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ë°˜í™˜ (O(1) ì¡°íšŒ)
 List<String> getSectorsForCoin(String ticker) {
   return coinToSectorsMap[ticker.toUpperCase()] ?? [];
 }

 /// í˜„ì¬ ë¶„ë¥˜ íƒ€ì… ë¬¸ìì—´ ë°˜í™˜
 String get currentClassificationName {
   return _isDetailedClassification ? 'ìƒì„¸' : 'ê¸°ë³¸';
 }

 /// ì„¹í„°ë³„ í†µê³„ ì •ë³´
 Map<String, int> get sectorSizes {
   return currentSectors.map((sector, coins) => 
       MapEntry(sector, coins.length));
 }

 /// ì „ì²´ ê³ ìœ  ì½”ì¸ ê°œìˆ˜
 int get totalUniqueCoins {
   return currentSectors.values
       .expand((coins) => coins)
       .toSet()
       .length;
 }

 /// ì¤‘ë³µë„ê°€ ë†’ì€ ì½”ì¸ë“¤ (ì—¬ëŸ¬ ì„¹í„°ì— ì†í•œ ì½”ì¸ë“¤)
 Map<String, int> getCoinDuplicationCount() {
   Map<String, int> duplications = {};
   
   currentSectors.forEach((sector, coins) {
     for (String coin in coins) {
       duplications[coin] = (duplications[coin] ?? 0) + 1;
     }
   });
   
   return Map.fromEntries(
     duplications.entries.toList()
       ..sort((a, b) => b.value.compareTo(a.value))
   );
 }

 /// ğŸ”§ ë””ë²„ê¹…ìš©: ìºì‹œ ìƒíƒœ ì •ë³´
 Map<String, dynamic> get cacheStatus {
   return {
     'isDetailed': _isDetailedClassification,
     'currentSectorsCached': _cachedCurrentSectors != null,
     'coinToSectorsMapCached': _cachedCoinToSectorsMap != null,
     'totalSectors': currentSectors.length,
     'totalCoins': coinToSectorsMap.length,
     'averageCoinsPerSector': currentSectors.values.map((e) => e.length).reduce((a, b) => a + b) / currentSectors.length,
   };
 }
}\n\n// ====== lib/shared/widgets/websocket_modal.dart ======\n
// lib/shared/widgets/websocket_modal.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';

/// WebSocket ìƒì„¸ ì •ë³´ íŒì—… ì˜¤ë²„ë ˆì´
class WebSocketStatsOverlay {
  static OverlayEntry? _overlayEntry;

  /// ë¡±í”„ë ˆìŠ¤ ì‹œ íŒì—… í‘œì‹œ (Market Mood ë°©ì‹)
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
  }) {
    hide(); // ê¸°ì¡´ íŒì—… ì œê±°

    // Market Moodì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ìœ„ì¹˜ ë¯¸ë¦¬ ê³„ì‚°
    final adjustedPosition = _calculateModalPosition(context, position, statusIconSize);

    _overlayEntry = OverlayEntry(
      builder: (context) => _WebSocketStatsPopup(
        position: adjustedPosition,
        statusIconSize: statusIconSize,
        ref: ref,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// WebSocket ì „ìš© ìœ„ì¹˜ ê³„ì‚° (í•­ìƒ ì•„ë˜ìª½ì—ë§Œ í‘œì‹œ)
  static Offset _calculateModalPosition(BuildContext context, Offset globalPosition, double size) {
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = size * 4.2 * 2.5;
    const modalHeight = 200.0; // âœ… const ì¶”ê°€ (Line 38)
    
    // ì•„ì´ì½˜ ì¤‘ì•™ ê¸°ì¤€ìœ¼ë¡œ ëª¨ë‹¬ ì¤‘ì•™ ì •ë ¬ + ìš°ì¸¡ìœ¼ë¡œ ì´ë™
    double adjustedX = globalPosition.dx - (modalWidth / 2) + 150; // ğŸ”§ ìš°ì¸¡ìœ¼ë¡œ 50px ì´ë™
    double adjustedY = globalPosition.dy + size + 2; // ğŸ”§ í•­ìƒ ì•„ë˜ìª½ì—ë§Œ
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16;
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 0) {
      adjustedX = screenSize.width - modalWidth - 0;
    }
    
    // í•˜ë‹¨ ê²½ê³„ ì²´í¬ (í™”ë©´ ì•„ë˜ë¡œ ë²—ì–´ë‚˜ë©´ ìœ„ìª½ìœ¼ë¡œë§Œ)
    if (adjustedY + modalHeight > screenSize.height - 50) {
      adjustedY = globalPosition.dy - modalHeight - 8;
    }
    
    return Offset(adjustedX, adjustedY);
  }

  /// íŒì—… ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

class _WebSocketStatsPopup extends StatefulWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;

  const _WebSocketStatsPopup({
    required this.position,
    required this.statusIconSize,
    required this.ref,
  });

  @override
  State<_WebSocketStatsPopup> createState() => _WebSocketStatsPopupState();
}

class _WebSocketStatsPopupState extends State<_WebSocketStatsPopup>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.0, 0.5),
    ));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => WebSocketStatsOverlay.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½ (íƒ­í•˜ë©´ ë‹«í˜)
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ íŒì—… (Market Mood ë°©ì‹: ì´ë¯¸ ê³„ì‚°ëœ ìœ„ì¹˜ ì‚¬ìš©)
            AnimatedBuilder(
              animation: _controller,
              builder: (context, child) {
                return Positioned(
                  left: widget.position.dx,
                  top: widget.position.dy,
                  child: Transform.scale(
                    scale: _scaleAnimation.value,
                    alignment: Alignment.center,
                    child: Opacity(
                      opacity: _opacityAnimation.value,
                      child: _buildPopupContent(),
                    ),
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPopupContent() {
    // Market Moodì™€ ë™ì¼í•œ í¬ê¸° ê³„ì‚°
    final baseSize = widget.statusIconSize * 4.2;
    
    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: baseSize,
          maxWidth: baseSize * 2.5,
          minHeight: baseSize,
        ),
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.surface,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.08),
              blurRadius: 16,
              offset: const Offset(0, 6),
              spreadRadius: 2,
            ),
            BoxShadow(
              color: Colors.black.withValues(alpha: 0.04),
              blurRadius: 4,
              offset: const Offset(0, 2),
            ),
          ],
          border: Border.all(
            color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
            width: 0.8,
          ),
        ),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildStatsContent(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildStatsContent() {
    final stats = widget.ref.read(wsStatsProvider);
    
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // â° ì‹œê°„ ì •ë³´
        _buildSectionTitle('ì‹œê°„ ì •ë³´', Icons.access_time),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.link,
          label: 'í˜„ì¬ ì—°ê²°',
          value: stats.connectTime != null && stats.uptime != null
              ? _formatDuration(stats.uptime!)
              : 'ë¯¸ì—°ê²°',
          isHighlight: stats.connectTime != null,
        ),
        
        if (stats.lastStateChangeTime != null)
          _buildStatRow(
            icon: Icons.schedule,
            label: 'ë§ˆì§€ë§‰ ë³€ê²½',
            value: _formatTimeAgo(stats.lastStateChangeTime!),
          ),
        
        const SizedBox(height: 8),
        
        // ğŸ”„ ì—°ê²° í†µê³„
        _buildSectionTitle('ì—°ê²° í†µê³„', Icons.analytics),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.refresh,
          label: 'ì¬ì—°ê²°',
          value: '${stats.reconnectCount}íšŒ',
          isWarning: stats.reconnectCount > 5,
        ),
        
        _buildStatRow(
          icon: Icons.play_arrow,
          label: 'ì´ ì„¸ì…˜',
          value: '${stats.totalSessions}íšŒ',
        ),
        
        if (stats.connectionAttempts > 0)
          _buildStatRow(
            icon: Icons.trending_up,
            label: 'ì„±ê³µë¥ ',
            value: '${stats.connectionSuccessRate.toStringAsFixed(1)}%',
            isHighlight: stats.connectionSuccessRate > 90,
            isWarning: stats.connectionSuccessRate < 70,
          ),
        
        const SizedBox(height: 8),
        
        // ğŸ“± ì•± ìƒëª…ì£¼ê¸°
        _buildSectionTitle('ì•± ìƒëª…ì£¼ê¸°', Icons.timeline),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.hourglass_full,
          label: 'ëˆ„ì  ì‹œê°„',
          value: _formatDuration(stats.cumulativeConnectTime),
        ),
        
        if (stats.totalSessions > 0)
          _buildStatRow(
            icon: Icons.timer_outlined,
            label: 'í‰ê·  ì„¸ì…˜',
            value: _formatDuration(stats.averageSessionDuration),
          ),
      ],
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Flexible(
          child: Text(
            title,
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w700,
              color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
              letterSpacing: 0.3,
            ),
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Theme.of(context).colorScheme.primary;
      if (isWarning) return Theme.of(context).colorScheme.tertiary;
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight 
            ? Theme.of(context).colorScheme.primary.withValues(alpha: 0.08)
            : isWarning
            ? Theme.of(context).colorScheme.tertiary.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  String _formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    if (difference.inSeconds < 60) {
      return 'ë°©ê¸ˆ ì „';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}ë¶„ ì „';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}ì‹œê°„ ì „';
    } else {
      return '${difference.inDays}ì¼ ì „';
    }
  }

  String _formatDuration(Duration duration) {
    if (duration == Duration.zero) return 'ì—†ìŒ';
    
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    
    if (duration.inHours > 0) {
      final hours = twoDigits(duration.inHours);
      final minutes = twoDigits(duration.inMinutes.remainder(60));
      final seconds = twoDigits(duration.inSeconds.remainder(60));
      return '$hours:$minutes:$seconds';
    } else if (duration.inMinutes > 0) {
      final minutes = duration.inMinutes;
      final seconds = twoDigits(duration.inSeconds.remainder(60));
      return '$minutesë¶„ $secondsì´ˆ';
    } else {
      return '${duration.inSeconds}ì´ˆ';
    }
  }
}\n\n// ====== lib/main.dart ======\n
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ†• SystemChrome ì¶”ê°€
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'core/config/app_config.dart';
import 'core/services/hive_service.dart';
import 'core/bridge/signal_bus.dart';
import 'core/di/app_providers.dart';
import 'app.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 1) í™˜ê²½ ì„¤ì • (Hive ì œì™¸)
  await AppConfig.init(envPath: '.env');
  await Firebase.initializeApp();

  // 2) Hive ë‹¨ì¼ ì´ˆê¸°í™” ğŸ¯
  final hive = HiveService();
  await hive.init();

  // 3) SharedPreferences, SignalBus ì¤€ë¹„
  final prefs = await SharedPreferences.getInstance();
  final signalBus = SignalBus();

  // ğŸ†• 4) ì´ˆê¸° í™”ë©´ íšŒì „ ì„¤ì • ì ìš©
  await _applyInitialOrientationSettings(prefs);

  // 5) ProviderContainer ìƒì„± ë° ì˜¤ë²„ë¼ì´ë“œ
  final container = ProviderContainer(
    observers: [AppProviderObserver()],
    overrides: [
      hiveServiceProvider.overrideWithValue(hive), // ğŸ¯ NEW
      sharedPreferencesProvider.overrideWithValue(prefs),
      signalBusProvider.overrideWithValue(signalBus),
    ],
  );

  // 6) ì•± ì‹¤í–‰
  runApp(
    UncontrolledProviderScope(
      container: container,
      child: ProviderInitializer(
        child: MyApp(navigatorKey: GlobalKey<NavigatorState>()),
      ),
    ),
  );
}

/// ğŸ†• ì´ˆê¸° í™”ë©´ íšŒì „ ì„¤ì • ì ìš©
Future<void> _applyInitialOrientationSettings(SharedPreferences prefs) async {
  final isPortraitLocked = prefs.getBool('portraitLocked') ?? false;
  
  if (isPortraitLocked) {
    // ì„¸ë¡œ ëª¨ë“œë§Œ í—ˆìš©
    await SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.portraitDown,
    ]);
  } else {
    // ëª¨ë“  ë°©í–¥ í—ˆìš©
    await SystemChrome.setPreferredOrientations([
      DeviceOrientation.landscapeRight,
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.portraitUp,
      DeviceOrientation.portraitDown,
    ]);
  }
}\n\n// ====== lib/data/datasources/trade_cache_ds.dart ======\n
// lib/data/datasources/trade_cache_ds.dart

import 'package:hive/hive.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Hive ê¸°ë°˜ ê°„ë‹¨ ê±°ë˜ ìºì‹œ ë°ì´í„°ì†ŒìŠ¤
/// - HiveServiceì—ì„œ ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ì•„ ì‚¬ìš©
/// - Box ìƒëª…ì£¼ê¸° ê´€ë¦¬ëŠ” HiveServiceê°€ ë‹´ë‹¹
class TradeCacheDataSource {
  static const _maxCacheSize = 1000;

  /// ğŸ¯ ì£¼ì…ë°›ì€ Box (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  final Box<TradeDto> _box;
  
  /// ìƒì„±ì: ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ìŒ
  TradeCacheDataSource(this._box);

  /// Tradeë¥¼ DTOë¡œ ë³€í™˜í•´ ì €ì¥, ì‚¬ì´ì¦ˆ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª© ì œê±°
  Future<void> cacheTrade(Trade trade) async {
    final dto = TradeDto(
      market: trade.market,
      price: trade.price,
      volume: trade.volume,
      side: trade.side,
      changePrice: trade.changePrice,
      changeState: trade.changeState,
      timestampMs: trade.timestampMs,
      sequentialId: trade.sequentialId,
    );
    
    await _box.put(trade.sequentialId, dto);
    
    // ìµœëŒ€ ìºì‹œ ì‚¬ì´ì¦ˆ ê´€ë¦¬
    if (_box.length > _maxCacheSize) {
      final toRemove = _box.keys.take(_box.length - _maxCacheSize);
      await _box.deleteAll(toRemove);
    }
  }

  /// ìºì‹œëœ Trade ì „ë¶€ ë°˜í™˜
  List<Trade> getCachedTrades() =>
      _box.values.map((dto) => dto.toEntity()).toList();

  /// ìºì‹œ í´ë¦¬ì–´
  Future<void> clearCache() => _box.clear();

  // ğŸ—‘ï¸ Box lifecycle ê´€ë¦¬ ë©”ì„œë“œë“¤ ì œê±°:
  // - init() : HiveServiceê°€ ë‹´ë‹¹
  // - dispose() : HiveServiceê°€ ë‹´ë‹¹
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Fetches a live trade stream; on error falls back to synthetic data.
/// ğŸ†• ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì§€ì›ìœ¼ë¡œ ì—¬ëŸ¬ Repositoryê°€ ë™ì¼í•œ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ê°€ëŠ¥
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  // ğŸ†• ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì‹œìŠ¤í…œ
  StreamController<Trade>? _masterController;
  StreamSubscription<List<Map<String, dynamic>>>? _wsSub;
  bool _disposed = false;
  List<String>? _currentMarkets; // í˜„ì¬ êµ¬ë… ì¤‘ì¸ ë§ˆì¼“ë“¤
  int _subscriberCount = 0; // êµ¬ë…ì ìˆ˜ ì¶”ì 

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData;

  /// ğŸ†• ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì œê³µ - ì—¬ëŸ¬ Repositoryê°€ êµ¬ë… ê°€ëŠ¥
  Stream<Trade> watch(List<String> markets) {
    if (_useTestData) return _testStream();

    // dispose í›„ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì´ˆê¸°í™”
    if (_disposed) {
      debugPrint('TradeRemoteDataSource: resetting after dispose');
      _disposed = false;
    }

    // ğŸ†• ë™ì¼í•œ ë§ˆì¼“ì´ë©´ ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì¬ì‚¬ìš©
    if (_masterController != null && 
        _currentMarkets != null && 
        _marketsEqual(_currentMarkets!, markets)) {
      debugPrint('TradeRemoteDataSource: reusing existing broadcast stream for ${markets.length} markets');
      return _masterController!.stream;
    }

    // ğŸ†• ìƒˆë¡œìš´ ë§ˆì¼“ì´ë©´ ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬í•˜ê³  ìƒˆë¡œ ìƒì„±
    _cleanupMasterStream();
    _initializeMasterStream(markets);

    return _masterController!.stream;
  }

  /// ğŸ†• ë§ˆìŠ¤í„° ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  void _initializeMasterStream(List<String> markets) {
    debugPrint('TradeRemoteDataSource: initializing master broadcast stream for ${markets.length} markets');
    
    _currentMarkets = List<String>.from(markets);
    
    _masterController = StreamController<Trade>.broadcast(
      onListen: () {
        _subscriberCount++;
        debugPrint('TradeRemoteDataSource: subscriber added (total: $_subscriberCount)');
        
        // ì²« ë²ˆì§¸ êµ¬ë…ìì¼ ë•Œë§Œ WebSocket ì‹œì‘
        if (_subscriberCount == 1 && !_disposed) {
          _startWebSocket(markets);
        }
      },
      onCancel: () {
        _subscriberCount--;
        debugPrint('TradeRemoteDataSource: subscriber removed (remaining: $_subscriberCount)');
        
        // ëª¨ë“  êµ¬ë…ìê°€ ë– ë‚˜ë©´ WebSocket ì •ë¦¬ (ì¦‰ì‹œëŠ” ì•„ë‹ˆê³  ì ì‹œ ëŒ€ê¸°)
        if (_subscriberCount <= 0) {
          Timer(const Duration(seconds: 5), () {
            if (_subscriberCount <= 0 && !_disposed) {
              debugPrint('TradeRemoteDataSource: no subscribers, cleaning up WebSocket');
              _cleanupWebSocket();
            }
          });
        }
      },
    );
  }

  /// ğŸ†• WebSocket ì—°ê²° ì‹œì‘
  Future<void> _startWebSocket(List<String> markets) async {
    if (_disposed) return;

    try {
      debugPrint('TradeRemoteDataSource: starting WebSocket for ${markets.length} markets');
      
      await _ws.connect(markets);
      _wsSub = _ws.stream.listen(
        (rawBatch) {
          // controllerê°€ ë‹«í˜”ê±°ë‚˜ disposedë©´ ì²˜ë¦¬ ì•ˆí•¨
          if (_disposed || _masterController == null || _masterController!.isClosed) {
            debugPrint('TradeRemoteDataSource: skipping data - disposed or closed');
            return;
          }

          for (final item in rawBatch) {
            final dto = TradeDto.tryParse(item);
            if (dto == null) continue;
            final entity = dto.toEntity();
            
            // ğŸ†• ë§ˆìŠ¤í„° ì»¨íŠ¸ë¡¤ëŸ¬ì— ë¸Œë¡œë“œìºìŠ¤íŠ¸
            if (!_disposed && _masterController != null && !_masterController!.isClosed) {
              _masterController!.add(entity);
            }

            // dispatch as AppEvent with metadata
            final event = AppEvent.now(dto.toMap());
            _signalBus.fireTradeEvent(event);
          }
        },
        onError: (error, stackTrace) {
          debugPrint('WebSocket error: $error');
          if (!_disposed && _masterController != null && !_masterController!.isClosed) {
            _masterController!.addStream(_testStream());
          }
        },
        onDone: () {
          debugPrint('WebSocket done');
          if (!_disposed && _masterController != null && !_masterController!.isClosed) {
            _masterController!.addStream(_testStream());
          }
        },
        cancelOnError: false,
      );
    } catch (e) {
      debugPrint('WS connection failed: $e');
      if (!_disposed && _masterController != null && !_masterController!.isClosed) {
        _masterController!.addStream(_testStream());
      }
    }
  }

  /// ğŸ†• WebSocketë§Œ ì •ë¦¬ (ì»¨íŠ¸ë¡¤ëŸ¬ëŠ” ìœ ì§€)
  void _cleanupWebSocket() {
    debugPrint('TradeRemoteDataSource: cleaning up WebSocket');
    _wsSub?.cancel();
    _wsSub = null;
  }

  /// ğŸ†• ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì™„ì „ ì •ë¦¬
  void _cleanupMasterStream() {
    debugPrint('TradeRemoteDataSource: cleaning up master stream');
    
    _cleanupWebSocket();
    
    if (_masterController != null && !_masterController!.isClosed) {
      _masterController!.close();
    }
    _masterController = null;
    _currentMarkets = null;
    _subscriberCount = 0;
  }

  /// ğŸ†• ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ í—¬í¼
  bool _marketsEqual(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    final setA = Set<String>.from(a);
    final setB = Set<String>.from(b);
    return setA.containsAll(setB) && setB.containsAll(setA);
  }

  /// Synthetic fallback stream for dev/test.
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'KRW-BTC', 'KRW-ETH', 'KRW-XRP',
      'KRW-DOGE', 'KRW-SOL', 'KRW-ADA',
      'KRW-LINK', 'KRW-DOT', 'KRW-AVAX',
      'KRW-MATIC',
    ];

    while (!_disposed) {
      await Future.delayed(const Duration(milliseconds: 500));
      if (_disposed) break;
      
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final dto = TradeDto(
        market: symbols[rnd.nextInt(symbols.length)],
        price: (rnd.nextDouble() * 1000).roundToDouble(),
        volume: rnd.nextDouble(),
        side: rnd.nextBool() ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: nowMs,
        sequentialId: 'test-$nowMs-${rnd.nextInt(1000)}',
      );
      yield dto.toEntity();
      _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
    }
  }

  /// Clean up resources when no longer needed.
  Future<void> dispose() async {
    if (_disposed) return;
    
    _disposed = true;
    
    debugPrint('TradeRemoteDataSource: disposing...');
    
    // ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    _cleanupMasterStream();
    
    debugPrint('TradeRemoteDataSource: disposed');
    
    // do not dispose shared ws client here
  }
}\n\n// ====== lib/data/datasources/market_mood_remote_ds.dart ======\n
// lib/data/datasources/market_mood_remote_ds.dart
// ğŸŒ Data Layer: ì›ê²© ë°ì´í„° ì†ŒìŠ¤ (ì•ˆì •ì„±ì´ ê²€ì¦ëœ Timer ë°©ì‹ìœ¼ë¡œ ë³µì›)

import 'dart:async';
import '../../core/network/api_client_coingecko.dart';
import '../../core/utils/logger.dart';
import '../../data/models/market_mood_dto.dart';

/// ğŸŒ ë§ˆì¼“ë¬´ë“œ ì›ê²© ë°ì´í„° ì†ŒìŠ¤
class MarketMoodRemoteDataSource {
  final CoinGeckoApiClient _apiClient;
  Timer? _globalDataTimer;
  StreamController<CoinGeckoGlobalDataDto>? _globalDataController;

  MarketMoodRemoteDataSource(this._apiClient);

  Stream<CoinGeckoGlobalDataDto> getGlobalMarketDataStream() {
    // ì´ë¯¸ ìŠ¤íŠ¸ë¦¼ì´ í™œì„±í™”ëœ ê²½ìš° ì¬ì‚¬ìš©
    if (_globalDataController != null && !_globalDataController!.isClosed) {
      return _globalDataController!.stream;
    }
    
    _globalDataController = StreamController<CoinGeckoGlobalDataDto>.broadcast();
    
    Future<void> fetch() async {
      try {
        final responseDto = await _apiClient.getGlobalMarketData();
        final dataDto = responseDto.data;

        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.add(dataDto);
          log.d('ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìˆ˜ì‹  ì„±ê³µ (Timer): ${dataDto.totalVolumeUsd.toStringAsFixed(0)}B USD');
        }
      } catch (e, st) {
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.addError(e, st);
          log.e('âŒ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ (Timer): $e');
        }
      }
    }

    // ì²« í˜¸ì¶œ
    fetch();

    // 30ë¶„ë§ˆë‹¤ í˜¸ì¶œ
    _globalDataTimer = Timer.periodic(const Duration(minutes: 30), (_) => fetch());

    _globalDataController!.onCancel = () {
      _globalDataTimer?.cancel();
      _globalDataTimer = null;
      log.d('ğŸ”„ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë„ˆ ì—†ìŒ. íƒ€ì´ë¨¸ ì¤‘ì§€.');
    };

    return _globalDataController!.stream;
  }

  Future<CoinGeckoGlobalDataDto> getGlobalMarketData() async {
    final responseDto = await _apiClient.getGlobalMarketData();
    return responseDto.data;
  }

  Future<double> getUsdToKrwRate() async {
    return _apiClient.getUsdToKrwRate();
  }

  Future<bool> checkApiHealth() async {
    try {
      await getGlobalMarketData();
      return true;
    } catch (_) {
      return false;
    }
  }

  void dispose() {
    _globalDataTimer?.cancel();
    _globalDataTimer = null;
    _globalDataController?.close();
    _globalDataController = null;
    log.d('ğŸ§¹ MarketMoodRemoteDataSource ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/datasources/settings_local_ds.dart ======\n
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../domain/entities/app_settings.dart';

class SettingsLocalDataSource {
 final SharedPreferences prefs;

 SettingsLocalDataSource(this.prefs);

 // í…Œë§ˆ ëª¨ë“œ ê´€ë¦¬
 ThemeMode getThemeMode() {
   final themeName = prefs.getString('themeMode') ?? 'system';
   return switch (themeName) {
     'light' => ThemeMode.light,
     'dark' => ThemeMode.dark,
     _ => ThemeMode.system,
   };
 }

 Future<void> saveThemeMode(ThemeMode mode) async {
   await prefs.setString('themeMode', mode.name);
 }

 // í™”ë©´ í•­ìƒ ì¼œê¸° ê´€ë¦¬
 bool getKeepScreenOn() {
   return prefs.getBool('keepScreenOn') ?? false;
 }

 Future<void> saveKeepScreenOn(bool value) async {
   await prefs.setBool('keepScreenOn', value);
 }

 // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ê´€ë¦¬
 SliderPosition getSliderPosition() {
   final raw = prefs.getString('sliderPosition') ?? 'top';
   return raw == 'bottom' ? SliderPosition.bottom : SliderPosition.top;
 }

 Future<void> saveSliderPosition(SliderPosition position) async {
   await prefs.setString('sliderPosition', position.name);
 }

 // ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ê´€ë¦¬
 DisplayMode getDisplayMode() {
   final raw = prefs.getString('displayMode') ?? 'ticker';
   return switch (raw) {
     'korean' => DisplayMode.korean,
     'english' => DisplayMode.english,
     _ => DisplayMode.ticker,
   };
 }

 Future<void> saveDisplayMode(DisplayMode mode) async {
   await prefs.setString('displayMode', mode.name);
 }

 // ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ê´€ë¦¬
 AmountDisplayMode getAmountDisplayMode() {
   final raw = prefs.getString('amountDisplayMode') ?? 'number';
   return switch (raw) {
     'icon' => AmountDisplayMode.icon,
     _ => AmountDisplayMode.number,
   };
 }

 Future<void> saveAmountDisplayMode(AmountDisplayMode mode) async {
   await prefs.setString('amountDisplayMode', mode.name);
 }

 // ë°˜ì§ì„ íš¨ê³¼ ê´€ë¦¬
 bool getBlinkEnabled() {
   return prefs.getBool('blinkEnabled') ?? true;
 }

 Future<void> saveBlinkEnabled(bool enabled) async {
   await prefs.setBool('blinkEnabled', enabled);
 }

 // í°íŠ¸ íŒ¨ë°€ë¦¬ ê´€ë¦¬
 FontFamily getFontFamily() {
   final raw = prefs.getString('fontFamily') ?? 'pretendard';
   for (final font in FontFamily.values) {
     if (font.name == raw) return font;
   }
   return FontFamily.pretendard;
 }

 Future<void> saveFontFamily(FontFamily font) async {
   await prefs.setString('fontFamily', font.name);
 }

 // í–…í‹± í”¼ë“œë°± ê´€ë¦¬ ğŸ†•
 bool getHapticEnabled() {
   return prefs.getBool('hapticEnabled') ?? true; // ê¸°ë³¸ê°’: í™œì„±í™”
 }

 Future<void> saveHapticEnabled(bool enabled) async {
   await prefs.setBool('hapticEnabled', enabled);
 }

 // í™”ë©´ íšŒì „ ì ê¸ˆ ê´€ë¦¬ ğŸ†•
 bool getPortraitLocked() {
   return prefs.getBool('portraitLocked') ?? false; // ê¸°ë³¸ê°’: ìë™ íšŒì „
 }

 Future<void> savePortraitLocked(bool locked) async {
   await prefs.setBool('portraitLocked', locked);
 }

 // ìºì‹œ ë¹„ìš°ê¸°
 Future<void> clearCache() async {
   final cacheKeys = [
     'coinData_cache',
     'priceHistory_cache',
     'chartData_cache',
     'marketData_cache',
     'imageCache_timestamp',
   ];

   for (final key in cacheKeys) {
     await prefs.remove(key);
   }
 }

 // ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
 Future<void> resetAllSettings() async {
   final settingKeys = [
     'themeMode',
     'keepScreenOn',
     'sliderPosition',
     'displayMode',
     'amountDisplayMode',
     'blinkEnabled',
     'fontFamily',
     'hapticEnabled',        // ğŸ†• ì¶”ê°€
     'portraitLocked',       // ğŸ†• ì¶”ê°€
   ];

   for (final key in settingKeys) {
     await prefs.remove(key);
   }
 }
}\n\n// ====== lib/data/datasources/market_mood_local_ds.dart ======\n
// lib/data/datasources/market_mood_local_ds.dart
// ğŸ’¾ Data Layer: ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤ (Hive ê¸°ë°˜, DI íŒ¨í„´)

import 'package:hive_flutter/hive_flutter.dart';
import '../../core/services/hive_service.dart';
import '../../core/utils/logger.dart';
import '../models/market_mood_dto.dart'; // ğŸ”¥ TimestampedVolumeì´ ì—¬ê¸° ìˆìŒ

/// ğŸ’¾ ë§ˆì¼“ë¬´ë“œ ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤
/// HiveServiceë¥¼ í†µí•œ ë³¼ë¥¨ ë°ì´í„° ì €ì¥/ì¡°íšŒ, í™˜ìœ¨ ìºì‹± (DI íŒ¨í„´)
class MarketMoodLocalDataSource {
  final HiveService _hiveService;
  
  static const String _exchangeRateKey = 'exchange_rate';
  static const String _appStartTimeKey = 'app_start_time';

  MarketMoodLocalDataSource(this._hiveService);

  /// Volume Box ì ‘ê·¼
  Box<TimestampedVolume> get _volumeBox => _hiveService.marketMoodVolumeBox;
  
  /// Cache Box ì ‘ê·¼ 
  Box get _cacheBox => _hiveService.marketMoodCacheBox;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ ìŠ¬ë¡¯)
  Future<void> addVolumeData(TimestampedVolume volume) async {
    try {
      // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”ëœ í‚¤ ìƒì„±
      final slotKey = _getSlotKey(volume.timestamp);
      
      await _volumeBox.put(slotKey, volume);
      log.d('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥: $slotKey -> ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<TimestampedVolume?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final targetTime = DateTime.now().subtract(Duration(minutes: minutes));
      final slotKey = _getSlotKey(targetTime);
      
      final volume = _volumeBox.get(slotKey);
      if (volume != null) {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${volume.volumeUsd.toStringAsFixed(0)}B');
      } else {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì—†ìŒ');
      }
      
      return volume;
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days) async {
    try {
      final now = DateTime.now();
      final cutoffTime = now.subtract(Duration(days: days));
      
      final volumes = _volumeBox.values
          .where((volume) => volume.timestamp.isAfter(cutoffTime))
          .map((volume) => volume.volumeUsd)
          .toList();
      
      if (volumes.isEmpty) {
        log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ë°ì´í„° ì—†ìŒ');
        return null;
      }
      
      final average = volumes.reduce((a, b) => a + b) / volumes.length;
      log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ${average.toStringAsFixed(0)}B (${volumes.length}ê°œ ë°ì´í„°)');
      
      return average;
    } catch (e, st) {
      log.e('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ê³„ì‚° ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount() async {
    try {
      final count = _volumeBox.length;
      log.d('ğŸ“Š ì´ ë°ì´í„° ê°œìˆ˜: $count');
      return count;
    } catch (e, st) {
      log.e('ğŸ“Š ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return 0;
    }
  }

  /// ëˆ„ë½ëœ 30ë¶„ ìŠ¬ë¡¯ í™•ì¸ ë° ë³´ì •
  Future<void> checkAndFillMissingSlots() async {
    try {
      final appStartTime = getAppStartTime();
      final now = DateTime.now();
      final totalMinutes = now.difference(appStartTime).inMinutes;
      final expectedSlots = (totalMinutes / 30).floor();
      
      log.i('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬: ì˜ˆìƒ $expectedSlotsê°œ, ì‹¤ì œ ${_volumeBox.length}ê°œ');
      
      if (_volumeBox.length < expectedSlots) {
        final missing = expectedSlots - _volumeBox.length;
        log.w('âš ï¸ $missingê°œ ìŠ¬ë¡¯ ëˆ„ë½ ê°ì§€');
        // ì‹¤ì œ ë³´ì • ë¡œì§ì€ í•„ìš” ì‹œ êµ¬í˜„
      }
    } catch (e, st) {
      log.e('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬ ì‹¤íŒ¨', e, st);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’± í™˜ìœ¨ ìºì‹±
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í™˜ìœ¨ ìºì‹œ ì €ì¥
  Future<void> cacheExchangeRate(double rate) async {
    try {
      await _cacheBox.put(_exchangeRateKey, {
        'rate': rate,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });
      log.d('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ (12ì‹œê°„ ìœ íš¨)
  Future<double?> getCachedExchangeRate() async {
    try {
      final cached = _cacheBox.get(_exchangeRateKey);
      if (cached == null) return null;
      
      final timestamp = DateTime.fromMillisecondsSinceEpoch(cached['timestamp']);
      final rate = cached['rate'] as double;
      
      // 12ì‹œê°„ ì´ë‚´ì¸ì§€ í™•ì¸ (Providerì™€ ë™ì¼í•œ ìºì‹œ ì •ì±…)
      if (DateTime.now().difference(timestamp).inHours < 12) {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì‚¬ìš©: $rate KRW');
        return rate;
      } else {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ë§Œë£Œ');
        return null;
      }
    } catch (e, st) {
      log.e('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ•°ï¸ ì‹œê°„ ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime() {
    try {
      final cached = _cacheBox.get(_appStartTimeKey);
      if (cached != null) {
        return cached as DateTime;
      }
      
      // ìµœì´ˆ ì‹¤í–‰ ì‹œ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      final now = DateTime.now();
      _cacheBox.put(_appStartTimeKey, now);
      log.i('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì„¤ì •: ${now.toIso8601String()}');
      return now;
    } catch (e, st) {
      log.e('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return DateTime.now(); // fallback
    }
  }

  /// 30ë¶„ ìŠ¬ë¡¯ í‚¤ ìƒì„± (ì •ê·œí™”)
  String _getSlotKey(DateTime timestamp) {
    // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”: ì˜ˆ) 14:23 -> 14:00, 14:47 -> 14:30
    final normalized = DateTime(
      timestamp.year,
      timestamp.month,
      timestamp.day,
      timestamp.hour,
      (timestamp.minute ~/ 30) * 30, // 30ë¶„ ë‹¨ìœ„ë¡œ ë‚´ë¦¼
    );
    
    return normalized.toIso8601String();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë””ë²„ê¹…ìš© ì •ë³´ ë°˜í™˜
  Map<String, Object> getDebugInfo() {
    try {
      final volumeInfo = {
        'total_count': _volumeBox.length,
        'box_open': _volumeBox.isOpen,
        'first_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.first.timestamp.toIso8601String() 
            : 'none',
        'last_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.last.timestamp.toIso8601String() 
            : 'none',
      };
      
      final cacheInfo = {
        'cache_keys': _cacheBox.keys.toList(),
        'app_start_time': getAppStartTime().toIso8601String(),
        'has_exchange_rate': _cacheBox.containsKey(_exchangeRateKey),
        'box_open': _cacheBox.isOpen,
      };

      return {
        'volume_storage': volumeInfo,
        'cache_storage': cacheInfo,
        'hive_service': 'injected',
        'status': 'healthy',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  /// ìƒíƒœ ë¡œê¹…
  void logStatus() {
    final info = getDebugInfo();
    log.i('ğŸ’¾ MarketMoodLocalDataSource ìƒíƒœ: $info');
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    try {
      // HiveServiceê°€ Box ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì •ë¦¬ ì•ˆí•¨
      log.i('ğŸ§¹ MarketMoodLocalDataSource ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', e, st);
    }
  }

  /// ê°œë°œìš©: ëª¨ë“  ë°ì´í„° ì‚­ì œ
  Future<void> clearAllData() async {
    try {
      await _volumeBox.clear();
      await _cacheBox.clear();
      log.w('ğŸ—‘ï¸ ëª¨ë“  ë¡œì»¬ ë°ì´í„° ì‚­ì œ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ—‘ï¸ ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ê°œë°œìš©: ìµœê·¼ Nê°œ ë°ì´í„°ë§Œ ìœ ì§€
  Future<void> trimOldData({int keepCount = 100}) async {
    try {
      if (_volumeBox.length <= keepCount) return;

      final allEntries = _volumeBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp)); // ìµœì‹ ìˆœ

      final toKeep = allEntries.take(keepCount).toList();
      
      await _volumeBox.clear();
      for (final volume in toKeep) {
        await addVolumeData(volume);
      }
      
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬: ${allEntries.length} -> $keepCountê°œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/datasources/analysis_isolate_manager.dart ======\n
\n\n// ====== lib/data/repositories/signal_repository_impl.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/signal_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/pattern_detector.dart';
import '../../core/utils/pattern_config.dart';
import '../../core/utils/market_data_context.dart';

/// ğŸš€ SignalRepositoryImpl V4.0 - ì™„ì „íˆ ê°œì„ ëœ êµ¬ì¡°
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - PatternDetector ì˜ì¡´ì„± ì£¼ì… ë°©ì‹ìœ¼ë¡œ ë³€ê²½
/// - MarketDataContextë¡œ íŒŒë¼ë¯¸í„° ì§€ì˜¥ í•´ê²°
/// - ì±…ì„ ë¶„ë¦¬ ë° ì½”ë“œ ë‹¨ìˆœí™”
/// - í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê°œì„ 
class SignalRepositoryImpl implements SignalRepository {
  final TradeRemoteDataSource _remote;
  final TradeAggregator _aggregator;
  final PatternDetector _patternDetector;
  final PatternConfig _patternConfig;

  // ğŸ“Š ë§ˆì¼“ë³„ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  final Map<String, MarketDataContext> _marketContexts = {};

  // ğŸ¯ ì‹ í˜¸ ê´€ë¦¬ ì‹œìŠ¤í…œ
  final Map<PatternType, List<Signal>> _signalLists = {};
  final Map<PatternType, bool> _patternEnabled = {};
  final Set<String> _seenIds = {};

  // ğŸ¯ íŒ¨í„´ë³„ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final Map<PatternType, StreamController<List<Signal>>> _patternControllers = {};
  final StreamController<List<Signal>> _allSignalsController = 
      StreamController<List<Signal>>.broadcast();

  // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _signalStream;
  StreamSubscription<Trade>? _signalSubscription;

  // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ ë° ì •ë¦¬ íƒ€ì´ë¨¸
  Timer? _batchUpdateTimer;
  Timer? _cleanupTimer;

  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  final Map<PatternType, int> _signalCounts = {};
  final Map<PatternType, DateTime?> _lastSignalTimes = {};
  int _totalProcessedTrades = 0;
  DateTime? _lastProcessingTime;

  // ==========================================================================
  // ì´ˆê¸°í™”
  // ==========================================================================

  SignalRepositoryImpl(
    this._remote, {
    PatternDetector? patternDetector,
    PatternConfig? patternConfig,
  }) : _aggregator = TradeAggregator(),
       _patternDetector = patternDetector ?? PatternDetector(),
       _patternConfig = patternConfig ?? PatternConfig() {
    _initializePatterns();
    _startCleanupTimer();
    log.i('ğŸš€ SignalRepository V4.0 ì´ˆê¸°í™” ì™„ë£Œ - ê°œì„ ëœ êµ¬ì¡°');
  }

  void _initializePatterns() {
    for (final pattern in PatternType.values) {
      _signalLists[pattern] = [];
      _patternEnabled[pattern] = true;
      _signalCounts[pattern] = 0;
      _patternControllers[pattern] = StreamController<List<Signal>>.broadcast();
    }

    if (kDebugMode) {
      log.i('ğŸ¯ íŒ¨í„´ ì´ˆê¸°í™” ì™„ë£Œ: ${PatternType.values.length}ê°œ íŒ¨í„´');
    }
  }

  /// ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ íƒ€ì´ë¨¸ ì‹œì‘
  void _startCleanupTimer() {
    _cleanupTimer = Timer.periodic(const Duration(minutes: 5), (_) {
      _cleanupMarketContexts();
      _cleanupSeenIds();
    });
  }

  /// ğŸ§¹ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  void _cleanupMarketContexts() {
    final now = DateTime.now();
    int removedMarkets = 0;

    _marketContexts.removeWhere((market, context) {
      // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬
      final quality = context.getDataQuality(onlineMetrics: _patternDetector.metrics);
      final isHealthy = quality['overall'] != 'POOR';
      
      // ìµœê·¼ í™œë™ í™•ì¸
      final hasRecentActivity = context.shortestPriceWindow.timestamps.isNotEmpty &&
          now.difference(context.shortestPriceWindow.timestamps.last).inMinutes < 30;
      
      if (!isHealthy || !hasRecentActivity) {
        // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œë„ í•¨ê»˜ ì •ë¦¬
        context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        removedMarkets++;
        return true;
      }
      
      return false;
    });

    if (kDebugMode && removedMarkets > 0) {
      log.d('ğŸ§¹ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬: $removedMarketsê°œ ë¹„í™œì„± ì‹œì¥ ì œê±° (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)');
    }
  }

  /// ğŸ§¹ ì¤‘ë³µ ê°ì§€ ID ì •ë¦¬
  void _cleanupSeenIds() {
    if (_seenIds.length > AppConfig.signalCacheSize) {
      final excess = _seenIds.length - AppConfig.signalCacheSize;
      final toRemove = _seenIds.take(excess).toList();
      _seenIds.removeAll(toRemove);
    }
  }

  // ==========================================================================
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  // ==========================================================================

  void _initializeSignalStream(List<String> markets) {
    if (_signalStream != null) return;

    log.i('SignalRepositoryImpl V4.0: ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” - ${markets.length}ê°œ ì‹œì¥');

    _signalStream = _remote.watch(markets).asBroadcastStream();

    _signalSubscription = _signalStream!.listen(
      _processRawTradeForSignal,
      onError: (error, stackTrace) {
        log.e('Signal stream error: $error', stackTrace);
      },
      onDone: () {
        log.i('Signal stream done');
      },
    );
  }

  // ==========================================================================
  // ğŸ“Š ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  // ==========================================================================

  /// ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ìƒì„± ë˜ëŠ” ì¡°íšŒ
  MarketDataContext _getOrCreateMarketContext(String market) {
    return _marketContexts.putIfAbsent(
      market,
      () => MarketDataContext.empty(market),
    );
  }

  /// ëª¨ë“  íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì—…ë°ì´íŠ¸ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
  void _updateMarketContext(Trade trade, DateTime timestamp) {
    final context = _getOrCreateMarketContext(trade.market);
    
    // ê±°ë˜ ê°„ê²© ê³„ì‚°
    final interval = context.intervalWindow != null && 
                    context.intervalWindow!.timestamps.isNotEmpty
        ? timestamp.difference(context.intervalWindow!.timestamps.last).inSeconds.toDouble()
        : 10.0;
    
    // ë§¤ìˆ˜ ë¹„ìœ¨ (ê°„ë‹¨í•œ ì¶”ì •)
    final buyRatio = trade.isBuy ? 1.0 : 0.0;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œì™€ í•¨ê»˜ ëª¨ë“  ìœˆë„ìš° ì—…ë°ì´íŠ¸
    context.updateWithOnlineMetrics(
      price: trade.price,
      volume: trade.total,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: max(interval, 1.0),
      onlineMetrics: _patternDetector.metrics, // ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
    );
  }

  // ==========================================================================
  // ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬
  // ==========================================================================

  void _processRawTradeForSignal(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      if (!_seenIds.add(key)) return;

      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleAggregatedTrade,
      );
    } catch (e, stackTrace) {
      log.w('_processRawTradeForSignal error: $e', stackTrace);
    }
  }

  void _handleAggregatedTrade(Map<String, dynamic> aggregatedTrade) {
    try {
      final trade = Trade(
        market: aggregatedTrade['market'] as String,
        price: aggregatedTrade['price'] as double,
        volume: aggregatedTrade['volume'] as double,
        side: (aggregatedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: aggregatedTrade['timestamp'] as int,
        sequentialId: aggregatedTrade['sequential_id'] as String? ?? '',
      );

      final now = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
      _updateMarketContext(trade, now);
      _analyzePatterns(trade, now);
    } catch (e, stackTrace) {
      log.w('_handleAggregatedTrade error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸ¯ íŒ¨í„´ ë¶„ì„ (ë‹¨ìˆœí™”ëœ ë¡œì§)
  // ==========================================================================

  /// ğŸ¯ ë©”ì¸ íŒ¨í„´ ë¶„ì„ ë¡œì§
  void _analyzePatterns(Trade trade, DateTime now) {
    try {
      final context = _getOrCreateMarketContext(trade.market);
      final detectedSignals = <Signal>[];

      // ğŸ”¥ ê° íŒ¨í„´ì— ëŒ€í•´ ê°ì§€ ìˆ˜í–‰
      for (final pattern in PatternType.values) {
        if (!(_patternEnabled[pattern] ?? false)) continue;

        try {
          // ğŸš€ ê°œì„ ëœ íŒ¨í„´ ê°ì§€ (ë‹¨ì¼ ë©”ì„œë“œ, ëª…í™•í•œ íŒŒë¼ë¯¸í„°)
          final signal = _patternDetector.detectPattern(
            patternType: pattern,
            trade: trade,
            timestamp: now,
            context: context,
          );

          if (signal != null) {
            detectedSignals.add(signal);
            _signalCounts[pattern] = (_signalCounts[pattern] ?? 0) + 1;
            _lastSignalTimes[pattern] = now;
          }
        } catch (e, stackTrace) {
          log.w('Pattern analysis error: ${pattern.name} - $e', stackTrace);
        }
      }

      // ì‹ í˜¸ ì¶”ê°€
      for (final signal in detectedSignals) {
        _addSignal(signal.patternType, signal);
      }

      if (detectedSignals.isNotEmpty) {
        _scheduleBatchUpdate();
      }

      _totalProcessedTrades++;
      _lastProcessingTime = now;
    } catch (e, stackTrace) {
      log.e('_analyzePatterns error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸš€ ì‹œê·¸ë„ ì¶”ê°€ ë° ê´€ë¦¬
  // ==========================================================================

  void _addSignal(PatternType pattern, Signal signal) {
    final signalList = _signalLists[pattern];
    if (signalList == null) return;

    // ì¤‘ë³µ ì‹ í˜¸ ì²´í¬ (5ë¶„ ì´ë‚´)
    final cutoff = signal.detectedAt.subtract(const Duration(minutes: 5));
    final isDuplicate = signalList.any((existingSignal) =>
        existingSignal.market == signal.market &&
        existingSignal.detectedAt.isAfter(cutoff));

    if (isDuplicate) return;

    signalList.insert(0, signal);

    // ìµœëŒ€ ì‹ í˜¸ ê°œìˆ˜ ì œí•œ
    if (signalList.length > AppConfig.maxSignalsPerPattern) {
      signalList.removeLast();
    }

    if (kDebugMode) {
      final confidence = signal.patternDetails['finalConfidence'] ?? 
                       signal.patternDetails['confidence'] ?? 0.0;
      log.i('ğŸš¨ V4.0 ì‹ í˜¸ ê°ì§€: ${signal.patternType.displayName} - ${signal.market} '
          '(${signal.changePercent.toStringAsFixed(2)}%, ì‹ ë¢°ë„: ${(confidence * 100).toStringAsFixed(1)}%)');
    }
  }

  /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    if (_batchUpdateTimer?.isActive != true) {
      _batchUpdateTimer = Timer(AppConfig.signalBatchInterval, _updateSignalStreams);
    }
  }

  /// ğŸ“Š ëª¨ë“  ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  void _updateSignalStreams() {
    try {
      for (final entry in _signalLists.entries) {
        final pattern = entry.key;
        final signals = List<Signal>.from(entry.value);

        final controller = _patternControllers[pattern];
        if (controller != null && !controller.isClosed) {
          controller.add(signals);
        }
      }

      final allSignals = _signalLists.values.expand((list) => list).toList();
      allSignals.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
      final recentSignals = allSignals.take(50).toList();

      if (!_allSignalsController.isClosed) {
        _allSignalsController.add(recentSignals);
      }

      if (kDebugMode && allSignals.isNotEmpty) {
        log.d('ğŸš€ V4.0 ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì—…ë°ì´íŠ¸: ${allSignals.length}ê°œ ì´ ì‹ í˜¸');
      }
    } catch (e, stackTrace) {
      log.w('_updateSignalStreams error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // SignalRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  // ==========================================================================

  @override
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    _initializeSignalStream(markets);
    return _patternControllers[patternType]?.stream ?? const Stream.empty();
  }

  @override
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    _initializeSignalStream(markets);
    return _allSignalsController.stream;
  }

  @override
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ì„¤ì • ì—…ë°ì´íŠ¸ ë¡œì§ (êµ¬ì²´ì ì¸ í‚¤ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
    try {
      _patternConfig.updatePatternConfig(patternType, 'priceChangePercent', threshold);
      log.i('V4.0: íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ - ${patternType.name}: $threshold');
    } catch (e) {
      log.w('íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: $e');
    }
  }

  @override
  double getPatternThreshold(PatternType patternType) {
    return _patternConfig.getConfigValue(patternType, 'priceChangePercent');
  }

  @override
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _patternEnabled[patternType] = enabled;
    log.i('íŒ¨í„´ ${patternType.name} ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}');
  }

  @override
  bool isPatternEnabled(PatternType patternType) {
    return _patternEnabled[patternType] ?? false;
  }

  @override
  void clearSignals(PatternType? patternType) {
    if (patternType != null) {
      _signalLists[patternType]?.clear();
      _patternControllers[patternType]?.add([]);
      _signalCounts[patternType] = 0;
    } else {
      for (final pattern in PatternType.values) {
        _signalLists[pattern]?.clear();
        _patternControllers[pattern]?.add([]);
        _signalCounts[pattern] = 0;
      }
      _patternDetector.clearAllCooldowns();
    }
    _scheduleBatchUpdate();
  }

  // ==========================================================================
  // ğŸ†• V4.0 í™•ì¥ ê¸°ëŠ¥ë“¤
  // ==========================================================================

  /// íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸
  @override
  void updatePatternConfig(PatternType pattern, String key, double value) {
    _patternConfig.updatePatternConfig(pattern, key, value);
  }

  /// íŒ¨í„´ë³„ í†µê³„ ì •ë³´
  @override
  Future<Map<String, dynamic>> getPatternStats(PatternType type) async {
    final signals = _signalLists[type] ?? [];
    final lastSignal = _lastSignalTimes[type];

    return {
      'patternType': type.name,
      'totalSignals': _signalCounts[type] ?? 0,
      'recentSignals': signals.length,
      'lastSignalTime': lastSignal?.toIso8601String(),
      'isEnabled': _patternEnabled[type] ?? false,
      'cooldownStatus': _patternDetector.getCooldownStatus(),
      'config': _patternConfig.getPatternConfig(type),
    };
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final now = DateTime.now();
    final uptime = _lastProcessingTime != null
        ? now.difference(_lastProcessingTime!).inMinutes
        : 0;

    final patternStats = <String, dynamic>{};
    for (final pattern in PatternType.values) {
      patternStats[pattern.name] = await getPatternStats(pattern);
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ
    final marketStats = <String, dynamic>{};
    for (final entry in _marketContexts.entries) {
      final quality = entry.value.getDataQuality(onlineMetrics: _patternDetector.metrics);
      marketStats[entry.key] = {
        'quality': quality['overall'],
        'score': quality['overallScore'],
        'timeframes': entry.value.availableTimeframes.length,
        'onlineMetrics': quality['onlineMetrics'], // ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨
      };
    }

    // ğŸ†• ì „ì²´ ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ê±´ê°•ì„±
    final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'version': '4.1-Online',
      'status': 'healthy',
      'uptime': uptime,
      'totalProcessedTrades': _totalProcessedTrades,
      'lastProcessingTime': _lastProcessingTime?.toIso8601String(),
      'activePatterns': _patternEnabled.values.where((enabled) => enabled).length,
      'trackedMarkets': _marketContexts.length,
      'patternStats': patternStats,
      'marketStats': marketStats,
      'onlineMetricsSystem': onlineMetricsHealth, // ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ì „ì²´ ìƒíƒœ
      'improvements': [
        'Online RSI/MACD Integration',
        'Stream Gap Auto-Recovery', 
        'O(1) Indicator Calculation',
        'Real Divergence Detection',
        'Dependency Injection Architecture',
        'Fixed Parameter Hell',
        'Enhanced Memory Management',
        'Testable Structure',
      ],
    };
  }

  /// ë§ˆì¼“ë³„ ë°ì´í„° í’ˆì§ˆ ì¡°íšŒ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Map<String, dynamic> getMarketDataQuality() {
    final qualityReport = <String, dynamic>{};

    for (final entry in _marketContexts.entries) {
      // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ í’ˆì§ˆ ê²€ì‚¬
      qualityReport[entry.key] = entry.value.getDataQuality(
        onlineMetrics: _patternDetector.metrics
      );
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ìš”ì•½
    final onlineHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'totalMarkets': _marketContexts.length,
      'markets': qualityReport,
      'healthyMarkets': qualityReport.values
          .where((q) => q['overall'] == 'EXCELLENT' || q['overall'] == 'GOOD')
          .length,
      'onlineMetricsSummary': {
        'totalMarkets': onlineHealth['totalMarkets'],
        'healthyMarkets': onlineHealth['healthyMarkets'],
        'staleMarkets': onlineHealth['staleMarkets'],
      },
    };
  }

  /// íŒ¨í„´ ì„¤ì • í”„ë¦¬ì…‹ ì ìš©
  @override
  void applyPatternPreset(String presetName) {
    switch (presetName.toLowerCase()) {
      case 'conservative':
        _patternConfig.applyConservativePreset();
        break;
      case 'aggressive':
        _patternConfig.applyAggressivePreset();
        break;
      case 'balanced':
        _patternConfig.applyBalancedPreset();
        break;
      default:
        throw ArgumentError('Unknown preset: $presetName');
    }

    log.i('íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©: $presetName');
  }

  /// ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  @override
  Map<String, dynamic> exportConfiguration() {
    return {
      'version': '4.0',
      'timestamp': DateTime.now().toIso8601String(),
      'patternConfig': _patternConfig.exportConfig(),
      'patternEnabled': _patternEnabled.map((k, v) => MapEntry(k.name, v)),
      'systemSettings': {
        'maxSignalsPerPattern': AppConfig.maxSignalsPerPattern,
        'signalCacheSize': AppConfig.signalCacheSize,
        'batchInterval': AppConfig.signalBatchInterval.inMilliseconds,
      },
    };
  }

  @override
  void importConfiguration(Map<String, dynamic> config) {
    try {
      // íŒ¨í„´ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
      if (config['patternConfig'] != null) {
        _patternConfig.importConfig(config['patternConfig']);
      }

      // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
      if (config['patternEnabled'] != null) {
        final enabledMap = config['patternEnabled'] as Map<String, dynamic>;
        for (final pattern in PatternType.values) {
          if (enabledMap.containsKey(pattern.name)) {
            _patternEnabled[pattern] = enabledMap[pattern.name] as bool;
          }
        }
      }

      log.i('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ');
    } catch (e, stackTrace) {
      log.e('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: $e', stackTrace);
      rethrow;
    }
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    return Stream.periodic(const Duration(seconds: 10), (_) {
      final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Online',
        'totalProcessedTrades': _totalProcessedTrades,
        'signalCounts': Map.from(_signalCounts),
        'activeMarkets': _marketContexts.length,
        'cooldownStatus': _patternDetector.getCooldownStatus(),
        'memoryUsage': {
          'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
          'seenIdsCount': _seenIds.length,
          'marketContexts': _marketContexts.length,
        },
        'onlineMetrics': {
          'totalMarkets': onlineMetricsHealth['totalMarkets'],
          'healthyMarkets': onlineMetricsHealth['healthyMarkets'],
          'staleMarkets': onlineMetricsHealth['staleMarkets'],
        },
        'architecture': 'V4.1 - Online Indicators + Dependency Injection + Clean Structure',
      };
    });
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  @override
  Future<void> dispose() async {
    log.i('SignalRepositoryImpl V4.0: dispose() ì‹œì‘');

    _batchUpdateTimer?.cancel();
    _cleanupTimer?.cancel();

    _aggregator.flushTrades(onTradeProcessed: (_) {});

    await _signalSubscription?.cancel();
    _signalStream = null;

    // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    for (final controller in _patternControllers.values) {
      await controller.close();
    }
    await _allSignalsController.close();

    // ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
    for (final context in _marketContexts.values) {
      context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
    }
    _marketContexts.clear();

    // ì‹ í˜¸ ë° ìºì‹œ ì •ë¦¬
    _signalLists.clear();
    _signalCounts.clear();
    _lastSignalTimes.clear();
    _seenIds.clear();

    // PatternDetector ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
    _patternDetector.dispose();

    log.i('SignalRepositoryImpl V4.1: dispose() ì™„ë£Œ - ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨');
  }
}\n\n// ====== lib/data/repositories/settings_repository_impl.dart ======\n
import 'package:flutter/material.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../datasources/settings_local_ds.dart';

class SettingsRepositoryImpl implements SettingsRepository {
 final SettingsLocalDataSource dataSource;

 SettingsRepositoryImpl(this.dataSource);

 @override
 Future<AppSettings> getSettings() async {
   return AppSettings(
     themeMode: dataSource.getThemeMode(),
     keepScreenOn: dataSource.getKeepScreenOn(),
     sliderPosition: dataSource.getSliderPosition(),
     displayMode: dataSource.getDisplayMode(),
     amountDisplayMode: dataSource.getAmountDisplayMode(),
     blinkEnabled: dataSource.getBlinkEnabled(),
     fontFamily: dataSource.getFontFamily(),
     isHapticEnabled: dataSource.getHapticEnabled(),        // ğŸ†• ì¶”ê°€
     isPortraitLocked: dataSource.getPortraitLocked(),      // ğŸ†• ì¶”ê°€
   );
 }

 @override
 Future<void> updateThemeMode(ThemeMode mode) async {
   await dataSource.saveThemeMode(mode);
 }

 @override
 Future<void> updateKeepScreenOn(bool value) async {
   await dataSource.saveKeepScreenOn(value);
 }

 @override
 Future<void> updateSliderPosition(SliderPosition position) async {
   await dataSource.saveSliderPosition(position);
 }

 @override
 Future<void> updateDisplayMode(DisplayMode mode) async {
   await dataSource.saveDisplayMode(mode);
 }

 @override
 Future<void> updateAmountDisplayMode(AmountDisplayMode mode) async {
   await dataSource.saveAmountDisplayMode(mode);
 }

 @override
 Future<void> updateBlinkEnabled(bool enabled) async {
   await dataSource.saveBlinkEnabled(enabled);
 }

 @override
 Future<void> updateFontFamily(FontFamily font) async {
   await dataSource.saveFontFamily(font);
 }

 @override
 Future<void> updateHapticEnabled(bool enabled) async {    // ğŸ†• ì¶”ê°€
   await dataSource.saveHapticEnabled(enabled);
 }

 @override
 Future<void> updatePortraitLocked(bool locked) async {    // ğŸ†• ì¶”ê°€
   await dataSource.savePortraitLocked(locked);
 }

 @override
 Future<void> clearCache() async {
   await dataSource.clearCache();
 }

 @override
 Future<void> resetSettings() async {
   await dataSource.resetAllSettings();
 }
}\n\n// ====== lib/data/repositories/surge_repository_impl.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/surge.dart';
import '../../domain/repositories/surge_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° í´ë˜ìŠ¤
class SurgeData {
  double? basePrice;      // ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  double currentPrice = 0; // í˜„ì¬ ê°€ê²© (ê³„ì† ì—…ë°ì´íŠ¸)
  double changePercent = 0; // ë³€ë™ë¥  (ê³„ì† ì¬ê³„ì‚°)

  SurgeData({this.basePrice, this.currentPrice = 0, this.changePercent = 0});

  void updatePrice(double price) {
    basePrice ??= price;
    currentPrice = price;
    changePercent = basePrice != null && basePrice! > 0 
        ? ((currentPrice - basePrice!) / basePrice!) * 100 
        : 0.0;
  }

  void reset(double price) {
    basePrice = price;
    currentPrice = price;
    changePercent = 0.0;
  }
}

/// â™»ï¸ 100ms ë°°ì¹˜ ì‹œìŠ¤í…œ + ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë°ì„ ì ìš©í•œ ê¸‰ë“±/ê¸‰ë½ Repository
class SurgeRepositoryImpl implements SurgeRepository {
  final TradeRemoteDataSource _remote;

  // ğŸ“Š ê¸‰ë“±/ê¸‰ë½ ìƒíƒœ ê´€ë¦¬ (ì‹¤ì‹œê°„ ë³€ë™ë¥ )
  final Map<String, Map<String, SurgeData>> _surgeByTimeFrame = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„)
  final Map<String, StreamController<Map<String, SurgeData>>> _surgeControllers = {};
  
  // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
  final Map<String, DateTime> _timeFrameStartTimes = {};
  
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _surgeStream;
  StreamSubscription<Trade>? _surgeSubscription;
  
  // ğŸ†• ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ íƒ€ì´ë¨¸
  Timer? _batchUpdateTimer;
  
  // ğŸ†• dispose ìƒíƒœ ê´€ë¦¬
  bool _disposed = false;

  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxMarketsPerTimeFrame = 200; // ğŸ†• ë©”ëª¨ë¦¬ ì œí•œ ì¶”ê°€
  static const int _maxCacheSize = 1000;
  // ğŸ†• ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì£¼ê¸° (100ms)
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

  SurgeRepositoryImpl(this._remote) {
    _initializeSurgeTracking();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SURGE ì „ìš© ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê¸‰ë“±/ê¸‰ë½ ì¶”ì  ì´ˆê¸°í™”
  void _initializeSurgeTracking() {
    for (final timeFrameMinutes in AppConfig.timeFrames) {
      final timeFrameStr = '${timeFrameMinutes}m';
      
      // ë¹ˆ ê¸‰ë“±/ê¸‰ë½ ë§µ ì´ˆê¸°í™”
      _surgeByTimeFrame[timeFrameStr] = <String, SurgeData>{};
      
      // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
      _surgeControllers[timeFrameStr] = StreamController<Map<String, SurgeData>>.broadcast();
      
      // ì‹œì‘ ì‹œê°„ ì„¤ì •
      _timeFrameStartTimes[timeFrameStr] = DateTime.now();
      
      // ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§ (Volumeê³¼ ë™ì¼)
      _scheduleNextReset(timeFrameStr, timeFrameMinutes);
    }
    
    if (kDebugMode) {
      debugPrint('ğŸš€ Surge tracking initialized for ${AppConfig.timeFrames.length} timeframes');
    }
  }

  /// ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§ (Volumeê³¼ ë™ì¼í•œ íŒ¨í„´)
  void _scheduleNextReset(String timeFrame, int minutes) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame]!;
    final nextReset = startTime.add(Duration(minutes: minutes));
    final delay = nextReset.difference(now);
    
    if (delay.isNegative) {
      // ì´ë¯¸ ì§€ë‚œ ì‹œê°„ì´ë©´ ì¦‰ì‹œ ë¦¬ì…‹ í›„ ë‹¤ìŒ ì£¼ê¸° ì˜ˆì•½
      _resetTimeFrame(timeFrame);
      _timeFrameStartTimes[timeFrame] = now;
      _scheduleNextReset(timeFrame, minutes);
    } else {
      Timer(delay, () {
        _resetTimeFrame(timeFrame);
        _timeFrameStartTimes[timeFrame] = DateTime.now();
        _scheduleNextReset(timeFrame, minutes); // ì¬ê·€ ì˜ˆì•½
      });
    }
  }

  /// ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryì™€ ë…ë¦½ì )
  void _initializeSurgeStream(List<String> markets) {
    if (_surgeStream != null) return;
    
    debugPrint('SurgeRepositoryImpl: initializing surge stream for ${markets.length} markets');
    
    _surgeStream = _remote.watch(markets).asBroadcastStream();
    
    _surgeSubscription = _surgeStream!.listen(
      _processRawTradeForSurge,
      onError: (error, stackTrace) {
        debugPrint('Surge stream error: $error');
        debugPrint('StackTrace: $stackTrace');
      },
      onDone: () {
        debugPrint('Surge stream done');
      },
    );
  }

  /// Map<String, SurgeData>ë¥¼ Surge ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ì •ë ¬ í¬í•¨)
  List<Surge> _createSurgeList(Map<String, SurgeData> surgeMap, String timeFrame) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame] ?? now;
    
    final surgeList = surgeMap.entries
        .where((entry) => entry.value.basePrice != null && entry.value.changePercent != 0)
        .map((entry) => Surge(
              market: entry.key,
              changePercent: entry.value.changePercent,
              basePrice: entry.value.basePrice!,
              currentPrice: entry.value.currentPrice,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame,
              timeFrameStartMs: startTime.millisecondsSinceEpoch,
            ))
        .toList();

    // ğŸš€ ë³€ë™ë¥  ì‹¤ì œê°’ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ê¸‰ë“±ì´ ìœ„ì—, ê¸‰ë½ì´ ì•„ë˜ì—)
    surgeList.sort((a, b) => b.changePercent.compareTo(a.changePercent));
    
    return surgeList;
  }

  @override
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets) {
    debugPrint('SurgeRepositoryImpl: watchSurgeByTimeFrame() - timeFrame: $timeFrame');
    
    _initializeSurgeStream(markets);
    
    return _surgeControllers[timeFrame]?.stream
        .map((surgeMap) => _createSurgeList(surgeMap, timeFrame))
        ?? const Stream.empty();
  }

  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ë³€ë™ë¥ ë¡œ ê³„ì‚°í•˜ê³  ì—…ë°ì´íŠ¸ ì˜ˆì•½
  void _processRawTradeForSurge(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';
      if (!_seenIds.add(key)) return;

      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ğŸš€ ë³€ë™ë¥  ê³„ì‚° í›„, ì¦‰ì‹œ ì—…ë°ì´íŠ¸ ëŒ€ì‹  'ì—…ë°ì´íŠ¸ ì˜ˆì•½'
      _calculateSurgeAndScheduleUpdate(trade);
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTradeForSurge error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// ğŸš€ ê±°ë˜ ë°ì´í„°ë¥¼ ë°›ì•„ ë³€ë™ë¥  ê³„ì‚° í›„, ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
  void _calculateSurgeAndScheduleUpdate(Trade trade) {
    final market = trade.market;
    final currentPrice = trade.price;
    
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      final surgeMap = _surgeByTimeFrame[timeFrameStr]!;
      
      // ğŸ†• í¬ê¸° ì œí•œ (ìƒìœ„ 200ê°œë§Œ ìœ ì§€) - Volumeê³¼ ë™ì¼í•œ íŒ¨í„´
      if (surgeMap.length > _maxMarketsPerTimeFrame) {
        final sorted = surgeMap.entries.toList()
          ..sort((a, b) => b.value.changePercent.abs().compareTo(a.value.changePercent.abs()));
        surgeMap.clear();
        surgeMap.addAll(Map.fromEntries(sorted.take(_maxMarketsPerTimeFrame)));
      }
      
      final surgeData = surgeMap[market] ??= SurgeData();
      surgeData.updatePrice(currentPrice);
    }
    
    // ğŸš€ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ ëŒ€ì‹ , ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
    _scheduleBatchUpdate();
  }

  /// ğŸ†• ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    // ì´ë¯¸ ì˜ˆì•½ëœ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì·¨ì†Œ (ë””ë°”ìš´ì‹±)
    _batchUpdateTimer?.cancel();
    
    // ì§€ì •ëœ ì‹œê°„(100ms) í›„ì— ì—…ë°ì´íŠ¸ ì‹¤í–‰
    _batchUpdateTimer = Timer(_batchUpdateInterval, _performBatchUpdate);
  }

  /// ğŸš€ ëª¨ë“  ì‹œê°„ëŒ€ì˜ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ì„ 'ë°°ì¹˜' ì—…ë°ì´íŠ¸ (íƒ€ì´ë¨¸ì— ì˜í•´ í˜¸ì¶œë¨)
  void _performBatchUpdate() {
    // ğŸ†• dispose ê°€ë“œ ì¶”ê°€
    if (_disposed) return;
    
    try {
      for (final entry in _surgeByTimeFrame.entries) {
        final timeFrameStr = entry.key;
        final surgeMap = Map<String, SurgeData>.from(entry.value);
        
        final controller = _surgeControllers[timeFrameStr];
        if (controller != null && !controller.isClosed) {
          controller.add(surgeMap);
        }
      }
      
      if (kDebugMode) {
        final totalMarkets = _surgeByTimeFrame.values.isNotEmpty 
            ? _surgeByTimeFrame.values.first.length 
            : 0;
        if (totalMarkets > 0) {
          debugPrint('ğŸš€ğŸš€ Surge batch update: $totalMarkets markets (every 100ms)');
        }
      }
    } catch (e, stackTrace) {
      debugPrint('_performBatchUpdate error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ë¦¬ì…‹
  void _resetTimeFrame(String timeFrameStr) {
    // ğŸš€ ë³€ë™ë¥  ë¦¬ì…‹: í˜„ì¬ ê°€ê²©ì„ ìƒˆë¡œìš´ basePriceë¡œ ì„¤ì •
    final surgeMap = _surgeByTimeFrame[timeFrameStr];
    if (surgeMap != null) {
      for (final surgeData in surgeMap.values) {
        surgeData.reset(surgeData.currentPrice);
      }
    }
    
    // ğŸš€ ë¦¬ì…‹ í›„ì—ë„ ì¦‰ì‹œ UIì— ë°˜ì˜ë˜ë„ë¡ ë°°ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì§ì ‘ í˜¸ì¶œ
    _performBatchUpdate(); 
  }

  @override
  void resetTimeFrame(String timeFrame) {
    debugPrint('ğŸ”„ Manual reset timeFrame: $timeFrame');
    _resetTimeFrame(timeFrame);
  }

  @override
  void resetAllTimeFrames() {
    debugPrint('ğŸ”„ Manual reset all timeFrames');
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      final surgeMap = _surgeByTimeFrame[timeFrameStr];
      if (surgeMap != null) {
        for (final surgeData in surgeMap.values) {
          surgeData.reset(surgeData.currentPrice);
        }
      }
    }
    // ğŸš€ ë¦¬ì…‹ í›„ì—ë„ ì¦‰ì‹œ UIì— ë°˜ì˜ë˜ë„ë¡ ë°°ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì§ì ‘ í˜¸ì¶œ
    _performBatchUpdate();
  }

  @override
  DateTime? getNextResetTime(String timeFrame) {
    final startTime = _timeFrameStartTimes[timeFrame];
    if (startTime == null) return null;
    
    final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (timeFrameMinutes == null) return null;
    
    return startTime.add(Duration(minutes: timeFrameMinutes));
  }

  @override
  List<String> getActiveTimeFrames() {
    return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  }

  @override
  bool isTimeFrameActive(String timeFrame) {
    return getActiveTimeFrames().contains(timeFrame);
  }

  @override
  Future<void> dispose() async {
    debugPrint('SurgeRepositoryImpl: dispose() called');
    
    // ğŸ†• dispose ìƒíƒœ ë¨¼ì € ì„¤ì •
    _disposed = true;
    
    // ğŸ†• ë°°ì¹˜ íƒ€ì´ë¨¸ ì •ë¦¬
    _batchUpdateTimer?.cancel();
    
    await _surgeSubscription?.cancel();
    _surgeStream = null;
    
    for (final controller in _surgeControllers.values) {
      await controller.close();
    }
    
    debugPrint('SurgeRepositoryImpl: dispose completed');
  }
}\n\n// ====== lib/data/repositories/signal_repository_impl copy.dart ======\n
\n\n// ====== lib/data/repositories/market_mood_repository_impl.dart ======\n
// lib/data/repositories/market_mood_repository_impl.dart
// ğŸ—ï¸ Data Layer: Repository êµ¬í˜„ì²´ (Domain ì¸í„°í˜ì´ìŠ¤ ì™„ì „ ë§¤ì¹­)

import 'dart:async';
import 'package:rxdart/rxdart.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/repositories/market_mood_repository.dart';
import '../datasources/market_mood_local_ds.dart';
import '../datasources/market_mood_remote_ds.dart';
import '../models/market_mood_dto.dart';

/// ğŸ—ï¸ ë§ˆì¼“ë¬´ë“œ Repository êµ¬í˜„ì²´
/// Remote + Local DataSourceë¥¼ í†µí•©í•˜ì—¬ Domain Entityë¡œ ë³€í™˜í•˜ì—¬ ì œê³µ
class MarketMoodRepositoryImpl implements MarketMoodRepository {
  final MarketMoodRemoteDataSource _remoteDataSource;
  final MarketMoodLocalDataSource _localDataSource;

  // [ë¦¬íŒ©í† ë§] ìˆ˜ë™ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ê°€ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ë³€ìˆ˜ ì‚­ì œ
  // StreamController<MarketMoodData>? _marketDataController;
  // StreamSubscription? _remoteSubscription;

  MarketMoodRepositoryImpl(this._remoteDataSource, this._localDataSource);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸŒ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Stream<MarketMoodData> getMarketDataStream() {
    // [ë¦¬íŒ©í† ë§] listen-add ëŒ€ì‹ , stream ì—°ì‚°ìë¥¼ ì‚¬ìš©í•œ ì„ ì–¸ì  ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    return _remoteDataSource
        .getGlobalMarketDataStream()
        .doOnData((globalDataDto) async {
          try {
            final volumeDto = TimestampedVolume(
              timestamp: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
              volumeUsd: globalDataDto.totalVolumeUsd,
            );
            await _localDataSource.addVolumeData(volumeDto);
            log.d('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì™„ë£Œ');
          } catch (e, st) {
            log.e('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì‹¤íŒ¨', e, st);
          }
        })
        .map((globalDataDto) {
          log.d('ğŸ“Š DTO -> Entity ë³€í™˜ ì™„ë£Œ');
          return MarketMoodData(
            totalMarketCapUsd: globalDataDto.totalMarketCapUsd,
            totalVolumeUsd: globalDataDto.totalVolumeUsd,
            btcDominance: globalDataDto.btcDominance,
            marketCapChange24h: globalDataDto.marketCapChangePercentage24hUsd,
            updatedAt: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
          );
        });
  }

  @override
  Future<MarketMoodData?> getCurrentMarketData() async {
    try {
      // [ìˆ˜ì •] remoteDataSourceëŠ” ì´ì œ DTOë¥¼ ë°˜í™˜
      final dataDto = await _remoteDataSource.getGlobalMarketData();
      
      final marketData = MarketMoodData(
        totalMarketCapUsd: dataDto.totalMarketCapUsd,
        totalVolumeUsd: dataDto.totalVolumeUsd,
        btcDominance: dataDto.btcDominance,
        marketCapChange24h: dataDto.marketCapChangePercentage24hUsd,
        updatedAt: DateTime.fromMillisecondsSinceEpoch(dataDto.updatedAt * 1000),
      );
      
      log.d('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì„±ê³µ');
      return marketData;
    } catch (e, st) {
      log.e('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double> getExchangeRate() async {
    try {
      final cachedRate = await _localDataSource.getCachedExchangeRate();
      if (cachedRate != null) {
        return cachedRate;
      }
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      return rate;
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©', e, st);
      return 1400.0;
    }
  }

  @override
  Future<void> refreshExchangeRate() async {
    try {
      log.i('ğŸ’± í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      log.i('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (ë³¼ë¥¨ ë²„í¼) - Domain Entity ì‚¬ìš©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> addVolumeData(VolumeData volume) async {
    try {
      final volumeDto = TimestampedVolume.fromEntity(volume);
      await _localDataSource.addVolumeData(volumeDto);
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final volumeDto = await _localDataSource.getVolumeNMinutesAgo(minutes);
      return volumeDto?.toEntity();
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double?> getAverageVolume(int days) async {
    return _localDataSource.getAverageVolume(days);
  }

  @override
  Future<int> getCollectedDataCount() async {
    return _localDataSource.getCollectedDataCount();
  }

  @override
  DateTime getAppStartTime() {
    return _localDataSource.getAppStartTime();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> syncMissingData() async {
    await _localDataSource.checkAndFillMissingSlots();
  }

  @override
  Future<void> clearOldData() async {
    await _localDataSource.trimOldData(keepCount: 336); // 7ì¼ * 48ìŠ¬ë¡¯/ì¼
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final localInfo = _localDataSource.getDebugInfo();
    final remoteHealth = await _remoteDataSource.checkApiHealth();
    final dataCount = await getCollectedDataCount();
    final appStartTime = getAppStartTime();
    final elapsedMinutes = DateTime.now().difference(appStartTime).inMinutes;

    return {
      'status': 'healthy',
      'local_storage': localInfo,
      'remote_api': {'healthy': remoteHealth, 'status': remoteHealth ? 'ok' : 'error'},
      'data_count': dataCount,
      'app_start_time': appStartTime.toIso8601String(),
      'elapsed_minutes': elapsedMinutes,
      'last_check': DateTime.now().toIso8601String(),
    };
  }

  @override
  Future<void> logCurrentStatus() async {
    final health = await getSystemHealth();
    _localDataSource.logStatus();
    log.i('ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì‹œìŠ¤í…œ ìƒíƒœ: $health');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> injectTestVolumeData(List<VolumeData> testData) async {
    if (testData.isEmpty) return;
    for (final volume in testData) {
      await addVolumeData(volume);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> dispose() async {
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘');
    _remoteDataSource.dispose();
    await _localDataSource.dispose();
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import
import '../../domain/repositories/volume_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ë³¼ë¥¨ ì „ìš© Repository - ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ TradeRemoteDataSource ê³µìœ 
class VolumeRepositoryImpl implements VolumeRepository {
 final TradeRemoteDataSource _remote;

 // ğŸ“Š ë³¼ë¥¨ ìƒíƒœ ê´€ë¦¬ (ì‹¤ì‹œê°„ ëˆ„ì )
 final Map<String, Map<String, double>> _volumeByTimeFrame = {};
 final Set<String> _seenIds = {};
 
 // ğŸ¯ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„)
 final Map<String, StreamController<Map<String, double>>> _volumeControllers = {};
 
 // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
 final Map<String, DateTime> _timeFrameStartTimes = {};
 
 // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
 Stream<Trade>? _volumeStream;
 StreamSubscription<Trade>? _volumeSubscription;
 
 // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ íƒ€ì´ë¨¸
 Timer? _batchUpdateTimer;
 
 // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
 static const int _maxMarketsPerTimeFrame = 200; // ğŸ”§ ë©”ëª¨ë¦¬ ì œí•œ ì¶”ê°€
 static const int _maxCacheSize = 1000;
 static const Duration _batchUpdateInterval = Duration(milliseconds: 100); // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ ì¶”ê°€

 VolumeRepositoryImpl(this._remote) {
   // ğŸ†• ë³¼ë¥¨ ê´€ë ¨ ì´ˆê¸°í™”
   _initializeVolumeTracking();
 }

 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 // ğŸ†• VOLUME ì „ìš© ë©”ì„œë“œë“¤
 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

 /// ë³¼ë¥¨ ì¶”ì  ì´ˆê¸°í™”
 void _initializeVolumeTracking() {
   for (final timeFrameMinutes in AppConfig.timeFrames) {
     final timeFrameStr = '${timeFrameMinutes}m';
     
     // ë¹ˆ ë³¼ë¥¨ ë§µ ì´ˆê¸°í™”
     _volumeByTimeFrame[timeFrameStr] = <String, double>{};
     
     // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
     _volumeControllers[timeFrameStr] = StreamController<Map<String, double>>.broadcast();
     
     // ì‹œì‘ ì‹œê°„ ì„¤ì •
     _timeFrameStartTimes[timeFrameStr] = DateTime.now();
     
     // ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
     _scheduleNextReset(timeFrameStr, timeFrameMinutes);
   }
   
   if (kDebugMode) {
     debugPrint('ğŸ¯ Volume tracking initialized for ${AppConfig.timeFrames.length} timeframes');
   }
 }

 /// ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
 void _scheduleNextReset(String timeFrame, int minutes) {
   final now = DateTime.now();
   final startTime = _timeFrameStartTimes[timeFrame]!;
   final nextReset = startTime.add(Duration(minutes: minutes));
   final delay = nextReset.difference(now);
   
   if (delay.isNegative) {
     // ì´ë¯¸ ì§€ë‚œ ì‹œê°„ì´ë©´ ì¦‰ì‹œ ë¦¬ì…‹ í›„ ë‹¤ìŒ ì£¼ê¸° ì˜ˆì•½
     _resetTimeFrame(timeFrame);
     _timeFrameStartTimes[timeFrame] = now;
     _scheduleNextReset(timeFrame, minutes);
   } else {
     Timer(delay, () {
       _resetTimeFrame(timeFrame);
       _timeFrameStartTimes[timeFrame] = DateTime.now();
       _scheduleNextReset(timeFrame, minutes); // ì¬ê·€ ì˜ˆì•½
     });
   }
 }

 /// ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryì™€ ë…ë¦½ì )
 void _initializeVolumeStream(List<String> markets) {
   if (_volumeStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
   
   debugPrint('VolumeRepositoryImpl: initializing volume stream for ${markets.length} markets');
   
   // ğŸ¯ TradeRemoteDataSource ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
   _volumeStream = _remote.watch(markets).asBroadcastStream();
   
   // ğŸ¯ ë³¼ë¥¨ ì „ìš© êµ¬ë… (ì›ì‹œ ë°ì´í„° ë°”ë¡œ ì²˜ë¦¬)
   _volumeSubscription = _volumeStream!.listen(
     _processRawTradeForVolume,
     onError: (error, stackTrace) {
       debugPrint('Volume stream error: $error');
       debugPrint('StackTrace: $stackTrace');
     },
     onDone: () {
       debugPrint('Volume stream done');
     },
   );
 }

 /// Map<String, double>ì„ Volume ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ì •ë ¬ í¬í•¨)
 List<Volume> _createVolumeList(Map<String, double> volumeMap, String timeFrame) {
   final now = DateTime.now();
   final startTime = _timeFrameStartTimes[timeFrame] ?? now;
   
   final volumeList = volumeMap.entries
       .where((entry) => entry.value > 0) // ë³¼ë¥¨ì´ 0ë³´ë‹¤ í° ê²ƒë§Œ
       .map((entry) => Volume(
             market: entry.key,
             totalVolume: entry.value,
             lastUpdatedMs: now.millisecondsSinceEpoch,
             timeFrame: timeFrame,
             timeFrameStartMs: startTime.millisecondsSinceEpoch,
           ))
       .toList();

   // ë³¼ë¥¨ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ìˆœ)
   volumeList.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
   
   return volumeList;
 }

 @override
 Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets) {
   debugPrint('VolumeRepositoryImpl: watchVolumeByTimeFrame() - timeFrame: $timeFrame');
   
   // ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeVolumeStream(markets);
   
   // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (Volume ë¦¬ìŠ¤íŠ¸ë¡œ)
   return _volumeControllers[timeFrame]?.stream
       .map((volumeMap) => _createVolumeList(volumeMap, timeFrame))
       ?? const Stream.empty();
 }

 /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ë³¼ë¥¨ìœ¼ë¡œ ëˆ„ì  (ë°°ì¹˜ ì²˜ë¦¬)
 void _processRawTradeForVolume(Trade trade) {
   try {
     final key = '${trade.market}/${trade.sequentialId}';

     // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
     if (!_seenIds.add(key)) return;

     // ë©”ëª¨ë¦¬ ê´€ë¦¬
     if (_seenIds.length > _maxCacheSize) {
       final removeCount = (_seenIds.length / 4).ceil();
       final toRemove = _seenIds.take(removeCount).toList();
       _seenIds.removeAll(toRemove);
     }

     // ğŸš€ ë³¼ë¥¨ ë°°ì¹˜ ëˆ„ì 
     _accumulateVolume(trade);
     
   } catch (e, stackTrace) {
     debugPrint('_processRawTradeForVolume error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// ğŸ”§ ê±°ë˜ ë°ì´í„°ë¥¼ ë°›ì„ ë•Œë§ˆë‹¤ ë³¼ë¥¨ ëˆ„ì  (ë°°ì¹˜ ì²˜ë¦¬)
 void _accumulateVolume(Trade trade) {
   final market = trade.market;
   final totalAmount = trade.total;
   
   // ëª¨ë“  ì‹œê°„ëŒ€ì— ë™ì‹œ ëˆ„ì 
   for (final timeFrameStr in _volumeByTimeFrame.keys) {
     final volumeMap = _volumeByTimeFrame[timeFrameStr]!;
     
     // ğŸ”§ í¬ê¸° ì œí•œ (ìƒìœ„ 200ê°œë§Œ ìœ ì§€)
     if (volumeMap.length > _maxMarketsPerTimeFrame) {
       final sorted = volumeMap.entries.toList()
         ..sort((a, b) => b.value.compareTo(a.value));
       volumeMap.clear();
       volumeMap.addAll(Map.fromEntries(sorted.take(_maxMarketsPerTimeFrame)));
     }
     
     volumeMap[market] = (volumeMap[market] ?? 0.0) + totalAmount;
   }
   
   // ğŸš€ ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ìœ¼ë¡œ ë³€ê²½
   _scheduleBatchUpdate();
 }

 /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
 void _scheduleBatchUpdate() {
   _batchUpdateTimer?.cancel();
   _batchUpdateTimer = Timer(_batchUpdateInterval, () {
     _updateVolumeStreams();
   });
 }

 /// ğŸ”§ ëª¨ë“  ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
 void _updateVolumeStreams() {
   try {
     for (final entry in _volumeByTimeFrame.entries) {
       final timeFrameStr = entry.key;
       final volumeMap = Map<String, double>.from(entry.value);
       
       // í•´ë‹¹ ì‹œê°„ëŒ€ ìŠ¤íŠ¸ë¦¼ì— ë°ì´í„° ì „ì†¡
       final controller = _volumeControllers[timeFrameStr];
       if (controller != null && !controller.isClosed) {
         controller.add(volumeMap);
       }
     }
     
     if (kDebugMode) {
       final totalMarkets = _volumeByTimeFrame.values.isNotEmpty 
           ? _volumeByTimeFrame.values.first.length 
           : 0;
       if (totalMarkets > 0) {
         debugPrint('ğŸš€ Volume streams updated (batch): $totalMarkets markets');
       }
     }
   } catch (e, stackTrace) {
     debugPrint('_updateVolumeStreams error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// íŠ¹ì • ì‹œê°„ëŒ€ ë¦¬ì…‹
 void _resetTimeFrame(String timeFrameStr) {
   _volumeByTimeFrame[timeFrameStr]?.clear();
   _updateVolumeStreams(); // ë¦¬ì…‹ í›„ ë¹ˆ ë°ì´í„° ì „ì†¡
 }

 @override
 void resetTimeFrame(String timeFrame) {
   debugPrint('ğŸ”„ Manual reset timeFrame: $timeFrame');
   _resetTimeFrame(timeFrame);
 }

 @override
 void resetAllTimeFrames() {
   debugPrint('ğŸ”„ Manual reset all timeFrames');
   for (final timeFrameStr in _volumeByTimeFrame.keys) {
     _volumeByTimeFrame[timeFrameStr]?.clear();
   }
   _updateVolumeStreams();
 }

 @override
 DateTime? getNextResetTime(String timeFrame) {
   final startTime = _timeFrameStartTimes[timeFrame];
   if (startTime == null) return null;
   
   final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
   if (timeFrameMinutes == null) return null;
   
   return startTime.add(Duration(minutes: timeFrameMinutes));
 }

 @override
 List<String> getActiveTimeFrames() {
   return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 }

 @override
 bool isTimeFrameActive(String timeFrame) {
   return getActiveTimeFrames().contains(timeFrame);
 }

 @override
 Future<void> dispose() async {
   debugPrint('VolumeRepositoryImpl: dispose() called');
   
   // ğŸš€ ë°°ì¹˜ íƒ€ì´ë¨¸ ì •ë¦¬ ì¶”ê°€
   _batchUpdateTimer?.cancel();
   
   // ë³¼ë¥¨ êµ¬ë… ì •ë¦¬
   await _volumeSubscription?.cancel();
   _volumeStream = null;
   
   // ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
   for (final controller in _volumeControllers.values) {
     await controller.close();
   }
   
   debugPrint('VolumeRepositoryImpl: dispose completed');
 }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_cache_ds.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹ì˜ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ì ìš©í•œ Repository
class TradeRepositoryImpl implements TradeRepository {
 final TradeRemoteDataSource _remote;
 final TradeCacheDataSource _cache;
 final TradeAggregator _aggregator;

 // ğŸ“Š ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ TradeNotifier ë°©ì‹)
 final Map<double, List<Trade>> _filterLists = {};
 final Set<String> _seenIds = {};
 
 // ğŸ¯ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
 final StreamController<List<Trade>> _filteredController = StreamController<List<Trade>>.broadcast();
 final StreamController<Trade> _aggregatedController = StreamController<Trade>.broadcast();
 
 // ğŸ”¥ í•µì‹¬: ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
 Stream<Trade>? _masterStream;
 StreamSubscription<Trade>? _masterSubscription;
 Timer? _periodicFlushTimer;
 Timer? _batchUpdateTimer;
 
 // ğŸ¯ ë™ì  ì„ê³„ê°’ ê´€ë¦¬
 double _currentThreshold = 20000000.0; // ê¸°ë³¸ê°’: 2ì²œë§Œì›
 
 // ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ê´€ë¦¬
 bool _isRangeMode = false; // false: ëˆ„ì  ëª¨ë“œ(ê¸°ë³¸), true: êµ¬ê°„ ëª¨ë“œ
 
 // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
 static const int _maxTrades = 200;
 static const int _maxCacheSize = 1000;
 static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

 TradeRepositoryImpl(this._remote, this._cache)
     : _aggregator = TradeAggregator() {
   
   // í•„í„° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
   for (final filter in AppConfig.tradeFilters) {
     _filterLists[filter] = [];
   }
   
   // ì£¼ê¸°ì  í”ŒëŸ¬ì‹œ íƒ€ì´ë¨¸
   _periodicFlushTimer = Timer.periodic(
     AppConfig.globalResetInterval,
     (_) => _aggregator.flushTrades(onTradeProcessed: _handleProcessedTrade),
   );
 }

 /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ í˜¸ì¶œ)
 void _initializeMasterStream(List<String> markets) {
   if (_masterStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
   
   debugPrint('TradeRepositoryImpl: initializing master stream for ${markets.length} markets');
   
   // ğŸ¯ ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ìƒì„± (ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ ë‹¤ë¥¸ Repositoryë„ êµ¬ë… ê°€ëŠ¥)
   _masterStream = _remote.watch(markets).asBroadcastStream();
   
   // ğŸ¯ ë‹¨ì¼ êµ¬ë…ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì²˜ë¦¬
   _masterSubscription = _masterStream!.listen(
     _processRawTrade,
     onError: (error, stackTrace) {
       debugPrint('Master stream error: $error');
       debugPrint('StackTrace: $stackTrace');
     },
     onDone: () {
       debugPrint('Master stream done');
     },
   );
 }

 @override
 Stream<Trade> watchTrades(List<String> markets) {
   debugPrint('TradeRepositoryImpl: watchTrades() - ${markets.length} markets');
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeMasterStream(markets);
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì¶”ê°€ êµ¬ë… ì—†ìŒ)
   return _masterStream!;
 }

 @override
 Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
   debugPrint('TradeRepositoryImpl: watchFilteredTrades() - threshold: $threshold');
   
   // ğŸ¯ ìˆ˜ì •: ì„ê³„ê°’ ì—…ë°ì´íŠ¸
   _currentThreshold = threshold;
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeMasterStream(markets);
   
   // ì„ê³„ê°’ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì¬í•„í„°ë§
   _scheduleBatchUpdate();
   
   // ë°°ì¹˜ ì²˜ë¦¬ëœ ê²°ê³¼ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
   return _filteredController.stream;
 }

 @override
 Stream<Trade> watchAggregatedTrades() {
   return _aggregatedController.stream;
 }

 /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
 @override
 void updateThreshold(double threshold) {
   if (_currentThreshold != threshold) {
     _currentThreshold = threshold;
     debugPrint('ğŸ¯ Threshold updated to: ${threshold.toStringAsFixed(0)}');
     
     // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
     _scheduleBatchUpdate();
   }
 }

 /// ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì—…ë°ì´íŠ¸
 @override
 void updateRangeMode(bool isRangeMode) {
   if (_isRangeMode != isRangeMode) {
     _isRangeMode = isRangeMode;
     debugPrint('ğŸ”„ Range mode updated to: ${isRangeMode ? "êµ¬ê°„" : "ëˆ„ì "}');
     
     // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
     _scheduleBatchUpdate();
   }
 }
 
 /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹)
 void _processRawTrade(Trade trade) async {
   try {
     final key = '${trade.market}/${trade.sequentialId}';

     // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
     if (!_seenIds.add(key)) return;

     // ë©”ëª¨ë¦¬ ê´€ë¦¬
     if (_seenIds.length > _maxCacheSize) {
       final removeCount = (_seenIds.length / 4).ceil();
       final toRemove = _seenIds.take(removeCount).toList();
       _seenIds.removeAll(toRemove);
     }

     // ìºì‹œ ì €ì¥
     await _cache.cacheTrade(trade);

     // ğŸ”„ Aggregatorë¥¼ í†µí•œ ê±°ë˜ ì²˜ë¦¬
     _aggregator.processTrade(
       {
         'market': trade.market,
         'price': trade.price,
         'volume': trade.volume,
         'timestamp': trade.timestampMs,
         'isBuy': trade.isBuy,
         'sequential_id': trade.sequentialId,
       },
       onTradeProcessed: _handleProcessedTrade,
     );
     
   } catch (e, stackTrace) {
     debugPrint('_processRawTrade error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }
 
 /// ğŸ¯ ì§‘ê³„ëœ ê±°ë˜ ì²˜ë¦¬ ë° í•„í„°ë§ (í•µì‹¬ ë¡œì§)
 void _handleProcessedTrade(Map<String, dynamic> processedTrade) {
   try {
     // Trade ì—”í‹°í‹°ë¡œ ë³€í™˜
     final trade = Trade(
       market: processedTrade['market'] as String,
       price: processedTrade['price'] as double,
       volume: processedTrade['volume'] as double,
       side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
       changePrice: 0.0,
       changeState: 'EVEN',
       timestampMs: processedTrade['timestamp'] as int,
       sequentialId: processedTrade['sequential_id'] as String,
     );
     
     // ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€
     if (!_aggregatedController.isClosed) {
       _aggregatedController.add(trade);
     }
     
     final total = trade.total;
     
     // ğŸ“‹ ê° í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê±°ë˜ ì¶”ê°€
     for (final filter in AppConfig.tradeFilters) {
       if (total >= filter) {
         final list = _filterLists[filter]!;
         list.insert(0, trade);
         
         // ìµœëŒ€ ê±°ë˜ ìˆ˜ ìœ ì§€
         if (list.length > _maxTrades) {
           list.removeLast();
         }
       }
     }
     
     // ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ê³¼ë„í•œ UI ì—…ë°ì´íŠ¸ ë°©ì§€)
     _scheduleBatchUpdate();
     
   } catch (e, stackTrace) {
     debugPrint('_handleProcessedTrade error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }
 
 /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ì˜ˆì „ í”„ë¡œì íŠ¸ì˜ _updateFilteredTrades ë°©ì‹)
 void _scheduleBatchUpdate() {
   // ì´ë¯¸ ìŠ¤ì¼€ì¤„ëœ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ë¦¬ì…‹
   _batchUpdateTimer?.cancel();
   
   _batchUpdateTimer = Timer(_batchUpdateInterval, () {
     _updateFilteredTrades();
   });
 }
 
 /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ì—…ë°ì´íŠ¸ (UI ì—…ë°ì´íŠ¸) - ğŸ†• êµ¬ê°„/ëˆ„ì  ë¡œì§ ì¶”ê°€
 void _updateFilteredTrades() {
   try {
     final threshold = _currentThreshold;
     
     final merged = <Trade>[];
     final seen = <String>{};

     if (_isRangeMode) {
       // ğŸ†• êµ¬ê°„ ëª¨ë“œ: í˜„ì¬ ì„ê³„ê°’ ~ ë‹¤ìŒ ì„ê³„ê°’ê¹Œì§€ë§Œ
       final nextThreshold = _getNextThreshold(threshold);
       
       for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
         for (final trade in _filterLists[filter] ?? <Trade>[]) {
           final id = '${trade.sequentialId}-${trade.timestampMs}';
           final total = trade.total;
           
           // ğŸ¯ êµ¬ê°„ í•„í„°ë§: threshold <= total < nextThreshold
           if (total >= threshold && total < nextThreshold && seen.add(id)) {
             merged.add(trade);
           }
         }
       }
       
       if (kDebugMode) {
         debugPrint('ğŸ”„ Range mode: ${threshold.toStringAsFixed(0)} ~ ${nextThreshold.toStringAsFixed(0)}');
       }
     } else {
       // ğŸ”„ ëˆ„ì  ëª¨ë“œ: í˜„ì¬ ì„ê³„ê°’ ì´ìƒ ëª¨ë“  ê±°ë˜ (ê¸°ì¡´ ë°©ì‹)
       for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
         for (final trade in _filterLists[filter] ?? <Trade>[]) {
           final id = '${trade.sequentialId}-${trade.timestampMs}';
           if (trade.total >= threshold && seen.add(id)) {
             merged.add(trade);
           }
         }
       }
       
       if (kDebugMode) {
         debugPrint('ğŸ“ˆ Cumulative mode: ${threshold.toStringAsFixed(0)} ì´ìƒ');
       }
     }

     // ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹  ìˆœ)
     merged.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
     
     // ìµœëŒ€ ê±°ë˜ ìˆ˜ë¡œ ì œí•œ
     final result = merged.take(_maxTrades).toList();
     
     // ğŸš€ UIì— ì—…ë°ì´íŠ¸ ì „ì†¡
     if (!_filteredController.isClosed) {
       _filteredController.add(result);
       
       if (kDebugMode && result.isNotEmpty) {
         final modeText = _isRangeMode ? "êµ¬ê°„" : "ëˆ„ì ";
         debugPrint('ğŸ¯ Batch update ($modeText): ${result.length} filtered trades');
       }
     }
     
   } catch (e, stackTrace) {
     debugPrint('_updateFilteredTrades error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// ğŸ†• ë‹¤ìŒ ì„ê³„ê°’ ì°¾ê¸° (êµ¬ê°„ ëª¨ë“œìš©)
 double _getNextThreshold(double currentThreshold) {
   final sortedFilters = AppConfig.tradeFilters.toList()..sort();
   
   for (int i = 0; i < sortedFilters.length; i++) {
     if (sortedFilters[i] == currentThreshold) {
       // ë‹¤ìŒ ì„ê³„ê°’ì´ ìˆìœ¼ë©´ ë°˜í™˜, ì—†ìœ¼ë©´ ë¬´í•œëŒ€
       return i + 1 < sortedFilters.length 
           ? sortedFilters[i + 1] 
           : double.infinity;
     }
   }
   
   // í˜„ì¬ ì„ê³„ê°’ì´ ë¦¬ìŠ¤íŠ¸ì— ì—†ìœ¼ë©´ ê·¸ë³´ë‹¤ í° ì²« ë²ˆì§¸ ê°’ ë°˜í™˜
   for (final filter in sortedFilters) {
     if (filter > currentThreshold) {
       return filter;
     }
   }
   
   return double.infinity;
 }

 @override
 Future<void> dispose() async {
   debugPrint('TradeRepositoryImpl: dispose() called');
   
   // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
   _periodicFlushTimer?.cancel();
   _batchUpdateTimer?.cancel();
   
   // ë§ˆìŠ¤í„° êµ¬ë… ì •ë¦¬
   await _masterSubscription?.cancel();
   _masterStream = null;
   
   // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
   await _filteredController.close();
   await _aggregatedController.close();
   
   // ë°ì´í„°ì†ŒìŠ¤ ì •ë¦¬ (remoteë§Œ)
   await _remote.dispose();
   
   // Aggregator í”ŒëŸ¬ì‹œ
   _aggregator.flushTrades(onTradeProcessed: (_) {});
 }
}\n\n// ====== lib/data/models/market_mood_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'market_mood_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TimestampedVolumeAdapter extends TypeAdapter<TimestampedVolume> {
  @override
  final int typeId = 1;

  @override
  TimestampedVolume read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TimestampedVolume(
      timestamp: fields[0] as DateTime,
      volumeUsd: fields[1] as double,
    );
  }

  @override
  void write(BinaryWriter writer, TimestampedVolume obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.volumeUsd);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimestampedVolumeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalDataDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalDataDto> {
  @override
  final int typeId = 2;

  @override
  CoinGeckoGlobalDataDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalDataDto(
      totalMarketCapUsd: fields[0] as double,
      totalVolumeUsd: fields[1] as double,
      btcDominance: fields[2] as double,
      marketCapChangePercentage24hUsd: fields[3] as double,
      updatedAt: fields[4] as int,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalDataDto obj) {
    writer
      ..writeByte(5)
      ..writeByte(0)
      ..write(obj.totalMarketCapUsd)
      ..writeByte(1)
      ..write(obj.totalVolumeUsd)
      ..writeByte(2)
      ..write(obj.btcDominance)
      ..writeByte(3)
      ..write(obj.marketCapChangePercentage24hUsd)
      ..writeByte(4)
      ..write(obj.updatedAt);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalDataDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalResponseDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalResponseDto> {
  @override
  final int typeId = 3;

  @override
  CoinGeckoGlobalResponseDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalResponseDto(
      data: fields[0] as CoinGeckoGlobalDataDto,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalResponseDto obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.data);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalResponseDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/market_mood_dto.dart ======\n
// lib/data/models/market_mood_dto.dart
// ğŸŒ Data Layer: í†µí•© DTO ëª¨ë¸ (Trade ìŠ¤íƒ€ì¼)

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../core/utils/date_time.dart'; // DateTime extension
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';

part 'market_mood_dto.g.dart';

/// ğŸ“ˆ ì¸íŠ¸ë¼ë°ì´ ë³¼ë¥¨ ë°ì´í„° (30ë¶„ ë‹¨ìœ„) - Hive ëª¨ë¸
@HiveType(typeId: 1) // TradeDtoê°€ typeId: 0 ì‚¬ìš©í•˜ë¯€ë¡œ 1 ì‚¬ìš©
class TimestampedVolume extends HiveObject {
  @HiveField(0)
  final DateTime timestamp;

  @HiveField(1)
  final double volumeUsd;

  TimestampedVolume({
    required this.timestamp,
    required this.volumeUsd,
  });

  /// Domain Entityë¡œ ë³€í™˜
  VolumeData toEntity() => VolumeData(
    timestamp: timestamp,
    volumeUsd: volumeUsd,
  );

  /// Domain Entityì—ì„œ ìƒì„±
  factory TimestampedVolume.fromEntity(VolumeData entity) => TimestampedVolume(
    timestamp: entity.timestamp,
    volumeUsd: entity.volumeUsd,
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'timestamp': timestamp.toIso8601String(),
    'volumeUsd': volumeUsd,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹±
  static TimestampedVolume? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final timestampStr = m['timestamp']?.toString() ?? '';
      final volumeUsd = (m['volumeUsd'] as num?)?.toDouble() ?? 0.0;

      if (timestampStr.isEmpty) return null;

      return TimestampedVolume(
        timestamp: DateTime.parse(timestampStr),
        volumeUsd: volumeUsd,
      );
    } catch (e) {
      log.w('TimestampedVolume.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TimestampedVolume.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TimestampedVolume(
        timestamp: DateTime.now(),
        volumeUsd: 0.0,
      );

  /// DateTime extension í™œìš©
  String get formattedTime => timestamp.yyyyMMddhhmm();
  String get timeAgoText => timestamp.timeAgo();
  String get shortTime => timestamp.hhmmss();

  @override
  String toString() => 'TimestampedVolume($formattedTime, ${volumeUsd.toStringAsFixed(2)}B)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° DTO
@HiveType(typeId: 2)
class CoinGeckoGlobalDataDto extends HiveObject {
  @HiveField(0)
  final double totalMarketCapUsd;

  @HiveField(1)
  final double totalVolumeUsd;

  @HiveField(2)
  final double btcDominance;

  @HiveField(3)
  final double marketCapChangePercentage24hUsd;

  @HiveField(4)
  final int updatedAt;

  CoinGeckoGlobalDataDto({
    required this.totalMarketCapUsd,
    required this.totalVolumeUsd,
    required this.btcDominance,
    required this.marketCapChangePercentage24hUsd,
    required this.updatedAt,
  });

  /// Domain Entityë¡œ ë³€í™˜
  MarketMoodData toEntity() => MarketMoodData(
    totalMarketCapUsd: totalMarketCapUsd,
    totalVolumeUsd: totalVolumeUsd,
    btcDominance: btcDominance,
    marketCapChange24h: marketCapChangePercentage24hUsd,
    updatedAt: DateTime.fromMillisecondsSinceEpoch(updatedAt * 1000),
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'total_market_cap_usd': totalMarketCapUsd,
    'total_volume_usd': totalVolumeUsd,
    'btc_dominance': btcDominance,
    'market_cap_change_percentage_24h_usd': marketCapChangePercentage24hUsd,
    'updated_at': updatedAt,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (CoinGecko API ì‘ë‹µ í˜•íƒœ)
  static CoinGeckoGlobalDataDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch ~/ 1000
            : DateTime.now().millisecondsSinceEpoch ~/ 1000;
      }

      final totalMarketCap = m['total_market_cap'] as Map<String, dynamic>?;
      final totalVolume = m['total_volume'] as Map<String, dynamic>?;
      final marketCapPercentage = m['market_cap_percentage'] as Map<String, dynamic>?;

      return CoinGeckoGlobalDataDto(
        totalMarketCapUsd: parseDouble(totalMarketCap?['usd']),
        totalVolumeUsd: parseDouble(totalVolume?['usd']),
        btcDominance: parseDouble(marketCapPercentage?['btc']),
        marketCapChangePercentage24hUsd: parseDouble(m['market_cap_change_percentage_24h_usd']),
        updatedAt: parseInt(m['updated_at']),
      );
    } catch (e) {
      log.w('CoinGeckoGlobalDataDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalDataDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalDataDto(
        totalMarketCapUsd: 0.0,
        totalVolumeUsd: 0.0,
        btcDominance: 0.0,
        marketCapChangePercentage24hUsd: 0.0,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

  @override
  String toString() => 'CoinGeckoGlobalDataDto(volume: ${totalVolumeUsd.toStringAsFixed(0)}B USD)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ì‘ë‹µ ë˜í¼ DTO
@HiveType(typeId: 3)
class CoinGeckoGlobalResponseDto extends HiveObject {
  @HiveField(0)
  final CoinGeckoGlobalDataDto data;

  CoinGeckoGlobalResponseDto({
    required this.data,
  });

  Map<String, dynamic> toMap() => {
    'data': data.toMap(),
  };

  String toJson() => json.encode(toMap());

  static CoinGeckoGlobalResponseDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      final dataMap = m['data'] as Map<String, dynamic>?;
      if (dataMap == null) return null;
      final data = CoinGeckoGlobalDataDto.tryParse(dataMap);
      if (data == null) return null;
      return CoinGeckoGlobalResponseDto(data: data);
    } catch (e) {
      log.w('CoinGeckoGlobalResponseDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalResponseDto.fromJson(Map<String, dynamic> json) {
     final parsed = tryParse(json);
     if(parsed != null) return parsed;
     
     return CoinGeckoGlobalResponseDto(
        data: CoinGeckoGlobalDataDto(
          totalMarketCapUsd: 0.0,
          totalVolumeUsd: 0.0,
          btcDominance: 0.0,
          marketCapChangePercentage24hUsd: 0.0,
          updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        ),
      );
  }

  @override
  String toString() => 'CoinGeckoGlobalResponseDto(data: $data)';
}\n\n// ====== lib/data/models/trade_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trade_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TradeDtoAdapter extends TypeAdapter<TradeDto> {
  @override
  final int typeId = 0;

  @override
  TradeDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TradeDto(
      market: fields[0] as String,
      price: fields[1] as double,
      volume: fields[2] as double,
      side: fields[3] as String,
      changePrice: fields[4] as double,
      changeState: fields[5] as String,
      timestampMs: fields[6] as int,
      sequentialId: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TradeDto obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.market)
      ..writeByte(1)
      ..write(obj.price)
      ..writeByte(2)
      ..write(obj.volume)
      ..writeByte(3)
      ..write(obj.side)
      ..writeByte(4)
      ..write(obj.changePrice)
      ..writeByte(5)
      ..write(obj.changeState)
      ..writeByte(6)
      ..write(obj.timestampMs)
      ..writeByte(7)
      ..write(obj.sequentialId);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TradeDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/volume_dto.dart ======\n
\n\n// ====== lib/data/models/pattern_data_dto.dart ======\n
\n\n// ====== lib/data/models/trade_dto.dart ======\n
// lib/data/models/trade_dto.dart

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

part 'trade_dto.g.dart';

@HiveType(typeId: 0)
class TradeDto {
  @HiveField(0)
  final String market;

  @HiveField(1)
  final double price;

  @HiveField(2)
  final double volume;

  @HiveField(3)
  final String side;

  @HiveField(4)
  final double changePrice;

  @HiveField(5)
  final String changeState;

  @HiveField(6)
  final int timestampMs;

  @HiveField(7)
  final String sequentialId;

  TradeDto({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  Trade toEntity() => Trade(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestampMs,
        sequentialId: sequentialId,
      );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜ (camelCase í‚¤ ì‚¬ìš©ìœ¼ë¡œ ì‹œìŠ¤í…œ í†µì¼)
  Map<String, dynamic> toMap() => {
        'market': market,
        'price': price,
        'volume': volume,
        'side': side,
        'changePrice': changePrice,
        'changeState': changeState,
        'timestampMs': timestampMs,
        'sequentialId': sequentialId,
      };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (ì—¬ëŸ¬ í‚¤ ë„¤ì´ë° ì§€ì›)
  static TradeDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      log.d('TradeDto.tryParse: ${m.toString().substring(0, m.toString().length.clamp(0, 100))}');

      String parseString(dynamic v, [String fallback = '']) =>
          v != null ? v.toString() : fallback;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch
                              : DateTime.now().millisecondsSinceEpoch;
      }

      final market = parseString(m['market'] ?? m['symbol'] ?? m['code'], 'UNKNOWN');
      final price = parseDouble(m['price'] ?? m['trade_price']);
      final volume = parseDouble(m['volume'] ?? m['trade_volume']);
      final side = parseString(m['side'] ?? m['ask_bid'], 'UNKNOWN');

      final changePrice = parseDouble(m['changePrice'] ?? m['change_price']);
      final changeState = parseString(m['changeState'] ?? m['change_state'], 'EVEN');
      final timestamp = parseInt(m['timestampMs'] ?? m['timestamp_ms'] ?? m['timestamp']);
      final sequentialId = parseString(
        m['sequentialId'] ?? m['sequential_id'] ?? m['sid'], 
        timestamp.toString(),
      );

      return TradeDto(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestamp,
        sequentialId: sequentialId,
      );
    } catch (e) {
      log.w('TradeDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TradeDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TradeDto(
        market: 'ERROR',
        price: 0.0,
        volume: 0.0,
        side: 'UNKNOWN',
        changePrice: 0.0,
        changeState: 'UNKNOWN',
        timestampMs: DateTime.now().millisecondsSinceEpoch,
        sequentialId: 'ERROR',
      );
}
\n\n// ====== lib/data/processors/volume_aggregator.dart ======\n
\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/features/trade/data/utils/trade_aggregator.dart
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ì™€ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Map<String, dynamic>> _lastTrades = {};
  final int mergeWindow = AppConfig.mergeWindowMs;

  /// ê±°ë˜ ì²˜ë¦¬ ë° ë³‘í•© ë¡œì§
  void processTrade(
    Map<String, dynamic> trade, {
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      // ì•ˆì „í•œ null ì²´í¬ì™€ íƒ€ì… ìºìŠ¤íŒ…
      final market = trade['market'] as String? ?? '';
      final price = trade['price'] as double? ?? 0.0;
      final volume = trade['volume'] as double? ?? 0.0;
      final timestamp = trade['timestamp'] as int? ?? 0;
      final isBuy = trade['isBuy'] as bool? ?? true;
      final sequentialId = trade['sequential_id'] as String? ?? '';

      // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (market.isEmpty || price <= 0 || volume <= 0 || timestamp <= 0) {
        if (kDebugMode) {
          debugPrint('TradeAggregator: Invalid trade data, skipping: market=$market, price=$price, volume=$volume, timestamp=$timestamp');
        }
        return;
      }

      final total = price * volume;

      if (_lastTrades.containsKey(market)) {
        final lastTrade = _lastTrades[market]!;
        final lastTs = lastTrade['timestamp'] as int;

        // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê±°ë˜ë©´ ë³‘í•©
        if (timestamp - lastTs <= mergeWindow) {
          final lastTotal = lastTrade['total'] as double;
          final lastVolume = lastTrade['volume'] as double;
          final newTotal = lastTotal + total;
          final newVolume = lastVolume + volume;

          // ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°
          final avgPrice = newTotal / newVolume;

          // ë³‘í•©ëœ ê±°ë˜ ì •ë³´ ì—…ë°ì´íŠ¸
          lastTrade['price'] = avgPrice;
          lastTrade['volume'] = newVolume;
          lastTrade['total'] = newTotal;
          lastTrade['timestamp'] = timestamp; // ìµœì‹  ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          lastTrade['sequential_id'] = sequentialId;
          lastTrade['isBuy'] = isBuy; // ìµœì‹  ê±°ë˜ì˜ ë°©í–¥ ì‚¬ìš©

          if (kDebugMode) {
            debugPrint(
              'Merged trade: $market, total: ${newTotal.toStringAsFixed(0)}, avg_price: ${avgPrice.toStringAsFixed(2)}',
            );
          }
        } else {
          // ì‹œê°„ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚˜ë©´ ì´ì „ ê±°ë˜ ì²˜ë¦¬í•˜ê³  ìƒˆ ê±°ë˜ë¡œ êµì²´
          onTradeProcessed(Map<String, dynamic>.from(lastTrade));
          _lastTrades[market] = {
            'market': market,
            'price': price,
            'volume': volume,
            'total': total,
            'timestamp': timestamp,
            'isBuy': isBuy,
            'sequential_id': sequentialId,
          };
        }
      } else {
        // ìƒˆë¡œìš´ ë§ˆì¼“ì˜ ì²« ê±°ë˜
        final newTrade = {
          'market': market,
          'price': price,
          'volume': volume,
          'total': total,
          'timestamp': timestamp,
          'isBuy': isBuy,
          'sequential_id': sequentialId,
        };
        _lastTrades[market] = newTrade;
        // ğŸ”¥ ì¤‘ìš”: ì²« ê±°ë˜ë„ ë°”ë¡œ ì²˜ë¦¬í•˜ì—¬ UIì— ë°˜ì˜
        onTradeProcessed(Map<String, dynamic>.from(newTrade));
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator processTrade error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í”ŒëŸ¬ì‹œ
  void flushTrades({
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      final tradesCount = _lastTrades.length;
      for (final trade in _lastTrades.values) {
        onTradeProcessed(Map<String, dynamic>.from(trade));
      }
      _lastTrades.clear();
      
      if (kDebugMode) {
        debugPrint('TradeAggregator: $tradesCount trades flushed');
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator flushTrades error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê¹…ìš©)
  Map<String, dynamic>? getPendingTrade(String market) {
    return _lastTrades[market] != null
        ? Map<String, dynamic>.from(_lastTrades[market]!)
        : null;
  }

  /// í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _lastTrades.length;

  /// ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _lastTrades.clear();
  }
}\n\n// ====== lib/data/processors/pattern_analyzer.dart ======\n
\n\n// ====== lib/data/processors/pattern_strategy.dart ======\n
\n\n// ====== lib/data/processors/streaming_market_buffer.dart ======\n
\n\n// ====== lib/data/factories/signal_stream_factory.dart ======\n
\n\n// ====== lib/domain/repositories/surge_repository.dart ======\n
// lib/domain/repositories/surge_repository.dart
import '../entities/surge.dart';

/// ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ì¶”ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class SurgeRepository {
  /// ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ìŠ¤íŠ¸ë¦¼ ì œê³µ (Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³€ë™ë¥  ì ˆëŒ“ê°’ ìˆœ ì •ë ¬)
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/market_mood_repository.dart ======\n
// lib/domain/repositories/market_mood_repository.dart
// ğŸ¯ Domain Layer: Repository ì¸í„°í˜ì´ìŠ¤ (í´ë¦° ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)

import '../entities/market_mood.dart';

/// ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
/// Data Layerì—ì„œ êµ¬í˜„í•´ì•¼ í•  ê³„ì•½ì„ ì •ì˜ (Domain â†’ Data ì˜ì¡´ì„± ì œê±°)
abstract class MarketMoodRepository {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¡ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (30ë¶„ ì£¼ê¸°)
  Stream<MarketMoodData> getMarketDataStream();

  /// í˜„ì¬ ë§ˆì¼“ ë°ì´í„° í•œ ë²ˆ ì¡°íšŒ
  Future<MarketMoodData?> getCurrentMarketData();

  /// í˜„ì¬ USD/KRW í™˜ìœ¨ ì¡°íšŒ (ìºì‹œ í¬í•¨)
  Future<double> getExchangeRate();

  /// í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (Hive ë³¼ë¥¨ ë²„í¼)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ë§ˆë‹¤)
  Future<void> addVolumeData(VolumeData volume);

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes);

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days);

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount();

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ëˆ„ë½ëœ ìŠ¬ë¡¯ ë³´ì •
  Future<void> syncMissingData();

  /// ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
  Future<void> clearOldData();

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth();

  /// í˜„ì¬ ìƒíƒœ ë¡œê¹…
  Future<void> logCurrentStatus();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì…
  Future<void> injectTestVolumeData(List<VolumeData> testData);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë° ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/momentary_repository.dart ======\n
\n\n// ====== lib/domain/repositories/settings_repository.dart ======\n
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';

abstract class SettingsRepository {
 /// í˜„ì¬ ì•± ì„¤ì • ê°€ì ¸ì˜¤ê¸°
 Future<AppSettings> getSettings();

 /// í…Œë§ˆ ëª¨ë“œ ì—…ë°ì´íŠ¸
 Future<void> updateThemeMode(ThemeMode mode);

 /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updateKeepScreenOn(bool value);

 /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì—…ë°ì´íŠ¸
 Future<void> updateSliderPosition(SliderPosition position);

 /// ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
 Future<void> updateDisplayMode(DisplayMode mode);

 /// ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
 Future<void> updateAmountDisplayMode(AmountDisplayMode mode);

 /// ë°˜ì§ì„ íš¨ê³¼ ì—…ë°ì´íŠ¸
 Future<void> updateBlinkEnabled(bool enabled);

 /// í°íŠ¸ íŒ¨ë°€ë¦¬ ì—…ë°ì´íŠ¸
 Future<void> updateFontFamily(FontFamily font);

 /// í–…í‹± í”¼ë“œë°± ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updateHapticEnabled(bool enabled);    // ğŸ†• ì¶”ê°€

 /// í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updatePortraitLocked(bool locked);    // ğŸ†• ì¶”ê°€

 /// ìºì‹œ ë¹„ìš°ê¸°
 Future<void> clearCache();

 /// ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
 Future<void> resetSettings();
}\n\n// ====== lib/domain/repositories/signal_repository.dart ======\n
import '../entities/signal.dart';

/// ğŸš€ Signal Repository ì¸í„°í˜ì´ìŠ¤ V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì§€ì›
/// - ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
/// - ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
/// - ì‹¤ì‹œê°„ ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
abstract class SignalRepository {
  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================
  
  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  );

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets);

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ê¸°ì¡´ + V4.1 í™•ì¥)
  // ==========================================================================
  
  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updatePatternThreshold(PatternType patternType, double threshold);

  /// í˜„ì¬ ì„¤ì •ëœ íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType);

  /// íŒ¨í„´ë³„ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled);

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType);

  /// ê°ì§€ëœ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearSignals(PatternType? patternType);

  // ==========================================================================
  // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥ ê¸°ëŠ¥
  // ==========================================================================
  
  /// íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì—…ë°ì´íŠ¸ (zScoreThreshold, buyRatioMin ë“±)
  void updatePatternConfig(PatternType pattern, String key, double value);

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (conservative, aggressive, balanced)
  void applyPatternPreset(String presetName);

  /// íŒ¨í„´ë³„ í†µê³„ ì •ë³´ ì¡°íšŒ (ì‹ í˜¸ ê°œìˆ˜, ë§ˆì§€ë§‰ ê°ì§€ ì‹œê°„ ë“±)
  Future<Map<String, dynamic>> getPatternStats(PatternType type);

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<Map<String, dynamic>> getSystemHealth();

  /// ë§ˆì¼“ë³„ ë°ì´í„° í’ˆì§ˆ ì¡°íšŒ (ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± í¬í•¨)
  Map<String, dynamic> getMarketDataQuality();

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  Stream<Map<String, dynamic>> watchPerformanceMetrics();

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬ (ë°±í…ŒìŠ¤íŒ…, A/B í…ŒìŠ¤íŠ¸ ì§€ì›)
  // ==========================================================================
  
  /// í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸° (JSON í˜•íƒœ)
  Map<String, dynamic> exportConfiguration();

  /// ì„¤ì • ê°€ì ¸ì˜¤ê¸° (ë°±ì—… ë³µì›, í”„ë¦¬ì…‹ ì ìš©)
  void importConfiguration(Map<String, dynamic> config);

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart
import '../entities/trade.dart';

/// Provides streams of trade data and handles resource cleanup.
abstract class TradeRepository {
 /// Streams raw [Trade] events for the given list of market codes.
 Stream<Trade> watchTrades(List<String> markets);
 
 /// Streams lists of [Trade] filtered by a minimum total trade value.
 /// => markets íŒŒë¼ë¯¸í„° ì¶”ê°€
 Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);
 
 /// Streams aggregated [Trade] events over a merge window.
 Stream<Trade> watchAggregatedTrades();
 
 /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
 void updateThreshold(double threshold);
 
 /// ğŸ†• ìƒˆë¡œ ì¶”ê°€: êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì—…ë°ì´íŠ¸
 void updateRangeMode(bool isRangeMode);
 
 /// Releases any held resources (e.g., WebSocket connections, Hive boxes).
 Future<void> dispose();
}\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
// lib/domain/repositories/volume_repository.dart

import '../entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import

/// ë³¼ë¥¨ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ëˆ„ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class VolumeRepository {
  /// ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ìŠ¤íŠ¸ë¦¼ ì œê³µ (Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³¼ë¥¨ìˆœ ì •ë ¬)
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/signal_usecase.dart ======\n
import '../entities/signal.dart';
import '../repositories/signal_repository.dart';

/// ğŸš€ Signal UseCase V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ì—°ë™
/// - ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
/// - ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§
/// - ë°±í…ŒìŠ¤íŒ… ì§€ì›
/// - ì„±ëŠ¥ ìµœì í™”ëœ í•„í„°ë§
class SignalUseCase {
  final SignalRepository _repository;

  const SignalUseCase(this._repository);

  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    return _repository.watchSignalsByPattern(patternType, markets);
  }

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    return _repository.watchAllSignals(markets);
  }

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ê¸°ë³¸ ê²€ì¦
    if (threshold <= 0) {
      throw ArgumentError('Threshold must be positive: $threshold');
    }

    // V4.1 íŒ¨í„´ë³„ ì„ê³„ê°’ ë²”ìœ„ ê²€ì¦ (ì™„í™”ëœ ê¸°ì¤€ ì ìš©)
    switch (patternType) {
      case PatternType.surge:
        if (threshold < 0.1 || threshold > 50.0) {
          throw ArgumentError('Surge threshold must be between 0.1% and 50%: $threshold');
        }
        break;
      case PatternType.flashFire:
        if (threshold < 1.1 || threshold > 10.0) {
          throw ArgumentError('FlashFire threshold must be between 1.1x and 10x: $threshold');
        }
        break;
      case PatternType.stackUp:
        if (threshold < 2 || threshold > 10) {
          throw ArgumentError('StackUp threshold must be between 2 and 10: $threshold');
        }
        break;
      case PatternType.stealthIn:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 300ë§Œ ~ 1ì–µ
        if (threshold < 3000000 || threshold > 100000000) {
          throw ArgumentError('StealthIn threshold must be between 3M and 100M: $threshold');
        }
        break;
      case PatternType.blackHole:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 0.5% ~ 5%
        if (threshold < 0.5 || threshold > 5.0) {
          throw ArgumentError('BlackHole threshold must be between 0.5% and 5%: $threshold');
        }
        break;
      case PatternType.reboundShot:
        if (threshold < 0.5 || threshold > 20.0) {
          throw ArgumentError('ReboundShot threshold must be between 0.5% and 20%: $threshold');
        }
        break;
    }

    _repository.updatePatternThreshold(patternType, threshold);
  }

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType) {
    return _repository.getPatternThreshold(patternType);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _repository.setPatternEnabled(patternType, enabled);
  }

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType) {
    return _repository.isPatternEnabled(patternType);
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearPatternSignals(PatternType patternType) {
    _repository.clearSignals(patternType);
  }

  /// ëª¨ë“  ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearAllSignals() {
    _repository.clearSignals(null);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì • (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updateAdvancedPatternConfig(PatternType pattern, String key, double value) {
    // ì„¤ì • í‚¤ë³„ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    switch (key) {
      case 'zScoreThreshold':
        if (value < 0.5 || value > 5.0) {
          throw ArgumentError('Z-Score threshold must be between 0.5 and 5.0: $value');
        }
        break;
      case 'buyRatioMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio must be between 0.0 and 1.0: $value');
        }
        break;
      case 'buyRatioMax':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio max must be between 0.0 and 1.0: $value');
        }
        break;
      case 'cvThreshold':
        if (value < 0.001 || value > 0.5) {
          throw ArgumentError('CV threshold must be between 0.001 and 0.5: $value');
        }
        break;
      case 'rSquaredMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('R-squared must be between 0.0 and 1.0: $value');
        }
        break;
      default:
        // ì¼ë°˜ì ì¸ ì–‘ìˆ˜ ê²€ì¦
        if (value < 0) {
          throw ArgumentError('Configuration value must be non-negative: $value');
        }
    }

    _repository.updatePatternConfig(pattern, key, value);
  }

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦)
  void applyPatternPreset(String presetName) {
    final validPresets = ['conservative', 'aggressive', 'balanced'];
    if (!validPresets.contains(presetName.toLowerCase())) {
      throw ArgumentError('Invalid preset name. Valid options: ${validPresets.join(', ')}');
    }

    _repository.applyPatternPreset(presetName);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<PatternPerformanceStats> getPatternPerformance(PatternType pattern) async {
    final stats = await _repository.getPatternStats(pattern);
    final systemHealth = await _repository.getSystemHealth();
    
    return PatternPerformanceStats(
      patternType: pattern,
      totalSignals: stats['totalSignals'] ?? 0,
      recentSignals: stats['recentSignals'] ?? 0,
      lastSignalTime: stats['lastSignalTime'] != null 
          ? DateTime.parse(stats['lastSignalTime'])
          : null,
      isEnabled: stats['isEnabled'] ?? false,
      config: Map<String, double>.from(stats['config'] ?? {}),
      cooldownStatus: Map<String, dynamic>.from(stats['cooldownStatus'] ?? {}),
      onlineMetricsHealth: systemHealth['onlineMetricsSystem'],
    );
  }

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Future<SystemHealthReport> getSystemHealthReport() async {
    final health = await _repository.getSystemHealth();
    final dataQuality = _repository.getMarketDataQuality();
    
    return SystemHealthReport(
      version: health['version'] ?? 'Unknown',
      status: health['status'] ?? 'Unknown',
      uptime: health['uptime'] ?? 0,
      totalProcessedTrades: health['totalProcessedTrades'] ?? 0,
      activePatterns: health['activePatterns'] ?? 0,
      trackedMarkets: health['trackedMarkets'] ?? 0,
      onlineMetricsHealth: health['onlineMetricsSystem'],
      marketDataQuality: dataQuality,
      lastProcessingTime: health['lastProcessingTime'] != null 
          ? DateTime.parse(health['lastProcessingTime'])
          : null,
    );
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ìŠ¤íŠ¸ë¦¼ (í•„í„°ë§ í¬í•¨)
  Stream<PerformanceMetrics> watchFilteredPerformanceMetrics() {
    return _repository.watchPerformanceMetrics().map((raw) {
      return PerformanceMetrics(
        timestamp: DateTime.parse(raw['timestamp']),
        version: raw['version'] ?? 'Unknown',
        totalProcessedTrades: raw['totalProcessedTrades'] ?? 0,
        activeMarkets: raw['activeMarkets'] ?? 0,
        signalCounts: Map<String, int>.from(raw['signalCounts'] ?? {}),
        memoryUsage: Map<String, dynamic>.from(raw['memoryUsage'] ?? {}),
        onlineMetrics: Map<String, dynamic>.from(raw['onlineMetrics'] ?? {}),
        architecture: raw['architecture'] ?? 'Unknown',
      );
    });
  }

  // ==========================================================================
  // ì‹œê·¸ë„ ë¶„ì„ ë° í•„í„°ë§ (ê°œì„ ëœ ë¡œì§)
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ ê³„ì‚° (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  SignalStats calculateSignalStats(List<Signal> signals) {
    if (signals.isEmpty) {
      return const SignalStats(
        totalCount: 0,
        patternCounts: {},
        avgChangePercent: 0.0,
        maxChangePercent: 0.0,
        minChangePercent: 0.0,
        totalTradeAmount: 0.0,
        avgConfidence: 0.0,
        onlineMetricsCount: 0,
      );
    }

    final patternCounts = <PatternType, int>{};
    double totalChangePercent = 0.0;
    double maxChangePercent = signals.first.changePercent;
    double minChangePercent = signals.first.changePercent;
    double totalTradeAmount = 0.0;
    double totalConfidence = 0.0;
    int onlineMetricsCount = 0;

    for (final signal in signals) {
      // íŒ¨í„´ë³„ ì¹´ìš´íŠ¸
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;

      // ë³€í™”ìœ¨ í†µê³„
      totalChangePercent += signal.changePercent;
      if (signal.changePercent > maxChangePercent) {
        maxChangePercent = signal.changePercent;
      }
      if (signal.changePercent < minChangePercent) {
        minChangePercent = signal.changePercent;
      }

      // ê±°ë˜ëŒ€ê¸ˆ í•©ê³„
      totalTradeAmount += signal.tradeAmount;
      
      // V4.1 ì‹ ë¢°ë„ í†µê³„
      final confidence = signal.confidence ?? 0.0;
      totalConfidence += confidence;
      
      // V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ ì¹´ìš´íŠ¸
      if (signal.hasOnlineMetrics) {
        onlineMetricsCount++;
      }
    }

    return SignalStats(
      totalCount: signals.length,
      patternCounts: patternCounts,
      avgChangePercent: totalChangePercent / signals.length,
      maxChangePercent: maxChangePercent,
      minChangePercent: minChangePercent,
      totalTradeAmount: totalTradeAmount,
      avgConfidence: totalConfidence / signals.length,
      onlineMetricsCount: onlineMetricsCount,
    );
  }

  /// ê³ ê¸‰ ì‹œê·¸ë„ í•„í„°ë§ (V4.1 í™•ì¥)
  List<Signal> filterSignals(
    List<Signal> signals, {
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<String>? markets,
  }) {
    return signals.where((signal) {
      // ê¸°ì¡´ í•„í„°ë“¤
      if (minChangePercent != null && signal.changePercent < minChangePercent) {
        return false;
      }
      if (maxChangePercent != null && signal.changePercent > maxChangePercent) {
        return false;
      }
      if (minTradeAmount != null && signal.tradeAmount < minTradeAmount) {
        return false;
      }
      if (maxTradeAmount != null && signal.tradeAmount > maxTradeAmount) {
        return false;
      }
      if (patternTypes != null && !patternTypes.contains(signal.patternType)) {
        return false;
      }
      if (timeWindow != null) {
        final cutoff = DateTime.now().subtract(timeWindow);
        if (signal.detectedAt.isBefore(cutoff)) {
          return false;
        }
      }
      
      // V4.1 ìƒˆë¡œìš´ í•„í„°ë“¤
      if (minConfidence != null && (signal.confidence ?? 0.0) < minConfidence) {
        return false;
      }
      if (requireOnlineMetrics == true && !signal.hasOnlineMetrics) {
        return false;
      }
      if (markets != null && !markets.contains(signal.market)) {
        return false;
      }

      return true;
    }).toList();
  }

  // ==========================================================================
  // ğŸ†• V4.1 ë°±í…ŒìŠ¤íŒ… ë° ì„¤ì • ê´€ë¦¬
  // ==========================================================================

  /// í˜„ì¬ ì„¤ì • ë°±ì—…
  SignalConfiguration exportCurrentConfiguration() {
    final config = _repository.exportConfiguration();
    return SignalConfiguration.fromJson(config);
  }

  /// ì„¤ì • ë³µì›
  void importConfiguration(SignalConfiguration configuration) {
    _repository.importConfiguration(configuration.toJson());
  }

  /// ì„¤ì • ë¹„êµ (A/B í…ŒìŠ¤íŠ¸ìš©)
  ConfigurationDiff compareConfigurations(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    return ConfigurationDiff.compare(configA, configB);
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    await _repository.dispose();
  }
}

// ==========================================================================
// ğŸ†• V4.1 í™•ì¥ ë°ì´í„° í´ë˜ìŠ¤ë“¤
// ==========================================================================

/// V4.1 í–¥ìƒëœ Signal í†µê³„ ì •ë³´
class SignalStats {
  final int totalCount;
  final Map<PatternType, int> patternCounts;
  final double avgChangePercent;
  final double maxChangePercent;
  final double minChangePercent;
  final double totalTradeAmount;
  final double avgConfidence;
  final int onlineMetricsCount;

  const SignalStats({
    required this.totalCount,
    required this.patternCounts,
    required this.avgChangePercent,
    required this.maxChangePercent,
    required this.minChangePercent,
    required this.totalTradeAmount,
    required this.avgConfidence,
    required this.onlineMetricsCount,
  });

  double get onlineMetricsRatio => 
      totalCount > 0 ? onlineMetricsCount / totalCount : 0.0;

   /// ğŸ†• V4.1 JSON ì§ë ¬í™”
  Map<String, dynamic> toJson() {
    return {
      'totalCount': totalCount,
      'patternCounts': patternCounts.map((k, v) => MapEntry(k.name, v)),
      'avgChangePercent': avgChangePercent,
      'maxChangePercent': maxChangePercent,
      'minChangePercent': minChangePercent,
      'totalTradeAmount': totalTradeAmount,
      'avgConfidence': avgConfidence,
      'onlineMetricsCount': onlineMetricsCount,
      'onlineMetricsRatio': onlineMetricsRatio,
    };
  }

  @override
  String toString() {
    return 'SignalStats(total: $totalCount, avg: ${avgChangePercent.toStringAsFixed(2)}%, '
        'confidence: ${(avgConfidence * 100).toStringAsFixed(1)}%, '
        'online: ${(onlineMetricsRatio * 100).toStringAsFixed(1)}%)';
  }
}

/// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
class PatternPerformanceStats {
  final PatternType patternType;
  final int totalSignals;
  final int recentSignals;
  final DateTime? lastSignalTime;
  final bool isEnabled;
  final Map<String, double> config;
  final Map<String, dynamic> cooldownStatus;
  final Map<String, dynamic>? onlineMetricsHealth;

  const PatternPerformanceStats({
    required this.patternType,
    required this.totalSignals,
    required this.recentSignals,
    this.lastSignalTime,
    required this.isEnabled,
    required this.config,
    required this.cooldownStatus,
    this.onlineMetricsHealth,
  });
}

/// ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
class SystemHealthReport {
  final String version;
  final String status;
  final int uptime;
  final int totalProcessedTrades;
  final int activePatterns;
  final int trackedMarkets;
  final Map<String, dynamic>? onlineMetricsHealth;
  final Map<String, dynamic> marketDataQuality;
  final DateTime? lastProcessingTime;

  const SystemHealthReport({
    required this.version,
    required this.status,
    required this.uptime,
    required this.totalProcessedTrades,
    required this.activePatterns,
    required this.trackedMarkets,
    this.onlineMetricsHealth,
    required this.marketDataQuality,
    this.lastProcessingTime,
  });

  bool get isHealthy => status == 'healthy';
}

/// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤
class PerformanceMetrics {
  final DateTime timestamp;
  final String version;
  final int totalProcessedTrades;
  final int activeMarkets;
  final Map<String, int> signalCounts;
  final Map<String, dynamic> memoryUsage;
  final Map<String, dynamic> onlineMetrics;
  final String architecture;

  const PerformanceMetrics({
    required this.timestamp,
    required this.version,
    required this.totalProcessedTrades,
    required this.activeMarkets,
    required this.signalCounts,
    required this.memoryUsage,
    required this.onlineMetrics,
    required this.architecture,
  });
}

/// ì„¤ì • ì •ë³´
class SignalConfiguration {
  final String version;
  final DateTime timestamp;
  final Map<String, dynamic> patternConfig;
  final Map<String, bool> patternEnabled;
  final Map<String, dynamic> systemSettings;

  const SignalConfiguration({
    required this.version,
    required this.timestamp,
    required this.patternConfig,
    required this.patternEnabled,
    required this.systemSettings,
  });

  factory SignalConfiguration.fromJson(Map<String, dynamic> json) {
    return SignalConfiguration(
      version: json['version'] ?? 'Unknown',
      timestamp: DateTime.parse(json['timestamp']),
      patternConfig: Map<String, dynamic>.from(json['patternConfig'] ?? {}),
      patternEnabled: Map<String, bool>.from(json['patternEnabled'] ?? {}),
      systemSettings: Map<String, dynamic>.from(json['systemSettings'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'version': version,
      'timestamp': timestamp.toIso8601String(),
      'patternConfig': patternConfig,
      'patternEnabled': patternEnabled,
      'systemSettings': systemSettings,
    };
  }
}

/// ì„¤ì • ë¹„êµ ê²°ê³¼
class ConfigurationDiff {
  final List<String> changedPatterns;
  final List<String> changedSettings;
  final Map<String, dynamic> differences;

  const ConfigurationDiff({
    required this.changedPatterns,
    required this.changedSettings,
    required this.differences,
  });

  static ConfigurationDiff compare(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    // ê°„ë‹¨í•œ ë¹„êµ ë¡œì§ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•˜ê²Œ êµ¬í˜„)
    return const ConfigurationDiff(
      changedPatterns: [],
      changedSettings: [],
      differences: {},
    );
  }

  bool get hasChanges => changedPatterns.isNotEmpty || changedSettings.isNotEmpty;
}\n\n// ====== lib/domain/usecases/settings_usecase.dart ======\n
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';
import '../repositories/settings_repository.dart';

/// ì•± ì„¤ì • ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class SettingsUsecase {
 final SettingsRepository _repo;

 SettingsUsecase(this._repo);

 Future<AppSettings> getSettings() {
   return _repo.getSettings();
 }

 Future<void> updateThemeMode(ThemeMode mode) {
   return _repo.updateThemeMode(mode);
 }

 Future<void> updateKeepScreenOn(bool on) {
   return _repo.updateKeepScreenOn(on);
 }

 Future<void> updateSliderPosition(SliderPosition pos) {
   return _repo.updateSliderPosition(pos);
 }

 Future<void> updateDisplayMode(DisplayMode mode) {
   return _repo.updateDisplayMode(mode);
 }

 Future<void> updateAmountDisplayMode(AmountDisplayMode mode) {
   return _repo.updateAmountDisplayMode(mode);
 }

 Future<void> updateBlinkEnabled(bool enabled) {
   return _repo.updateBlinkEnabled(enabled);
 }

 Future<void> updateFontFamily(FontFamily font) {
   return _repo.updateFontFamily(font);
 }

 Future<void> updateHapticEnabled(bool enabled) {    // ğŸ†• ì¶”ê°€
   return _repo.updateHapticEnabled(enabled);
 }

 Future<void> updatePortraitLocked(bool locked) {    // ğŸ†• ì¶”ê°€
   return _repo.updatePortraitLocked(locked);
 }

 Future<void> clearCache() {
   return _repo.clearCache();
 }

 Future<void> resetSettings() {
   return _repo.resetSettings();
 }
}\n\n// ====== lib/domain/usecases/market_mood_usecase.dart ======\n
// lib/domain/usecases/market_mood_usecase.dart
// ğŸ¯ Domain Layer: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ìˆœìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜)

import 'dart:async';
import 'dart:math';
import '../entities/market_mood.dart';
import '../repositories/market_mood_repository.dart';

/// ğŸ’° ë§ˆì¼“ ë¬´ë“œ ê³„ì‚°ê¸° (ìˆœìˆ˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
class MarketMoodCalculator {
  static MarketMood calculateMoodByComparison(double current, double previous) {
    if (previous <= 0) return MarketMood.sideways;
    final changePercent = ((current - previous) / previous) * 100;
    
    // [ìˆ˜ì •] ìš”ì²­í•˜ì‹  ì„ê³„ê°’ (10, 5, -5, -10)ìœ¼ë¡œ ë³€ê²½
    if (changePercent >= 10) return MarketMood.bull;
    if (changePercent >= 5) return MarketMood.weakBull;
    if (changePercent >= -5) return MarketMood.sideways;
    if (changePercent >= -10) return MarketMood.bear;
    return MarketMood.deepBear;
  }

  static MarketMood calculateMoodByAbsolute(double volumeUsd) {
    if (volumeUsd >= 150e9) return MarketMood.bull;
    if (volumeUsd >= 100e9) return MarketMood.weakBull;
    if (volumeUsd >= 70e9) return MarketMood.sideways;
    if (volumeUsd >= 50e9) return MarketMood.bear;
    return MarketMood.deepBear;
  }
}

/// ğŸ§® ë³¼ë¥¨ ë¹„êµ ê³„ì‚°ê¸° (ìˆœìˆ˜ ê³„ì‚° ë¡œì§)
class VolumeComparator {
  final MarketMoodRepository _repository;

  VolumeComparator(this._repository);

  double _calculateChangePercent(double current, double previous) {
    if (previous <= 0) return 0.0;
    return ((current - previous) / previous) * 100;
  }

  double _calculateProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    if (elapsed < targetMinutes) {
      return min(elapsed / targetMinutes, 1.0);
    }
    final cycleElapsed = (elapsed - targetMinutes) % targetMinutes;
    return cycleElapsed / targetMinutes;
  }

  double _calculateLongTermProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    return min(elapsed / targetMinutes, 1.0);
  }

  Future<ComparisonResult> _compareGeneric({
    required double currentVolume,
    required int targetMinutes,
    required bool isLongTermAverage,
    required int daysForAverage,
  }) async {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;

    if (isLongTermAverage) {
      if (elapsed < targetMinutes) {
        return ComparisonResult.collecting(_calculateLongTermProgress(targetMinutes));
      }
      final average = await _repository.getAverageVolume(daysForAverage);
      if (average == null) {
        return ComparisonResult.unavailable('ìƒ˜í”Œ ë¶€ì¡±');
      }
      return ComparisonResult.ready(_calculateChangePercent(currentVolume, average));
    }

    if (elapsed < targetMinutes) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    final past = await _repository.getVolumeNMinutesAgo(targetMinutes);
    if (past == null) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    return ComparisonResult.ready(_calculateChangePercent(currentVolume, past.volumeUsd));
  }

  Future<ComparisonResult> compare30Minutes(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 30, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare1Hour(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 60, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare2Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 120, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare4Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 240, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare8Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 480, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare12Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 720, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare24Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 1440, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare3DayAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 4320, isLongTermAverage: true, daysForAverage: 3);

  Future<ComparisonResult> compareWeeklyAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 10080, isLongTermAverage: true, daysForAverage: 7);

  /// [ê°œì„ ] ì „ì²´ ë¹„êµ ë°ì´í„° ê³„ì‚° (ë³‘ë ¬ ì²˜ë¦¬)
  Future<ComparisonData> calculateAll(double currentVolume) async {
    final results = await Future.wait([
      compare30Minutes(currentVolume),
      compare1Hour(currentVolume),
      compare2Hours(currentVolume),
      compare4Hours(currentVolume),
      compare8Hours(currentVolume),
      compare12Hours(currentVolume),
      compare24Hours(currentVolume),
      compare3DayAverage(currentVolume),
      compareWeeklyAverage(currentVolume),
    ]);

    return ComparisonData(
      thirtyMin: results[0],
      oneHour: results[1],
      twoHour: results[2],
      fourHour: results[3],
      eightHour: results[4],
      twelveHour: results[5],
      twentyFourHour: results[6],
      threeDayAverage: results[7],
      weeklyAverage: results[8],
    );
  }
}

/// ğŸ¯ ë§ˆì¼“ë¬´ë“œ UseCase (ì „ì²´ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¡°í•©) - Providerì™€ ë§¤ì¹­
class MarketMoodUsecase {
  final MarketMoodRepository _repository;
  final VolumeComparator _comparator;

  MarketMoodUsecase(this._repository) : _comparator = VolumeComparator(_repository);

  Future<void> addVolumeData(double volumeUsd) async {
    final volumeData = VolumeData(
      timestamp: DateTime.now(),
      volumeUsd: volumeUsd,
    );
    await _repository.addVolumeData(volumeData);
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ê¸°ì¤€ì„ 2ì‹œê°„ìœ¼ë¡œ ë³€ê²½
  Future<MarketMood> calculateCurrentMood(double currentVolume) async {
    // 2ì‹œê°„ = 120ë¶„
    final twoHoursAgo = await _repository.getVolumeNMinutesAgo(120);
    
    if (twoHoursAgo != null) {
      return MarketMoodCalculator.calculateMoodByComparison(
        currentVolume, 
        twoHoursAgo.volumeUsd
      );
    }
    return MarketMoodCalculator.calculateMoodByAbsolute(currentVolume);
  }

  Future<ComparisonData> calculateVolumeComparison(double currentVolume) {
    return _comparator.calculateAll(currentVolume);
  }

  MarketMoodSystemState createSystemState({
    required MarketMoodData? marketData,
    required ComparisonData comparisonData,
    required MarketMood currentMood,
    required double exchangeRate,
    required bool isLoading,
    required bool hasError,
  }) {
    return MarketMoodSystemState(
      marketData: marketData,
      comparisonData: comparisonData,
      currentMood: currentMood,
      exchangeRate: exchangeRate,
      isLoading: isLoading,
      hasError: hasError,
    );
  }

  String generateMoodSummary(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull: return 'ğŸš€ ë¶ˆì¥';
      case MarketMood.weakBull: return 'ğŸ”¥ ì•½ë¶ˆì¥';
      case MarketMood.sideways: return 'âš–ï¸ ì¤‘ê°„ì¥';
      case MarketMood.bear: return 'ğŸ’§ ë¬¼ì¥';
      case MarketMood.deepBear: return 'ğŸ§Š ì–¼ìŒì¥';
    }
  }

  Future<void> handleBackgroundResume() async {
    await _repository.syncMissingData();
  }

  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  Future<void> logSystemStatus() async {
    await _repository.logCurrentStatus();
  }

  Future<int> getCollectedDataCount() async {
    return await _repository.getCollectedDataCount();
  }

  DateTime getAppStartTime() {
    return _repository.getAppStartTime();
  }

  Future<double> getExchangeRate() async {
    return await _repository.getExchangeRate();
  }

  Future<void> refreshExchangeRate() async {
    await _repository.refreshExchangeRate();
  }
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/volume.dart';
import '../repositories/volume_repository.dart';

/// Volume ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class VolumeUsecase {
  final VolumeRepository _repository;

  VolumeUsecase(this._repository);

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë­í‚¹ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
  Stream<Result<List<Volume>, AppException>> getVolumeRanking(
    String timeFrame,
    List<String> markets,
  ) {
    return _repository
        .watchVolumeByTimeFrame(timeFrame, markets)
        .transform(_wrapWithErrorHandling<List<Volume>>('Volume ranking failed'));
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetTimeFrame(String timeFrame) {
    try {
      _repository.resetTimeFrame(timeFrame);
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset timeframe failed: $e'));
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetAllTimeFrames() {
    try {
      _repository.resetAllTimeFrames();
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset all timeframes failed: $e'));
    }
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  Result<DateTime?, AppException> getNextResetTime(String timeFrame) {
    try {
      final resetTime = _repository.getNextResetTime(timeFrame);
      return Ok(resetTime);
    } catch (e) {
      return Err(AppException('Get reset time failed: $e'));
    }
  }

  /// í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  Result<List<String>, AppException> getActiveTimeFrames() {
    try {
      final timeFrames = _repository.getActiveTimeFrames();
      return Ok(timeFrames);
    } catch (e) {
      return Err(AppException('Get active timeframes failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦
  Result<bool, AppException> validateTimeFrame(String timeFrame) {
    try {
      final isActive = _repository.isTimeFrameActive(timeFrame);
      return Ok(isActive);
    } catch (e) {
      return Err(AppException('Validate timeframe failed: $e'));
    }
  }

  /// ë³¼ë¥¨ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Volume>, AppException> validateVolumeData(List<Volume> volumes) {
    try {
      // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ë³¼ë¥¨ì´ ìˆëŠ” ê²ƒë§Œ, ì¤‘ë³µ ì œê±°, ì •ë ¬ í™•ì¸
      final validVolumes = volumes
          .where((v) => v.hasVolume && v.market.isNotEmpty)
          .toSet() // ì¤‘ë³µ ì œê±°
          .toList();

      // ì •ë ¬ í™•ì¸ (ë³¼ë¥¨ ë‚´ë¦¼ì°¨ìˆœ)
      final isSorted = _isVolumeSorted(validVolumes);
      if (!isSorted) {
        validVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
      }

      return Ok(validVolumes);
    } catch (e) {
      return Err(AppException('Volume data validation failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë¹„êµ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<Map<String, double>, AppException> compareVolumeAcrossTimeFrames(
    String market,
    List<String> timeFrames,
  ) {
    try {
      // ì—¬ëŸ¬ ì‹œê°„ëŒ€ì˜ íŠ¹ì • ì½”ì¸ ë³¼ë¥¨ ë¹„êµ
      // ì‹¤ì œ êµ¬í˜„ì€ Repositoryì—ì„œ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¦¼ì„ ì¡°í•©í•´ì•¼ í•¨
      final comparison = <String, double>{};
      
      // TODO: ì‹¤ì œ êµ¬í˜„ ì‹œ ì—¬ëŸ¬ timeFrameì˜ ë°ì´í„°ë¥¼ ì¡°í•©
      // í˜„ì¬ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ
      for (final tf in timeFrames) {
        comparison[tf] = 0.0; // ì‹¤ì œ ë°ì´í„° ì¡°íšŒ í•„ìš”
      }
      
      return Ok(comparison);
    } catch (e) {
      return Err(AppException('Volume comparison failed: $e'));
    }
  }

  /// í—¬í¼: ë³¼ë¥¨ ì •ë ¬ í™•ì¸
  bool _isVolumeSorted(List<Volume> volumes) {
    if (volumes.length <= 1) return true;
    
    for (int i = 0; i < volumes.length - 1; i++) {
      if (volumes[i].totalVolume < volumes[i + 1].totalVolume) {
        return false;
      }
    }
    return true;
  }

  /// í—¬í¼: ì—ëŸ¬ ì²˜ë¦¬ ë³€í™˜ê¸°
  StreamTransformer<T, Result<T, AppException>> _wrapWithErrorHandling<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/usecases/surge_usecase.dart ======\n
// lib/domain/usecases/surge_usecase.dart
import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/surge.dart';
import '../repositories/surge_repository.dart';

/// Surge(ê¸‰ë“±/ê¸‰ë½) ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class SurgeUsecase {
  final SurgeRepository _repository;

  SurgeUsecase(this._repository);

  /// ì‹œê°„ëŒ€ë³„ ê¸‰ë“±/ê¸‰ë½ ë­í‚¹ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
  Stream<Result<List<Surge>, AppException>> getSurgeRanking(
    String timeFrame,
    List<String> markets,
  ) {
    return _repository
        .watchSurgeByTimeFrame(timeFrame, markets)
        .transform(_wrapWithErrorHandling<List<Surge>>('Surge ranking failed'));
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetTimeFrame(String timeFrame) {
    try {
      _repository.resetTimeFrame(timeFrame);
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset timeframe failed: $e'));
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetAllTimeFrames() {
    try {
      _repository.resetAllTimeFrames();
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset all timeframes failed: $e'));
    }
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  Result<DateTime?, AppException> getNextResetTime(String timeFrame) {
    try {
      final resetTime = _repository.getNextResetTime(timeFrame);
      return Ok(resetTime);
    } catch (e) {
      return Err(AppException('Get reset time failed: $e'));
    }
  }

  /// í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  Result<List<String>, AppException> getActiveTimeFrames() {
    try {
      final timeFrames = _repository.getActiveTimeFrames();
      return Ok(timeFrames);
    } catch (e) {
      return Err(AppException('Get active timeframes failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦
  Result<bool, AppException> validateTimeFrame(String timeFrame) {
    try {
      final isActive = _repository.isTimeFrameActive(timeFrame);
      return Ok(isActive);
    } catch (e) {
      return Err(AppException('Validate timeframe failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Surge>, AppException> validateSurgeData(List<Surge> surges) {
    try {
      // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ë³€ë™ì´ ìˆëŠ” ê²ƒë§Œ, ì¤‘ë³µ ì œê±°, ì •ë ¬ í™•ì¸
      final validSurges = surges
          .where((s) => s.hasChange && s.market.isNotEmpty)
          .toSet() // ì¤‘ë³µ ì œê±°
          .toList();

      // ì •ë ¬ í™•ì¸ (ë³€ë™ë¥  ì ˆëŒ“ê°’ ë‚´ë¦¼ì°¨ìˆœ)
      final isSorted = _isSurgeSorted(validSurges);
      if (!isSorted) {
        validSurges.sort((a, b) => b.absChangePercent.compareTo(a.absChangePercent));
      }

      return Ok(validSurges);
    } catch (e) {
      return Err(AppException('Surge data validation failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ í•„í„°ë§ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Surge>, AppException> filterSurgesByType(
    List<Surge> surges,
    SurgeFilterType filterType,
  ) {
    try {
      List<Surge> filtered;
      
      switch (filterType) {
        case SurgeFilterType.all:
          filtered = surges;
          break;
        case SurgeFilterType.risingOnly:
          filtered = surges.where((s) => s.isRising).toList();
          break;
        case SurgeFilterType.fallingOnly:
          filtered = surges.where((s) => s.isFalling).toList();
          break;
      }

      return Ok(filtered);
    } catch (e) {
      return Err(AppException('Surge filtering failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ê¸‰ë“±/ê¸‰ë½ ë¹„êµ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<Map<String, double>, AppException> compareSurgeAcrossTimeFrames(
    String market,
    List<String> timeFrames,
  ) {
    try {
      // ì—¬ëŸ¬ ì‹œê°„ëŒ€ì˜ íŠ¹ì • ì½”ì¸ ë³€ë™ë¥  ë¹„êµ
      // ì‹¤ì œ êµ¬í˜„ì€ Repositoryì—ì„œ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¦¼ì„ ì¡°í•©í•´ì•¼ í•¨
      final comparison = <String, double>{};
      
      // TODO: ì‹¤ì œ êµ¬í˜„ ì‹œ ì—¬ëŸ¬ timeFrameì˜ ë°ì´í„°ë¥¼ ì¡°í•©
      // í˜„ì¬ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ
      for (final tf in timeFrames) {
        comparison[tf] = 0.0; // ì‹¤ì œ ë°ì´í„° ì¡°íšŒ í•„ìš”
      }
      
      return Ok(comparison);
    } catch (e) {
      return Err(AppException('Surge comparison failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ í†µê³„ ê³„ì‚° (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<SurgeStatistics, AppException> calculateSurgeStatistics(List<Surge> surges) {
    try {
      if (surges.isEmpty) {
        return Ok(SurgeStatistics.empty());
      }

      final risingCount = surges.where((s) => s.isRising).length;
      final fallingCount = surges.where((s) => s.isFalling).length;
      final maxRising = surges.where((s) => s.isRising).isNotEmpty 
          ? surges.where((s) => s.isRising).map((s) => s.changePercent).reduce((a, b) => a > b ? a : b)
          : 0.0;
      final maxFalling = surges.where((s) => s.isFalling).isNotEmpty 
          ? surges.where((s) => s.isFalling).map((s) => s.changePercent).reduce((a, b) => a < b ? a : b)
          : 0.0;

      return Ok(SurgeStatistics(
        totalCount: surges.length,
        risingCount: risingCount,
        fallingCount: fallingCount,
        maxRisingPercent: maxRising,
        maxFallingPercent: maxFalling,
      ));
    } catch (e) {
      return Err(AppException('Surge statistics calculation failed: $e'));
    }
  }

  /// í—¬í¼: ê¸‰ë“±/ê¸‰ë½ ì •ë ¬ í™•ì¸
  bool _isSurgeSorted(List<Surge> surges) {
    if (surges.length <= 1) return true;
    
    for (int i = 0; i < surges.length - 1; i++) {
      if (surges[i].absChangePercent < surges[i + 1].absChangePercent) {
        return false;
      }
    }
    return true;
  }

  /// í—¬í¼: ì—ëŸ¬ ì²˜ë¦¬ ë³€í™˜ê¸°
  StreamTransformer<T, Result<T, AppException>> _wrapWithErrorHandling<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}

/// ê¸‰ë“±/ê¸‰ë½ í•„í„° íƒ€ì…
enum SurgeFilterType {
  all,            // ì „ì²´ (ê¸‰ë“± + ê¸‰ë½)
  risingOnly,     // ìƒìŠ¹ë§Œ
  fallingOnly,    // í•˜ë½ë§Œ
}

/// ê¸‰ë“±/ê¸‰ë½ í†µê³„ ë°ì´í„°
class SurgeStatistics {
  final int totalCount;
  final int risingCount;
  final int fallingCount;
  final double maxRisingPercent;
  final double maxFallingPercent;

  const SurgeStatistics({
    required this.totalCount,
    required this.risingCount,
    required this.fallingCount,
    required this.maxRisingPercent,
    required this.maxFallingPercent,
  });

  factory SurgeStatistics.empty() {
    return const SurgeStatistics(
      totalCount: 0,
      risingCount: 0,
      fallingCount: 0,
      maxRisingPercent: 0.0,
      maxFallingPercent: 0.0,
    );
  }

  /// ê¸‰ë“± ë¹„ìœ¨ (0.0 ~ 1.0)
  double get risingRatio => totalCount > 0 ? risingCount / totalCount : 0.0;
  
  /// ê¸‰ë½ ë¹„ìœ¨ (0.0 ~ 1.0)
  double get fallingRatio => totalCount > 0 ? fallingCount / totalCount : 0.0;
  
  /// ê¸‰ë“± ìš°ì„¸ ì—¬ë¶€
  bool get isRisingDominant => risingCount > fallingCount;
  
  /// ê¸‰ë½ ìš°ì„¸ ì—¬ë¶€
  bool get isFallingDominant => fallingCount > risingCount;
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// Trade ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  /// thresholdì™€ marketsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<List<Trade>, AppException>> filterTrades(
    double threshold,
    List<String> markets,
  ) {
    return _repository
        .watchFilteredTrades(threshold, markets)
        .transform(_wrap<List<Trade>>('Filter trades failed'));
  }

  /// ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<Trade, AppException>> aggregateTrades() {
    return _repository
        .watchAggregatedTrades()
        .transform(_wrap<Trade>('Aggregate trades failed'));
  }

  StreamTransformer<T, Result<T, AppException>> _wrap<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/usecases/filter_params.dart ======\n
// ===== lib/domain/usecases/filter_params.dart =====
import '../entities/signal.dart'; // PatternType import ì¶”ê°€

class FilterParams {
  final double? minChangePercent;
  final double? maxChangePercent;
  final double? minTradeAmount;
  final double? maxTradeAmount;
  final Set<PatternType>? patternTypes; // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
  final Duration? timeWindow;
  final double? minSeverityScore;

  const FilterParams({
    this.minChangePercent,
    this.maxChangePercent,
    this.minTradeAmount,
    this.maxTradeAmount,
    this.patternTypes, // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
    this.timeWindow,
    this.minSeverityScore,
  });

  FilterParams copyWith({
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes, // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
    Duration? timeWindow,
    double? minSeverityScore,
  }) {
    return FilterParams(
      minChangePercent: minChangePercent ?? this.minChangePercent,
      maxChangePercent: maxChangePercent ?? this.maxChangePercent,
      minTradeAmount: minTradeAmount ?? this.minTradeAmount,
      maxTradeAmount: maxTradeAmount ?? this.maxTradeAmount,
      patternTypes: patternTypes ?? this.patternTypes,
      timeWindow: timeWindow ?? this.timeWindow,
      minSeverityScore: minSeverityScore ?? this.minSeverityScore,
    );
  }
}
\n\n// ====== lib/domain/entities/app_settings.dart ======\n
import 'package:flutter/material.dart';
import 'package:equatable/equatable.dart';

/// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë¥¼ í‘œí˜„í•˜ëŠ” enum
enum SliderPosition { top, bottom }

/// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum DisplayMode {
 ticker, // BTC, ETH, XRP
 korean, // ë¹„íŠ¸ì½”ì¸, ì´ë”ë¦¬ì›€, ë¦¬í”Œ
 english, // Bitcoin, Ethereum, Ripple
}

/// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum AmountDisplayMode {
 number, // 1,234ë§Œ (ìˆ«ì)
 icon, // ğŸ’µ (ì•„ì´ì½˜)
}

/// ğŸ”¤ í°íŠ¸ íŒ¨ë°€ë¦¬ë¥¼ í‘œí˜„í•˜ëŠ” enum (âœ¨ pubspec.yaml ê¸°ì¤€ìœ¼ë¡œ ì •ë¦¬)
enum FontFamily {
 // --- ê¸°ë³¸ ---
 pretendard,
 // --- ì „ì²´ ì¶”ê°€ í°íŠ¸ ---
 dotGothic16,
 dynaPuff,
 gloriaHallelujah,
 gowunDodum,
 gugi,
 ibmPlexSansKRLight,
 inconsolata,
 kirangHaerang,
 nanumGothicCoding,
 notoSerifKR,
 novaMono,
 novaSquare,
 permanentMarker,
 pixelifySans,
 sunflowerLight,
 syneMono;

 // ì‹¤ì œ í°íŠ¸ëª… ë§¤í•‘ (âœ¨ pubspec.yaml ê¸°ì¤€ìœ¼ë¡œ ì •ë¦¬)
 String get fontName {
   switch (this) {
     case FontFamily.pretendard: return 'Pretendard';
     case FontFamily.dotGothic16: return 'DotGothic16-Regular';
     case FontFamily.dynaPuff: return 'DynaPuff-VariableFont_wdth,wght';
     case FontFamily.gloriaHallelujah: return 'GloriaHallelujah-Regular';
     case FontFamily.gowunDodum: return 'GowunDodum-Regular';
     case FontFamily.gugi: return 'Gugi-Regular';
     case FontFamily.ibmPlexSansKRLight: return 'IBMPlexSansKR-Light';
     case FontFamily.inconsolata: return 'Inconsolata-VariableFont_wdth,wght';
     case FontFamily.kirangHaerang: return 'KirangHaerang-Regular';
     case FontFamily.nanumGothicCoding: return 'NanumGothicCoding-Regular';
     case FontFamily.notoSerifKR: return 'NotoSerifKR-VariableFont_wght';
     case FontFamily.novaMono: return 'NovaMono-Regular';
     case FontFamily.novaSquare: return 'NovaSquare-Regular';
     case FontFamily.permanentMarker: return 'PermanentMarker-Regular';
     case FontFamily.pixelifySans: return 'PixelifySans-VariableFont_wght';
     case FontFamily.sunflowerLight: return 'Sunflower-Light';
     case FontFamily.syneMono: return 'SyneMono-Regular';
   }
 }
}

class AppSettings extends Equatable {
 final ThemeMode themeMode;
 final bool keepScreenOn;
 final SliderPosition sliderPosition;
 final DisplayMode displayMode;
 final AmountDisplayMode amountDisplayMode;
 final bool blinkEnabled;
 final FontFamily fontFamily;
 final bool isHapticEnabled;      // ğŸ†• í–…í‹± í”¼ë“œë°± ì„¤ì •
 final bool isPortraitLocked;     // ğŸ†• í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì •

 const AppSettings({
   this.themeMode = ThemeMode.system,
   this.keepScreenOn = false,
   this.sliderPosition = SliderPosition.top,
   this.displayMode = DisplayMode.ticker,
   this.amountDisplayMode = AmountDisplayMode.number,
   this.blinkEnabled = true,
   this.fontFamily = FontFamily.pretendard,
   this.isHapticEnabled = true,      // ğŸ†• ê¸°ë³¸ê°’: í™œì„±í™”
   this.isPortraitLocked = false,    // ğŸ†• ê¸°ë³¸ê°’: ìë™ íšŒì „
 });

 AppSettings copyWith({
   ThemeMode? themeMode,
   bool? keepScreenOn,
   SliderPosition? sliderPosition,
   DisplayMode? displayMode,
   AmountDisplayMode? amountDisplayMode,
   bool? blinkEnabled,
   FontFamily? fontFamily,
   bool? isHapticEnabled,           // ğŸ†• ì¶”ê°€
   bool? isPortraitLocked,          // ğŸ†• ì¶”ê°€
 }) =>
     AppSettings(
       themeMode: themeMode ?? this.themeMode,
       keepScreenOn: keepScreenOn ?? this.keepScreenOn,
       sliderPosition: sliderPosition ?? this.sliderPosition,
       displayMode: displayMode ?? this.displayMode,
       amountDisplayMode: amountDisplayMode ?? this.amountDisplayMode,
       blinkEnabled: blinkEnabled ?? this.blinkEnabled,
       fontFamily: fontFamily ?? this.fontFamily,
       isHapticEnabled: isHapticEnabled ?? this.isHapticEnabled,        // ğŸ†• ì¶”ê°€
       isPortraitLocked: isPortraitLocked ?? this.isPortraitLocked,     // ğŸ†• ì¶”ê°€
     );

 @override
 List<Object?> get props => [
   themeMode,
   keepScreenOn,
   sliderPosition,
   displayMode,
   amountDisplayMode,
   blinkEnabled,
   fontFamily,
   isHapticEnabled,      // ğŸ†• ì¶”ê°€
   isPortraitLocked,     // ğŸ†• ì¶”ê°€
 ];
}\n\n// ====== lib/domain/entities/momentary.dart ======\n
\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨
class Trade extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;

  /// ì²´ê²° ë‹¨ê°€
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰
  final double volume;

  /// 'BID' ë˜ëŠ” 'ASK'
  final String side;

  /// ê°€ê²© ë³€ë™ëŸ‰
  final double changePrice;

  /// ë³€ë™ ìƒíƒœ ('RISE'/'FALL'/'EVEN')
  final String changeState;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int timestampMs;

  /// ì¤‘ë³µ ì œê±°ìš© ê³ ìœ  ID
  final String sequentialId;

  const Trade({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  @override
  List<Object?> get props => [
        market,
        price,
        volume,
        side,
        changePrice,
        changeState,
        timestampMs,
        sequentialId,
      ];

  /// ì´ ì²´ê²° ê¸ˆì•¡
  double get total => price * volume;

  /// ë§¤ìˆ˜ ì—¬ë¶€
  bool get isBuy => side == 'BID';

  /// DateTime ë³€í™˜
  DateTime get timestamp => DateTime.fromMillisecondsSinceEpoch(timestampMs);
}
\n\n// ====== lib/domain/entities/surge.dart ======\n
// lib/domain/entities/surge.dart
import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Surge extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ë³€ë™ë¥  (í¼ì„¼íŠ¸ ê¸°ì¤€)
  final double changePercent;
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  final double basePrice;
  
  /// í˜„ì¬ ê°€ê²©
  final double currentPrice;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Surge({
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    changePercent,
    basePrice,
    currentPrice,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³€ë™ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ì´ ì•„ë‹˜)
  bool get hasChange => changePercent != 0;
  
  /// ê¸‰ë“±ì¸ì§€ ì²´í¬ (ì–‘ìˆ˜)
  bool get isRising => changePercent > 0;
  
  /// ê¸‰ë½ì¸ì§€ ì²´í¬ (ìŒìˆ˜)
  bool get isFalling => changePercent < 0;
  
  /// ë³€ë™ë¥  ì ˆëŒ“ê°’
  double get absChangePercent => changePercent.abs();
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³€ë™ë¥  í¬ë§·íŒ… (ì˜ˆ: "+12.34%", "-5.67%")
  String get formattedChangePercent {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Surge copyWith({
    String? market,
    double? changePercent,
    double? basePrice,
    double? currentPrice,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Surge(
      market: market ?? this.market,
      changePercent: changePercent ?? this.changePercent,
      basePrice: basePrice ?? this.basePrice,
      currentPrice: currentPrice ?? this.currentPrice,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/domain/entities/volume.dart ======\n
// lib/domain/entities/volume.dart

import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë³¼ë¥¨ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Volume extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì´ ê±°ë˜ëŸ‰ (ì›í™” ê¸°ì¤€)
  final double totalVolume;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Volume({
    required this.market,
    required this.totalVolume,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    totalVolume,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³¼ë¥¨ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ë³´ë‹¤ í¼)
  bool get hasVolume => totalVolume > 0;
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Volume copyWith({
    String? market,
    double? totalVolume,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Volume(
      market: market ?? this.market,
      totalVolume: totalVolume ?? this.totalVolume,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/domain/entities/signal.dart ======\n
// lib/domain/entities/signal.dart

/// ğŸš€ Signal Entity V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ì˜¨ë¼ì¸ RSI/MACD ì •ë³´ í¬í•¨
/// - ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ ê²°ê³¼
/// - ì‹ ë¢°ë„ ë™ì  ì¡°ì •
/// - ìŠ¤íŠ¸ë¦¼ ê±´ê°•ì„± ì •ë³´
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ë©”íƒ€ë°ì´í„°

/// Signal íŒ¨í„´ íƒ€ì… ì •ì˜ (V4.1 í™•ì¥)
enum PatternType {
  surge,       // 1. ê¸‰ë“± (1ë¶„ ì „ ëŒ€ë¹„ 0.4% ìƒìŠ¹)
  flashFire,   // 2. ë¶ˆí‹°ğŸ”¥ (3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦)
  stackUp,     // 3. ìŠ¤íƒì—…ğŸ’° (1ë¶„ì”© ì—°ì† ì¦ê°€)
  stealthIn,   // 4. ì¹¨íˆ¬ìğŸ‘£ (ì†ŒëŸ‰ ì§€ì† ìœ ì…) - ì™„í™”ë¨
  blackHole,   // 5. ë¸”ë™í™€ğŸ•³ï¸ (ê±°ë˜ëŒ€ê¸ˆâ†‘ ê°€ê²©ë³€ë™â†“) - ì™„í™”ë¨
  reboundShot, // 6. ì‡¼íŠ¸í„°ì¹˜âš¡ (ê¸‰ë½ í›„ ë°˜ë“±)
}

extension PatternTypeExtension on PatternType {
  String get displayName {
    switch (this) {
      case PatternType.surge:
        return 'ê¸‰ë“±';
      case PatternType.flashFire:
        return 'ë¶ˆí‹°ğŸ”¥';
      case PatternType.stackUp:
        return 'ìŠ¤íƒì—…ğŸ’°';
      case PatternType.stealthIn:
        return 'ì¹¨íˆ¬ìğŸ‘£';
      case PatternType.blackHole:
        return 'ë¸”ë™í™€ğŸ•³ï¸';
      case PatternType.reboundShot:
        return 'ì‡¼íŠ¸í„°ì¹˜âš¡';
    }
  }

  String get description {
    switch (this) {
      case PatternType.surge:
        return '1ë¶„ ì „ ëŒ€ë¹„ 0.4% ì´ìƒ ìƒìŠ¹ (V4.1)';
      case PatternType.flashFire:
        return '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ + RSI í™•ì¸';
      case PatternType.stackUp:
        return 'ì—°ì† ë§¤ì§‘ + MACD ëª¨ë©˜í…€';
      case PatternType.stealthIn:
        return 'ì€ë°€í•œ ìœ ì… (ì™„í™”ëœ ê¸°ì¤€)';
      case PatternType.blackHole:
        return 'ì´ìƒ ì²´ê²° (ì™„í™”ëœ ê¸°ì¤€)';
      case PatternType.reboundShot:
        return 'ê³¼ë§¤ë„ ë°˜ë“± + ì˜¨ë¼ì¸ ì§€í‘œ';
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ (ì™„í™”ë¨)
  double get defaultThreshold {
    switch (this) {
      case PatternType.surge:
        return 0.4; // 0.4% ìƒìŠ¹ (ê¸°ì¡´ 1.1%ì—ì„œ ì™„í™”)
      case PatternType.flashFire:
        return 2.0; // 2ë°° ê¸‰ì¦
      case PatternType.stackUp:
        return 2.0; // 2ì—°ì† (ê¸°ì¡´ 3ì—ì„œ ì™„í™”)
      case PatternType.stealthIn:
        return 5000000.0; // 500ë§Œì› (ê¸°ì¡´ 2000ë§Œì—ì„œ ëŒ€í­ ì™„í™”)
      case PatternType.blackHole:
        return 2.0; // 2% ì´í•˜ ë³€ë™ (ê¸°ì¡´ 1%ì—ì„œ ì™„í™”)
      case PatternType.reboundShot:
        return 1.5; // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
    }
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  int get timeWindowMinutes {
    switch (this) {
      case PatternType.surge:
        return 1; // 1ë¶„
      case PatternType.flashFire:
        return 1; // 1ë¶„ (V4.1 ë‹¨ì¶•)
      case PatternType.stackUp:
        return 1; // 1ë¶„
      case PatternType.stealthIn:
        return 5; // 5ë¶„
      case PatternType.blackHole:
        return 5; // 5ë¶„ (V4.1 í™•ì¥)
      case PatternType.reboundShot:
        return 1; // 1ë¶„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì‹œê°„ (ì´ˆ)
  int get defaultCooldownSeconds {
    switch (this) {
      case PatternType.surge:
        return 3; // ë¹ ë¥¸ ê°ì§€
      case PatternType.flashFire:
        return 2; // ê°€ì¥ ë¹ ë¦„
      case PatternType.stackUp:
        return 4; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 8; // ëŠë¦¼ (ì€ë°€í•¨ íŠ¹ì„±)
      case PatternType.blackHole:
        return 10; // ê°€ì¥ ëŠë¦¼ (ì•ˆì •ì„± íŠ¹ì„±)
      case PatternType.reboundShot:
        return 5; // ì¤‘ê°„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ì‹ ë¢°ë„ ê¸°ë³¸ê°’
  double get defaultConfidence {
    switch (this) {
      case PatternType.surge:
        return 0.8; // ë†’ìŒ
      case PatternType.flashFire:
        return 0.85; // ë§¤ìš° ë†’ìŒ
      case PatternType.stackUp:
        return 0.75; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 0.7; // ë‚®ìŒ (ì€ë°€í•¨)
      case PatternType.blackHole:
        return 0.8; // ë†’ìŒ (ì•ˆì •ì„±)
      case PatternType.reboundShot:
        return 0.9; // ë§¤ìš° ë†’ìŒ (ëª…í™•í•¨)
    }
  }
}

/// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
class OnlineIndicatorInfo {
  final double? rsi;
  final double? macd;
  final double? macdSignal;
  final double? macdHistogram;
  final bool isStale;
  final DateTime lastUpdate;

  const OnlineIndicatorInfo({
    this.rsi,
    this.macd,
    this.macdSignal,
    this.macdHistogram,
    required this.isStale,
    required this.lastUpdate,
  });

  /// RSI/MACDê°€ ìœ íš¨í•œì§€ ì²´í¬
  bool get hasValidData => !isStale && (rsi != null || macd != null);

  /// RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ ìƒíƒœ
  String get rsiState {
    if (rsi == null) return 'N/A';
    if (rsi! >= 70) return 'Overbought';
    if (rsi! <= 30) return 'Oversold';
    return 'Neutral';
  }

  /// MACD ì‹ í˜¸ ìƒíƒœ
  String get macdState {
    if (macd == null || macdSignal == null) return 'N/A';
    if (macd! > macdSignal!) return 'Bullish';
    if (macd! < macdSignal!) return 'Bearish';
    return 'Neutral';
  }

  Map<String, dynamic> toJson() {
    return {
      'rsi': rsi,
      'macd': macd,
      'macdSignal': macdSignal,
      'macdHistogram': macdHistogram,
      'isStale': isStale,
      'lastUpdate': lastUpdate.toIso8601String(),
      'rsiState': rsiState,
      'macdState': macdState,
    };
  }
}

/// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
class DivergenceInfo {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  final String source; // 'online-rsi', 'online-macd' ë“±

  const DivergenceInfo({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
    required this.source,
  });

  /// ë‹¤ì´ë²„ì „ìŠ¤ íƒ€ì…
  String get type {
    if (isBullish) return 'Bullish';
    if (isBearish) return 'Bearish';
    return 'None';
  }

  /// ì‹ ë¢°ë„ (ê°•ë„ ê¸°ë°˜)
  String get confidenceLevel {
    if (strength >= 0.8) return 'Very High';
    if (strength >= 0.6) return 'High';
    if (strength >= 0.4) return 'Medium';
    if (strength >= 0.2) return 'Low';
    return 'Very Low';
  }

  Map<String, dynamic> toJson() {
    return {
      'isBullish': isBullish,
      'isBearish': isBearish,
      'strength': strength,
      'source': source,
      'type': type,
      'confidenceLevel': confidenceLevel,
    };
  }
}

/// ğŸš€ Signal ê°ì§€ ê²°ê³¼ ì—”í‹°í‹° V4.1
class Signal {
  final String market;
  final String name;
  final double currentPrice;
  final double changePercent;
  final double volume;
  final double tradeAmount;
  final DateTime detectedAt;
  final PatternType patternType;
  final Map<String, dynamic> patternDetails;

  const Signal({
    required this.market,
    required this.name,
    required this.currentPrice,
    required this.changePercent,
    required this.volume,
    required this.tradeAmount,
    required this.detectedAt,
    required this.patternType,
    required this.patternDetails,
  });

  /// ê±°ë˜ ì´ì•¡ ê³„ì‚°
  double get total => currentPrice * volume;

  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ (ë™ì  ì¡°ì •ëœ ìµœì¢… ì‹ ë¢°ë„)
  double? get confidence {
    final finalConf = patternDetails['finalConfidence'] as double?;
    final originalConf = patternDetails['confidence'] as double?;
    return finalConf ?? originalConf;
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ ì¡°íšŒ
  OnlineIndicatorInfo? get onlineIndicators {
    final rsi = patternDetails['rsi'] as double?;
    final macd = patternDetails['macd'] as double?;
    final macdSignal = patternDetails['macdSignal'] as double?;
    final macdHistogram = patternDetails['macdHistogram'] as double?;
    
    if (rsi == null && macd == null) return null;
    
    return OnlineIndicatorInfo(
      rsi: rsi,
      macd: macd,
      macdSignal: macdSignal,
      macdHistogram: macdHistogram,
      isStale: false, // Signal ìƒì„±ì‹œì ì—ëŠ” ìµœì‹ 
      lastUpdate: detectedAt,
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´ ì¡°íšŒ
  DivergenceInfo? get divergence {
    final divData = patternDetails['divergence'] as Map<String, dynamic>?;
    if (divData == null) return null;
    
    return DivergenceInfo(
      isBullish: divData['isBullish'] as bool? ?? false,
      isBearish: divData['isBearish'] as bool? ?? false,
      strength: (divData['strength'] as num?)?.toDouble() ?? 0.0,
      source: divData['source'] as String? ?? 'unknown',
    );
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ì¸ì§€ ì²´í¬
  bool get hasOnlineMetrics {
    return onlineIndicators?.hasValidData ?? false;
  }

  /// ğŸ†• V4.1 ë²„ì „ ì •ë³´
  String? get version => patternDetails['version'] as String?;

  /// íŒ¨í„´ë³„ íŠ¹í™” ì •ë³´ getterë“¤
  
  /// Surge ì „ìš©: ê¸°ì¤€ê°€ (1ë¶„ ì „ ê°€ê²©)
  double? get basePrice => patternDetails['basePrice'] as double?;
  
  /// FlashFire ì „ìš©: ê¸‰ì¦ ë°°ìœ¨
  double? get surgeMultiplier => patternDetails['surgeMultiplier'] as double?;
  
  /// StackUp ì „ìš©: ì—°ì† ì¦ê°€ íšŸìˆ˜
  int? get consecutiveCount => patternDetails['consecutiveCount'] as int?;
  
  /// StealthIn ì „ìš©: ì§€ì† ì‹œê°„ (ì´ˆ)
  int? get sustainedSeconds => patternDetails['sustainedSeconds'] as int?;
  
  /// BlackHole ì „ìš©: ê°€ê²© ë³€ë™ë¥ 
  double? get priceStability => patternDetails['priceStability'] as double?;
  
  /// ReboundShot ì „ìš©: ë°˜ë“± ê°•ë„
  double? get reboundStrength => patternDetails['reboundStrength'] as double?;

  /// ğŸ†• V4.1 ê³ ê¸‰ ì§€í‘œë“¤
  double? get liquidityVortex => patternDetails['liquidityVortex'] as double?;
  double? get flashPulse => patternDetails['flashPulse'] as double?;
  double? get microBurstRadar => patternDetails['microBurstRadar'] as double?;
  double? get machineRush => patternDetails['machineRush'] as double?;
  double? get jumpScore => patternDetails['jumpScore'] as double?;
  double? get zScore => patternDetails['zScore'] as double?;

  /// ğŸ†• ì‹ ë¢°ë„ ë ˆë²¨ (í…ìŠ¤íŠ¸)
  String get confidenceLevel {
    final conf = confidence ?? 0.0;
    if (conf >= 0.9) return 'Excellent';
    if (conf >= 0.8) return 'Very High';
    if (conf >= 0.7) return 'High';
    if (conf >= 0.6) return 'Good';
    if (conf >= 0.5) return 'Medium';
    if (conf >= 0.3) return 'Low';
    return 'Very Low';
  }

  /// ğŸ†• ì‹ í˜¸ ê°•ë„ (ì¢…í•© ì ìˆ˜)
  String get signalStrength {
    double score = 0.0;
    
    // ê¸°ë³¸ ì ìˆ˜ (ë³€í™”ìœ¨ ê¸°ë°˜)
    score += (changePercent.abs() / 10.0).clamp(0.0, 1.0);
    
    // ì‹ ë¢°ë„ ì ìˆ˜
    score += (confidence ?? 0.0);
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ë³´ë„ˆìŠ¤
    if (hasOnlineMetrics) score += 0.3;
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ë³´ë„ˆìŠ¤
    final div = divergence;
    if (div != null && div.strength > 0.5) score += 0.2;
    
    score = score.clamp(0.0, 3.0) / 3.0; // 0-1 ì •ê·œí™”
    
    if (score >= 0.8) return 'Very Strong';
    if (score >= 0.6) return 'Strong';
    if (score >= 0.4) return 'Moderate';
    if (score >= 0.2) return 'Weak';
    return 'Very Weak';
  }

  /// ğŸ†• ìƒì„¸ ì •ë³´ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> get debugInfo {
    return {
      'market': market,
      'pattern': patternType.name,
      'confidence': confidence,
      'hasOnlineMetrics': hasOnlineMetrics,
      'onlineIndicators': onlineIndicators?.toJson(),
      'divergence': divergence?.toJson(),
      'signalStrength': signalStrength,
      'version': version,
      'detectedAt': detectedAt.toIso8601String(),
    };
  }

  Signal copyWith({
    String? market,
    String? name,
    double? currentPrice,
    double? changePercent,
    double? volume,
    double? tradeAmount,
    DateTime? detectedAt,
    PatternType? patternType,
    Map<String, dynamic>? patternDetails,
  }) {
    return Signal(
      market: market ?? this.market,
      name: name ?? this.name,
      currentPrice: currentPrice ?? this.currentPrice,
      changePercent: changePercent ?? this.changePercent,
      volume: volume ?? this.volume,
      tradeAmount: tradeAmount ?? this.tradeAmount,
      detectedAt: detectedAt ?? this.detectedAt,
      patternType: patternType ?? this.patternType,
      patternDetails: patternDetails ?? this.patternDetails,
    );
  }

  @override
  String toString() {
    final confText = confidence != null 
        ? '${(confidence! * 100).toStringAsFixed(1)}%' 
        : 'N/A';
    final onlineText = hasOnlineMetrics ? '[Online]' : '';
    
    return 'Signal(${patternType.displayName} $onlineText: $market '
        '${changePercent.toStringAsFixed(2)}% @ $currentPrice, '
        'Conf: $confText, at: ${detectedAt.toString().substring(11, 19)})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Signal &&
        other.market == market &&
        other.detectedAt == detectedAt &&
        other.patternType == patternType;
  }

  @override
  int get hashCode {
    return market.hashCode ^ detectedAt.hashCode ^ patternType.hashCode;
  }

  /// ğŸ†• V4.1 JSON ì§ë ¬í™” (ì €ì¥/ë¡œë“œìš©)
  Map<String, dynamic> toJson() {
    return {
      'market': market,
      'name': name,
      'currentPrice': currentPrice,
      'changePercent': changePercent,
      'volume': volume,
      'tradeAmount': tradeAmount,
      'detectedAt': detectedAt.toIso8601String(),
      'patternType': patternType.name,
      'patternDetails': patternDetails,
      'version': 'V4.1-Online',
    };
  }

  /// ğŸ†• V4.1 JSON ì—­ì§ë ¬í™”
  factory Signal.fromJson(Map<String, dynamic> json) {
    return Signal(
      market: json['market'] as String,
      name: json['name'] as String,
      currentPrice: (json['currentPrice'] as num).toDouble(),
      changePercent: (json['changePercent'] as num).toDouble(),
      volume: (json['volume'] as num).toDouble(),
      tradeAmount: (json['tradeAmount'] as num).toDouble(),
      detectedAt: DateTime.parse(json['detectedAt'] as String),
      patternType: PatternType.values.firstWhere(
        (e) => e.name == json['patternType'],
        orElse: () => PatternType.surge,
      ),
      patternDetails: Map<String, dynamic>.from(json['patternDetails'] as Map),
    );
  }
}\n\n// ====== lib/domain/entities/market_mood.dart ======\n
// lib/domain/entities/market_mood.dart
// ğŸ¯ Domain Layer: ìˆœìˆ˜ ì—”í‹°í‹°ë“¤ (VolumeData ì¶”ê°€)

import '../../core/utils/date_time.dart'; // DateTime extension

/// ğŸ•’ ë³¼ë¥¨ ê´€ë ¨ ìƒìˆ˜ ì •ì˜
class VolumeConstants {
 static const int minutesPerSlot = 30;
 static const int slotsPerHour = 60 ~/ minutesPerSlot; // 2
 static const int hoursPerDay = 24;
 static const int daysInBuffer = 7;
 static const int totalSlots = slotsPerHour * hoursPerDay * daysInBuffer; // 336
 static const int maxMinutesBuffer = minutesPerSlot * totalSlots; // 10080
 static const String volumeBoxName = 'market_volumes';
}

/// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° enum
enum MarketMood {
 bull,       // ğŸš€ ë¶ˆì¥
 weakBull,   // ğŸ”¥ ì•½ë¶ˆì¥
 sideways,   // âš–ï¸ ì¤‘ê°„ì¥
 bear,       // ğŸ’§ ë¬¼ì¥
 deepBear,   // ğŸ§Š ì–¼ìŒì¥
}

/// ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì—”í‹°í‹° (30ë¶„ ë‹¨ìœ„)
class VolumeData {
 final DateTime timestamp;
 final double volumeUsd;

 const VolumeData({
   required this.timestamp,
   required this.volumeUsd,
 });

 /// DateTime extension í™œìš©
 String get formattedTime => timestamp.yyyyMMddhhmm();
 String get timeAgoText => timestamp.timeAgo();
 String get shortTime => timestamp.hhmmss();

 /// JSON ì§ë ¬í™”
 Map<String, dynamic> toJson() => {
   'timestamp': timestamp.toIso8601String(),
   'volume_usd': volumeUsd,
 };

 factory VolumeData.fromJson(Map<String, dynamic> json) {
   return VolumeData(
     timestamp: DateTime.parse(json['timestamp']),
     volumeUsd: (json['volume_usd'] as num).toDouble(),
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is VolumeData &&
         runtimeType == other.runtimeType &&
         timestamp == other.timestamp &&
         volumeUsd == other.volumeUsd;

 @override
 int get hashCode => timestamp.hashCode ^ volumeUsd.hashCode;

 @override
 String toString() =>
     'VolumeData(${volumeUsd.toStringAsFixed(0)}B USD at ${timestamp.hhmmss()})';
}

/// ğŸ“Š ë§ˆì¼“ ë¬´ë“œ ë°ì´í„° ì—”í‹°í‹°
class MarketMoodData {
 final double totalMarketCapUsd;
 final double totalVolumeUsd;
 final double btcDominance;
 final double marketCapChange24h;
 final DateTime updatedAt;

 const MarketMoodData({
   required this.totalMarketCapUsd,
   required this.totalVolumeUsd,
   required this.btcDominance,
   required this.marketCapChange24h,
   required this.updatedAt,
 });

 /// JSON ì§ë ¬í™” (DTO í˜¸í™˜ìš©)
 Map<String, dynamic> toJson() => {
   'total_market_cap_usd': totalMarketCapUsd,
   'total_volume_usd': totalVolumeUsd,
   'btc_dominance': btcDominance,
   'market_cap_change_24h': marketCapChange24h,
   'updated_at': updatedAt.toIso8601String(),
 };

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodData &&
         runtimeType == other.runtimeType &&
         totalMarketCapUsd == other.totalMarketCapUsd &&
         totalVolumeUsd == other.totalVolumeUsd &&
         btcDominance == other.btcDominance &&
         marketCapChange24h == other.marketCapChange24h;

 @override
 int get hashCode =>
     totalMarketCapUsd.hashCode ^
     totalVolumeUsd.hashCode ^
     btcDominance.hashCode ^
     marketCapChange24h.hashCode;

 @override
 String toString() =>
     'MarketMoodData(volume: ${totalVolumeUsd.toStringAsFixed(0)}, '
     'cap: ${totalMarketCapUsd.toStringAsFixed(0)}, '
     'btc: ${btcDominance.toStringAsFixed(1)}%)';
}

/// ğŸ“Š ë¹„êµ ê²°ê³¼ ì—”í‹°í‹°
class ComparisonResult {
 final bool isReady;
 final double? changePercent;
 final double progressPercent;
 final String status;

 const ComparisonResult({
   required this.isReady,
   this.changePercent,
   required this.progressPercent,
   required this.status,
 });

 factory ComparisonResult.collecting(double progress) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: progress,
     status: 'ìˆ˜ì§‘ì¤‘',
   );
 }

 factory ComparisonResult.ready(double changePercent) {
   return ComparisonResult(
     isReady: true,
     changePercent: changePercent,
     progressPercent: 1.0,
     status: 'ì™„ë£Œ',
   );
 }

 factory ComparisonResult.unavailable(String message) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: 0.0,
     status: message,
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonResult &&
         runtimeType == other.runtimeType &&
         isReady == other.isReady &&
         changePercent == other.changePercent &&
         progressPercent == other.progressPercent &&
         status == other.status;

 @override
 int get hashCode =>
     isReady.hashCode ^
     changePercent.hashCode ^
     progressPercent.hashCode ^
     status.hashCode;

 @override
 String toString() =>
     'ComparisonResult(ready: $isReady, change: $changePercent%, progress: ${(progressPercent * 100).round()}%)';
}

/// ğŸ“ˆ ì „ì²´ ë¹„êµ ë°ì´í„° ì—”í‹°í‹°
class ComparisonData {
 final ComparisonResult thirtyMin;
 final ComparisonResult oneHour;
 final ComparisonResult twoHour;
 final ComparisonResult fourHour;
 final ComparisonResult eightHour;
 final ComparisonResult twelveHour;
 final ComparisonResult twentyFourHour;
 final ComparisonResult threeDayAverage;
 final ComparisonResult weeklyAverage;

 const ComparisonData({
   required this.thirtyMin,
   required this.oneHour,
   required this.twoHour,
   required this.fourHour,
   required this.eightHour,
   required this.twelveHour,
   required this.twentyFourHour,
   required this.threeDayAverage,
   required this.weeklyAverage,
 });

 factory ComparisonData.loading() {
   final loading = ComparisonResult.collecting(0.0);
   return ComparisonData(
     thirtyMin: loading,
     oneHour: loading,
     twoHour: loading,
     fourHour: loading,
     eightHour: loading,
     twelveHour: loading,
     twentyFourHour: loading,
     threeDayAverage: loading,
     weeklyAverage: loading,
   );
 }

 factory ComparisonData.error() {
   final error = ComparisonResult.unavailable('ì˜¤ë¥˜');
   return ComparisonData(
     thirtyMin: error,
     oneHour: error,
     twoHour: error,
     fourHour: error,
     eightHour: error,
     twelveHour: error,
     twentyFourHour: error,
     threeDayAverage: error,
     weeklyAverage: error,
   );
 }

 /// ëª¨ë“  ë¹„êµ ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜
 List<ComparisonResult> get allResults => [
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     ];

 /// ì¤€ë¹„ëœ ë¹„êµ ê²°ê³¼ ê°œìˆ˜
 int get readyCount => allResults.where((r) => r.isReady).length;

 /// ì „ì²´ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get overallProgress =>
     allResults.map((r) => r.progressPercent).reduce((a, b) => a + b) / 9;

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonData &&
         runtimeType == other.runtimeType &&
         thirtyMin == other.thirtyMin &&
         oneHour == other.oneHour &&
         twoHour == other.twoHour &&
         fourHour == other.fourHour &&
         eightHour == other.eightHour &&
         twelveHour == other.twelveHour &&
         twentyFourHour == other.twentyFourHour &&
         threeDayAverage == other.threeDayAverage &&
         weeklyAverage == other.weeklyAverage;

 @override
 int get hashCode => Object.hash(
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     );

 @override
 String toString() =>
     'ComparisonData(ready: $readyCount/9, progress: ${(overallProgress * 100).round()}%)';
}

/// ğŸ“¦ ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì—”í‹°í‹°
class MarketMoodSystemState {
 final MarketMoodData? marketData;
 final ComparisonData comparisonData;
 final MarketMood currentMood;
 final double exchangeRate;
 final bool isLoading;
 final bool hasError;

 const MarketMoodSystemState({
   required this.marketData,
   required this.comparisonData,
   required this.currentMood,
   required this.exchangeRate,
   required this.isLoading,
   required this.hasError,
 });

 /// ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸
 bool get isHealthy => !hasError && marketData != null;

 /// ë°ì´í„° ìˆ˜ì§‘ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get dataProgress => comparisonData.overallProgress;

 /// ìƒíƒœ ìš”ì•½ ë¬¸ìì—´
 String get statusSummary {
   if (hasError) return 'ì˜¤ë¥˜ ë°œìƒ';
   if (isLoading) return 'ë¡œë”© ì¤‘';
   if (marketData == null) return 'ë°ì´í„° ì—†ìŒ';
   return 'ì •ìƒ ì‘ë™';
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodSystemState &&
         runtimeType == other.runtimeType &&
         marketData == other.marketData &&
         comparisonData == other.comparisonData &&
         currentMood == other.currentMood &&
         exchangeRate == other.exchangeRate &&
         isLoading == other.isLoading &&
         hasError == other.hasError;

 @override
 int get hashCode => Object.hash(
       marketData,
       comparisonData,
       currentMood,
       exchangeRate,
       isLoading,
       hasError,
     );

 @override
 String toString() =>
     'MarketMoodSystemState(mood: $currentMood, status: $statusSummary, progress: ${(dataProgress * 100).round()}%)';
}\n\n// ====== lib/app.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Core
import 'core/config/app_config.dart';
import 'core/navigation/app_router.dart';
// Shared UI
import 'shared/theme/app_theme.dart';
// All app-level providers
import 'core/di/app_providers.dart';
import 'domain/entities/app_settings.dart';

/// Entry widget for the application
class MyApp extends ConsumerStatefulWidget {
  final GlobalKey<NavigatorState> navigatorKey;

  const MyApp({required this.navigatorKey, Key? key}) : super(key: key);

  @override
  ConsumerState<MyApp> createState() => _MyAppState();
}

class _MyAppState extends ConsumerState<MyApp> {
  late final AppRouter _appRouter;

  @override
  void initState() {
    super.initState();
    _appRouter = AppRouter(ref, widget.navigatorKey)
      ..setupFCMListeners();
  }

  @override
  void dispose() {
    _appRouter.dispose();
    ref.read(signalBusProvider).dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final settings = ref.watch(appSettingsProvider);

    return MaterialApp.router(
      title: 'ì½”ì¸ í¬ì°© ì•±',
      debugShowCheckedModeBanner: AppConfig.isDebugMode,
      
      theme: _applyFontFamily(AppTheme.light(), settings.fontFamily),
      darkTheme: _applyFontFamily(AppTheme.dark(), settings.fontFamily),
      themeMode: settings.themeMode,
      
      routerConfig: _appRouter.router,
      scaffoldMessengerKey: ref.watch(scaffoldMessengerKeyProvider),
    );
  }

  ThemeData _applyFontFamily(ThemeData baseTheme, FontFamily fontFamily) {
    final fontName = fontFamily.fontName;
    
    return baseTheme.copyWith(
      textTheme: baseTheme.textTheme.apply(
        fontFamily: fontName,
      ),
      primaryTextTheme: baseTheme.primaryTextTheme.apply(
        fontFamily: fontName,
      ),
      appBarTheme: baseTheme.appBarTheme.copyWith(
        titleTextStyle: baseTheme.appBarTheme.titleTextStyle?.copyWith(
          fontFamily: fontName,
        ),
      ),
      bottomNavigationBarTheme: baseTheme.bottomNavigationBarTheme.copyWith(
        selectedLabelStyle: TextStyle(fontFamily: fontName),
        unselectedLabelStyle: TextStyle(fontFamily: fontName),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: baseTheme.elevatedButtonTheme.style?.copyWith(
          textStyle: WidgetStateProperty.all(
            TextStyle(
              fontFamily: fontName,
              fontSize: 16,
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }
}

/// ProviderObserver for logging state changes
class AppProviderObserver extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase provider,
    Object? value,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] ğŸ†• Provider Added: ${provider.name ?? provider.runtimeType}');
    }
  }

  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] ğŸ”„ Provider Updated: ${provider.name ?? provider.runtimeType}');
    }
  }

  @override
  void didDisposeProvider(
    ProviderBase provider,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] â™»ï¸ Provider Disposed: ${provider.name ?? provider.runtimeType}');
    }
  }
}

/// Initializes critical providers on app start
class ProviderInitializer extends ConsumerWidget {
  final Widget child;

  const ProviderInitializer({required this.child, Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (AppConfig.isDebugMode) {
        debugPrint('[Initializer] âš¡ Initializing providers...');
      }

      ref.read(appSettingsProvider);
      ref.read(appLifecycleManagerProvider);

      if (AppConfig.isDebugMode) {
        debugPrint('[Initializer] âœ… Provider initialization complete.');
      }
    });

    return child;
  }
}\n\n// ====== lib/presentation/controllers/surge_controller.dart ======\n
// lib/presentation/controllers/surge_controller.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/surge_provider.dart'; // ğŸš€ surge_provider ì‚¬ìš©
import '../../domain/entities/surge.dart';
import '../../domain/usecases/surge_usecase.dart'; // SurgeFilterType import

/// ğŸš€ ì‹¬í”Œí•œ ê¸‰ë“±/ê¸‰ë½ ì»¨íŠ¸ë¡¤ëŸ¬ - SurgeTimeFrameController í™œìš©
class SurgeController extends StateNotifier<SurgeControllerState> {
  final Ref ref;
  
  SurgeController(this.ref) : super(const SurgeControllerState());

  /// ğŸš€ Top 50/100 í† ê¸€
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
  }

  /// ğŸš€ í•„í„° íƒ€ì… ë³€ê²½ (ì „ì²´/ê¸‰ë“±ë§Œ/ê¸‰ë½ë§Œ)
  void setFilterType(SurgeFilterType filterType) {
    state = state.copyWith(filterType: filterType);
  }

  /// ğŸš€ í˜„ì¬ í‘œì‹œ ê°œìˆ˜ (50 ë˜ëŠ” 100)
  int get currentLimit => state.isTop100 ? 100 : 50;

  /// ğŸš€ í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// ğŸš€ í˜„ì¬ í•„í„° íƒ€ì… ì´ë¦„
  String get currentFilterName {
    switch (state.filterType) {
      case SurgeFilterType.all:
        return 'ì „ì²´';
      case SurgeFilterType.risingOnly:
        return 'ìƒìŠ¹';
      case SurgeFilterType.fallingOnly:
        return 'í•˜ë½';
    }
  }

  /// ğŸš€ Top 100 ëª¨ë“œ ì—¬ë¶€
  bool get isTop100 => state.isTop100;

  /// ğŸš€ í˜„ì¬ í•„í„° íƒ€ì…
  SurgeFilterType get currentFilterType => state.filterType;

  void setTimeFrame(String timeFrame, int index) {
    // surge_provider.dartì˜ SurgeTimeFrameController ì‚¬ìš©
    final controller = ref.read(surgeTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€
  String get currentTimeFrame => ref.read(surgeTimeFrameController).currentTimeFrame;

  /// í˜„ì¬ ì¸ë±ìŠ¤
  int get currentIndex => ref.read(surgeTimeFrameController).currentIndex;

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë“¤
  List<String> get availableTimeFrames => ref.read(surgeTimeFrameController).availableTimeFrames;

  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    return ref.read(surgeTimeFrameController).getTimeFrameName(timeFrame);
  }

  /// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ë¥¼ ë³€ë™ë¥  ìˆœìœ¼ë¡œ ì •ë ¬ + í•„í„°ë§ + ë™ì  ìˆœìœ„ ì œí•œ (Top 50/100)
  List<Surge> sortAndFilterSurgeData(List<Surge> surgeData) {
    // 1) í•„í„° íƒ€ì…ì— ë”°ë¥¸ í•„í„°ë§
    List<Surge> filteredData = _applyFilter(surgeData, state.filterType);
    
    // 2) í•„í„° íƒ€ì…ì— ë”°ë¥¸ ì •ë ¬
    if (state.filterType == SurgeFilterType.fallingOnly) {
      // í•˜ë½ë§Œ: í•˜ë½ í° ìˆœì„œ (ì˜¤ë¦„ì°¨ìˆœ)
      filteredData.sort((a, b) => a.changePercent.compareTo(b.changePercent));
    } else {
      // ì „ì²´/ìƒìŠ¹: ë³€ë™ë¥  ë‚´ë¦¼ì°¨ìˆœ (í° í”ŒëŸ¬ìŠ¤ë¶€í„°)
      filteredData.sort((a, b) => b.changePercent.compareTo(a.changePercent));
    }
    
    // 3) í˜„ì¬ ì„¤ì •ì— ë”°ë¼ 50ê°œ ë˜ëŠ” 100ê°œë¡œ ì œí•œ
    return filteredData.take(currentLimit).toList();
  }

  /// ğŸš€ í•„í„° íƒ€ì… ì ìš©
  List<Surge> _applyFilter(List<Surge> surgeData, SurgeFilterType filterType) {
    switch (filterType) {
      case SurgeFilterType.all:
        return surgeData.where((s) => s.hasChange).toList();
      case SurgeFilterType.risingOnly:
        return surgeData.where((s) => s.isRising).toList();
      case SurgeFilterType.fallingOnly:
        return surgeData.where((s) => s.isFalling).toList();
    }
  }

  /// ì½”ì¸ëª… í•„í„°ë§
  List<Surge> filterByMarket(List<Surge> sortedData, String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return sortedData;
    }
    
    final upper = marketFilter.toUpperCase();
    return sortedData.where((surge) => surge.market.contains(upper)).toList();
  }

  /// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´íŠ¸ ê³„ì‚° (UIìš©)
  Map<String, int> getSurgeCount(List<Surge> surgeData) {
    final filteredData = _applyFilter(surgeData, state.filterType);
    
    final risingCount = filteredData.where((s) => s.isRising).length;
    final fallingCount = filteredData.where((s) => s.isFalling).length;
    
    return {
      'rising': risingCount,
      'falling': fallingCount,
    };
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    ref.read(surgeTimeFrameController).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    ref.read(surgeTimeFrameController).resetAllTimeFrames();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    return ref.read(surgeTimeFrameController).getNextResetTime();
  }
}

/// ğŸš€ SurgeController ìƒíƒœ ê´€ë¦¬
class SurgeControllerState {
  final bool isTop100;
  final SurgeFilterType filterType;

  const SurgeControllerState({
    this.isTop100 = false, // ê¸°ë³¸ê°’: Top 50
    this.filterType = SurgeFilterType.all, // ê¸°ë³¸ê°’: ì „ì²´
  });

  SurgeControllerState copyWith({
    bool? isTop100,
    SurgeFilterType? filterType,
  }) {
    return SurgeControllerState(
      isTop100: isTop100 ?? this.isTop100,
      filterType: filterType ?? this.filterType,
    );
  }
}

/// Provider ì„ ì–¸ - StateNotifierProviderë¡œ ë³€ê²½!
final surgeControllerProvider = StateNotifierProvider<SurgeController, SurgeControllerState>((ref) => SurgeController(ref));\n\n// ====== lib/presentation/controllers/main_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/settings_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/sector_controller.dart ======\n
// lib/presentation/controllers/sector_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/sector_provider.dart';
import '../../domain/entities/volume.dart';

/// ì„¹í„° í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class SectorState {
  final List<Volume> sectorVolumes;
  final bool isLoading;
  final bool isDetailedClassification;
  final String timeFrame;
  final int selectedTimeFrameIndex;
  final String? errorMessage;

  const SectorState({
    this.sectorVolumes = const [],
    this.isLoading = false,
    this.isDetailedClassification = true,
    this.timeFrame = '1m',
    this.selectedTimeFrameIndex = 0,
    this.errorMessage,
  });

  SectorState copyWith({
    List<Volume>? sectorVolumes,
    bool? isLoading,
    bool? isDetailedClassification,
    String? timeFrame,
    int? selectedTimeFrameIndex,
    String? errorMessage,
  }) {
    return SectorState(
      sectorVolumes: sectorVolumes ?? this.sectorVolumes,
      isLoading: isLoading ?? this.isLoading,
      isDetailedClassification: isDetailedClassification ?? this.isDetailedClassification,
      timeFrame: timeFrame ?? this.timeFrame,
      selectedTimeFrameIndex: selectedTimeFrameIndex ?? this.selectedTimeFrameIndex,
      errorMessage: errorMessage,
    );
  }
}

/// Sector í™”ë©´ ì „ìš© ViewModel
class SectorController extends StateNotifier<SectorState> {
  final Ref _ref;
  ProviderSubscription<AsyncValue<List<Volume>>>? _subscription;

  SectorController(this._ref) : super(const SectorState()) {
    _initializeStream();
  }

  /// ì„¹í„° ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì´ˆê¸°í™”
  void _initializeStream() {
    _subscription?.close();
    
    final controller = _ref.read(sectorTimeFrameController);
    
    state = state.copyWith(
      isLoading: true,
      isDetailedClassification: controller.isDetailedClassification,
      timeFrame: controller.currentTimeFrame,
      selectedTimeFrameIndex: controller.currentIndex,
      errorMessage: null,
    );

    // AsyncValue ì§ì ‘ êµ¬ë…
    _subscription = _ref.listen(sectorVolumeDataProvider, (previous, next) {
      next.when(
        data: (volumes) {
          state = state.copyWith(
            sectorVolumes: volumes,
            isLoading: false,
            errorMessage: null,
          );
        },
        loading: () {
          state = state.copyWith(
            isLoading: true,
            errorMessage: null,
          );
        },
        error: (error, stackTrace) {
          state = state.copyWith(
            isLoading: false,
            errorMessage: error.toString(),
          );
        },
      );
    });
  }

  /// ì‹œê°„ëŒ€ ë³€ê²½
  void setTimeFrame(String timeFrame, int index) {
    final controller = _ref.read(sectorTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
    
    state = state.copyWith(
      timeFrame: timeFrame,
      selectedTimeFrameIndex: index,
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _initializeStream();
  }

  /// ì„¹í„° ë¶„ë¥˜ í† ê¸€ (ìƒì„¸ â†” ê¸°ë³¸)
  void toggleSectorClassification() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.toggleSectorClassification();
    
    state = state.copyWith(
      isDetailedClassification: !state.isDetailedClassification,
      isLoading: true,
      errorMessage: null,
    );
    
    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë… (ìƒˆë¡œìš´ ë¶„ë¥˜ë¡œ)
    _initializeStream();
  }

  /// ìƒˆë¡œê³ ì¹¨
  void refresh() {
    _initializeStream();
  }

  /// ì„¹í„° ëª©ë¡ í•„í„°ë§ (ì„¹í„°ëª…ìœ¼ë¡œ)
  List<Volume> filterBySector(String? sectorFilter) {
    if (sectorFilter == null || sectorFilter.isEmpty) {
      return state.sectorVolumes;
    }
    final upper = sectorFilter.toUpperCase();
    return state.sectorVolumes.where((volume) {
      final sectorName = volume.market.replaceFirst('SECTOR-', '');
      return sectorName.contains(upper);
    }).toList();
  }

  /// ì„¹í„° ëª©ë¡ ì •ë ¬
  void sortSectors(String field, bool ascending) {
    final list = [...state.sectorVolumes];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'sector':
          aValue = a.market.replaceFirst('SECTOR-', '');
          bValue = b.market.replaceFirst('SECTOR-', '');
          break;
        case 'volume':
          aValue = a.totalVolume;
          bValue = b.totalVolume;
          break;
        case 'timestamp':
          aValue = a.lastUpdatedMs;
          bValue = b.lastUpdatedMs;
          break;
        default:
          aValue = a.totalVolume;
          bValue = b.totalVolume;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(sectorVolumes: list);
  }

  /// ì„¹í„° ë³¼ë¥¨ ë°ì´í„° ì •ë ¬ ì ìš© (ê¸°ë³¸: ë³¼ë¥¨ ë‚´ë¦¼ì°¨ìˆœ)
  List<Volume> applySorting(List<Volume> volumes) {
    final sorted = [...volumes];
    sorted.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
    return sorted;
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetCurrentTimeFrame();
    refresh();
  }

  void resetAllTimeFrames() {
    final controller = _ref.read(sectorTimeFrameController);
    controller.resetAllTimeFrames();
    refresh();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getNextResetTime();
  }

  /// ìœ í‹¸ë¦¬í‹° Getters
  List<String> get availableTimeFrames {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.availableTimeFrames;
  }

  String getTimeFrameName(String timeFrame) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getTimeFrameName(timeFrame);
  }

  String get currentSectorClassificationName {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.currentSectorClassificationName;
  }

  int get totalSectors {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.totalSectors;
  }

  /// íŠ¹ì • ì„¹í„°ì˜ ì½”ì¸ë“¤ ì¡°íšŒ
  List<String> getCoinsInSector(String sectorName) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getCoinsInSector(sectorName);
  }

  /// íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì¡°íšŒ
  List<String> getSectorsForCoin(String ticker) {
    final controller = _ref.read(sectorTimeFrameController);
    return controller.getSectorsForCoin(ticker);
  }

  @override
  void dispose() {
    _subscription?.close();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final sectorControllerProvider =
    StateNotifierProvider<SectorController, SectorState>((ref) {
  return SectorController(ref);
});\n\n// ====== lib/presentation/controllers/signal_controller.dart ======\n
// lib/presentation/controllers/signal_controller.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/signal_provider.dart';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/usecases/signal_usecase.dart';

/// ğŸš€ Signal í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸ V4.1
class SignalState {
  final List<Signal> signals;
  final bool isLoading;
  final bool isConnected;
  final PatternType currentPattern;
  final int selectedIndex;
  final double threshold;
  final bool isPatternEnabled;
  final String? errorMessage;
  final Map<String, dynamic>? systemHealth; // ğŸ†• V4.1
  final Map<String, dynamic>? onlineMetricsHealth; // ğŸ†• V4.1
  final String sortField; // ğŸ†• V4.1
  final bool sortAscending; // ğŸ†• V4.1

  const SignalState({
    this.signals = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.currentPattern = PatternType.surge,
    this.selectedIndex = 0,
    this.threshold = 0.4,
    this.isPatternEnabled = true,
    this.errorMessage,
    this.systemHealth,
    this.onlineMetricsHealth,
    this.sortField = 'time',
    this.sortAscending = false,
  });

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ê²° ìƒíƒœ
  bool get hasOnlineMetrics => onlineMetricsHealth != null;
  
  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„±
  bool get isSystemHealthy => 
      systemHealth?['status'] == 'healthy' && 
      (onlineMetricsHealth?['staleMarkets'] ?? 0) == 0;

  /// ğŸ†• V4.1 ì‹ í˜¸ í†µê³„
  Map<String, dynamic> get signalStats {
    final total = signals.length;
    final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
    final avgConfidence = signals.isNotEmpty 
        ? signals.map((s) => s.confidence ?? 0.0).reduce((a, b) => a + b) / total
        : 0.0;
    
    return {
      'total': total,
      'withOnlineMetrics': withOnlineMetrics,
      'onlineMetricsRatio': total > 0 ? withOnlineMetrics / total : 0.0,
      'avgConfidence': avgConfidence,
      'pattern': currentPattern.displayName,
    };
  }

  SignalState copyWith({
    List<Signal>? signals,
    bool? isLoading,
    bool? isConnected,
    PatternType? currentPattern,
    int? selectedIndex,
    double? threshold,
    bool? isPatternEnabled,
    String? errorMessage,
    Map<String, dynamic>? systemHealth,
    Map<String, dynamic>? onlineMetricsHealth,
    String? sortField,
    bool? sortAscending,
  }) {
    return SignalState(
      signals: signals ?? this.signals,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      currentPattern: currentPattern ?? this.currentPattern,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      threshold: threshold ?? this.threshold,
      isPatternEnabled: isPatternEnabled ?? this.isPatternEnabled,
      errorMessage: errorMessage,
      systemHealth: systemHealth ?? this.systemHealth,
      onlineMetricsHealth: onlineMetricsHealth ?? this.onlineMetricsHealth,
      sortField: sortField ?? this.sortField,
      sortAscending: sortAscending ?? this.sortAscending,
    );
  }
}

/// ğŸš€ Signal í™”ë©´ ì „ìš© ViewModel V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
class SignalController extends StateNotifier<SignalState> {
  final SignalUseCase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Signal>, AppException>>? _subscription;
  StreamSubscription<Map<String, dynamic>>? _healthSubscription; // ğŸ†• V4.1
  Timer? _healthUpdateTimer; // ğŸ†• V4.1

  SignalController(this._usecase, this._ref) : super(const SignalState()) {
    _startSystemHealthMonitoring(); // ğŸ†• V4.1
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§
  // ==========================================================================

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
  void _startSystemHealthMonitoring() {
    _healthUpdateTimer = Timer.periodic(const Duration(seconds: 10), (_) {
      _updateSystemHealth();
      _updateOnlineMetricsHealth();
    });
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸
  void _updateSystemHealth() async {
    try {
      final controller = _ref.read(signalPatternController);
      final health = await controller.getSystemHealth();
      
      state = state.copyWith(systemHealth: health);
      
      if (AppConfig.enableTradeLog) {
        final staleMarkets = health['onlineMetricsSystem']?['staleMarkets'] ?? 0;
        if (staleMarkets > 0) {
          log.w('âš ï¸ Signal Controller: $staleMarketsê°œ ë§ˆì¼“ ì˜¨ë¼ì¸ ì§€í‘œ ë§Œë£Œ');
        }
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: System health update failed - $e');
      }
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í—¬ìŠ¤ ì—…ë°ì´íŠ¸
  void _updateOnlineMetricsHealth() {
    try {
      final controller = _ref.read(signalPatternController);
      final health = controller.getOnlineMetricsHealth();
      
      state = state.copyWith(onlineMetricsHealth: health);
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.w('Signal Controller: Online metrics health update failed - $e');
      }
    }
  }

  // ==========================================================================
  // ê¸°ë³¸ íŒ¨í„´ ê´€ë¦¬ (ê¸°ì¡´ + V4.1 ê°œì„ )
  // ==========================================================================

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™) - V4.1 ê°œì„ 
  void setPatternIndex(int index, List<String> markets) {
    if (index < 0 || index >= PatternType.values.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid pattern index: $index');
      }
      return;
    }

    final patternType = PatternType.values[index];
    final defaultThreshold = patternType.defaultThreshold; // V4.1 ê¸°ë³¸ê°’

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    final controller = _ref.read(signalPatternController);
    controller.updatePatternIndex(index);

    state = state.copyWith(
      currentPattern: patternType,
      selectedIndex: index,
      threshold: defaultThreshold,
      isLoading: true,
      errorMessage: null,
    );

    // ìŠ¤íŠ¸ë¦¼ ì¬êµ¬ë…
    _subscribeToPattern(patternType, markets);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ¯ Pattern changed to: ${patternType.displayName} (V4.1)');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½ - V4.1 ê°œì„ 
  void updateThreshold(double threshold) {
    try {
      // UseCaseë¥¼ í†µí•œ ê²€ì¦ëœ ì—…ë°ì´íŠ¸
      _usecase.updatePatternThreshold(state.currentPattern, threshold);
      
      final controller = _ref.read(signalPatternController);
      controller.updateThreshold(threshold);

      state = state.copyWith(threshold: threshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“Š Threshold updated: ${state.currentPattern.displayName} â†’ $threshold');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Threshold update failed: $e');
      }
      
      // ì—ëŸ¬ë¥¼ ì‚¬ìš©ìì—ê²Œ í‘œì‹œ
      state = state.copyWith(
        errorMessage: 'Invalid threshold value: ${e.toString()}'
      );
    }
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€ - V4.1 ê°œì„ 
  void togglePatternEnabled() {
    final newEnabled = !state.isPatternEnabled;
    
    _usecase.setPatternEnabled(state.currentPattern, newEnabled);
    
    final controller = _ref.read(signalPatternController);
    controller.setPatternEnabled(state.currentPattern, newEnabled);

    state = state.copyWith(isPatternEnabled: newEnabled);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Pattern ${newEnabled ? "enabled" : "disabled"}: ${state.currentPattern.displayName}');
    }
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™” - V4.1 ê°œì„ 
  void clearSignals([PatternType? pattern]) {
    final controller = _ref.read(signalPatternController);
    controller.clearSignals(pattern);

    if (pattern == null || pattern == state.currentPattern) {
      state = state.copyWith(signals: []);
    }
    
    if (AppConfig.enableTradeLog) {
      final patternName = pattern?.displayName ?? 'All patterns';
      log.i('ğŸ§¹ Signals cleared: $patternName');
    }
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì •
  // ==========================================================================

  /// ğŸ†• ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸
  void updateAdvancedPatternConfig(String key, double value) {
    try {
      _usecase.updateAdvancedPatternConfig(state.currentPattern, key, value);
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Advanced config updated: ${state.currentPattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Advanced config update failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration update failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    try {
      _usecase.applyPatternPreset(presetName);
      
      // í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ë„ ì—…ë°ì´íŠ¸
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      state = state.copyWith(threshold: newThreshold);
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Preset applied: $presetName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Preset application failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Preset application failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
  void resetOnlineMetrics([String? market]) {
    final controller = _ref.read(signalPatternController);
    controller.resetOnlineMetrics(market);
    
    // í—¬ìŠ¤ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    _updateOnlineMetricsHealth();
    
    if (AppConfig.enableTradeLog) {
      final target = market ?? 'all markets';
      log.i('ğŸ”„ Online metrics reset: $target');
    }
  }

  // ==========================================================================
  // ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ (V4.1 ê°œì„ )
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ êµ¬ë… - V4.1 ê°œì„ 
  void _subscribeToPattern(PatternType patternType, List<String> markets) {
    _subscription?.cancel();
    
    _subscription = _usecase
        .watchSignalsByPattern(patternType, markets)
        .map((signals) => Ok<List<Signal>, AppException>(signals))
        .handleError((error) => Err<List<Signal>, AppException>(
            AppException(
              'Signal pattern detection failed: ${error.toString()}',
              code: 'SIGNAL_PATTERN_ERROR',
              originalException: error is Exception ? error : null,
            )))
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Signal>, AppException> result) {
    result.when(
      ok: (signals) {
        // V4.1 ì •ë ¬ ì ìš©
        final sortedSignals = _applySorting(signals);
        
        state = state.copyWith(
          signals: sortedSignals,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
        
        // ì˜¨ë¼ì¸ ì§€í‘œ í†µê³„ ë¡œê¹…
        if (AppConfig.enableTradeLog && signals.isNotEmpty) {
          final withOnlineMetrics = signals.where((s) => s.hasOnlineMetrics).length;
          final ratio = (withOnlineMetrics / signals.length * 100).toStringAsFixed(1);
          log.i('ğŸ“Š Signals received: ${signals.length}, Online metrics: $withOnlineMetrics ($ratio%)');
        }
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
        
        if (AppConfig.enableTradeLog) {
          log.e('âŒ Signal stream error: ${e.message}');
        }
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨ - V4.1 ê°œì„ 
  void refresh(List<String> markets) {
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Signal refresh requested for ${markets.length} markets');
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœë„ ë¦¬ì…‹
    resetOnlineMetrics();
    
    // íŒ¨í„´ ì¬êµ¬ë…
    setPatternIndex(state.selectedIndex, markets);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì •ë ¬ ë° í•„í„°ë§
  // ==========================================================================

  /// ğŸ†• ì •ë ¬ í•„ë“œ ë³€ê²½
  void setSortField(String field, {bool? ascending}) {
    final newAscending = ascending ?? (state.sortField == field ? !state.sortAscending : false);
    
    state = state.copyWith(
      sortField: field,
      sortAscending: newAscending,
      signals: _applySorting(state.signals),
    );
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ“Š Sort changed: $field (${newAscending ? "ASC" : "DESC"})');
    }
  }

  /// ğŸ†• ì •ë ¬ ì ìš©
  List<Signal> _applySorting(List<Signal> signals) {
    final list = List<Signal>.from(signals);
    
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      
      switch (state.sortField) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.currentPrice;
          bValue = b.currentPrice;
          break;
        case 'change':
          aValue = a.changePercent.abs();
          bValue = b.changePercent.abs();
          break;
        case 'amount':
          aValue = a.tradeAmount;
          bValue = b.tradeAmount;
          break;
        case 'confidence':
          aValue = a.confidence ?? 0.0;
          bValue = b.confidence ?? 0.0;
          break;
        case 'time':
        default:
          aValue = a.detectedAt.millisecondsSinceEpoch;
          bValue = b.detectedAt.millisecondsSinceEpoch;
      }
      
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      
      return state.sortAscending ? cmp : -cmp;
    });
    
    return list;
  }

  /// ğŸ†• ê³ ê¸‰ í•„í„°ë§ (V4.1)
  List<Signal> filterSignals({
    String? marketFilter,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
  }) {
    return _usecase.filterSignals(
      state.signals,
      markets: marketFilter != null ? {marketFilter.toUpperCase()} : null,
      minConfidence: minConfidence,
      requireOnlineMetrics: requireOnlineMetrics,
      patternTypes: patternTypes,
      timeWindow: timeWindow,
    );
  }

  // ==========================================================================
  // í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± (V4.1 ê°œì„ )
  // ==========================================================================

  /// í˜„ì¬ íŒ¨í„´ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± - V4.1 ê°œì„ 
  String getPatternDisplayText() {
    final pattern = state.currentPattern;
    return '${pattern.displayName}: ${pattern.description}';
  }

  /// í˜„ì¬ íŒ¨í„´ ì•„ì´ì½˜/ì´ëª¨ì§€
  String getPatternIcon() {
    return state.currentPattern.displayName;
  }

  /// ì„ê³„ê°’ í‘œì‹œ í…ìŠ¤íŠ¸ - V4.1 ê°œì„ 
  String getThresholdDisplayText() {
    final threshold = state.threshold;
    final pattern = state.currentPattern;

    switch (pattern) {
      case PatternType.surge:
        return '${threshold.toStringAsFixed(1)}% ìƒìŠ¹';
      case PatternType.flashFire:
        return '${threshold.toStringAsFixed(1)}ë°° ê¸‰ì¦';
      case PatternType.stackUp:
        return '${threshold.toInt()}ì—°ì† ì¦ê°€';
      case PatternType.stealthIn:
        final amountText = threshold >= 1000000 
            ? '${(threshold / 1000000).toStringAsFixed(0)}ë°±ë§Œì›'
            : '${threshold.toStringAsFixed(0)}ì›';
        return '$amountText ì´ìƒ';
      case PatternType.blackHole:
        return '${threshold.toStringAsFixed(1)}% ì´í•˜ ë³€ë™';
      case PatternType.reboundShot:
        return '${threshold.toStringAsFixed(1)}% ê¸‰ë½ í›„ ë°˜ë“±';
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ í…ìŠ¤íŠ¸
  String getSystemStatusText() {
    if (!state.hasOnlineMetrics) return 'Online metrics: Connecting...';
    
    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    if (staleMarkets > 0) {
      return 'Online metrics: $healthyMarkets/$totalMarkets healthy ($staleMarkets stale)';
    }
    
    return 'Online metrics: $healthyMarkets/$totalMarkets healthy âœ…';
  }

  /// ğŸ†• ì‹ ë¢°ë„ ìƒíƒœ í‘œì‹œ
  String getConfidenceStatusText() {
    final stats = state.signalStats;
    final avgConf = stats['avgConfidence'] as double;
    final onlineRatio = stats['onlineMetricsRatio'] as double;
    
    return 'Avg confidence: ${(avgConf * 100).toStringAsFixed(1)}%, '
           'Online: ${(onlineRatio * 100).toStringAsFixed(1)}%';
  }

  // ==========================================================================
  // ğŸ†• V4.1 í†µê³„ ë° ë¶„ì„
  // ==========================================================================

  /// ğŸ†• íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<Map<String, dynamic>> getPatternPerformance() async {
    try {
      final performance = await _usecase.getPatternPerformance(state.currentPattern);
      return {
        'pattern': performance.patternType.displayName,
        'totalSignals': performance.totalSignals,
        'recentSignals': performance.recentSignals,
        'lastSignalTime': performance.lastSignalTime?.toIso8601String(),
        'isEnabled': performance.isEnabled,
        'onlineMetricsHealth': performance.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Pattern performance query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
  Future<Map<String, dynamic>> getSystemHealthReport() async {
    try {
      final report = await _usecase.getSystemHealthReport();
      return {
        'version': report.version,
        'status': report.status,
        'uptime': report.uptime,
        'totalProcessedTrades': report.totalProcessedTrades,
        'activePatterns': report.activePatterns,
        'trackedMarkets': report.trackedMarkets,
        'isHealthy': report.isHealthy,
        'onlineMetricsHealth': report.onlineMetricsHealth,
      };
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ System health report query failed: $e');
      }
      return {'error': e.toString()};
    }
  }

  /// ğŸ†• ì‹ í˜¸ í†µê³„ ê³„ì‚°
  Map<String, dynamic> calculateSignalStats() {
    return _usecase.calculateSignalStats(state.signals).toJson();
  }

  // ==========================================================================
  // ê¸°ì¡´ í˜¸í™˜ì„± ë©”ì„œë“œë“¤ (V4.1 ê°œì„ )
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ (ê¸°ì¡´ í˜¸í™˜ì„±)
  Map<String, dynamic> getSignalStats() {
    return state.signalStats;
  }

  /// ì‹œê·¸ë„ ëª©ë¡ ì ìš© (ì •ë ¬ ë“±) - V4.1 ê°œì„ 
  List<Signal> apply(List<Signal> signals) {
    return _applySorting(signals);
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ëª©ë¡ - V4.1 ê°œì„ 
  List<String> get availablePatterns => 
      PatternType.values.map((p) => p.name).toList();

  /// íŒ¨í„´ í‘œì‹œëª… ëª©ë¡ - V4.1 ê°œì„ 
  List<String> get patternDisplayNames => 
      PatternType.values.map((p) => p.displayName).toList();

  /// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê°„ ìœˆë„ìš° - V4.1 ê°œì„ 
  int get currentTimeWindow => state.currentPattern.timeWindowMinutes;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ê¸°ë³¸ ì‹ ë¢°ë„
  double get currentPatternDefaultConfidence => state.currentPattern.defaultConfidence;

  /// ğŸ†• V4.1 í˜„ì¬ íŒ¨í„´ì˜ ì¿¨ë‹¤ìš´ ì‹œê°„
  int get currentPatternCooldownSeconds => state.currentPattern.defaultCooldownSeconds;

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬
  // ==========================================================================

  /// ğŸ†• í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸°
  Map<String, dynamic> exportConfiguration() {
    final controller = _ref.read(signalPatternController);
    return controller.exportConfiguration();
  }

  /// ğŸ†• ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  void importConfiguration(Map<String, dynamic> config) {
    try {
      final controller = _ref.read(signalPatternController);
      controller.importConfiguration(config);
      
      // í˜„ì¬ ìƒíƒœ ìƒˆë¡œê³ ì¹¨
      final newThreshold = _usecase.getPatternThreshold(state.currentPattern);
      final newEnabled = _usecase.isPatternEnabled(state.currentPattern);
      
      state = state.copyWith(
        threshold: newThreshold,
        isPatternEnabled: newEnabled,
      );
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“¥ Configuration imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Configuration import failed: $e');
      }
      
      state = state.copyWith(
        errorMessage: 'Configuration import failed: ${e.toString()}'
      );
    }
  }

  /// ğŸ†• ì—ëŸ¬ ë©”ì‹œì§€ í´ë¦¬ì–´
  void clearError() {
    state = state.copyWith(errorMessage: null);
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (V4.1 í™•ì¥)
  // ==========================================================================

  @override
  void dispose() {
    _subscription?.cancel();
    _healthSubscription?.cancel();
    _healthUpdateTimer?.cancel();
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal Controller V4.1 disposed');
    }
    
    super.dispose();
  }
}

/// Provider ì„ ì–¸ - V4.1
final signalControllerProvider =
    StateNotifierProvider<SignalController, SignalState>((ref) {
  final usecase = ref.read(signalUsecaseProvider);
  return SignalController(usecase, ref);
});

/// ğŸ†• V4.1 í™•ì¥ - ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ Provider
final signalSystemMonitorProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final controller = ref.watch(signalControllerProvider.notifier);
  
  yield* Stream.periodic(const Duration(seconds: 15), (_) async {
    final performance = await controller.getPatternPerformance();
    final systemHealth = await controller.getSystemHealthReport();
    final signalStats = controller.calculateSignalStats();
    
    return {
      'timestamp': DateTime.now().toIso8601String(),
      'performance': performance,
      'systemHealth': systemHealth,
      'signalStats': signalStats,
      'version': 'V4.1-Online',
    };
  }).asyncMap((event) => event);
});\n\n// ====== lib/presentation/controllers/market_mood_controller.dart ======\n
// lib/presentation/controllers/market_mood_controller.dart
// ğŸ® Presentation Layer: Market Mood ì»¨íŠ¸ë¡¤ëŸ¬ (ë¦¬íŒ©í† ë§ëœ Providerì— ë§ì¶° ìˆ˜ì •)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/utils/date_time.dart';
import '../pages/market_mood_page.dart';

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬
class MarketMoodPageController extends StateNotifier<MarketMoodPageState> {
  final Ref _ref;

  MarketMoodPageController(this._ref) : super(MarketMoodPageState.initial()) {
    // [ìˆ˜ì •] ì´ˆê¸°í™” ë¡œì§ì„ ìƒì„±ìì—ì„œ ë¶„ë¦¬í•˜ì—¬ ëª…í™•í•˜ê²Œ ê´€ë¦¬
    _initialize();
  }

  /// [ìˆ˜ì •] ì´ˆê¸°í™” ë° ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë‹ ì‹œì‘
  void _initialize() {
    // 1. ì´ˆê¸° ìƒíƒœ ì„¤ì •
    final initialState = _ref.read(marketMoodSystemProvider);
    state = state.copyWith(
      isLoading: initialState.isLoading,
      error: initialState.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
      systemState: initialState,
    );

    // 2. ì‹¤ì‹œê°„ ìƒíƒœ ë³€í™” ê°ì§€ ë° ë™ê¸°í™”
    //    ì´ì œ ìµœì¢… ìƒíƒœì¸ marketMoodSystemProviderë§Œ listení•˜ë©´ ë©ë‹ˆë‹¤.
    _ref.listen<MarketMoodSystemState>(
      marketMoodSystemProvider,
      (previous, next) {
        state = state.copyWith(
          isLoading: next.isLoading,
          error: next.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
          systemState: next,
        );
      },
    );
  }

  /// [ìˆ˜ì •] ë°ì´í„° ë¡œë“œ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // Future<void> loadData() async { ... }

  /// ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  void refresh() {
    // [ìˆ˜ì •] controllerë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë‘ì§€ ì•Šê³  í•„ìš” ì‹œ read
    final controller = _ref.read(marketMoodControllerProvider);
    controller.refresh();
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  MarketMood getCurrentMood() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(currentMarketMoodProvider);
  }

  /// í™˜ìœ¨ ì¡°íšŒ (Future ëŒ€ì‘ - ì´ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ)
  Future<double> getExchangeRate() async {
    final exchangeAsync = _ref.read(exchangeRateProvider);
    return exchangeAsync.when(
      data: (rate) => rate,
      loading: () => 1400.0,
      error: (_, __) => 1400.0,
    );
  }

  /// [ìˆ˜ì •] ë³¼ë¥¨ ë¹„êµ ë°ì´í„° ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  ComparisonData getVolumeComparisons() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(volumeComparisonProvider);
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<void> checkSystemHealth() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      final health = await controller.getSystemHealth();

      state = state.copyWith(
        systemHealth: health,
        lastHealthCheck: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.refreshExchangeRate();
      // loadData() ëŒ€ì‹  systemProviderê°€ ìë™ìœ¼ë¡œ ê°±ì‹ í•˜ë¯€ë¡œ ë³„ë„ í˜¸ì¶œ ë¶ˆí•„ìš”
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ë¡œê¹…
  Future<void> logSystemStatus() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.logSystemStatus();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ë¶„ìœ„ê¸° ì´ëª¨ì§€ ì¡°íšŒ
  String getMoodEmoji(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ğŸš€',
      MarketMood.weakBull => 'ğŸ”¥',
      MarketMood.sideways => 'âš–ï¸',
      MarketMood.bear => 'ğŸ’§',
      MarketMood.deepBear => 'ğŸ§Š',
    };
  }

  /// ë¶„ìœ„ê¸° ì´ë¦„ ì¡°íšŒ
  String getMoodName(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ë¶ˆì¥',
      MarketMood.weakBull => 'ì•½ë¶ˆì¥',
      MarketMood.sideways => 'ì¤‘ê°„ì¥',
      MarketMood.bear => 'ë¬¼ì¥',
      MarketMood.deepBear => 'ì–¼ìŒì¥',
    };
  }

  /// [ìˆ˜ì •] ë¶„ìœ„ê¸° ìš”ì•½ í…ìŠ¤íŠ¸ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  String getMoodSummary() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(marketMoodSummaryProvider);
  }

  /// ë³¼ë¥¨ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatVolume(double volumeUsd) async {
    final rate = await getExchangeRate();
    final volumeKrw = volumeUsd * rate;

    if (volumeKrw >= 1e12) {
      final trillions = (volumeKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    if (volumeKrw >= 1e8) {
      final hundreds = (volumeKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    return '${(volumeKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì‹œê°€ì´ì•¡ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatMarketCap(double marketCapUsd) async {
    final rate = await getExchangeRate();
    // [ìˆ˜ì •] marketCapKrw ë³€ìˆ˜ ì„ ì–¸
    final marketCapKrw = marketCapUsd * rate; 

    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e12) { 
      final trillions = (marketCapKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e8) {
      final hundreds = (marketCapKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    return '${(marketCapKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì—…ë°ì´íŠ¸ ì‹œê°„ í¬ë§·íŒ…
  String formatUpdateTime(DateTime updatedAt) {
    return updatedAt.hhmmss(); // DateTime extension ì‚¬ìš©
  }

  /// ë¹„êµ ê²°ê³¼ ê°’ í¬ë§·íŒ…
  String formatComparisonValue(ComparisonResult result) {
    if (result.isReady && result.changePercent != null) {
      final value = result.changePercent!;
      final arrow = value > 5 ? 'â†—ï¸' : value < -5 ? 'â†˜ï¸' : 'â¡ï¸';
      return '${value >= 0 ? '+' : ''}${value.toStringAsFixed(1)}% $arrow';
    }
    return '${(result.progressPercent * 100).round()}% (${result.status})';
  }

  /// ì§„í–‰ë¥  ê³„ì‚°
  int getProgressPercent(ComparisonResult result) {
    return (result.progressPercent * 100).round();
  }

  /// í•˜ì´ë¼ì´íŠ¸ ìƒ‰ìƒ íŒë‹¨
  bool isHighlight(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) > 5;
  }

  /// ê²½ê³  ìƒ‰ìƒ íŒë‹¨
  bool isWarning(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) < -5;
  }

  /// [ìˆ˜ì •] ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë‹ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // void startListening() { ... }

  /// ìˆ«ìì— ì½¤ë§ˆ ì¶”ê°€
  String _addCommas(String numberStr) {
    final parts = numberStr.split('.');
    final integerPart = parts[0];
    final reversedInteger = integerPart.split('').reversed.join('');
    final withCommas = reversedInteger
        .replaceAllMapped(RegExp(r'.{3}'), (match) => '${match.group(0)},')
        .split('')
        .reversed
        .join('');
    final result =
        withCommas.startsWith(',') ? withCommas.substring(1) : withCommas;
    return parts.length > 1 ? '$result.${parts[1]}' : result;
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ìƒíƒœ
class MarketMoodPageState {
  final bool isLoading;
  final String? error;
  final MarketMoodSystemState? systemState;
  final Map<String, dynamic>? systemHealth;
  final DateTime? lastHealthCheck;

  const MarketMoodPageState({
    required this.isLoading,
    this.error,
    this.systemState,
    this.systemHealth,
    this.lastHealthCheck,
  });

  factory MarketMoodPageState.initial() {
    return const MarketMoodPageState(isLoading: true); // [ìˆ˜ì •] ì´ˆê¸° ìƒíƒœëŠ” ë¡œë”©ì¤‘
  }

  MarketMoodPageState copyWith({
    bool? isLoading,
    String? error,
    MarketMoodSystemState? systemState,
    Map<String, dynamic>? systemHealth,
    DateTime? lastHealthCheck,
  }) {
    return MarketMoodPageState(
      isLoading: isLoading ?? this.isLoading,
      error: error, // [ìˆ˜ì •] nullë¡œ ë®ì–´ì“°ê¸° ê°€ëŠ¥í•˜ë„ë¡ ?? this.error ì œê±°
      systemState: systemState ?? this.systemState,
      systemHealth: systemHealth ?? this.systemHealth,
      lastHealthCheck: lastHealthCheck ?? this.lastHealthCheck,
    );
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬ Provider
final marketMoodPageControllerProvider = StateNotifierProvider.autoDispose<
    MarketMoodPageController, MarketMoodPageState>((ref) {
  // [ìˆ˜ì •] ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± ì‹œ ë°”ë¡œ _initialize()ê°€ í˜¸ì¶œë˜ë¯€ë¡œ ë³„ë„ ë¡œì§ ë¶ˆí•„ìš”
  return MarketMoodPageController(ref);
});

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ ê´€ë¦¬ì (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalManager {
  static OverlayEntry? _overlayEntry;

  /// ëª¨ë‹¬ í‘œì‹œ
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
    required MarketMoodData data,
  }) {
    hide(); // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°

    _overlayEntry = OverlayEntry(
      builder: (context) => MarketMoodModalOverlay(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
        data: data,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalOverlay extends StatelessWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;
  final MarketMoodData data;

  const MarketMoodModalOverlay({
    super.key,
    required this.position,
    required this.statusIconSize,
    required this.ref,
    required this.data,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => MarketMoodModalManager.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ MarketMoodPage ìœ„ì ¯
            Positioned(
              left: position.dx,
              top: position.dy,
              child: Consumer(
                builder: (context, ref, child) {
                  return MarketMoodPage(
                    statusIconSize: statusIconSize,
                    data: data,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
// lib/presentation/controllers/volume_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/volume_provider.dart'; // ğŸ†• volume_provider ì‚¬ìš©
import '../../domain/entities/volume.dart';

/// ğŸ¯ ì‹¬í”Œí•œ ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ëŸ¬ - VolumeTimeFrameController í™œìš©
class VolumeController extends StateNotifier<VolumeControllerState> {
  final Ref ref;
  
  VolumeController(this.ref) : super(const VolumeControllerState());

  /// ğŸ†• Top 50/100 í† ê¸€
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
  }

  /// ğŸ†• í˜„ì¬ í‘œì‹œ ê°œìˆ˜ (50 ë˜ëŠ” 100)
  int get currentLimit => state.isTop100 ? 100 : 50;

  /// ğŸ†• í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// ğŸ†• Top 100 ëª¨ë“œ ì—¬ë¶€
  bool get isTop100 => state.isTop100;
  void setTimeFrame(String timeFrame, int index) {
    // volume_provider.dartì˜ VolumeTimeFrameController ì‚¬ìš©
    final controller = ref.read(volumeTimeFrameController);
    controller.updateTimeFrame(timeFrame, index);
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€
  String get currentTimeFrame => ref.read(volumeTimeFrameController).currentTimeFrame;

  /// í˜„ì¬ ì¸ë±ìŠ¤
  int get currentIndex => ref.read(volumeTimeFrameController).currentIndex;

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ë“¤
  List<String> get availableTimeFrames => ref.read(volumeTimeFrameController).availableTimeFrames;

  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    return ref.read(volumeTimeFrameController).getTimeFrameName(timeFrame);
  }

  /// ë³¼ë¥¨ ë°ì´í„°ë¥¼ ê±°ë˜ëŸ‰ ìˆœìœ¼ë¡œ ì •ë ¬ + ğŸ¯ ë™ì  ìˆœìœ„ ì œí•œ (Top 50/100)
  List<Volume> sortVolumeData(List<Volume> volumeData) {
    final filteredData = volumeData.where((v) => v.totalVolume > 0).toList();
    filteredData.sort((a, b) => b.totalVolume.compareTo(a.totalVolume)); // ë‚´ë¦¼ì°¨ìˆœ
    
    // ğŸš€ í˜„ì¬ ì„¤ì •ì— ë”°ë¼ 50ê°œ ë˜ëŠ” 100ê°œë¡œ ì œí•œ
    return filteredData.take(currentLimit).toList();
  }

  /// ì½”ì¸ëª… í•„í„°ë§
  List<Volume> filterByMarket(List<Volume> sortedData, String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return sortedData;
    }
    
    final upper = marketFilter.toUpperCase();
    return sortedData.where((volume) => volume.market.contains(upper)).toList();
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤
  void resetCurrentTimeFrame() {
    ref.read(volumeTimeFrameController).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    ref.read(volumeTimeFrameController).resetAllTimeFrames();
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    return ref.read(volumeTimeFrameController).getNextResetTime();
  }
}

/// ğŸ†• VolumeController ìƒíƒœ ê´€ë¦¬
class VolumeControllerState {
  final bool isTop100;

  const VolumeControllerState({
    this.isTop100 = false, // ê¸°ë³¸ê°’: Top 50
  });

  VolumeControllerState copyWith({
    bool? isTop100,
  }) {
    return VolumeControllerState(
      isTop100: isTop100 ?? this.isTop100,
    );
  }
}

/// Provider ì„ ì–¸ - StateNotifierProviderë¡œ ë³€ê²½!
final volumeControllerProvider = StateNotifierProvider<VolumeController, VolumeControllerState>((ref) => VolumeController(ref));\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// lib/presentation/controllers/trade_controller.dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart'; // usecaseProvider, repoProvider
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class TradeState {
  final List<Trade> trades;
  final bool isLoading;
  final bool isConnected;
  final double threshold;
  final int selectedIndex;
  final bool isRangeMode; // ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì¶”ê°€
  final String? errorMessage;

  const TradeState({
    this.trades = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.threshold = 20000000,
    this.selectedIndex = 0,
    this.isRangeMode = true, // ğŸ†• ê¸°ë³¸ê°’: êµ¬ê°„ ëª¨ë“œ
    this.errorMessage,
  });

  TradeState copyWith({
    List<Trade>? trades,
    bool? isLoading,
    bool? isConnected,
    double? threshold,
    int? selectedIndex,
    bool? isRangeMode, // ğŸ†• ì¶”ê°€
    String? errorMessage,
  }) {
    return TradeState(
      trades: trades ?? this.trades,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      threshold: threshold ?? this.threshold,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      isRangeMode: isRangeMode ?? this.isRangeMode, // ğŸ†• ì¶”ê°€
      errorMessage: errorMessage,
    );
  }
}

/// Trade í™”ë©´ ì „ìš© ViewModel
class TradeController extends StateNotifier<TradeState> {
  final TradeUsecase _usecase;
  final Ref _ref;
  StreamSubscription<Result<List<Trade>, AppException>>? _subscription;

  TradeController(this._usecase, this._ref) : super(const TradeState());

  /// ì„ê³„ê°’ ë° ì¸ë±ìŠ¤ ì„¤ì • í›„ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  void setThreshold(double threshold, int index, List<String> markets) {
    final repository = _ref.read(repoProvider);
    repository.updateThreshold(threshold);
    
    state = state.copyWith(
      threshold: threshold,
      selectedIndex: index,
      isLoading: true,
      errorMessage: null,
    );
    _subscription?.cancel();
    _subscription = _usecase
        .filterTrades(threshold, markets)
        .listen(_handleResult);
  }

  /// ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ í† ê¸€
  void toggleRangeMode() {
    final newMode = !state.isRangeMode;
    final repository = _ref.read(repoProvider);
    repository.updateRangeMode(newMode);
    
    state = state.copyWith(isRangeMode: newMode);
  }

  /// ğŸ†• í˜„ì¬ ì„¤ì •ì— ë”°ë¥¸ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„± - ìˆ˜ì •ëœ ë²„ì „
  String getThresholdDisplayText() {
    final threshold = state.threshold;
    final thresholds = availableThresholds;
    final currentIndex = thresholds.indexOf(threshold);
    
    if (state.isRangeMode) {
      // ğŸ†• êµ¬ê°„ ëª¨ë“œ: "ê¸ˆì•¡ ë ˆì¸ì§€: 2ì²œë§Œ ~ 5ì²œë§Œì›"
      if (currentIndex >= 0 && currentIndex < thresholds.length - 1) {
        final nextThreshold = thresholds[currentIndex + 1];
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        final nextLabel = AppConfig.filterNames[nextThreshold] ?? nextThreshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabel ~ $nextLabelì›';
      } else {
        // ë§ˆì§€ë§‰ êµ¬ê°„
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabelì› ì´ìƒ';
      }
    } else {
      // ğŸ”„ ëˆ„ì  ëª¨ë“œ: "ìµœì†Œ ê±°ë˜ê¸ˆì•¡: 5ì²œë§Œì›"
      final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
      return 'ìµœì†Œ ê±°ë˜ê¸ˆì•¡: $currentLabelì›';
    }
  }

  /// ğŸ†• í† ê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸
  String get toggleButtonText => state.isRangeMode ? 'êµ¬ê°„' : 'ëˆ„ì ';

  void _handleResult(Result<List<Trade>, AppException> result) {
    result.when(
      ok: (trades) {
        state = state.copyWith(
          trades: trades,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨: marketsë§Œ ë°›ì•„ì„œ ë‚´ë¶€ì ìœ¼ë¡œ setThreshold í˜¸ì¶œ
  void refresh(List<String> markets) {
    setThreshold(state.threshold, state.selectedIndex, markets);
  }

  /// ê±°ë˜ ëª©ë¡ ì¶”ê°€ í•„í„° (ì‹œì¥ëª…)
  List<Trade> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.trades;
    }
    final upper = marketFilter.toUpperCase();
    return state.trades.where((t) => t.market.contains(upper)).toList();
  }

  /// ê±°ë˜ ëª©ë¡ ì •ë ¬
  void sortTrades(String field, bool ascending) {
    final list = [...state.trades];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'volume':
          aValue = a.volume;
          bValue = b.volume;
          break;
        case 'total':
          aValue = a.total;
          bValue = b.total;
          break;
        case 'timestamp':
          aValue = a.timestampMs;
          bValue = b.timestampMs;
          break;
        default:
          aValue = a.timestampMs;
          bValue = b.timestampMs;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(trades: list);
  }

  /// ê±°ë˜ ëª©ë¡ í•„í„°ë§/ì •ë ¬ ì ìš©
  List<Trade> apply(List<Trade> trades) {
    // Repositoryì—ì„œ ì´ë¯¸ í•„í„°ë§ ì²˜ë¦¬ë˜ë¯€ë¡œ ì •ë ¬ë§Œ
    final filtered = [...trades];
    filtered.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return filtered;
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì„ê³„ê°’ ì˜µì…˜ë“¤
  List<double> get availableThresholds =>
    AppConfig.tradeFilters.where((f) => f >= 20000000).toList();

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final tradeControllerProvider =
    StateNotifierProvider<TradeController, TradeState>((ref) {
  final usecase = ref.read(usecaseProvider);
  return TradeController(usecase, ref);
});\n\n// ====== lib/presentation/pages/main_page.dart ======\n
// lib/presentation/pages/main_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedbackìš©
import '../../core/di/app_providers.dart';
import '../../shared/widgets/common_app_bar.dart';
import 'trade_page.dart';
import 'volume_page.dart'; // ğŸ†• VolumePage import ì¶”ê°€
import 'sector_page.dart'; // ğŸ†• SectorPage import ì¶”ê°€
import 'surge_page.dart'; // ğŸš€ SurgePage import ì¶”ê°€

/// ğŸ¯ ë©”ì¸ í˜ì´ì§€ - PageViewë¡œ 4ê°œ í™”ë©´ ê´€ë¦¬
class MainPage extends ConsumerStatefulWidget {
  const MainPage({Key? key}) : super(key: key);

  @override
  ConsumerState<MainPage> createState() => _MainPageState();
}

class _MainPageState extends ConsumerState<MainPage> with TickerProviderStateMixin {
  late PageController _pageController;
  late AnimationController _animationController;
  
  // âœ… TradePageì˜ ScrollControllerë¥¼ ìœ„í•œ ê° í˜ì´ì§€ë³„ ê´€ë¦¬
  final Map<int, ScrollController> _pageScrollControllers = {};
  
  // 4ê°œ í˜ì´ì§€ ì •ë³´
  final List<PageInfo> _pages = [
    PageInfo(
      index: 0,
      title: 'ê¸‰ë“±ë½',
      icon: Icons.trending_up, // âœ… ê·¸ëŒ€ë¡œ ìœ ì§€
      builder: (scrollController) => SurgePage(scrollController: scrollController), // ğŸš€ SurgePage ì—°ê²°!
    ),
    PageInfo(
      index: 1,
      title: 'ì²´ê²°',
      icon: Icons.monetization_on, // âœ… ë³€ê²½: show_chart â†’ monetization_on ğŸ’°
      builder: (scrollController) => TradePage(scrollController: scrollController), // âœ… ScrollController ì „ë‹¬
    ),
    PageInfo(
      index: 2,
      title: 'ë³¼ë¥¨',
      icon: Icons.bar_chart, // âœ… ê·¸ëŒ€ë¡œ ìœ ì§€
      builder: (scrollController) => VolumePage(scrollController: scrollController), // ğŸ†• VolumePage ì—°ê²°!
    ),
    PageInfo(
      index: 3,
      title: 'ì„¹í„°',
      icon: Icons.pie_chart, // âœ… ë³€ê²½: business â†’ pie_chart ğŸ¥§
      builder: (scrollController) => SectorPage(scrollController: scrollController), // ğŸ†• SectorPage ì—°ê²°!
    ),
  ];

  @override
  void initState() {
    super.initState();
    
    // PageController ì´ˆê¸°í™” (ì²´ê²° í˜ì´ì§€ë¥¼ ê¸°ë³¸ìœ¼ë¡œ)
    _pageController = PageController(initialPage: 1);
    
    // ì• ë‹ˆë©”ì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™” 
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    // âœ… ê° í˜ì´ì§€ë³„ ScrollController ì´ˆê¸°í™”
    for (int i = 0; i < _pages.length; i++) {
      _pageScrollControllers[i] = ScrollController();
    }
    
    // ì´ˆê¸° í˜ì´ì§€ ì¸ë±ìŠ¤ ì„¤ì •
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(selectedTabProvider.notifier).state = 1; // ì²´ê²° í˜ì´ì§€
    });
  }

  @override
  void dispose() {
    _pageController.dispose();
    _animationController.dispose();
    // âœ… ëª¨ë“  ScrollController í•´ì œ
    for (final controller in _pageScrollControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // âœ… GestureDetector ì œê±° - ìˆœìˆ˜í•˜ê²Œ PrimaryScrollControllerê°€ ìƒíƒœë°” í„°ì¹˜ ì²˜ë¦¬
    return Scaffold(
      appBar: CommonAppBar(
        title: '', // ë¹ˆ ì œëª© (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°ê°€ ë“¤ì–´ê°ˆ ìë¦¬)
        pages: _pages,
        pageController: _pageController,
        animationController: _animationController,
      ),
      body: SafeArea( // âœ… SafeArea ì¶”ê°€
        child: PageView.builder(
          controller: _pageController,
          onPageChanged: _onPageChanged,
          itemCount: _pages.length,
          // âœ… iOS ìŠ¤íƒ€ì¼ physics + ìŠ¤í¬ë¡¤ ì¶©ëŒ ë°©ì§€
          physics: const BouncingScrollPhysics(
            parent: AlwaysScrollableScrollPhysics(),
          ),
          // âœ… ìŠ¤í¬ë¡¤ ë°©í–¥ ëª…ì‹œ (ìˆ˜í‰ ìŠ¤ì™€ì´í”„)
          scrollDirection: Axis.horizontal,
          itemBuilder: (context, index) {
            // âœ… ê° í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ScrollController ì „ë‹¬
            final scrollController = _pageScrollControllers[index]!;
            return _pages[index].builder(scrollController);
          },
        ),
      ),
    );
  }

  /// í˜ì´ì§€ ë³€ê²½ ì²˜ë¦¬
  void _onPageChanged(int index) {
    HapticFeedback.lightImpact(); // ğŸ¯ ìŠ¤ì™€ì´í”„ í–…í‹± ì¶”ê°€!

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(selectedTabProvider.notifier).state = index;
    
    // ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±°
    _animationController.forward().then((_) {
      _animationController.reset();
    });
    
    debugPrint('ğŸ“± í˜ì´ì§€ ë³€ê²½: ${_pages[index].title} (index: $index)');
  }

  /// ğŸ¯ ì™¸ë¶€ì—ì„œ í˜ì´ì§€ ì´ë™ (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° í´ë¦­ ì‹œ)
  void goToPage(int index) {
    if (index >= 0 && index < _pages.length) {
      _pageController.animateToPage(
        index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }
}

/// ğŸ“„ í˜ì´ì§€ ì •ë³´ í´ë˜ìŠ¤
class PageInfo {
  final int index;
  final String title;
  final IconData icon;
  final Widget Function(ScrollController scrollController) builder; // âœ… ScrollController íŒŒë¼ë¯¸í„° ì¶”ê°€

  const PageInfo({
    required this.index,
    required this.title,
    required this.icon,
    required this.builder,
  });
}\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
// lib/presentation/pages/trade_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart';
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const TradePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ğŸ†• Controller ê¸°ë°˜ ì‹œìŠ¤í…œìœ¼ë¡œ ì™„ì „ í†µì¼
    final controller = ref.watch(tradeControllerProvider.notifier);
    final state = ref.watch(tradeControllerProvider);
    final thresholds = AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    
    // ê±°ë˜ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ ìœ ì§€)
    final tradesAsync = ref.watch(tradeListProvider);
    
    // markets ì •ë³´ í•„ìš”
    final marketsAsync = ref.watch(marketsProvider);
    
    // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(thresholds, controller, state, marketsAsync, ref);
    
    // ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final tradeListWidget = _buildTradeList(tradesAsync, controller, scrollController, thresholds, state, context);

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: tradeListWidget),
          
          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± - Controller ì™„ì „ í†µì¼
  Widget _buildSliderWidget(
    List<double> thresholds, 
    TradeController controller, 
    TradeState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ†• ìƒë‹¨: í‘œì‹œ í…ìŠ¤íŠ¸ + í† ê¸€ ë²„íŠ¼
          Row(
            children: [
              // ğŸ†• ë™ì  í…ìŠ¤íŠ¸ (êµ¬ê°„/ëˆ„ì ì— ë”°ë¼ ë³€ê²½)
              Expanded(
                child: Text(
                  controller.getThresholdDisplayText(),
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
              ),
              // ğŸ†• êµ¬ê°„/ëˆ„ì  í† ê¸€ ë²„íŠ¼ (Volume Top50/100 ìŠ¤íƒ€ì¼ê³¼ ë™ì¼)
              GestureDetector(
                onTap: () {
                  if (ref.read(appSettingsProvider).isHapticEnabled) {
                    HapticFeedback.lightImpact(); // ğŸ¯ í† ê¸€ ë²„íŠ¼ í–…í‹± í”¼ë“œë°±
                  }
                  controller.toggleRangeMode();
                },
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.orange,
                      width: 1.5,
                    ),
                    // ğŸ¯ êµ¬ê°„: ì˜¤ë Œì§€ í…Œë‘ë¦¬ë§Œ, ëˆ„ì : ì˜¤ë Œì§€ ëª¸í†µ + í°ê¸€ì”¨
                    color: state.isRangeMode ? Colors.transparent : Colors.orange,
                  ),
                  child: Text(
                    controller.toggleButtonText,
                    style: TextStyle(
                      color: state.isRangeMode ? Colors.orange : Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 6),
          // ğŸ†• ìŠ¬ë¼ì´ë” - Controller ì‚¬ìš©ìœ¼ë¡œ ë³€ê²½
          Slider(
            value: state.selectedIndex.toDouble(),
            min: 0,
            max: (thresholds.length - 1).toDouble(),
            divisions: thresholds.length - 1,
            label: AppConfig.filterNames[thresholds[state.selectedIndex]] ?? thresholds[state.selectedIndex].toStringAsFixed(0),
            onChanged: (v) {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact(); // ğŸ¯ ì›ë˜ ìˆë˜ ìŠ¬ë¼ì´ë” í–…í‹± í”¼ë“œë°±
              }
              final i = v.round();
              final threshold = thresholds[i];
              
              // ğŸ†• Controllerë¥¼ í†µí•´ ì²˜ë¦¬
              marketsAsync.whenData((markets) {
                controller.setThreshold(threshold, i, markets);
              });
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ê°œì„  (20% ì¶•ì†Œ + ì‚¬ìš©ì‹œë§Œ í‘œì‹œ)
  Widget _buildTradeList(
    AsyncValue tradesAsync, 
    TradeController controller, 
    ScrollController scrollController,
    List<double> thresholds,
    TradeState state,
    BuildContext context,
  ) {
    return tradesAsync.when(
      data: (list) {
        final viewList = controller.apply(list);
        if (viewList.isEmpty) {
          return Center(
            child: Text(
              'í¬ì°©ëœ ì²´ê²°ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì„ê³„ê°’: ${AppConfig.filterNames[thresholds[state.selectedIndex]] ?? thresholds[state.selectedIndex].toStringAsFixed(0)})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ìŠ¤í¬ë¡¤ë°” ê°œì„ : 20% ì¶•ì†Œ + ì‚¬ìš©ì‹œë§Œ í‘œì‹œ
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: false, // âœ… í‰ì†Œì—” ìˆ¨ê¹€
          trackVisibility: false, // âœ… íŠ¸ë™ë„ ìˆ¨ê¹€
          thickness: 6.4, // âœ… 20% ì¶•ì†Œ (8 â†’ 6.4)
          radius: const Radius.circular(3.2), // âœ… ë°˜ì§€ë¦„ë„ 20% ì¶•ì†Œ (4 â†’ 3.2)
          thumbColor: Colors.orange.withValues(alpha: 0.5),
          trackColor: Colors.transparent,
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 40, // âœ… ìµœì†Œ ì¸ ê¸¸ì´ë„ 20% ì¶•ì†Œ (50 â†’ 40)
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¡°ì •
            itemCount: viewList.length,
            itemBuilder: (_, i) => TradeTile(trade: viewList[i]),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ì²´ê²° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/pages/splash_page.dart ======\n
// lib/presentation/pages/splash_page.dart

import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';
import 'main_page.dart';

class SplashPage extends StatefulWidget {
  const SplashPage({Key? key}) : super(key: key);

  @override
  State<SplashPage> createState() => _SplashPageState();
}

class _SplashPageState extends State<SplashPage> {
  VideoPlayerController? _controller;
  bool _isVideoInitialized = false;
  bool _hasNavigated = false;

  @override
  void initState() {
    super.initState();
    _initializeVideo();
    
    // ì•ˆì „ë§: 5ì´ˆ í›„ ê°•ì œ ì´ë™ (ë¹„ë””ì˜¤ ë¬¸ì œ ì‹œ)
    Future.delayed(const Duration(seconds: 5), () {
      if (!_hasNavigated && mounted) {
        _navigateToMain();
      }
    });
  }

  Future<void> _initializeVideo() async {
    try {
      _controller = VideoPlayerController.asset('assets/noonchit_intro_84frames.mp4');
      
      await _controller!.initialize();
      
      if (mounted) {
        setState(() {
          _isVideoInitialized = true;
        });
        
        // ë¹„ë””ì˜¤ ì„¤ì •
        _controller!.setVolume(0.0); // ìŒì†Œê±°
        _controller!.setLooping(false);
        
        // ì¬ìƒ ì™„ë£Œ ë¦¬ìŠ¤ë„ˆ
        _controller!.addListener(_videoListener);
        
        // ì¬ìƒ ì‹œì‘
        _controller!.play();
      }
    } catch (e) {
      // ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ë©”ì¸ìœ¼ë¡œ ì´ë™
      debugPrint('Video initialization failed: $e');
      if (mounted) {
        _navigateToMain();
      }
    }
  }

  void _videoListener() {
    if (_controller != null && _controller!.value.position >= _controller!.value.duration) {
      // ë¹„ë””ì˜¤ ì¬ìƒ ì™„ë£Œ
      _navigateToMain();
    }
  }

  void _navigateToMain() {
    if (_hasNavigated) return;
    _hasNavigated = true;
    
    if (mounted) {
      Navigator.of(context).pushReplacement(
        PageRouteBuilder(
          pageBuilder: (context, animation, secondaryAnimation) => const MainPage(),
          transitionDuration: const Duration(milliseconds: 300),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(
              opacity: animation,
              child: child,
            );
          },
        ),
      );
    }
  }

  @override
  void dispose() {
    _controller?.removeListener(_videoListener);
    _controller?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF121212), // ì–´ë‘ìš´ ë°°ê²½
      body: Center(
        child: _isVideoInitialized && _controller != null
            ? AspectRatio(
                aspectRatio: _controller!.value.aspectRatio,
                child: VideoPlayer(_controller!),
              )
            : _buildLoadingFallback(),
      ),
    );
  }

  Widget _buildLoadingFallback() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // ë¡œë”© ì¤‘ì´ê±°ë‚˜ ë¹„ë””ì˜¤ ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ UI
        Icon(
          Icons.currency_bitcoin,
          size: 64,
          color: Colors.orange.withValues(alpha: 0.8),
        ),
        const SizedBox(height: 16),
        Text(
          'NOONCHIT',
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: Colors.white.withValues(alpha: 0.9),
            letterSpacing: 2.0,
          ),
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: 32,
          height: 32,
          child: CircularProgressIndicator(
            strokeWidth: 3,
            valueColor: AlwaysStoppedAnimation<Color>(
              Colors.orange.withValues(alpha: 0.8),
            ),
          ),
        ),
      ],
    );
  }
}\n\n// ====== lib/presentation/pages/market_mood_page.dart ======\n
// lib/presentation/pages/market_mood_page.dart
// ğŸ“± Presentation Layer: Market Mood í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ, í´ë¦° ì•„í‚¤í…ì²˜)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../controllers/market_mood_controller.dart';

/// ğŸ“± ë§ˆì¼“ë¬´ë“œ ìƒì„¸ í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ)
class MarketMoodPage extends ConsumerStatefulWidget {
  final double statusIconSize;
  final MarketMoodData data;

  const MarketMoodPage({
    super.key,
    required this.statusIconSize,
    required this.data,
  });

  @override
  ConsumerState<MarketMoodPage> createState() => _MarketMoodPageState();
}

class _MarketMoodPageState extends ConsumerState<MarketMoodPage>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _animationController.forward();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.5),
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          alignment: Alignment.center,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildPageContent(),
          ),
        );
      },
    );
  }

  Widget _buildPageContent() {
    // í™”ë©´ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final maxWidth = screenSize.width * 0.9;

    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: widget.statusIconSize * 4.2,
          maxWidth: maxWidth,
        ),
        decoration: _buildContainerDecoration(),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              const SizedBox(height: 8),
              _buildCoreMetrics(),
              const SizedBox(height: 8),
              _buildIntradayAnalysis(),
              const SizedBox(height: 8),
              _buildLongTermAnalysis(),
            ],
          ),
        ),
      ),
    );
  }

  BoxDecoration _buildContainerDecoration() {
    return BoxDecoration(
      color: Theme.of(context).colorScheme.surface,
      borderRadius: BorderRadius.circular(16),
      boxShadow: [
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.08),
          blurRadius: 16,
          offset: const Offset(0, 6),
          spreadRadius: 2,
        ),
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.04),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        // [ìˆ˜ì •] withOpacity -> withValues
        color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
        width: 0.8,
      ),
    );
  }

  Widget _buildHeader() {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final updateTime = controller.formatUpdateTime(widget.data.updatedAt);

    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final currentMood = ref.watch(currentMarketMoodProvider);
            final moodEmoji = controller.getMoodEmoji(currentMood);
            final moodName = controller.getMoodName(currentMood);

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      moodEmoji,
                      style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '$moodName - ğŸ˜„',
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w700,
                          color: Theme.of(context).colorScheme.onSurface,
                          letterSpacing: 0.3,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      'ì‹¤ì‹œê°„ ê¸°ì¤€ â€¢ ',
                      style: TextStyle(
                        fontSize: 8,
                        fontWeight: FontWeight.w500,
                        // [ìˆ˜ì •] withOpacity -> withValues
                        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                      ),
                    ),
                    Icon(
                      Icons.access_time,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                    const SizedBox(width: 3),
                    Flexible(
                      child: Text(
                        '$updateTime ì—…ë°ì´íŠ¸',
                        style: TextStyle(
                          fontSize: 8,
                          // [ìˆ˜ì •] withOpacity -> withValues
                          color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
          loading: () => _buildLoadingHeader(),
          error: (_, __) => _buildErrorHeader(),
        );
      },
    );
  }

  Widget _buildLoadingHeader() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 16, height: 16,
              child: CircularProgressIndicator(strokeWidth: 2)
            ),
            SizedBox(width: 8),
            Text(
              'ë¡œë”©ì¤‘...',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildErrorHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 12,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 4),
            Text(
              'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCoreMetrics() {
    return Consumer(
      builder: (context, ref, child) {
        final exchangeAsync = ref.watch(exchangeRateProvider);

        return exchangeAsync.when(
          data: (exchangeRate) => _buildCoreMetricsContent(exchangeRate),
          loading: () => _buildLoadingMetrics(),
          error: (_, __) => _buildCoreMetricsContent(1400.0),
        );
      },
    );
  }

  Widget _buildCoreMetricsContent(double exchangeRate) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    return FutureBuilder<List<String>>(
      future: Future.wait([
        controller.formatVolume(widget.data.totalVolumeUsd),
        controller.formatMarketCap(widget.data.totalMarketCapUsd),
      ]),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingMetrics();
        }
        if (snapshot.hasData) {
          final values = snapshot.data!;
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
              const SizedBox(height: 4),
              _buildStatRow(
                icon: Icons.monetization_on,
                label: '24ì‹œê°„ ê±°ë˜ëŒ€ê¸ˆ',
                value: values[0],
                isHighlight: true,
              ),
              _buildStatRow(
                icon: Icons.pie_chart,
                label: 'ì´ ì‹œê°€ì´ì•¡',
                value: values[1],
              ),
              _buildStatRow(
                icon: Icons.trending_up,
                label: 'ì‹œì´ 24ì‹œê°„ ë³€í™”',
                value: '${widget.data.marketCapChange24h >= 0 ? '+' : ''}${widget.data.marketCapChange24h.toStringAsFixed(2)}%',
                isHighlight: widget.data.marketCapChange24h > 0,
                isWarning: widget.data.marketCapChange24h < -2,
              ),
              _buildStatRow(
                icon: Icons.flash_on,
                label: 'BTC ë„ë¯¸ë„ŒìŠ¤',
                value: '${widget.data.btcDominance.toStringAsFixed(1)}%',
              ),
            ],
          );
        }
        return _buildLoadingMetrics();
      },
    );
  }

  Widget _buildLoadingMetrics() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildIntradayAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
                const SizedBox(height: 4),
                _buildComparisonRow('30ë¶„ ëŒ€ë¹„', comparisonData.thirtyMin, Icons.hourglass_empty),
                _buildComparisonRow('1ì‹œê°„ ëŒ€ë¹„', comparisonData.oneHour, Icons.hourglass_full),
                _buildComparisonRow('2ì‹œê°„ ëŒ€ë¹„', comparisonData.twoHour, Icons.access_time),
                _buildComparisonRow('4ì‹œê°„ ëŒ€ë¹„', comparisonData.fourHour, Icons.timer),
                _buildComparisonRow('8ì‹œê°„ ëŒ€ë¹„', comparisonData.eightHour, Icons.timer_outlined),
                _buildComparisonRow('12ì‹œê°„ ëŒ€ë¹„', comparisonData.twelveHour, Icons.update),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
          error: (_, __) => _buildErrorSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
        );
      },
    );
  }

  Widget _buildLongTermAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
                const SizedBox(height: 4),
                _buildComparisonRow('24ì‹œê°„ ëŒ€ë¹„', comparisonData.twentyFourHour, Icons.calendar_today),
                _buildComparisonRow('3ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.threeDayAverage, Icons.view_day),
                _buildComparisonRow('ì¼ì£¼ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.weeklyAverage, Icons.date_range),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
          error: (_, __) => _buildErrorSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
        );
      },
    );
  }

  Widget _buildLoadingSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildErrorSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        Text(
          'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
          style: TextStyle(
            fontSize: 9,
            color: Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  Widget _buildComparisonRow(String label, ComparisonResult result, IconData icon) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    if (result.isReady && result.changePercent != null) {
      return _buildStatRow(
        icon: icon,
        label: label,
        value: controller.formatComparisonValue(result),
        isHighlight: controller.isHighlight(result),
        isWarning: controller.isWarning(result),
      );
    } else {
      return _buildProgressRow(icon, label, result);
    }
  }

  Widget _buildProgressRow(IconData icon, String label, ComparisonResult result) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final progressPercent = controller.getProgressPercent(result);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
          ),
          const SizedBox(width: 5),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '$label: $progressPercent% (${result.status})',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.w500,
                    // [ìˆ˜ì •] withOpacity -> withValues
                    color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: result.progressPercent.clamp(0.0, 1.0),
                  // [ìˆ˜ì •] withOpacity -> withValues
                  backgroundColor: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                  valueColor: AlwaysStoppedAnimation(
                    result.progressPercent >= 1.0
                      ? Colors.green
                      // [ìˆ˜ì •] withOpacity -> withValues
                      : Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
                  ),
                  minHeight: 3,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Colors.green;
      if (isWarning) return Colors.red;
      // [ìˆ˜ì •] withOpacity -> withValues
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.green.withValues(alpha: 0.08)
            : isWarning
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.red.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              // [ìˆ˜ì •] withOpacity -> withValues
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/sector_page.dart ======\n
// lib/presentation/pages/sector_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/sector_provider.dart';
import '../../core/di/settings_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/volume.dart';
import '../controllers/sector_controller.dart';
import '../widgets/sector_tile.dart';

class SectorPage extends ConsumerWidget {
  final ScrollController scrollController;
  
  const SectorPage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) TimeFrame ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(sectorTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(sectorTimeFrameController);
    
    // 2) ì„¹í„° ìŠ¤íŠ¸ë¦¼
    final sectorsAsync = ref.watch(sectorVolumeDataProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬
    final uiController = ref.watch(sectorControllerProvider.notifier);
    
    // 4) ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(timeFrames, index, timeFrameCtrl, ref);
    
    // ì„¹í„° ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final sectorListWidget = _buildSectorList(sectorsAsync, uiController, scrollController, timeFrames, index, context);

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ì„¹í„° ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: sectorListWidget),
          
          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± (ì‹œê°„ëŒ€ ì„ íƒ + ğŸ†• í† ê¸€ + ì¹´ìš´íŠ¸ë‹¤ìš´)
  Widget _buildSliderWidget(List<String> timeFrames, int index, SectorTimeFrameController timeFrameCtrl, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì‹œê°„ëŒ€, í† ê¸€, ì¹´ìš´íŠ¸ë‹¤ìš´ì„ Rowë¡œ ë°°ì¹˜ (3ë“±ë¶„)
          Row(
            children: [
              // ì¢Œì¸¡: ì‹œê°„ëŒ€ (1/3 ì˜ì—­)
              Expanded(
                flex: 1,
                child: Text(
                  'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              
              // ğŸ†• ì¤‘ì•™: í† ê¸€ ë²„íŠ¼ (1/3 ì˜ì—­, ì •ì¤‘ì•™ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Center(
                  child: _buildClassificationToggle(timeFrameCtrl, ref),
                ),
              ),
              
              // ìš°ì¸¡: ì¹´ìš´íŠ¸ë‹¤ìš´ (1/3 ì˜ì—­, ìš°ì¸¡ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.centerRight,
                  child: _buildCountdownWidget(timeFrameCtrl),
                ),
              ),
            ],
          ),
          const SizedBox(height: 6),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (timeFrames.length - 1).toDouble(),
            divisions: timeFrames.length - 1,
            label: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
            onChanged: (v) {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact();
              }
              final i = v.round();
              timeFrameCtrl.updateTimeFrame(timeFrames[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ì‘ì€ ë¶„ë¥˜ í† ê¸€ ë²„íŠ¼ (ìƒì„¸/ê¸°ë³¸)
  Widget _buildClassificationToggle(SectorTimeFrameController timeFrameCtrl, WidgetRef ref) {
    final isDetailed = timeFrameCtrl.isDetailedClassification;
    final currentName = timeFrameCtrl.currentSectorClassificationName;
    
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact(); // ğŸ¯ light haptic ì¶”ê°€
        }
        timeFrameCtrl.toggleSectorClassification();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: isDetailed ? Colors.orange : Colors.transparent, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ íˆ¬ëª…
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange, // ğŸ¯ ë‘˜ ë‹¤ ì£¼í™© í…Œë‘ë¦¬
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              isDetailed ? Icons.view_module : Icons.view_list,
              size: 14,
              color: isDetailed ? Colors.white : Colors.orange, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ ì£¼í™© ì•„ì´ì½˜
            ),
            const SizedBox(width: 4),
            Text(
              currentName,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isDetailed ? Colors.white : Colors.orange, // ğŸ¯ ê¸°ë³¸ì¼ ë•Œ ì£¼í™© í…ìŠ¤íŠ¸
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ¯ ì¹´ìš´íŠ¸ë‹¤ìš´ ìœ„ì ¯ ìƒì„± - ìë™ í¬ê¸° ì¡°ì • (ì´ëª¨ì§€+ìˆ«ì ì‚´ì§ ë„ìš°ê¸°)
  Widget _buildCountdownWidget(SectorTimeFrameController timeFrameCtrl) {
    final nextResetTime = timeFrameCtrl.getNextResetTime();
    
    if (nextResetTime == null) {
      return const Row( // âœ… const ì¶”ê°€
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.grey), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '--:--',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final now = DateTime.now();
    final remaining = nextResetTime.difference(now);
    
    if (remaining.isNegative) {
      return const Row( // âœ… const ì¶”ê°€
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.orange), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '00:00',
            style: TextStyle(
              fontSize: 13,
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final minutes = remaining.inMinutes;
    final seconds = remaining.inSeconds % 60;
    final minutesStr = minutes.toString().padLeft(2, '0');
    final secondsStr = seconds.toString().padLeft(2, '0');
    
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.access_time, size: 16, color: Colors.orange),
        const SizedBox(width: 2),
        Text(
          '$minutesStr:$secondsStr',
          style: const TextStyle(
            fontSize: 12,
            color: Colors.orange,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  /// ì„¹í„° ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ê°œì„  (Trade/Volumeê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
  Widget _buildSectorList(
    AsyncValue<List<Volume>> sectorsAsync, 
    SectorController uiController, 
    ScrollController scrollController,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    return sectorsAsync.when(
      data: (sectorVolumes) {
        // List<Volume>ì„ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
        final sortedSectors = uiController.applySorting(sectorVolumes);
        
        if (sortedSectors.isEmpty) {
          return Center(
            child: Text(
              'ì„¹í„° ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ìŠ¤í¬ë¡¤ë°” ê°œì„ : 20% ì¶•ì†Œ + ì‚¬ìš©ì‹œë§Œ í‘œì‹œ (Trade/Volumeê³¼ ë™ì¼)
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: false, // âœ… í‰ì†Œì—” ìˆ¨ê¹€
          trackVisibility: false, // âœ… íŠ¸ë™ë„ ìˆ¨ê¹€
          thickness: 6.4, // âœ… 20% ì¶•ì†Œ (8 â†’ 6.4)
          radius: const Radius.circular(3.2), // âœ… ë°˜ì§€ë¦„ë„ 20% ì¶•ì†Œ (4 â†’ 3.2)
          thumbColor: Colors.orange.withValues(alpha: 0.5),
          trackColor: Colors.transparent,
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 40, // âœ… ìµœì†Œ ì¸ ê¸¸ì´ë„ 20% ì¶•ì†Œ (50 â†’ 40)
          child: ListView.builder(
            controller: scrollController,
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¡°ì •
            itemCount: sortedSectors.length,
            itemBuilder: (_, i) => SectorTile(
              sectorName: sortedSectors[i].market.replaceFirst('SECTOR-', ''),
              totalVolume: sortedSectors[i].totalVolume,
              rank: i + 1,
              timeFrame: sortedSectors[i].timeFrame,
              lastUpdated: sortedSectors[i].lastUpdated,
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ì„¹í„° ë°ì´í„° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/pages/notification_page.dart ======\n
// lib/presentation/pages/notification_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// ì„ì‹œ ì•Œë¦¼ í˜ì´ì§€ (ì—ëŸ¬ í•´ê²°ìš©)
class NotificationPage extends ConsumerWidget {
  const NotificationPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ì•Œë¦¼'),
        centerTitle: true,
        elevation: 0,
      ),
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.notifications_outlined,
              size: 80,
              color: Colors.orange,
            ),
            SizedBox(height: 24),
            Text(
              'ì•Œë¦¼ í˜ì´ì§€',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.orange,
              ),
            ),
            SizedBox(height: 12),
            Text(
              'ì„ì‹œ í˜ì´ì§€ì…ë‹ˆë‹¤',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
// lib/presentation/pages/volume_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/volume_provider.dart'; // ğŸ†• volume_provider ì‚¬ìš©!
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹°
import '../controllers/volume_controller.dart';
import '../widgets/volume_tile.dart';

class VolumePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const VolumePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) TimeFrame ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(volumeTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(volumeTimeFrameController);
    
    // 2) ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼
    final volumesAsync = ref.watch(volumeDataProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬ (í•„í„°/ì •ë ¬) - StateNotifierë¡œ ë³€ê²½ë¨
    final uiController = ref.watch(volumeControllerProvider.notifier);
    
    // 4) ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(timeFrames, index, timeFrameCtrl, ref);
    
    // ğŸ†• ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final volumeListWidget = _buildVolumeList(volumesAsync, uiController, scrollController, timeFrames, index, context);

    // âœ… PrimaryScrollControllerë¡œ ìƒíƒœë°” í„°ì¹˜ í™œì„±í™” + ì •í™•í•œ ScrollController ì—°ê²°
    return PrimaryScrollController(
      controller: scrollController, // âœ… ì´ì œ MainPageì™€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤!
      child: Column(
        children: [
          // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: volumeListWidget),
          
          // ğŸ†• ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± (ì‹œê°„ëŒ€ ì„ íƒ + Top 50/100 í† ê¸€ + ì¹´ìš´íŠ¸ë‹¤ìš´)
  Widget _buildSliderWidget(List<String> timeFrames, int index, VolumeTimeFrameController timeFrameCtrl, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì‹œê°„ëŒ€, í† ê¸€, ì¹´ìš´íŠ¸ë‹¤ìš´ì„ Rowë¡œ ë°°ì¹˜ (3ë“±ë¶„)
          Row(
            children: [
              // ì¢Œì¸¡: ì‹œê°„ëŒ€ (1/3 ì˜ì—­)
              Expanded(
                flex: 1,
                child: Text(
                  'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              
              // ğŸ†• ì¤‘ì•™: Top 50/100 í† ê¸€ ë²„íŠ¼ (1/3 ì˜ì—­, ì •ì¤‘ì•™ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Center(
                  child: _buildTopLimitToggle(ref),
                ),
              ),
              
              // ìš°ì¸¡: ì¹´ìš´íŠ¸ë‹¤ìš´ (1/3 ì˜ì—­, ìš°ì¸¡ ì •ë ¬)
              Expanded(
                flex: 1,
                child: Align(
                  alignment: Alignment.centerRight,
                  child: _buildCountdownWidget(timeFrameCtrl),
                ),
              ),
            ],
          ),
          const SizedBox(height: 6),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (timeFrames.length - 1).toDouble(),
            divisions: timeFrames.length - 1,
            label: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
            onChanged: (v) {
              if (ref.read(appSettingsProvider).isHapticEnabled) {
                HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± í”¼ë“œë°±
              }
              final i = v.round();
              timeFrameCtrl.updateTimeFrame(timeFrames[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• Top 50/100 í† ê¸€ ë²„íŠ¼
  Widget _buildTopLimitToggle(WidgetRef ref) {
    final uiController = ref.watch(volumeControllerProvider.notifier);
    final isTop100 = ref.watch(volumeControllerProvider).isTop100;
    final currentName = uiController.currentLimitName;
    
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact(); // ğŸ¯ light haptic ì¶”ê°€
        }
        uiController.toggleTopLimit();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        decoration: BoxDecoration(
          color: isTop100 ? Colors.orange : Colors.transparent, // ğŸ¯ Top 100ì¼ ë•Œ ì£¼í™©
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange, // ğŸ¯ ë‘˜ ë‹¤ ì£¼í™© í…Œë‘ë¦¬
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              currentName,
              style: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.w600,
                color: isTop100 ? Colors.white : Colors.orange, // ğŸ¯ Top 50ì¼ ë•Œ ì£¼í™© í…ìŠ¤íŠ¸
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ¯ ì¹´ìš´íŠ¸ë‹¤ìš´ ìœ„ì ¯ ìƒì„± - ìë™ í¬ê¸° ì¡°ì • (ì´ëª¨ì§€+ìˆ«ì ì‚´ì§ ë„ìš°ê¸°)
  Widget _buildCountdownWidget(VolumeTimeFrameController timeFrameCtrl) {
    final nextResetTime = timeFrameCtrl.getNextResetTime();
    
    if (nextResetTime == null) {
      return const Row( // âœ… const ì¶”ê°€
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.grey), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '--:--',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final now = DateTime.now();
    final remaining = nextResetTime.difference(now);
    
    if (remaining.isNegative) {
      return const Row( // âœ… const ì¶”ê°€
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.access_time, size: 16, color: Colors.orange), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '00:00',
            style: TextStyle(
              fontSize: 13,
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final minutes = remaining.inMinutes;
    final seconds = remaining.inSeconds % 60;
    final minutesStr = minutes.toString().padLeft(2, '0');
    final secondsStr = seconds.toString().padLeft(2, '0');
    
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.access_time, size: 16, color: Colors.orange),
        const SizedBox(width: 2), // âœ… ì‚´ì§ ë„ìš°ê¸°
        Text(
          '$minutesStr:$secondsStr',
          style: const TextStyle(
            fontSize: 12,
            color: Colors.orange,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  /// ğŸ†• ë³¼ë¥¨ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ê°œì„  (Trade/Sectorì™€ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
  Widget _buildVolumeList(
    AsyncValue<List<Volume>> volumesAsync, 
    VolumeController uiController, 
    ScrollController scrollController,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    return volumesAsync.when(
      data: (volumes) {
        // List<Volume>ì„ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ë™ì  ìˆœìœ„ ì œí•œ ì ìš©)
        final sortedVolumes = uiController.sortVolumeData(volumes);
        
        if (sortedVolumes.isEmpty) {
          return Center(
            child: Text(
              'ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ìŠ¤í¬ë¡¤ë°” ê°œì„ : 20% ì¶•ì†Œ + ì‚¬ìš©ì‹œë§Œ í‘œì‹œ (Trade/Sectorì™€ ë™ì¼)
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: false, // âœ… í‰ì†Œì—” ìˆ¨ê¹€
          trackVisibility: false, // âœ… íŠ¸ë™ë„ ìˆ¨ê¹€
          thickness: 6.4, // âœ… 20% ì¶•ì†Œ (8 â†’ 6.4)
          radius: const Radius.circular(3.2), // âœ… ë°˜ì§€ë¦„ë„ 20% ì¶•ì†Œ (4 â†’ 3.2)
          thumbColor: Colors.orange.withValues(alpha: 0.5),
          trackColor: Colors.transparent,
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 40, // âœ… ìµœì†Œ ì¸ ê¸¸ì´ë„ 20% ì¶•ì†Œ (50 â†’ 40)
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¡°ì •
            itemCount: sortedVolumes.length,
            itemBuilder: (_, i) => VolumeTile(
              market: sortedVolumes[i].market,
              totalVolume: sortedVolumes[i].totalVolume,
              rank: i + 1, // ğŸ¯ ìˆœìœ„ ì „ë‹¬ (1ìœ„ë¶€í„° ì‹œì‘)
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ë³¼ë¥¨ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/pages/surge_page.dart ======\n
// lib/presentation/pages/surge_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/surge_provider.dart'; // ğŸš€ surge_provider ì‚¬ìš©!
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../../domain/entities/surge.dart'; // ğŸš€ Surge ì—”í‹°í‹°
import '../../domain/usecases/surge_usecase.dart'; // SurgeFilterType import
import '../controllers/surge_controller.dart';
import '../widgets/surge_tile.dart';

class SurgePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const SurgePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) TimeFrame ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    final index = ref.watch(surgeTimeFrameIndexProvider);
    final timeFrameCtrl = ref.read(surgeTimeFrameController);
    
    // 2) ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼
    final surgesAsync = ref.watch(surgeDataProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬ (í•„í„°/ì •ë ¬) - StateNotifierë¡œ ë³€ê²½ë¨
    final uiController = ref.watch(surgeControllerProvider.notifier);
    
    // 4) ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // ğŸš€ ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± - í† ê¸€ ì¶”ê°€
    final sliderWidget = _buildSliderWidget(timeFrames, index, timeFrameCtrl, ref);
    
    // ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final surgeListWidget = _buildSurgeList(surgesAsync, uiController, scrollController, timeFrames, index, context);

    // âœ… PrimaryScrollControllerë¡œ ìƒíƒœë°” í„°ì¹˜ í™œì„±í™” + ì •í™•í•œ ScrollController ì—°ê²°
    return PrimaryScrollController(
      controller: scrollController, // âœ… ì´ì œ MainPageì™€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤!
      child: Column(
        children: [
          // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: surgeListWidget),
          
          // ğŸ†• ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸš€ ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„± - ì›ë³¸ í† ê¸€ ë¼ì¸ + í˜„ì¬ ì‹œìŠ¤í…œ
  Widget _buildSliderWidget(List<String> timeFrames, int index, SurgeTimeFrameController timeFrameCtrl, WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸš€ ì›ë³¸ í† ê¸€ ë¼ì¸ (12-6-10-10-11 ë¹„ìœ¨)
          Row(
            children: [
              // ì¢Œì¸¡: ì‹œê°„ëŒ€ (12/49 ì˜ì—­)
              Expanded(
                flex: 12,
                child: Text(
                  'ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]}',
                  style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                  overflow: TextOverflow.ellipsis,
                ),
              ),
              
              // ğŸš€ í•„í„° í† ê¸€ ë²„íŠ¼ (6/49 ì˜ì—­) - Volume ê¸°ì¤€ radius
              Expanded(
                flex: 6,
                child: Center(
                  child: _buildFilterToggle(ref),
                ),
              ),
              
              // ğŸš€ Top 50/100 í† ê¸€ ë²„íŠ¼ (10/49 ì˜ì—­) - Volume ê¸°ì¤€ radius
              Expanded(
                flex: 10,
                child: Center(
                  child: _buildTopLimitToggle(ref),
                ),
              ),
              
              // ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° (10/49 ì˜ì—­) - ì›ë³¸ ìŠ¤íƒ€ì¼
              Expanded(
                flex: 10,
                child: Center(
                  child: _buildSurgeCounter(ref),
                ),
              ),
              
              // ìš°ì¸¡: ì¹´ìš´íŠ¸ë‹¤ìš´ (11/49 ì˜ì—­, ìš°ì¸¡ ì •ë ¬)
              Expanded(
                flex: 11,
                child: Align(
                  alignment: Alignment.centerRight,
                  child: _buildCountdownWidget(timeFrameCtrl),
                ),
              ),
            ],
          ),
          const SizedBox(height: 6), // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: Volume ê¸°ì¤€ ê°„ê²©
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (timeFrames.length - 1).toDouble(),
            divisions: timeFrames.length - 1,
            label: AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index],
            onChanged: (v) {
              if (ref.read(appSettingsProvider).isHapticEnabled) { // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: í–…í‹± ì„¤ì • ì²´í¬
                HapticFeedback.lightImpact(); // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: lightImpact
              }
              final i = v.round();
              timeFrameCtrl.updateTimeFrame(timeFrames[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸš€ Top 50/100 í† ê¸€ ë²„íŠ¼ - Volume ê¸°ì¤€ radius 12
  Widget _buildTopLimitToggle(WidgetRef ref) {
    final uiController = ref.watch(surgeControllerProvider.notifier);
    final isTop100 = ref.watch(surgeControllerProvider).isTop100;
    final currentName = uiController.currentLimitName;
    
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) { // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: í–…í‹± ì„¤ì • ì²´í¬
          HapticFeedback.lightImpact();
        }
        uiController.toggleTopLimit();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6), // âœ… Volume ê¸°ì¤€ íŒ¨ë”©
        decoration: BoxDecoration(
          color: isTop100 ? Colors.orange : Colors.transparent,
          borderRadius: BorderRadius.circular(12), // âœ… Volume ê¸°ì¤€ radius 12
          border: Border.all(
            color: Colors.orange,
            width: 1,
          ),
        ),
        child: Text(
          currentName,
          style: TextStyle(
            fontSize: 10, // âœ… ì›ë³¸ í°íŠ¸
            fontWeight: FontWeight.w600,
            color: isTop100 ? Colors.white : Colors.orange,
          ),
        ),
      ),
    );
  }

  /// ğŸš€ í•„í„° í† ê¸€ ë²„íŠ¼ - Volume ê¸°ì¤€ radius 12
  Widget _buildFilterToggle(WidgetRef ref) {
    final uiController = ref.watch(surgeControllerProvider.notifier);
    final currentFilter = ref.watch(surgeControllerProvider).filterType;
    final currentName = uiController.currentFilterName;
    
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) { // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: í–…í‹± ì„¤ì • ì²´í¬
          HapticFeedback.lightImpact();
        }
        // ğŸš€ í•„í„° ìˆœí™˜: ì „ì²´ â†’ ê¸‰ë“±ë§Œ â†’ ê¸‰ë½ë§Œ â†’ ì „ì²´
        SurgeFilterType nextFilter;
        switch (currentFilter) {
          case SurgeFilterType.all:
            nextFilter = SurgeFilterType.risingOnly;
            break;
          case SurgeFilterType.risingOnly:
            nextFilter = SurgeFilterType.fallingOnly;
            break;
          case SurgeFilterType.fallingOnly:
            nextFilter = SurgeFilterType.all;
            break;
        }
        uiController.setFilterType(nextFilter);
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6), // âœ… Volume ê¸°ì¤€ íŒ¨ë”©
        decoration: BoxDecoration(
          color: currentFilter != SurgeFilterType.all ? Colors.blue : Colors.transparent,
          borderRadius: BorderRadius.circular(12), // âœ… Volume ê¸°ì¤€ radius 12
          border: Border.all(
            color: Colors.blue,
            width: 1,
          ),
        ),
        child: Text(
          currentName,
          style: TextStyle(
            fontSize: 10, // âœ… ì›ë³¸ í°íŠ¸
            fontWeight: FontWeight.w600,
            color: currentFilter != SurgeFilterType.all ? Colors.white : Colors.blue,
          ),
        ),
      ),
    );
  }

  /// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° ìœ„ì ¯ - ì›ë³¸ ìŠ¤íƒ€ì¼
  Widget _buildSurgeCounter(WidgetRef ref) {
    final surgesAsync = ref.watch(surgeDataProvider);
    final uiController = ref.watch(surgeControllerProvider.notifier);
    
    return surgesAsync.when(
      data: (surges) {
        final count = uiController.getSurgeCount(surges);
        final risingCount = count['rising'] ?? 0;
        final fallingCount = count['falling'] ?? 0;
        
        return Container(
          height: 29, // âœ… 29pxë¡œ ì¡°ì •
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12), // âœ… ì›ë³¸ radius
            border: Border.all(color: Colors.grey.withValues(alpha: 0.3), width: 1), // âœ… ì›ë³¸ border
          ),
          child: Row(
            children: [
              // ì¢Œì¸¡: ê¸‰ë“± ì¹´ìš´í„° (ì´ˆë¡ ë°°ê²½)
              Expanded(
                child: Container(
                  decoration: const BoxDecoration(
                    color: Colors.green,
                    borderRadius: BorderRadius.only(
                      topLeft: Radius.circular(11), // âœ… ì›ë³¸ ë‚´ë¶€ radius
                      bottomLeft: Radius.circular(11),
                    ),
                  ),
                  child: Center(
                    child: Text(
                      '$risingCount',
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10, // âœ… ì›ë³¸ í°íŠ¸
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ),
              // ìš°ì¸¡: ê¸‰ë½ ì¹´ìš´í„° (ë¹¨ê°„ ë°°ê²½)
              Expanded(
                child: Container(
                  decoration: const BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.only(
                      topRight: Radius.circular(11), // âœ… ì›ë³¸ ë‚´ë¶€ radius
                      bottomRight: Radius.circular(11),
                    ),
                  ),
                  child: Center(
                    child: Text(
                      '$fallingCount',
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10, // âœ… ì›ë³¸ í°íŠ¸
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
      loading: () => Container(
        height: 29, // âœ… 29pxë¡œ ì¡°ì •
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12), // âœ… ì›ë³¸ radius
          color: Colors.grey.withValues(alpha: 0.1),
        ),
        child: const Center(
          child: Text(
            'ë¡œë”©ì¤‘',
            style: TextStyle(fontSize: 8, color: Colors.grey), // âœ… ì›ë³¸ í°íŠ¸
          ),
        ),
      ),
      error: (_, __) => Container(
        height: 29, // âœ… 29pxë¡œ ì¡°ì •
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12), // âœ… ì›ë³¸ radius
          color: Colors.grey.withValues(alpha: 0.1),
        ),
        child: const Center(
          child: Text(
            'ì˜¤ë¥˜',
            style: TextStyle(fontSize: 8, color: Colors.grey), // âœ… ì›ë³¸ í°íŠ¸
          ),
        ),
      ),
    );
  }

  /// ğŸ¯ ì¹´ìš´íŠ¸ë‹¤ìš´ ìœ„ì ¯ ìƒì„± - ìë™ í¬ê¸° ì¡°ì • (ì´ëª¨ì§€+ìˆ«ì ë”± ë¶™ì´ê¸°)
  Widget _buildCountdownWidget(SurgeTimeFrameController timeFrameCtrl) {
    final nextResetTime = timeFrameCtrl.getNextResetTime();
    
    if (nextResetTime == null) {
      return const Row( // âœ… const ì¶”ê°€ (Line 320)
        mainAxisSize: MainAxisSize.min,
        children: [ // âœ… const ì¶”ê°€ (Line 322)
          Icon(Icons.access_time, size: 16, color: Colors.grey), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '--:--',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final now = DateTime.now();
    final remaining = nextResetTime.difference(now);
    
    if (remaining.isNegative) {
      return const Row( // âœ… const ì¶”ê°€ (Line 341)
        mainAxisSize: MainAxisSize.min,
        children: [ // âœ… const ì¶”ê°€ (Line 343)
          Icon(Icons.access_time, size: 16, color: Colors.orange), // âœ… const ì¶”ê°€
          SizedBox(width: 2), // âœ… const ì¶”ê°€
          Text( // âœ… const ì¶”ê°€
            '00:00',
            style: TextStyle(
              fontSize: 13,
              color: Colors.orange,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      );
    }

    final minutes = remaining.inMinutes;
    final seconds = remaining.inSeconds % 60;
    final minutesStr = minutes.toString().padLeft(2, '0');
    final secondsStr = seconds.toString().padLeft(2, '0');
    
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        const Icon(Icons.access_time, size: 16, color: Colors.orange),
        const SizedBox(width: 2), // âœ… ì¡°ê¸ˆë§Œ ë„ìš°ê¸°
        Text(
          '$minutesStr:$secondsStr',
          style: const TextStyle(
            fontSize: 12,
            color: Colors.orange,
            fontWeight: FontWeight.w500,
          ),
        ),
      ],
    );
  }

  /// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - í˜„ì¬ ì‹œìŠ¤í…œ (Volume ê¸°ì¤€ ìŠ¤í¬ë¡¤ë°”)
  Widget _buildSurgeList(
    AsyncValue<List<Surge>> surgesAsync, 
    SurgeController uiController, 
    ScrollController scrollController,
    List<String> timeFrames,
    int index,
    BuildContext context,
  ) {
    return surgesAsync.when(
      data: (surges) {
        // List<Surge>ë¥¼ ì •ë ¬ ë° í•„í„°ë§ëœ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ë™ì  ìˆœìœ„ ì œí•œ ì ìš©)
        final sortedSurges = uiController.sortAndFilterSurgeData(surges);
        
        if (sortedSurges.isEmpty) {
          return Center(
            child: Text(
              'ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${AppConfig.timeFrameNames[AppConfig.timeFrames[index]] ?? timeFrames[index]})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // âœ… í˜„ì¬ ì‹œìŠ¤í…œ: Volume ê¸°ì¤€ ìŠ¤í¬ë¡¤ë°” ì ìš©
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: false, // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
          trackVisibility: false, // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
          thickness: 6.4, // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
          radius: const Radius.circular(3.2), // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
          thumbColor: Colors.orange.withValues(alpha: 0.5),
          trackColor: Colors.transparent,
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 40, // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16), // âœ… í˜„ì¬ ì‹œìŠ¤í…œ
            itemCount: sortedSurges.length,
            itemBuilder: (_, i) => SurgeTile(
              market: sortedSurges[i].market,
              changePercent: sortedSurges[i].changePercent,
              basePrice: sortedSurges[i].basePrice,
              currentPrice: sortedSurges[i].currentPrice,
              rank: i + 1, // ğŸš€ ìˆœìœ„ ì „ë‹¬ (1ìœ„ë¶€í„° ì‹œì‘)
            ),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ê¸‰ë“±/ê¸‰ë½ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/pages/signal_page.dart ======\n
// lib/presentation/pages/signal_page.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/settings_provider.dart';
import '../../core/di/signal_provider.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/entities/signal.dart';
import '../controllers/signal_controller.dart';
import '../widgets/signal_tile.dart';

/// ğŸš€ Signal Page V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
class SignalPage extends ConsumerWidget {
  final ScrollController scrollController;

  const SignalPage({
    super.key,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // V4.1 Controller ê¸°ë°˜ ì‹œìŠ¤í…œ
    final controller = ref.watch(signalControllerProvider.notifier);
    final state = ref.watch(signalControllerProvider);

    // ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
    final signalsAsync = ref.watch(signalListProvider);

    // markets ì •ë³´
    final marketsAsync = ref.watch(marketsProvider);

    // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;

    // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
    ref.listen(signalSystemMonitorProvider, (prev, next) {
      if (next.hasError && AppConfig.enableTradeLog) {
        debugPrint('âš ï¸ Signal system monitoring error: ${next.error}');
      }
    });

    // ì—ëŸ¬ ë©”ì‹œì§€ ìë™ í´ë¦¬ì–´
    ref.listen(signalControllerProvider.select((s) => s.errorMessage), (prev, next) {
      if (next != null) {
        Future.delayed(const Duration(seconds: 5), () {
          controller.clearError();
        });
      }
    });

    // ğŸ†• V4.1 ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
    final sliderWidget = _buildEnhancedSliderWidget(
      controller,
      state,
      marketsAsync,
      ref,
      context,
    );

    // ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° í•„í„°ë§ í¬í•¨)
    final signalListWidget = _buildEnhancedSignalList(
      signalsAsync,
      controller,
      scrollController,
      state,
      context,
      ref,
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜
          if (sliderPosition == SliderPosition.top) sliderWidget,

          // ğŸ†• V4.1 ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
          if (state.errorMessage != null) _buildErrorBanner(state.errorMessage!, controller),

          // ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: signalListWidget),

          // ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ë°°ë„ˆ
  Widget _buildErrorBanner(String errorMessage, SignalController controller) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.red.withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.red.withValues(alpha: 0.3)),
      ),
      child: Row(
        children: [
          const Icon(Icons.error_outline, color: Colors.red, size: 16),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              errorMessage,
              style: const TextStyle(color: Colors.red, fontSize: 12),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          GestureDetector(
            onTap: controller.clearError,
            child: const Icon(Icons.close, color: Colors.red, size: 16),
          ),
        ],
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ìŠ¬ë¼ì´ë” ìœ„ì ¯ (ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨)
  Widget _buildEnhancedSliderWidget(
    SignalController controller,
    SignalState state,
    AsyncValue<List<String>> marketsAsync,
    WidgetRef ref,
    BuildContext context,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // ğŸ¯ ì²« ë²ˆì§¸ ì¤„: ì•„ì´ì½˜ + ì œëª© + ì„¤ëª… + ìƒíƒœ í‘œì‹œ
          Row(
            children: [
              // íŒ¨í„´ ì•„ì´ì½˜ + ì œëª©
              Icon(
                _getPatternIcon(state.currentPattern),
                size: 18,
                color: _getPatternColor(state.currentPattern),
              ),
              const SizedBox(width: 8),
              
              // ì œëª© + ì„¤ëª…
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      state.currentPattern.displayName,
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      state.currentPattern.description,
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),

              // ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ í‘œì‹œ
              _buildSystemStatusChip(state),
              const SizedBox(width: 8),

              // í™œì„±í™”/ë¹„í™œì„±í™” í† ê¸€
              _buildPatternToggle(state, controller, ref),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ë‘ ë²ˆì§¸ ì¤„: ì„ê³„ê°’ + ì‹ ë¢°ë„ ì •ë³´
          Row(
            children: [
              Text(
                'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
              const Spacer(),
              // ğŸ†• V4.1 ì‹ ë¢°ë„ ì •ë³´
              Text(
                controller.getConfidenceStatusText(),
                style: const TextStyle(fontSize: 10, color: Colors.grey),
              ),
            ],
          ),

          const SizedBox(height: 8),

          // ğŸ¯ ì„¸ ë²ˆì§¸ ì¤„: íŒ¨í„´ ìŠ¬ë¼ì´ë”
          Row(
            children: [
              // ìŠ¬ë¼ì´ë”
              Expanded(
                child: Slider(
                  value: state.selectedIndex.toDouble(),
                  min: 0,
                  max: (PatternType.values.length - 1).toDouble(),
                  divisions: PatternType.values.length - 1,
                  label: state.currentPattern.displayName,
                  activeColor: _getPatternColor(state.currentPattern),
                  onChanged: (v) {
                    if (ref.read(appSettingsProvider).isHapticEnabled) {
                      HapticFeedback.lightImpact();
                    }
                    final index = v.round();
                    marketsAsync.whenData((markets) {
                      controller.setPatternIndex(index, markets);
                    });
                  },
                ),
              ),

              // ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
              _buildSortButton(state, controller),
            ],
          ),

          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
          _buildOnlineMetricsStatusBar(state),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ ìƒíƒœ ì¹©
  Widget _buildSystemStatusChip(SignalState state) {
    final isHealthy = state.isSystemHealthy;
    final color = isHealthy ? Colors.green : Colors.orange;
    final icon = isHealthy ? Icons.check_circle : Icons.warning;
    
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: color.withValues(alpha: 0.1),
        border: Border.all(color: color.withValues(alpha: 0.3), width: 0.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            isHealthy ? 'OK' : 'WARN',
            style: TextStyle(fontSize: 8, color: color, fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ í† ê¸€ ë²„íŠ¼
  Widget _buildPatternToggle(SignalState state, SignalController controller, WidgetRef ref) {
    return GestureDetector(
      onTap: () {
        if (ref.read(appSettingsProvider).isHapticEnabled) {
          HapticFeedback.lightImpact();
        }
        controller.togglePatternEnabled();
      },
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: Colors.orange,
            width: 1.5,
          ),
          color: state.isPatternEnabled ? Colors.orange : Colors.transparent,
        ),
        child: Text(
          state.isPatternEnabled ? 'í™œì„±' : 'ë¹„í™œì„±',
          style: TextStyle(
            color: state.isPatternEnabled ? Colors.white : Colors.orange,
            fontSize: 11,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì •ë ¬ ë²„íŠ¼
  Widget _buildSortButton(SignalState state, SignalController controller) {
    return PopupMenuButton<String>(
      icon: Icon(
        Icons.sort,
        size: 18,
        color: Colors.grey[600],
      ),
      onSelected: (value) {
        controller.setSortField(value);
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'time', child: Text('ì‹œê°„ ${_getSortIcon(state, 'time')}')),
        PopupMenuItem(value: 'confidence', child: Text('ì‹ ë¢°ë„ ${_getSortIcon(state, 'confidence')}')),
        PopupMenuItem(value: 'change', child: Text('ë³€í™”ìœ¨ ${_getSortIcon(state, 'change')}')),
        PopupMenuItem(value: 'amount', child: Text('ê±°ë˜ì•¡ ${_getSortIcon(state, 'amount')}')),
        PopupMenuItem(value: 'market', child: Text('ë§ˆì¼“ ${_getSortIcon(state, 'market')}')),
      ],
    );
  }

  /// ğŸ†• ì •ë ¬ ì•„ì´ì½˜ í—¬í¼
  String _getSortIcon(SignalState state, String field) {
    if (state.sortField != field) return '';
    return state.sortAscending ? 'â†‘' : 'â†“';
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ë°”
  Widget _buildOnlineMetricsStatusBar(SignalState state) {
    if (!state.hasOnlineMetrics) {
      return Container(
        height: 2,
        margin: const EdgeInsets.only(top: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(1),
          color: Colors.grey[300],
        ),
      );
    }

    final health = state.onlineMetricsHealth!;
    final totalMarkets = health['totalMarkets'] ?? 0;
    final healthyMarkets = health['healthyMarkets'] ?? 0;
    final staleMarkets = health['staleMarkets'] ?? 0;
    
    final healthRatio = totalMarkets > 0 ? healthyMarkets / totalMarkets : 0.0;
    final color = staleMarkets > 0 ? Colors.orange : Colors.green;

    return Container(
      height: 2,
      margin: const EdgeInsets.only(top: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(1),
        color: Colors.grey[300],
      ),
      child: FractionallySizedBox(
        widthFactor: healthRatio,
        alignment: Alignment.centerLeft,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(1),
            color: color,
          ),
        ),
      ),
    );
  }

  /// ğŸš€ V4.1 ê°•í™”ëœ ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ (ì •ë ¬ ë° ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ)
  Widget _buildEnhancedSignalList(
    AsyncValue<List<Signal>> signalsAsync,
    SignalController controller,
    ScrollController scrollController,
    SignalState state,
    BuildContext context,
    WidgetRef ref,
  ) {
    return signalsAsync.when(
      data: (list) {
        final viewList = controller.apply(list);

        if (viewList.isEmpty) {
          return _buildEmptyState(state, context, controller);
        }

        return _buildSignalListView(viewList, scrollController, state, ref);
      },
      loading: () => _buildLoadingState(context),
      error: (e, _) => _buildErrorState(e, context, ref),
    );
  }

  /// ğŸ†• V4.1 ë¹ˆ ìƒíƒœ (ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ í¬í•¨)
  Widget _buildEmptyState(SignalState state, BuildContext context, SignalController controller) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.radar,
            size: 64,
            color: Theme.of(context).hintColor.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            state.isPatternEnabled
                ? '${state.currentPattern.displayName} íŒ¨í„´ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
                : 'íŒ¨í„´ ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.',
            textAlign: TextAlign.center,
            style: TextStyle(
                color: Theme.of(context).hintColor, fontSize: 16),
          ),
          const SizedBox(height: 8),
          Text(
            'ì„ê³„ê°’: ${controller.getThresholdDisplayText()}',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor.withValues(alpha: 0.7),
              fontSize: 14,
            ),
          ),
          // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ
          if (state.hasOnlineMetrics) ...[
            const SizedBox(height: 8),
            Text(
              controller.getSystemStatusText(),
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Theme.of(context).hintColor.withValues(alpha: 0.7),
                fontSize: 12,
              ),
            ),
          ],
          // ğŸ†• V4.1 ë¹ ë¥¸ ì•¡ì…˜ ë²„íŠ¼ë“¤
          const SizedBox(height: 24),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => controller.resetOnlineMetrics(),
                icon: const Icon(Icons.refresh, size: 16),
                label: const Text('ì§€í‘œ ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
              const SizedBox(width: 12),
              // í”„ë¦¬ì…‹ ì ìš© ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showPresetDialog(context, controller),
                icon: const Icon(Icons.tune, size: 16),
                label: const Text('í”„ë¦¬ì…‹'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                  textStyle: const TextStyle(fontSize: 12),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ë¡œë”© ìƒíƒœ (ê°œì„ ëœ ë””ìì¸)
  Widget _buildLoadingState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(
            'ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ ì¤‘...',
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì—ëŸ¬ ìƒíƒœ (ê°œì„ ëœ ì—ëŸ¬ ì²˜ë¦¬)
  Widget _buildErrorState(Object error, BuildContext context, WidgetRef ref) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.error_outline,
            size: 64,
            color: Theme.of(context).colorScheme.error.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 16),
          Text(
            'ì‹œê·¸ë„ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
            style: TextStyle(
              color: Theme.of(context).colorScheme.error,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            '$error',
            textAlign: TextAlign.center,
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton.icon(
                onPressed: () {
                  ref.invalidate(signalListProvider);
                },
                icon: const Icon(Icons.refresh),
                label: const Text('ë‹¤ì‹œ ì‹œë„'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                ),
              ),
              const SizedBox(width: 12),
              // ğŸ†• V4.1 ê³ ê¸‰ ì§„ë‹¨ ë²„íŠ¼
              ElevatedButton.icon(
                onPressed: () => _showDiagnosticsDialog(context, ref),
                icon: const Icon(Icons.info),
                label: const Text('ì§„ë‹¨'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue,
                  foregroundColor: Colors.white,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ğŸ†• V4.1 ì‹œê·¸ë„ ë¦¬ìŠ¤íŠ¸ ë·° (ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ í¬í•¨)
  Widget _buildSignalListView(
    List<Signal> viewList,
    ScrollController scrollController,
    SignalState state,
    WidgetRef ref,
  ) {
    return RawScrollbar(
      controller: scrollController,
      thumbVisibility: false,
      trackVisibility: false,
      thickness: 6.4,
      radius: const Radius.circular(3.2),
      thumbColor: Colors.orange.withValues(alpha: 0.5),
      interactive: true,
      minThumbLength: 40,
      child: ListView.builder(
        controller: scrollController,
        physics: const BouncingScrollPhysics(
          parent: AlwaysScrollableScrollPhysics(),
        ),
        padding: const EdgeInsets.only(left: 16, right: 20, top: 16, bottom: 16),
        itemCount: viewList.length,
        itemBuilder: (context, index) {
          final signal = viewList[index];
          
          return Column(
            children: [
              // ğŸ†• V4.1 Signal Tile ì‚¬ìš© (íƒ­ ê¸°ëŠ¥ ì¶”ê°€)
              GestureDetector(
                onTap: () => _showSignalDetails(context, signal, ref),
                child: SignalTile(
                  signal: signal,
                  showOnlineMetrics: true,
                ),
              ),
              
              // êµ¬ë¶„ì„  (ë§ˆì§€ë§‰ ì•„ì´í…œ ì œì™¸)
              if (index < viewList.length - 1)
                Divider(
                  height: 1,
                  thickness: 0.5,
                  color: Colors.grey[300],
                  indent: 16,
                  endIndent: 16,
                ),
            ],
          );
        },
      ),
    );
  }

  // ==========================================================================
  // ğŸ†• V4.1 ëŒ€í™”ìƒìë“¤
  // ==========================================================================

  /// ğŸ†• í”„ë¦¬ì…‹ ì„ íƒ ëŒ€í™”ìƒì
  void _showPresetDialog(BuildContext context, SignalController controller) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('íŒ¨í„´ í”„ë¦¬ì…‹ ì„ íƒ'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.security, color: Colors.blue),
              title: const Text('Conservative'),
              subtitle: const Text('False Positive ìµœì†Œí™”'),
              onTap: () {
                controller.applyPreset('conservative');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.balance, color: Colors.green),
              title: const Text('Balanced'),
              subtitle: const Text('ê· í˜•ì¡íŒ ê¸°ë³¸ ì„¤ì •'),
              onTap: () {
                controller.applyPreset('balanced');
                Navigator.pop(context);
              },
            ),
            ListTile(
              leading: const Icon(Icons.speed, color: Colors.red),
              title: const Text('Aggressive'),
              subtitle: const Text('ê°ì§€ìœ¨ ìµœëŒ€í™”'),
              onTap: () {
                controller.applyPreset('aggressive');
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ†• ì§„ë‹¨ ì •ë³´ ëŒ€í™”ìƒì
  void _showDiagnosticsDialog(BuildContext context, WidgetRef ref) {
    final controller = ref.read(signalControllerProvider.notifier);
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ì‹œìŠ¤í…œ ì§„ë‹¨'),
        content: FutureBuilder<Map<String, dynamic>>(
          future: controller.getSystemHealthReport(),
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('ì§„ë‹¨ ì¤‘...'),
                ],
              );
            }
            
            if (snapshot.hasError) {
              return Text('ì§„ë‹¨ ì‹¤íŒ¨: ${snapshot.error}');
            }
            
            final report = snapshot.data!;
            return SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text('ë²„ì „: ${report['version']}'),
                  Text('ìƒíƒœ: ${report['status']}'),
                  Text('ì—…íƒ€ì„: ${report['uptime']}ë¶„'),
                  Text('ì²˜ë¦¬ëœ ê±°ë˜: ${report['totalProcessedTrades']}ê±´'),
                  Text('í™œì„± íŒ¨í„´: ${report['activePatterns']}ê°œ'),
                  Text('ì¶”ì  ë§ˆì¼“: ${report['trackedMarkets']}ê°œ'),
                  const SizedBox(height: 16),
                  const Text('ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ:', style: TextStyle(fontWeight: FontWeight.bold)),
                  if (report['onlineMetricsHealth'] != null) ...[
                    Text('ì´ ë§ˆì¼“: ${report['onlineMetricsHealth']['totalMarkets']}'),
                    Text('ì •ìƒ: ${report['onlineMetricsHealth']['healthyMarkets']}'),
                    Text('ë§Œë£Œ: ${report['onlineMetricsHealth']['staleMarkets']}'),
                  ],
                ],
              ),
            );
          },
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ì‹œê·¸ë„ ìƒì„¸ ì •ë³´ ëŒ€í™”ìƒì
  void _showSignalDetails(BuildContext context, Signal signal, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('${signal.patternType.displayName} - ${signal.ticker}'),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              // ê¸°ë³¸ ì •ë³´
              _buildDetailRow('ë§ˆì¼“', signal.market),
              _buildDetailRow('í˜„ì¬ê°€', '${signal.currentPrice.toStringAsFixed(0)}ì›'),
              _buildDetailRow('ë³€í™”ìœ¨', '${signal.changePercent.toStringAsFixed(2)}%'),
              _buildDetailRow('ê±°ë˜ì•¡', '${(signal.tradeAmount / 1000000).toStringAsFixed(1)}M'),
              _buildDetailRow('ê°ì§€ì‹œê°„', signal.detectedAt.toString().substring(0, 19)),
              
              if (signal.confidence != null)
                _buildDetailRow('ì‹ ë¢°ë„', '${(signal.confidence! * 100).toStringAsFixed(1)}%'),
              
              // ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
              if (signal.hasOnlineMetrics) ...[
                const SizedBox(height: 16),
                const Text('ì˜¨ë¼ì¸ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                
                if (signal.onlineIndicators?.rsi != null)
                  _buildDetailRow('RSI', '${signal.onlineIndicators!.rsi!.toStringAsFixed(1)} (${signal.onlineIndicators!.rsiState})'),
                
                if (signal.onlineIndicators?.macd != null)
                  _buildDetailRow('MACD', '${signal.onlineIndicators!.macd!.toStringAsFixed(2)} (${signal.onlineIndicators!.macdState})'),
              ],
              
              // ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
              if (signal.divergence != null) ...[
                const SizedBox(height: 16),
                const Text('ë‹¤ì´ë²„ì „ìŠ¤', style: TextStyle(fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                _buildDetailRow('íƒ€ì…', signal.divergence!.type),
                _buildDetailRow('ê°•ë„', signal.divergence!.confidenceLevel),
                _buildDetailRow('ì†ŒìŠ¤', signal.divergence!.source),
              ],
              
              // ê³ ê¸‰ ì§€í‘œë“¤
              const SizedBox(height: 16),
              const Text('ê³ ê¸‰ ì§€í‘œ', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              
              if (signal.zScore != null)
                _buildDetailRow('Z-Score', signal.zScore!.toStringAsFixed(2)),
              
              if (signal.liquidityVortex != null)
                _buildDetailRow('Liquidity Vortex', signal.liquidityVortex!.toStringAsFixed(3)),
              
              if (signal.flashPulse != null)
                _buildDetailRow('Flash Pulse', signal.flashPulse!.toStringAsFixed(2)),
              
              // ë²„ì „ ì •ë³´
              if (signal.version != null) ...[
                const SizedBox(height: 16),
                _buildDetailRow('ë²„ì „', signal.version!),
              ],
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('ë‹«ê¸°'),
          ),
        ],
      ),
    );
  }

  /// ìƒì„¸ ì •ë³´ í–‰
  Widget _buildDetailRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              '$label:',
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  // ==========================================================================
  // í—¬í¼ í•¨ìˆ˜ë“¤
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì•„ì´ì½˜ ë°˜í™˜
  IconData _getPatternIcon(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Icons.trending_up;
      case PatternType.flashFire:
        return Icons.flash_on;
      case PatternType.stackUp:
        return Icons.stacked_line_chart;
      case PatternType.stealthIn:
        return Icons.visibility_off;
      case PatternType.blackHole:
        return Icons.radio_button_unchecked;
      case PatternType.reboundShot:
        return Icons.trending_up;
    }
  }

  /// íŒ¨í„´ë³„ ìƒ‰ìƒ ë°˜í™˜
  Color _getPatternColor(PatternType pattern) {
    switch (pattern) {
      case PatternType.surge:
        return Colors.red;
      case PatternType.flashFire:
        return Colors.orange;
      case PatternType.stackUp:
        return Colors.amber;
      case PatternType.stealthIn:
        return Colors.green;
      case PatternType.blackHole:
        return Colors.purple;
      case PatternType.reboundShot:
        return Colors.blue;
    }
  }
}\n\n// ====== lib/presentation/widgets/sector_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart'; // AmountDisplayMode ì¶”ê°€
import '../../shared/widgets/sector_names.dart';
import '../../shared/widgets/sector_logo_provider.dart'; // ì„¹í„° ë¡œê³  í”„ë¡œë°”ì´ë”
import '../../shared/widgets/amount_display_widget.dart'; // ğŸ’° ë¨¸ë‹ˆì•„ì´ì½˜ ìœ„ì ¯
import '../../shared/utils/tile_common.dart'; // ğŸ¯ ê³µí†µ ìœ í‹¸ë¦¬í‹°
import '../../shared/utils/blink_animation_mixin.dart'; // âœ¨ ë°˜ì§ì„ í—¬í¼
import '../../shared/utils/amount_formatter.dart'; // ğŸ’° í¬ë§·í„° ìœ í‹¸ë¦¬í‹°

// ğŸ¯ ìˆœìœ„ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (ì„¹í„°ë³„ ì´ì „ ìˆœìœ„ ì €ì¥)
final Map<String, int> _previousSectorRanks = {};

// ğŸ”¥ HOT ì„¹í„° ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (ì„¹í„°ë³„ HOT ì‹œì‘ ì‹œê°„)
final Map<String, DateTime> _hotSectors = {};

class SectorTile extends ConsumerStatefulWidget {
  final String sectorName;
  final double totalVolume;
  final int rank;
  final String timeFrame;
  final DateTime lastUpdated;
  final bool showHotIcon;
  final bool enableBlinkAnimation;
  
  const SectorTile({
    Key? key, 
    required this.sectorName,
    required this.totalVolume,
    required this.rank,
    required this.timeFrame,
    required this.lastUpdated,
    this.showHotIcon = false,
    this.enableBlinkAnimation = false,
  }) : super(key: key);

  @override
  ConsumerState<SectorTile> createState() => _SectorTileState();
}

class _SectorTileState extends ConsumerState<SectorTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SectorTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    // ğŸ¯ ìˆœìœ„ ë³€í™” ê°ì§€ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
    if (BlinkAnimationHelper.checkRankChange(
      previousRanksMap: _previousSectorRanks,
      key: widget.sectorName,
      currentRank: widget.rank,
    )) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ”¥ HOT ìƒíƒœ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹ ì‹œ 10ì´ˆê°„ ìœ ì§€)
  bool _checkIfHot() {
    final now = DateTime.now();
    
    // 1. ê¸°ì¡´ HOT ìƒíƒœ ì²´í¬ (10ì´ˆ ìœ ì§€)
    if (_hotSectors.containsKey(widget.sectorName)) {
      final hotStartTime = _hotSectors[widget.sectorName]!;
      if (now.difference(hotStartTime).inSeconds <= 20) {
        return true; // ì•„ì§ HOT ìœ ì§€
      } else {
        _hotSectors.remove(widget.sectorName); // ì‹œê°„ ì§€ë‚˜ë©´ ì œê±°
      }
    }
    
    // 2. ìƒˆë¡œìš´ HOT ì¡°ê±´ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹)
    final previousRank = _previousSectorRanks[widget.sectorName];
    if (previousRank != null && previousRank - widget.rank >= 5) {
      _hotSectors[widget.sectorName] = now; // HOT ì‹œì‘ ê¸°ë¡
      return true;
    }
    
    return false;
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  /// ì„¹í„°ëª… í‘œì‹œ (ê¸°ì¡´ ìœ ì§€ - ì„¹í„° ì „ìš© ë¡œì§)
  String _getDisplaySectorName() {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final isDetailed = ref.watch(sectorClassificationProvider).isDetailedClassification;
    
    return SectorNames.getDisplayName(widget.sectorName, displayMode, isDetailed: isDetailed);
  }

  /// ì„¹í„° ë²ˆí˜¸ ë§¤í•‘ (ê¸°ì¡´ ìœ ì§€ - ì„¹í„° ì „ìš© ë¡œì§)
  int _getSectorNumber(String sectorName) {
    const sectorNumberMap = {
      // ìƒì„¸ ë¶„ë¥˜ (1-28ë²ˆ)
      'ë¹„íŠ¸ì½”ì¸ ê·¸ë£¹': 1, 'ì´ë”ë¦¬ì›€ ê·¸ë£¹': 2, 'ìŠ¤í…Œì´í‚¹': 3, 'ëª¨ë†€ë¦¬ì‹ ë¸”ë¡ì²´ì¸': 4,
      'ëª¨ë“ˆëŸ¬ ë¸”ë¡ì²´ì¸': 5, 'ìŠ¤í…Œì´ë¸” ì½”ì¸': 6, 'DEX/ì• ê·¸ë¦¬ê²Œì´í„°': 7, 'ëœë”©': 8,
      'ìœ ë™í™” ìŠ¤í…Œì´í‚¹/ë¦¬ìŠ¤í…Œì´í‚¹': 9, 'RWA': 10, 'ì§€ê¸‰ê²°ì œ ì¸í”„ë¼': 11, 'ìƒí˜¸ìš´ìš©ì„±/ë¸Œë¦¿ì§€': 12,
      'ì—”í„°í”„ë¼ì´ì¦ˆ ë¸”ë¡ì²´ì¸': 13, 'ì˜¤ë¼í´': 14, 'ë°ì´í„° ì¸í”„ë¼': 15, 'ìŠ¤í† ë¦¬ì§€': 16,
      'AI': 17, 'ë©”íƒ€ë²„ìŠ¤': 18, 'NFT/ê²Œì„': 19, 'ë¯¸ë””ì–´/ìŠ¤íŠ¸ë¦¬ë°': 20,
      'ê´‘ê³ ': 21, 'êµìœ¡/ê¸°íƒ€ ì½˜í…ì¸ ': 22, 'ì†Œì…œ/DAO': 23, 'íŒ¬í† í°': 24,
      'ë°ˆ': 25, 'DID': 26, 'ì˜ë£Œ': 27, 'ì›”ë ›/ë©”ì„¸ì§•': 28,
      
      // ê¸°ë³¸ ë¶„ë¥˜ (29-46ë²ˆ)
      'ë©”ì´ì € ì½”ì¸': 29, 'ë¹„íŠ¸ì½”ì¸ ê³„ì—´': 30, 'ì´ë”ë¦¬ì›€ ìƒíƒœê³„': 31, 'ë ˆì´ì–´1 ë¸”ë¡ì²´ì¸': 32,
      'ê³  ì‹œì´': 33, 'ì¤‘ ì‹œì´': 34, 'ì € ì‹œì´': 35, 'ë§ˆì´ë„ˆ ì•ŒíŠ¸ì½”ì¸': 36,
      'DeFi í† í°': 37, 'ìŠ¤í…Œì´ë¸”ì½”ì¸': 38, 'ê²Œì„/NFT/ë©”íƒ€ë²„ìŠ¤': 39, 'í•œêµ­ í”„ë¡œì íŠ¸': 40,
      'ì†”ë¼ë‚˜ ìƒíƒœê³„': 41, 'AI/ê¸°ìˆ  í† í°': 42, '2023ë…„ ì‹ ê·œìƒì¥': 43, '2024ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 44,
      '2024ë…„ í•˜ë°˜ê¸° ì‹ ê·œìƒì¥': 45, '2025ë…„ ìƒë°˜ê¸° ì‹ ê·œìƒì¥': 46,
    };
    
    return sectorNumberMap[sectorName] ?? 1;
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // ğŸ”¥ HOT ìƒíƒœ ì²´í¬
    final isHot = _checkIfHot();
    
    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank), // âœ… ê³µí†µ í•¨ìˆ˜
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì„¹í„° ì•„ì´ì½˜ ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            SectorLogoProvider.buildSectorIcon(
              sectorNumber: _getSectorNumber(widget.sectorName),
              size: 40.0,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì„¹í„°ëª… ë¶€ë¶„: flex 25
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        _getDisplaySectorName(), // âœ… ì„¹í„° ì „ìš© í•¨ìˆ˜
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜ (ì‹¤ì‹œê°„ ê³„ì‚°)
                    if (TileCommon.buildHotIcon(isHot) case final hotIcon?) 
                      hotIcon, // âœ… ê³µí†µ í•¨ìˆ˜
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  SectorNames.getDisplayName(widget.sectorName, DisplayMode.ticker, isDetailed: ref.watch(sectorClassificationProvider).isDetailedClassification), // ì‹¤ì œ ticker í‘œì‹œ
                  style: TextStyle(
                    color: onSurface70,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 30 - ì„¸ë¡œ ê°€ìš´ë° ì •ë ¬ë¡œ ë³€ê²½!
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
                  
                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget( // âœ… ë¨¸ë‹ˆì•„ì´ì½˜ ëª¨ë“œ
                          totalAmount: widget.totalVolume,
                          isBuy: true, // Sectorë„ ì¤‘ë¦½ì  ìƒ‰ìƒ
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text( // âœ… ìˆ«ì ëª¨ë“œ (ê¸°ì¡´ ë°©ì‹)
                          AmountFormatter.formatVolume(widget.totalVolume), // âœ… ê³µí†µ í¬ë§·í„°
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬ ì¶”ê°€)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    Widget finalWidget = blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: Colors.amber, // Sectorë„ ì•°ë²„ ìƒ‰ìƒ
          )
        : cardWidget;
    
    // ğŸ¨ ì¡°ê±´ë¶€ ê¹œë¹¡ì„ íš¨ê³¼ (ì„¤ì • í™•ì¸)
    if (!_shouldBlink && widget.enableBlinkAnimation && blinkEnabled) {
      finalWidget = BlinkAnimationHelper.wrapWithConditionalBlink(
        child: cardWidget,
        enableBlinkAnimation: widget.enableBlinkAnimation,
        theme: theme,
      );
    }
    
    return finalWidget;
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';
import '../../shared/widgets/amount_display_widget.dart'; // ğŸ’° AmountDisplayWidget import
import '../../shared/utils/tile_common.dart'; // ğŸ¯ ê³µí†µ ìœ í‹¸ë¦¬í‹°
import '../../shared/utils/amount_formatter.dart'; // ğŸ’° í¬ë§·í„° ìœ í‹¸ë¦¬í‹°

class TradeTile extends ConsumerWidget {
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');
  
  final Trade trade;
  
  const TradeTile({Key? key, required this.trade}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // ğŸ¯ ê³µí†µ ì¹´ë“œ ìœ„ì ¯ ì‚¬ìš©
    return TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 12
          FlexChild.expanded(
            Text(
              _timeFormat.format(trade.timestamp),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 12,
          ),
          
          // ğŸª™ ì½”ì¸ëª… ë¶€ë¶„: flex 18 - ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©
          FlexChild.expanded(
            Text(
              TileCommon.getDisplayName(ref, trade.market), // âœ… ê³µí†µ í•¨ìˆ˜
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
                fontSize: 16,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
            flex: 18,
          ),
          
          // ğŸ’µ ê°€ê²©/ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 20
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(trade.price)}ì›', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface, fontSize: 14),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatTradeVolume(trade.volume)}ê°œ', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface70, fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 20,
          ),
          
          // ğŸ’° ì´ì•¡ ë¶€ë¶„: flex 20 - AmountDisplayWidget ì‚¬ìš©
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: trade.total,
                isBuy: trade.isBuy,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            flex: 20,
          ),
          
          // ğŸ“ˆ ë°©í–¥ ì•„ì´ì½˜: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            Icon(
              trade.isBuy ? Icons.arrow_upward : Icons.arrow_downward,
              color: trade.isBuy ? Colors.green : Colors.red,
              size: 16,
            ),
          ),
        ],
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/surge_tile.dart ======\n
// lib/presentation/widgets/surge_tile.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart'; // DisplayMode import
import '../../shared/widgets/coin_logo_provider.dart'; // ğŸ†• ì½”ì¸ ë¡œê³  í”„ë¡œë°”ì´ë” import
import '../../shared/utils/tile_common.dart'; // ğŸ¯ ê³µí†µ ìœ í‹¸ë¦¬í‹°
import '../../shared/utils/blink_animation_mixin.dart'; // âœ¨ ë°˜ì§ì„ í—¬í¼
import '../../shared/utils/amount_formatter.dart'; // ğŸ’° í¬ë§·í„° ìœ í‹¸ë¦¬í‹°

// ğŸš€ ìˆœìœ„ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (marketë³„ ì´ì „ ìˆœìœ„ ì €ì¥)
final Map<String, int> _previousRanks = {};

// ğŸ”¥ HOT ë§ˆì¼“ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (marketë³„ HOT ì‹œì‘ ì‹œê°„)
final Map<String, DateTime> _hotMarkets = {};

class SurgeTile extends ConsumerStatefulWidget {
  final String market; // ğŸš€ Surge ì—”í‹°í‹° ëŒ€ì‹  ë‹¨ìˆœ ë°ì´í„°
  final double changePercent; // ë³€ë™ë¥ 
  final double basePrice; // ê¸°ì¤€ ê°€ê²©
  final double currentPrice; // í˜„ì¬ ê°€ê²©
  final int rank; // ğŸš€ ìˆœìœ„ (1ìœ„ë¶€í„°)
  final bool showHotIcon; // ğŸš€ ê¸‰ìƒìŠ¹ í‘œì‹œ ì—¬ë¶€
  final bool enableBlinkAnimation; // ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ ì—¬ë¶€
  
  const SurgeTile({
    Key? key, 
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.rank,
    this.showHotIcon = false,
    this.enableBlinkAnimation = false,
  }) : super(key: key);

  @override
  ConsumerState<SurgeTile> createState() => _SurgeTileState();
}

class _SurgeTileState extends ConsumerState<SurgeTile> 
    with SingleTickerProviderStateMixin {
  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SurgeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    // ğŸ¯ ìˆœìœ„ ë³€í™” ê°ì§€ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
    if (BlinkAnimationHelper.checkRankChange(
      previousRanksMap: _previousRanks,
      key: widget.market,
      currentRank: widget.rank,
    )) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ”¥ HOT ìƒíƒœ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹ ì‹œ 10ì´ˆê°„ ìœ ì§€)
  bool _checkIfHot() {
    final now = DateTime.now();
    
    // 1. ê¸°ì¡´ HOT ìƒíƒœ ì²´í¬ (10ì´ˆ ìœ ì§€)
    if (_hotMarkets.containsKey(widget.market)) {
      final hotStartTime = _hotMarkets[widget.market]!;
      if (now.difference(hotStartTime).inSeconds <= 20) {
        return true; // ì•„ì§ HOT ìœ ì§€
      } else {
        _hotMarkets.remove(widget.market); // ì‹œê°„ ì§€ë‚˜ë©´ ì œê±°
      }
    }
    
    // 2. ìƒˆë¡œìš´ HOT ì¡°ê±´ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹)
    final previousRank = _previousRanks[widget.market];
    if (previousRank != null && previousRank - widget.rank >= 5) {
      _hotMarkets[widget.market] = now; // HOT ì‹œì‘ ê¸°ë¡
      return true;
    }
    
    return false;
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  // ğŸš€ ë³€ë™ë¥  í¬ë§·íŒ… (ìƒ‰ìƒ í¬í•¨)
  String _formatChangePercent(double changePercent) {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }

  // ğŸš€ ë³€ë™ë¥ ì— ë”°ë¥¸ ìƒ‰ìƒ
  Color _getChangeColor() {
    if (widget.changePercent > 0) {
      return Colors.green; // ğŸŸ¢ ê¸‰ë“± - ì´ˆë¡
    } else if (widget.changePercent < 0) {
      return Colors.red; // ğŸ”´ ê¸‰ë½ - ë¹¨ê°•
    } else {
      return Colors.grey; // âšª ë³€ë™ ì—†ìŒ - íšŒìƒ‰
    }
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final changeColor = _getChangeColor();
    
    // ğŸ”¥ HOT ìƒíƒœ ì²´í¬
    final isHot = _checkIfHot();
    
    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank), // âœ… ê³µí†µ í•¨ìˆ˜
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„: flex 25 (í™•ì¥ ê°€ëŠ¥)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.market), // âœ… ê³µí†µ í•¨ìˆ˜
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜ (ì‹¤ì‹œê°„ ê³„ì‚°)
                    if (TileCommon.buildHotIcon(isHot) case final hotIcon?) 
                      hotIcon, // âœ… ê³µí†µ í•¨ìˆ˜
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''), // í•­ìƒ í‹°ì»¤ëŠ” í‘œì‹œ
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
                // âœ… ì´ˆë¡ìƒ‰ ì  ì œê±°ë¨
              ],
            ),
            flex: 25,
          ),
          
          // ğŸš€ ë³€ë™ë¥  ë¶€ë¶„: flex 30
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  _formatChangePercent(widget.changePercent),
                  style: TextStyle(
                    color: changeColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatPrice(widget.currentPrice)}ì›', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬ ì¶”ê°€)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    Widget finalWidget = blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: changeColor, // SurgeëŠ” ë³€ë™ë¥  ìƒ‰ìƒìœ¼ë¡œ
          )
        : cardWidget;
    
    // ğŸ¨ ì¡°ê±´ë¶€ ê¹œë¹¡ì„ íš¨ê³¼ (ì„¤ì • í™•ì¸)
    if (!_shouldBlink && widget.enableBlinkAnimation && blinkEnabled) {
      finalWidget = BlinkAnimationHelper.wrapWithConditionalBlink(
        child: cardWidget,
        enableBlinkAnimation: widget.enableBlinkAnimation,
        theme: theme,
      );
    }
    
    return finalWidget;
  }
}\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart'; // appSettingsProvider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // AmountDisplayMode ì¶”ê°€
import '../../shared/widgets/coin_logo_provider.dart'; // ì½”ì¸ ë¡œê³  í”„ë¡œë°”ì´ë”
import '../../shared/widgets/amount_display_widget.dart'; // ğŸ’° ë¨¸ë‹ˆì•„ì´ì½˜ ìœ„ì ¯
import '../../shared/utils/tile_common.dart'; // ğŸ¯ ê³µí†µ ìœ í‹¸ë¦¬í‹°
import '../../shared/utils/blink_animation_mixin.dart'; // âœ¨ ë°˜ì§ì„ í—¬í¼
import '../../shared/utils/amount_formatter.dart'; // ğŸ’° í¬ë§·í„° ìœ í‹¸ë¦¬í‹°

// ğŸ¯ ìˆœìœ„ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (marketë³„ ì´ì „ ìˆœìœ„ ì €ì¥)
final Map<String, int> _previousRanks = {};

// ğŸ”¥ HOT ë§ˆì¼“ ì¶”ì ì„ ìœ„í•œ ì „ì—­ Map (marketë³„ HOT ì‹œì‘ ì‹œê°„)
final Map<String, DateTime> _hotMarkets = {};

class VolumeTile extends ConsumerStatefulWidget {
  final String market;
  final double totalVolume;
  final int rank; // ğŸ¯ ìˆœìœ„ (1ìœ„ë¶€í„°)
  final bool showHotIcon; // ğŸš€ ê¸‰ìƒìŠ¹ í‘œì‹œ ì—¬ë¶€
  final bool enableBlinkAnimation; // ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜ ì—¬ë¶€
  
  const VolumeTile({
    Key? key, 
    required this.market,
    required this.totalVolume,
    required this.rank,
    this.showHotIcon = false,
    this.enableBlinkAnimation = false,
  }) : super(key: key);

  @override
  ConsumerState<VolumeTile> createState() => _VolumeTileState();
}

class _VolumeTileState extends ConsumerState<VolumeTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(VolumeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    // ğŸ¯ ìˆœìœ„ ë³€í™” ê°ì§€ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
    if (BlinkAnimationHelper.checkRankChange(
      previousRanksMap: _previousRanks,
      key: widget.market,
      currentRank: widget.rank,
    )) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ”¥ HOT ìƒíƒœ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹ ì‹œ 10ì´ˆê°„ ìœ ì§€)
  bool _checkIfHot() {
    final now = DateTime.now();
    
    // 1. ê¸°ì¡´ HOT ìƒíƒœ ì²´í¬ (10ì´ˆ ìœ ì§€)
    if (_hotMarkets.containsKey(widget.market)) {
      final hotStartTime = _hotMarkets[widget.market]!;
      if (now.difference(hotStartTime).inSeconds <= 20) {
        return true; // ì•„ì§ HOT ìœ ì§€
      } else {
        _hotMarkets.remove(widget.market); // ì‹œê°„ ì§€ë‚˜ë©´ ì œê±°
      }
    }
    
    // 2. ìƒˆë¡œìš´ HOT ì¡°ê±´ ì²´í¬ (5ê³„ë‹¨ ì´ìƒ ìƒìŠ¹)
    final previousRank = _previousRanks[widget.market];
    if (previousRank != null && previousRank - widget.rank >= 5) {
      _hotMarkets[widget.market] = now; // HOT ì‹œì‘ ê¸°ë¡
      return true;
    }
    
    return false;
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    
    // ğŸ”¥ HOT ìƒíƒœ ì²´í¬
    final isHot = _checkIfHot();
    
    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank), // âœ… ê³µí†µ í•¨ìˆ˜
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„: flex 25
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.market), // âœ… ê³µí†µ í•¨ìˆ˜
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜ (ì‹¤ì‹œê°„ ê³„ì‚°)
                    if (TileCommon.buildHotIcon(isHot) case final hotIcon?) 
                      hotIcon, // âœ… ê³µí†µ í•¨ìˆ˜
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''), // í•­ìƒ í‹°ì»¤ëŠ” í‘œì‹œ
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸ’° ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 30 - ì„¸ë¡œ ê°€ìš´ë° ì •ë ¬ë¡œ ë³€ê²½!
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: Consumer(
                builder: (context, ref, child) {
                  final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
                  
                  return amountDisplayMode == AmountDisplayMode.icon
                      ? AmountDisplayWidget( // âœ… ë¨¸ë‹ˆì•„ì´ì½˜ ëª¨ë“œ
                          totalAmount: widget.totalVolume,
                          isBuy: true, // Volumeì€ ì¤‘ë¦½ì  ìƒ‰ìƒ
                          fontSize: 15,
                          fontWeight: FontWeight.w600,
                        )
                      : Text( // âœ… ìˆ«ì ëª¨ë“œ (ê¸°ì¡´ ë°©ì‹)
                          AmountFormatter.formatVolume(widget.totalVolume), // âœ… ê³µí†µ í¬ë§·í„°
                          style: TextStyle(
                            color: onSurface,
                            fontSize: 15,
                            fontWeight: FontWeight.w600,
                          ),
                          overflow: TextOverflow.ellipsis,
                          maxLines: 1,
                        );
                },
              ),
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (ì„¤ì • ì²´í¬ ì¶”ê°€)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    Widget finalWidget = blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: Colors.amber, // Volumeì€ ì•°ë²„ ìƒ‰ìƒ
          )
        : cardWidget;
    
    // ğŸ¨ ì¡°ê±´ë¶€ ê¹œë¹¡ì„ íš¨ê³¼ (ì„¤ì • í™•ì¸)
    if (!_shouldBlink && widget.enableBlinkAnimation && blinkEnabled) {
      finalWidget = BlinkAnimationHelper.wrapWithConditionalBlink(
        child: cardWidget,
        enableBlinkAnimation: widget.enableBlinkAnimation,
        theme: theme,
      );
    }
    
    return finalWidget;
  }
}\n\n// ====== lib/presentation/widgets/signal_tile.dart ======\n
// lib/presentation/widgets/signal_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/signal.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';

// ğŸ¯ ì¤‘ë³µ ë°˜ì§ì„ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ Set
final Set<String> _blinkedSignals = {};

/// ğŸš€ SignalTile V4.1 - Clean UI (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
class SignalTile extends ConsumerStatefulWidget {
  final Signal signal;
  final bool showOnlineMetrics; // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í‘œì‹œ ì˜µì…˜

  const SignalTile({
    super.key, 
    required this.signal,
    this.showOnlineMetrics = true, // ê¸°ë³¸ê°’: í‘œì‹œ
  });

  @override
  ConsumerState<SignalTile> createState() => _SignalTileState();
}

class _SignalTileState extends ConsumerState<SignalTile>
    with SingleTickerProviderStateMixin {
  
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _shouldBlink = false;

  @override
  void initState() {
    super.initState();
    // âœ¨ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™” (ê¸°ì¡´ ë°©ì‹)
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 800), // Signalì€ ì¡°ê¸ˆ ë” ê¸¸ê²Œ
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.2).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );

    _checkNewSignal();
  }

  /// ğŸ¯ ìƒˆë¡œìš´ ì‹œê·¸ë„ ê°ì§€ ë° ë°˜ì§ì„ ì²˜ë¦¬ (í—¬í¼ í´ë˜ìŠ¤ ì‚¬ìš©)
  void _checkNewSignal() {
    final signalKey = '${widget.signal.market}_${widget.signal.detectedAt.millisecondsSinceEpoch}';
    
    if (BlinkAnimationHelper.checkNewSignal(
      blinkedSignalsSet: _blinkedSignals,
      detectedAt: widget.signal.detectedAt,
      signalKey: signalKey,
      maxAgeSeconds: 10,
    )) {
      _startBlink();
    }
  }

  /// ë°˜ì§ì„ ì‹œì‘ (ì„¤ì • ì—°ë™ ì¶”ê°€)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return; // ğŸ¯ ì„¤ì • ì²´í¬ ì¶”ê°€!
    
    _shouldBlink = true;
    _blinkController.forward().then((_) {
      _blinkController.reverse().then((_) {
        if (mounted) {
          setState(() {
            _shouldBlink = false;
          });
        }
      });
    });
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ ì¹©
  Widget? _buildConfidenceChip() {
    final confidence = widget.signal.confidence;
    if (confidence == null) return null;

    Color color;
    if (confidence >= 0.8) {
      color = Colors.green;
    } else if (confidence >= 0.6) {
      color = Colors.amber;
    } else {
      color = Colors.orange;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        '${(confidence * 100).toStringAsFixed(0)}%',
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ìƒì„±
  List<Widget> _buildOnlineIndicatorChips() {
    if (!widget.showOnlineMetrics || !widget.signal.hasOnlineMetrics) {
      return [];
    }

    final indicators = widget.signal.onlineIndicators!;
    final chips = <Widget>[];

    // RSI ì¹©
    if (indicators.rsi != null) {
      Color rsiColor;
      String rsiText;
      
      if (indicators.rsi! >= 70) {
        rsiColor = Colors.red;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else if (indicators.rsi! <= 30) {
        rsiColor = Colors.blue;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      } else {
        rsiColor = Colors.grey[600]!;
        rsiText = 'RSI${indicators.rsi!.toStringAsFixed(0)}';
      }

      chips.add(_buildIndicatorChip(rsiText, rsiColor));
    }

    // MACD ì¹©
    if (indicators.macd != null && indicators.macdSignal != null) {
      final isBullish = indicators.macd! > indicators.macdSignal!;
      final macdColor = isBullish ? Colors.green : Colors.red;
      final macdText = isBullish ? 'M+' : 'M-';

      chips.add(_buildIndicatorChip(macdText, macdColor));
    }

    return chips;
  }

  /// ğŸ†• V4.1 ì§€í‘œ ì¹© ìœ„ì ¯
  Widget _buildIndicatorChip(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Text(
        text,
        style: TextStyle(
          fontSize: 9,
          color: color,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„°
  Widget? _buildDivergenceIndicator() {
    final divergence = widget.signal.divergence;
    if (divergence == null || (!divergence.isBullish && !divergence.isBearish)) {
      return null;
    }

    Color color;
    IconData icon;
    
    if (divergence.isBullish) {
      color = Colors.green;
      icon = Icons.trending_up;
    } else {
      color = Colors.red;
      icon = Icons.trending_down;
    }

    return Container(
      padding: const EdgeInsets.all(3),
      margin: const EdgeInsets.only(right: 4),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: color.withValues(alpha: 0.15),
        border: Border.all(color: color.withValues(alpha: 0.4), width: 0.5),
      ),
      child: Icon(
        icon,
        size: 10,
        color: color,
      ),
    );
  }

  /// ğŸ†• V4.1 ëª¨ë“  ë°°ì§€ë“¤ì„ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€í•˜ë©° ë°°ì¹˜
  Widget _buildBadgeRow() {
    final badges = <Widget>[];
    
    // ì‹ ë¢°ë„ ì¹© ì¶”ê°€
    final confidenceChip = _buildConfidenceChip();
    if (confidenceChip != null) {
      badges.add(confidenceChip);
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ì¹©ë“¤ ì¶”ê°€
    badges.addAll(_buildOnlineIndicatorChips());
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ì¸ë””ì¼€ì´í„° ì¶”ê°€
    final divergenceIndicator = _buildDivergenceIndicator();
    if (divergenceIndicator != null) {
      badges.add(divergenceIndicator);
    }

    if (badges.isEmpty) {
      return const SizedBox.shrink();
    }

    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Row(
        children: badges,
      ),
    );
  }

  /// ğŸ†• V4.1 íŒ¨í„´ ìƒ‰ìƒ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ì‹œ ë” ìƒë™ê°ìˆê²Œ)
  Color _getEnhancedPatternColor() {
    Color baseColor;
    
    switch (widget.signal.patternType) {
      case PatternType.surge:
        baseColor = Colors.red;
        break;
      case PatternType.flashFire:
        baseColor = Colors.orange;
        break;
      case PatternType.stackUp:
        baseColor = Colors.amber;
        break;
      case PatternType.stealthIn:
        baseColor = Colors.green;
        break;
      case PatternType.blackHole:
        baseColor = Colors.purple;
        break;
      case PatternType.reboundShot:
        baseColor = Colors.blue;
        break;
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œê°€ ìˆìœ¼ë©´ ë” ì„ ëª…í•˜ê²Œ
    if (widget.signal.hasOnlineMetrics) {
      return baseColor;
    } else {
      return baseColor.withValues(alpha: 0.7);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;

    // ğŸ¯ í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„± (V4.1 Clean ë²„ì „)
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 13
          FlexChild.expanded(
            Text(
              _timeFormat.format(widget.signal.detectedAt),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 13,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„: ê³ ì • í¬ê¸° (V4.1 íŒ¨í„´ ìƒ‰ìƒ í…Œë‘ë¦¬ ì¶”ê°€)
          FlexChild.fixed(
            Container(
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: _getEnhancedPatternColor(),
                  width: 1.5,
                ),
              ),
              child: CoinLogoProvider.buildCoinLogo(
                ticker: widget.signal.market.replaceFirst('KRW-', ''),
                radius: 14,
              ),
            ),
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸª™ ì½”ì¸ëª… + ë°°ì§€ë“¤: flex 24 (ğŸ†• Clean ë²„ì „)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // ì²« ë²ˆì§¸ ì¤„: ì½”ì¸ëª… + NEW ë±ƒì§€
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.signal.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // NEW ë±ƒì§€ (í•„ìš”í•œ ê²½ìš°)
                    if (TileCommon.buildNewBadge(widget.signal.detectedAt) case final badge?) 
                      badge,
                  ],
                ),
                
                const SizedBox(height: 3),
                
                // ğŸ†• ë‘ ë²ˆì§¸ ì¤„: ëª¨ë“  ë°°ì§€ë“¤ (ì˜¤ë²„í”Œë¡œìš° ë°©ì§€)
                _buildBadgeRow(),
              ],
            ),
            flex: 24,
          ),

          // ğŸ’µ ê°€ê²© + ë³€í™”ìœ¨: flex 18 (ì‹ ë¢°ë„ ì¹© ì œê±°ë¨)
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(widget.signal.currentPrice)}ì›',
                  style: TextStyle(color: onSurface, fontSize: 13),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  TileCommon.formatChangePercent(widget.signal.changePercent),
                  style: TextStyle(
                    color: TileCommon.getChangeColor(widget.signal.changePercent),
                    fontSize: 12,
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 18,
          ),

          const FlexChild.fixed(SizedBox(width: 8)),

          // ğŸ’° ê±°ë˜ëŒ€ê¸ˆ: flex 18 (AmountDisplayWidget ì‚¬ìš©)
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: widget.signal.tradeAmount,
                isBuy: widget.signal.changePercent >= 0,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            flex: 18,
          ),
        ],
      ),
    );

    // ğŸ¯ ë°˜ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì ìš© (V4.1 íŒ¨í„´ ìƒ‰ìƒ ì—°ë™)
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    return blinkEnabled 
        ? BlinkAnimationHelper.wrapWithBlinkEffect(
            child: cardWidget,
            shouldBlink: _shouldBlink,
            blinkAnimation: _blinkAnimation,
            blinkColor: _getEnhancedPatternColor(), // ğŸ†• V4.1 ë™ì  ìƒ‰ìƒ
          )
        : cardWidget;
  }
}

/// ğŸ†• V4.1 í™•ì¥: AmountDisplayWidgetì— highlightColor íŒŒë¼ë¯¸í„° ì¶”ê°€ìš© í™•ì¥
/// (ì‹¤ì œë¡œëŠ” AmountDisplayWidget í´ë˜ìŠ¤ì— ì¶”ê°€í•´ì•¼ í•¨)
extension AmountDisplayWidgetV41 on AmountDisplayWidget {
  /// V4.1 ê°•ì¡° ìƒ‰ìƒì´ ì ìš©ëœ ìœ„ì ¯ ìƒì„±
  static Widget withHighlight({
    required double totalAmount,
    required bool isBuy,
    double fontSize = 14,
    FontWeight fontWeight = FontWeight.w600,
    Color? highlightColor,
  }) {
    return Container(
      padding: highlightColor != null 
          ? const EdgeInsets.symmetric(horizontal: 4, vertical: 1)
          : null,
      decoration: highlightColor != null
          ? BoxDecoration(
              borderRadius: BorderRadius.circular(3),
              color: highlightColor.withValues(alpha: 0.1),
              border: Border.all(color: highlightColor.withValues(alpha: 0.3), width: 0.5),
            )
          : null,
      child: AmountDisplayWidget(
        totalAmount: totalAmount,
        isBuy: isBuy,
        fontSize: fontSize,
        fontWeight: fontWeight,
      ),
    );
  }
}