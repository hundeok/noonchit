\n\n// ====== lib/core/di/trade_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../services/hive_service.dart';          // ğŸ¯ NEW
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider; // ğŸ†• WebSocket import
import '../../data/datasources/trade_cache_ds.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// ğŸ†• ë§ˆì¼“ ì •ë³´ í´ë˜ìŠ¤
class MarketInfo {
  final String market;      // KRW-BTC
  final String koreanName;  // ë¹„íŠ¸ì½”ì¸
  final String englishName; // Bitcoin

  const MarketInfo({
    required this.market,
    required this.koreanName,
    required this.englishName,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      market: json['market'] ?? '',
      koreanName: json['korean_name'] ?? '',
      englishName: json['english_name'] ?? '',
    );
  }
}

/// 0) REST API client
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient(
      apiKey: AppConfig.apiKey,
      apiSecret: AppConfig.apiSecret,
    ));

/// ğŸ¯ HiveService Provider (main.dartì—ì„œ override)
final hiveServiceProvider = Provider<HiveService>((ref) {
  throw UnimplementedError('HiveService must be provided via main.dart override');
});

/// ğŸ†• ë§ˆì¼“ ì •ë³´ Provider (1ì‹œê°„ ìºì‹œ + market_warning í•„í„°ë§)
final marketInfoProvider = FutureProvider<Map<String, MarketInfo>>((ref) async {
  final client = ref.read(apiClientProvider);
  
  try {
    final result = await client.request<List<dynamic>>(
      method: 'GET',
      path: '${AppConfig.upbitRestBase}/market/all',
      cacheDur: const Duration(hours: 1), // 1ì‹œê°„ ìºì‹œ
    );
    
    return result.when(
      ok: (markets) {
        final Map<String, MarketInfo> marketMap = {};
        int filteredCount = 0;
        
        for (final market in markets) {
          if (market is Map<String, dynamic>) {
            // ğŸ”’ market_warning í•„í„°ë§ (ì—…ë¹„íŠ¸ ë°±ì„œ ì¤€ìˆ˜)
            final warning = market['market_warning'] as String?;
            if (warning == 'CAUTION') {
              filteredCount++;
              if (AppConfig.enableTradeLog) {
                log.d('Filtered CAUTION market: ${market['market']}');
              }
              continue; // CAUTION ì¢…ëª©ì€ ê±´ë„ˆë›°ê¸°
            }
            
            final info = MarketInfo.fromJson(market);
            marketMap[info.market] = info;
          }
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('ë§ˆì¼“ ì •ë³´ ë¡œë“œë¨: ${marketMap.length}ê°œ (CAUTION í•„í„°ë§: $filteredCountê°œ)');
        }
        return marketMap;
      },
      err: (error) {
        log.w('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: $error');
        return <String, MarketInfo>{};
      },
    );
  } catch (e) {
    log.e('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e');
    return <String, MarketInfo>{};
  }
});

/// 1) KRW market list (top 199 by volume + essentials) + market_warning í•„í„°ë§
final marketsProvider = FutureProvider<List<String>>((ref) async {
  final client = ref.read(apiClientProvider);

  // fetch all markets (cache 5 minutes)
  final marketResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/market/all',
    cacheDur: const Duration(minutes: 5),
  );
  final allMarkets =
      marketResult.when(ok: (v) => v, err: (_) => <dynamic>[]);

  // ğŸ”’ filter KRW markets + market_warning í•„í„°ë§ (ì—…ë¹„íŠ¸ ë°±ì„œ ì¤€ìˆ˜)
  final krwMarkets = <String>[];
  int cautionCount = 0;
  
  for (final market in allMarkets.whereType<Map<String, dynamic>>()) {
    final marketCode = market['market'] as String?;
    if (marketCode != null && marketCode.startsWith('KRW-')) {
      // CAUTION ì¢…ëª©ì€ WebSocket êµ¬ë…ì—ì„œ ì œì™¸
      final warning = market['market_warning'] as String?;
      if (warning == 'CAUTION') {
        cautionCount++;
        continue;
      }
      krwMarkets.add(marketCode);
    }
  }
  
  if (AppConfig.enableTradeLog && cautionCount > 0) {
    log.i('CAUTION ì¢…ëª© $cautionCountê°œ ì œì™¸ë¨ (WebSocket êµ¬ë… ì•ˆì „ì„±)');
  }

  // pick top by 24h volume (or acc_trade_price when outside 9â€“10am)
  final now = DateTime.now();
  final isEarly = now.hour >= 9 && now.hour < 10;
  final key = isEarly ? 'acc_trade_price_24h' : 'acc_trade_price';

  // real-time ticker lookup (no cache)
  final tickerResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/ticker',
    query: {'markets': krwMarkets.join(',')},
    cacheDur: null,
  );
  final tickers = tickerResult
      .when(ok: (v) => v, err: (_) => <dynamic>[])  
      .whereType<Map<String, dynamic>>()
      .toList()
    ..sort((a, b) =>
        ((b[key] as num?) ?? 0).compareTo((a[key] as num?) ?? 0));

  // â”€â”€â”€ WS êµ¬ë… ì¢…ëª© ìŠ¬ë¼ì´ì‹± ë¡œì§ (essentials ìš°ì„  + ì¤‘ë³µ ì œê±° í›„ ìƒìœ„ 199ê°œ) â”€â”€â”€
  const essentials = ['KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL'];
  final sortedMarkets = tickers.map((e) => e['market'] as String).toList();
  final combined = [
    ...essentials.where((market) => krwMarkets.contains(market)), // ğŸ”’ essentialsë„ CAUTION ì²´í¬
    ...sortedMarkets.where((m) => !essentials.contains(m)),
  ];
  return combined.take(199).toList();
});

final cacheDSProvider = Provider<TradeCacheDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return TradeCacheDataSource(hive.tradeBox);
});

final remoteDSProvider = Provider((ref) => TradeRemoteDataSource(
      ref.read(wsClientProvider), // ğŸ”„ websocket_providerì—ì„œ import
      ref.read(signalBusProvider),
      useTestData: AppConfig.useTestDataInDev,
    ));

final repoProvider = Provider((ref) => TradeRepositoryImpl(
      ref.read(remoteDSProvider),
      ref.read(cacheDSProvider),
    ));

final usecaseProvider = Provider((ref) => TradeUsecase(ref.read(repoProvider)));

/// 3) Filter state
final tradeFilterIndexProvider = StateProvider<int>((_) => 0);
final tradeFilterThresholdProvider = StateProvider<double>((ref) =>
    AppConfig.tradeFilters.firstWhere(
      (f) => f >= 20000000,
      orElse: () => AppConfig.tradeFilters.last,
    ));

/// 4) Filtered trades stream
final tradeListProvider = StreamProvider.autoDispose<List<Trade>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ threshold ê°’ê³¼ marketsë¥¼ ì½ì–´ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  final threshold = ref.watch(tradeFilterThresholdProvider);
  final markets = await ref.watch(marketsProvider.future);
  final repository = ref.read(repoProvider);

  // threshold ë³€ê²½ ì‹œ Repositoryì—ë„ ì—…ë°ì´íŠ¸
  ref.listen<double>(tradeFilterThresholdProvider, (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i(
          'Threshold changed: ${prev.toStringAsFixed(0)} â†’ ${next.toStringAsFixed(0)}',
        );
      }
      repository.updateThreshold(next);
    }
  });

  // ì‹¤ì œ í•„í„°ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchFilteredTrades(threshold, markets);
});

/// 5) Aggregated trades stream
final aggregatedTradeProvider = StreamProvider.autoDispose<Trade>((ref) {
  // Prevent dispose on background
  ref.keepAlive();
  final repository = ref.read(repoProvider);
  return repository.watchAggregatedTrades();
});

/// 6) Helper to change threshold & index
final tradeThresholdController = Provider((ref) => TradeThresholdController(ref));

class TradeThresholdController {
  final Ref ref;
  TradeThresholdController(this.ref);

  void updateThreshold(double threshold, int index) {
    final options =
        AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    if (index < 0 || index >= options.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid threshold index: $index');
      return;
    }
    ref.read(tradeFilterThresholdProvider.notifier).state = threshold;
    ref.read(tradeFilterIndexProvider.notifier).state = index;
    AppConfig.updateFilters(options);
    if (AppConfig.enableTradeLog) {
      log.i(
        'Threshold updated: ${threshold.toStringAsFixed(0)} (index: $index)',
      );
    }
  }

  double get currentThreshold => ref.read(tradeFilterThresholdProvider);
  int get currentIndex => ref.read(tradeFilterIndexProvider);
  List<double> get availableThresholds =>
      AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
}\n\n// ====== lib/core/di/websocket_provider.dart ======\n
// lib/core/di/websocket_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../network/websocket/trade_ws_client.dart';
import '../network/websocket/base_ws_client.dart'; // WsStatus enum
import '../utils/logger.dart';
import '../bridge/signal_bus.dart';

/// ğŸ†• WebSocket ìƒì„¸ í†µê³„ í´ë˜ìŠ¤ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸° ì¤‘ì‹¬)
class WebSocketStats {
  final DateTime? connectTime;
  final int reconnectCount;
  final int totalSessions;
  final Duration cumulativeConnectTime;
  final int connectionAttempts;
  final DateTime? lastStateChangeTime;
  
  const WebSocketStats({
    this.connectTime,
    this.reconnectCount = 0,
    this.totalSessions = 0,
    this.cumulativeConnectTime = Duration.zero,
    this.connectionAttempts = 0,
    this.lastStateChangeTime,
  });

  /// ì—°ê²° ì§€ì† ì‹œê°„ ê³„ì‚°
  Duration? get uptime {
    if (connectTime == null) return null;
    return DateTime.now().difference(connectTime!);
  }

  /// í‰ê·  ì—°ê²° ì§€ì† ì‹œê°„
  Duration get averageSessionDuration {
    if (totalSessions == 0) return Duration.zero;
    return Duration(
      milliseconds: cumulativeConnectTime.inMilliseconds ~/ totalSessions,
    );
  }

  /// ì—°ê²° ì„±ê³µë¥  (%)
  double get connectionSuccessRate {
    if (connectionAttempts == 0) return 0.0;
    return (totalSessions / connectionAttempts) * 100;
  }
}

/// ğŸ”„ SignalBus Provider (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});

/// ğŸ†• WebSocket ìƒíƒœ ê´€ë¦¬
final wsStatusProvider = StateProvider<WsStatus>((ref) => WsStatus.disconnected);

/// ğŸ†• WebSocket í†µê³„ ê´€ë¦¬ (ê°œë³„ Providerë“¤ - ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
final wsConnectTimeProvider = StateProvider<DateTime?>((ref) => null);
final wsReconnectCountProvider = StateProvider<int>((ref) => 0);
final wsTotalSessionsProvider = StateProvider<int>((ref) => 0);
final wsCumulativeConnectTimeProvider = StateProvider<Duration>((ref) => Duration.zero);
final wsConnectionAttemptsProvider = StateProvider<int>((ref) => 0);
final wsLastStateChangeTimeProvider = StateProvider<DateTime?>((ref) => null);

/// ğŸ†• í†µí•© WebSocket í†µê³„ Provider (ê°œë³„ Providerë“¤ì„ ì¡°í•©)
final wsStatsProvider = Provider<WebSocketStats>((ref) {
  final connectTime = ref.watch(wsConnectTimeProvider);
  final reconnectCount = ref.watch(wsReconnectCountProvider);
  final totalSessions = ref.watch(wsTotalSessionsProvider);
  final cumulativeConnectTime = ref.watch(wsCumulativeConnectTimeProvider);
  final connectionAttempts = ref.watch(wsConnectionAttemptsProvider);
  final lastStateChangeTime = ref.watch(wsLastStateChangeTimeProvider);

  return WebSocketStats(
    connectTime: connectTime,
    reconnectCount: reconnectCount,
    totalSessions: totalSessions,
    cumulativeConnectTime: cumulativeConnectTime,
    connectionAttempts: connectionAttempts,
    lastStateChangeTime: lastStateChangeTime,
  );
});

/// ğŸ†• WebSocket í´ë¼ì´ì–¸íŠ¸ (ê¸°ë³¸ - ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
final wsClientProvider = Provider<TradeWsClient>((ref) {
  return TradeWsClient(
    onStatusChange: (status) {
      final now = DateTime.now();
      ref.read(wsStatusProvider.notifier).state = status;
      ref.read(wsLastStateChangeTimeProvider.notifier).state = now;
      
      // ê°„ë‹¨í•œ í†µê³„ ì—…ë°ì´íŠ¸ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
      switch (status) {
        case WsStatus.connecting:
          // ì—°ê²° ì‹œë„ ì¹´ìš´íŠ¸
          final attempts = ref.read(wsConnectionAttemptsProvider);
          ref.read(wsConnectionAttemptsProvider.notifier).state = attempts + 1;
          break;
          
        case WsStatus.connected:
          // ì—°ê²° ì„±ê³µ
          ref.read(wsConnectTimeProvider.notifier).state = now;
          
          // ì´ ì„¸ì…˜ ìˆ˜ ì¦ê°€
          final sessions = ref.read(wsTotalSessionsProvider);
          ref.read(wsTotalSessionsProvider.notifier).state = sessions + 1;
          break;
          
        case WsStatus.reconnecting:
          // ì¬ì—°ê²° ì¹´ìš´íŠ¸
          final currentCount = ref.read(wsReconnectCountProvider);
          ref.read(wsReconnectCountProvider.notifier).state = currentCount + 1;
          break;
          
        case WsStatus.disconnected:
          // ì—°ê²° ì¢…ë£Œ ì‹œ ëˆ„ì  ì‹œê°„ ì—…ë°ì´íŠ¸
          final connectTime = ref.read(wsConnectTimeProvider);
          if (connectTime != null) {
            final sessionDuration = now.difference(connectTime);
            final cumulative = ref.read(wsCumulativeConnectTimeProvider);
            ref.read(wsCumulativeConnectTimeProvider.notifier).state = 
                cumulative + sessionDuration;
          }
          ref.read(wsConnectTimeProvider.notifier).state = null;
          break;
          
        default:
          break;
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('WebSocket status changed: $status');
      }
    },
  );
});\n\n// ====== lib/core/di/signal_provider.dart ======\n
// lib/core/di/signal_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import '../utils/pattern_detector.dart';
import '../utils/pattern_config.dart';
import '../utils/advanced_metrics.dart';
import 'trade_provider.dart'; // ì „ì²´ import (app_providers.dart íŒ¨í„´)
import '../../data/repositories/signal_repository_impl.dart';
import '../../domain/entities/signal.dart';
import '../../domain/repositories/signal_repository.dart';
import '../../domain/usecases/signal_usecase.dart';

// ==========================================================================
// ğŸš€ V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì… êµ¬ì¡°
// ==========================================================================

/// AdvancedMetrics Provider (ì˜¨ë¼ì¸ ê³„ì‚°ê¸° ê´€ë¦¬)
final advancedMetricsProvider = Provider<AdvancedMetrics>((ref) {
  final metrics = AdvancedMetrics(
    maxGap: const Duration(seconds: 10),     // ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ì‹œê°„
    staleThreshold: const Duration(seconds: 30), // ë°ì´í„° ë§Œë£Œ ì‹œê°„
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() {
    metrics.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ AdvancedMetrics disposed - ì˜¨ë¼ì¸ ì§€í‘œ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return metrics;
});

/// PatternConfig Provider (ìƒíƒœ ê´€ë¦¬ ê°€ëŠ¥)
final patternConfigProvider = StateNotifierProvider<PatternConfigNotifier, PatternConfig>((ref) {
  return PatternConfigNotifier();
});

/// PatternDetector Provider (ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì…)
final patternDetectorProvider = Provider<PatternDetector>((ref) {
  final config = ref.watch(patternConfigProvider);
  final metrics = ref.watch(advancedMetricsProvider);
  
  final detector = PatternDetector(
    config: config,
    metrics: metrics,
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() {
    detector.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ PatternDetector disposed - ì¿¨ë‹¤ìš´ ë° ì§€í‘œ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return detector;
});

/// Signal Repository Provider (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì˜ì¡´ì„± ì£¼ì…)
final signalRepoProvider = Provider<SignalRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider);
  final patternDetector = ref.watch(patternDetectorProvider);
  final patternConfig = ref.watch(patternConfigProvider);
  
  final repository = SignalRepositoryImpl(
    remoteDS,
    patternDetector: patternDetector,
    patternConfig: patternConfig,
  );
  
  // Provider disposeì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ SignalRepository V4.1 disposed - ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
    }
  });
  
  return repository;
});

/// Signal UseCase Provider
final signalUsecaseProvider = Provider<SignalUseCase>((ref) {
  final repository = ref.read(signalRepoProvider);
  return SignalUseCase(repository);
});

// ==========================================================================
// ğŸ¯ ìƒíƒœ ê´€ë¦¬ Providers (V4.1 í™•ì¥)
// ==========================================================================

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ ì¸ë±ìŠ¤ (ìŠ¬ë¼ì´ë” ìœ„ì¹˜)
final signalPatternIndexProvider = StateProvider<int>((_) => 0);

/// í˜„ì¬ ì„ íƒëœ íŒ¨í„´ íƒ€ì…
final signalPatternTypeProvider = StateProvider<PatternType>((ref) {
  final index = ref.watch(signalPatternIndexProvider);
  final patternName = AppConfig.getSignalPatternByIndex(index);
  
  // AppConfig íŒ¨í„´ëª…ì„ PatternTypeìœ¼ë¡œ ë³€í™˜
  switch (patternName) {
    case 'surge':
      return PatternType.surge;
    case 'flashFire':
      return PatternType.flashFire;
    case 'stackUp':
      return PatternType.stackUp;
    case 'stealthIn':
      return PatternType.stealthIn;
    case 'blackHole':
      return PatternType.blackHole;
    case 'reboundShot':
      return PatternType.reboundShot;
    default:
      return PatternType.surge; // ê¸°ë³¸ê°’
  }
});

/// íŒ¨í„´ë³„ ì„ê³„ê°’ ê´€ë¦¬ (V4.1 PatternConfig ê¸°ë°˜)
final signalThresholdProvider = StateProvider.family<double, PatternType>((ref, pattern) {
  final config = ref.watch(patternConfigProvider);
  return config.getConfigValue(pattern, 'priceChangePercent');
});

/// íŒ¨í„´ë³„ í™œì„±í™” ìƒíƒœ ê´€ë¦¬
final signalPatternEnabledProvider = StateProvider.family<bool, PatternType>((ref, pattern) => true);

/// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§
final onlineMetricsHealthProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final metrics = ref.watch(advancedMetricsProvider);
  
  yield* Stream.periodic(const Duration(seconds: 5), (_) {
    return metrics.getSystemHealth();
  });
});

/// ğŸ†• ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
final systemPerformanceProvider = StreamProvider.autoDispose<Map<String, dynamic>>((ref) async* {
  final repository = ref.watch(signalRepoProvider) as SignalRepositoryImpl;
  
  yield* repository.watchPerformanceMetrics();
});

// ==========================================================================
// ğŸ”¥ ìŠ¤íŠ¸ë¦¼ Providers (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
// ==========================================================================

/// í˜„ì¬ íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
final signalListProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ ì„ íƒëœ íŒ¨í„´ê³¼ ë§ˆì¼“ ì •ë³´ êµ¬ë…
  final patternType = ref.watch(signalPatternTypeProvider);
  final repository = ref.read(signalRepoProvider);

  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);

  // íŒ¨í„´ ë³€ê²½ ì‹œ ë¡œê·¸
  if (AppConfig.enableTradeLog) {
    log.i('ğŸ¯ Signal pattern changed to: ${patternType.displayName} (V4.1-Online)');
  }

  // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ëª¨ë‹ˆí„°ë§
  ref.listen(onlineMetricsHealthProvider, (prev, next) {
    if (next.hasValue) {
      final health = next.value!;
      final staleMarkets = health['staleMarkets'] ?? 0;
      if (staleMarkets > 0 && AppConfig.enableTradeLog) {
        log.w('âš ï¸ ì˜¨ë¼ì¸ ì§€í‘œ ê²½ê³ : $staleMarketsê°œ ë§ˆì¼“ ë°ì´í„° ë§Œë£Œ');
      }
    }
  });

  // ì„ê³„ê°’ ë³€ê²½ ê°ì§€ ë° Repository ì—…ë°ì´íŠ¸
  ref.listen<double>(signalThresholdProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“Š Signal threshold changed: ${patternType.displayName} ${prev.toStringAsFixed(2)} â†’ ${next.toStringAsFixed(2)}');
      }
      repository.updatePatternThreshold(patternType, next);
    }
  });

  // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ë³€ê²½ ê°ì§€
  ref.listen<bool>(signalPatternEnabledProvider(patternType), (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Signal pattern ${next ? "enabled" : "disabled"}: ${patternType.displayName}');
      }
      repository.setPatternEnabled(patternType, next);
    }
  });

  // íŒ¨í„´ë³„ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchSignalsByPattern(patternType, markets);
});

/// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ í†µí•© ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
final allSignalsProvider = StreamProvider.autoDispose<List<Signal>>((ref) async* {
  // Prevent dispose on background
  ref.keepAlive();
  
  final repository = ref.read(signalRepoProvider);
  
  // marketsProviderì—ì„œ ë°ì´í„° ë¡œë“œ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
  final markets = await ref.watch(marketsProvider.future);
  
  if (AppConfig.enableTradeLog) {
    log.i('ğŸš€ All signals stream initialized with ${markets.length} markets (V4.1-Online)');
  }
  
  yield* repository.watchAllSignals(markets);
});

// ==========================================================================
// ğŸ› ï¸ PatternConfig StateNotifier (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì„¤ì • ê´€ë¦¬)
// ==========================================================================

class PatternConfigNotifier extends StateNotifier<PatternConfig> {
  PatternConfigNotifier() : super(PatternConfig());

  /// íŠ¹ì • íŒ¨í„´ì˜ ì„¤ì •ê°’ ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    try {
      state.updatePatternConfig(pattern, key, value);
      // ìƒíƒœ ê°±ì‹ ì„ ìœ„í•´ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('âš™ï¸ Pattern config updated: ${pattern.name}.$key = $value');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Pattern config update failed: $e');
      }
    }
  }

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    try {
      switch (presetName.toLowerCase()) {
        case 'conservative':
          state.applyConservativePreset();
          break;
        case 'aggressive':
          state.applyAggressivePreset();
          break;
        case 'balanced':
          state.applyBalancedPreset();
          break;
        default:
          throw ArgumentError('Unknown preset: $presetName');
      }
      
      // ìƒíƒœ ê°±ì‹ 
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ¯ Pattern preset applied: $presetName');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Preset application failed: $e');
      }
    }
  }

  /// ì„¤ì • ê°€ì ¸ì˜¤ê¸°/ë‚´ë³´ë‚´ê¸°
  void importConfig(Map<String, dynamic> config) {
    try {
      state.importConfig(config);
      state = PatternConfig(customConfig: state.getAllPatternConfigs());
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ“¥ Pattern config imported successfully');
      }
    } catch (e) {
      if (AppConfig.enableTradeLog) {
        log.e('âŒ Config import failed: $e');
      }
    }
  }

  Map<String, dynamic> exportConfig() {
    return state.exportConfig();
  }

  /// ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  void resetToDefault([PatternType? pattern]) {
    state.resetToDefault(pattern);
    state = PatternConfig(customConfig: state.getAllPatternConfigs());
    
    if (AppConfig.enableTradeLog) {
      final message = pattern != null 
          ? 'Pattern ${pattern.name} reset to default'
          : 'All patterns reset to default';
      log.i('ğŸ”„ $message');
    }
  }
}

// ==========================================================================
// ğŸ® Signal íŒ¨í„´ ì»¨íŠ¸ë¡¤ëŸ¬ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥)
// ==========================================================================

final signalPatternController = Provider((ref) => SignalPatternControllerV4(ref));

class SignalPatternControllerV4 {
  final Ref ref;
  SignalPatternControllerV4(this.ref);

  /// íŒ¨í„´ ì¸ë±ìŠ¤ ë³€ê²½ (ìŠ¬ë¼ì´ë” ì´ë™)
  void updatePatternIndex(int index) {
    final maxIndex = AppConfig.signalPatterns.length - 1;
    if (index < 0 || index > maxIndex) {
      if (AppConfig.enableTradeLog) {
        log.w('âš ï¸ Invalid pattern index: $index (max: $maxIndex)');
      }
      return;
    }

    ref.read(signalPatternIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      final patternName = AppConfig.getSignalPatternByIndex(index);
      log.i('ğŸ¯ Pattern index updated: $index (${AppConfig.getSignalPatternName(patternName)})');
    }
  }

  /// í˜„ì¬ íŒ¨í„´ì˜ ì„ê³„ê°’ ë³€ê²½ (V4.1 PatternConfig ì—°ë™)
  void updateThreshold(double threshold) {
    final currentPattern = ref.read(signalPatternTypeProvider);
    
    // PatternConfigì—ë„ ë°˜ì˜
    ref.read(patternConfigProvider.notifier)
        .updatePatternConfig(currentPattern, 'priceChangePercent', threshold);
    
    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(signalThresholdProvider(currentPattern).notifier).state = threshold;
  }

  /// ğŸ†• V4.1 ê³ ê¸‰ ì„¤ì • ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    ref.read(patternConfigProvider.notifier).updatePatternConfig(pattern, key, value);
  }

  /// ğŸ†• í”„ë¦¬ì…‹ ì ìš©
  void applyPreset(String presetName) {
    ref.read(patternConfigProvider.notifier).applyPreset(presetName);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™”
  void setPatternEnabled(PatternType pattern, bool enabled) {
    ref.read(signalPatternEnabledProvider(pattern).notifier).state = enabled;
  }

  /// ì‹œê·¸ë„ ì´ˆê¸°í™”
  void clearSignals([PatternType? pattern]) {
    final repository = ref.read(signalRepoProvider);
    repository.clearSignals(pattern);
    
    if (AppConfig.enableTradeLog) {
      final message = pattern != null 
          ? 'Signals cleared for pattern: ${pattern.displayName}'
          : 'All signals cleared';
      log.i('ğŸ§¹ $message');
    }
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ë¦¬ì…‹
  void resetOnlineMetrics([String? market]) {
    final metrics = ref.read(advancedMetricsProvider);
    
    if (market != null) {
      metrics.resetMarket(market);
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Online metrics reset for market: $market');
      }
    } else {
      metrics.resetAll();
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ All online metrics reset');
      }
    }
  }

  /// ğŸ†• V4.1 ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth() async {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return await repository.getSystemHealth();
  }

  /// ğŸ†• V4.1 íŒ¨í„´ë³„ í†µê³„ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<Map<String, dynamic>> getPatternStats(PatternType pattern) async {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return await repository.getPatternStats(pattern);
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getOnlineMetricsHealth() {
    final metricsHealth = ref.read(onlineMetricsHealthProvider);
    return metricsHealth.when(
      data: (health) => health,
      loading: () => {'status': 'loading'},
      error: (error, stack) => {'status': 'error', 'message': error.toString()},
    );
  }

  /// ğŸ†• V4.1 ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  Map<String, dynamic> exportConfiguration() {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return repository.exportConfiguration();
  }

  void importConfiguration(Map<String, dynamic> config) {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    repository.importConfiguration(config);
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ“¥ Configuration imported successfully');
    }
  }

  /// í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  int get currentIndex => ref.read(signalPatternIndexProvider);
  PatternType get currentPattern => ref.read(signalPatternTypeProvider);
  double get currentThreshold => ref.read(signalThresholdProvider(currentPattern));
  bool get isCurrentPatternEnabled => ref.read(signalPatternEnabledProvider(currentPattern));

  /// ì‚¬ìš© ê°€ëŠ¥í•œ íŒ¨í„´ ì •ë³´
  List<String> get availablePatterns => AppConfig.signalPatterns;
  List<String> get patternDisplayNames => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternName(p)).toList();
  List<String> get patternDescriptions => 
      AppConfig.signalPatterns.map((p) => AppConfig.getSignalPatternDescription(p)).toList();

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ ì¡°íšŒ (PatternConfig ê¸°ë°˜)
  double getDefaultThreshold(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getConfigValue(pattern, 'priceChangePercent');
  }

  /// V4.1 íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ì¡°íšŒ
  Duration getCooldownDuration(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getCooldownDuration(pattern);
  }

  /// V4.1 íŒ¨í„´ ì„¤ì • ì „ì²´ ì¡°íšŒ
  Map<String, double> getPatternConfig(PatternType pattern) {
    final config = ref.read(patternConfigProvider);
    return config.getPatternConfig(pattern);
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° ì¡°íšŒ (ê¸°ì¡´ í˜¸í™˜ì„±)
  int getTimeWindow(PatternType pattern) {
    final patternName = _getPatternConfigName(pattern);
    return AppConfig.getSignalTimeWindow(patternName);
  }

  /// íŒ¨í„´ í†µê³„ ì¡°íšŒ (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥)
  Map<String, dynamic> getPatternStatsOverview() {
    final allSignals = ref.read(allSignalsProvider).value ?? [];
    final patternCounts = <PatternType, int>{};
    
    for (final signal in allSignals) {
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;
    }
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ì¶”ê°€
    final onlineHealth = getOnlineMetricsHealth();
    
    return {
      'totalSignals': allSignals.length,
      'patternCounts': patternCounts,
      'lastUpdate': allSignals.isNotEmpty ? allSignals.first.detectedAt : null,
      'version': '4.1-Online',
      'onlineMetrics': onlineHealth,
    };
  }

  /// ğŸ†• V4.1 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ìŠ¤íŠ¸ë¦¼
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    final repository = ref.read(signalRepoProvider) as SignalRepositoryImpl;
    return repository.watchPerformanceMetrics();
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ëª¨ë‹ˆí„°ë§ ìŠ¤íŠ¸ë¦¼
  Stream<Map<String, dynamic>> watchOnlineMetricsHealth() {
    return Stream.periodic(const Duration(seconds: 5), (_) {
      final metrics = ref.read(advancedMetricsProvider);
      return metrics.getSystemHealth();
    });
  }
}

/// Helper function: PatternTypeì„ AppConfig íŒ¨í„´ëª…ìœ¼ë¡œ ë³€í™˜
String _getPatternConfigName(PatternType pattern) {
  switch (pattern) {
    case PatternType.surge:
      return 'surge';
    case PatternType.flashFire:
      return 'flashFire';
    case PatternType.stackUp:
      return 'stackUp';
    case PatternType.stealthIn:
      return 'stealthIn';
    case PatternType.blackHole:
      return 'blackHole';
    case PatternType.reboundShot:
      return 'reboundShot';
  }
}

// ==========================================================================
// ğŸ” ê°œë°œììš© ë””ë²„ê¹… Providers
// ==========================================================================

/// ğŸ†• ë””ë²„ê¹…ìš© Provider - ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ
final debugSystemStatusProvider = FutureProvider.autoDispose<Map<String, dynamic>>((ref) async {
  final controller = ref.watch(signalPatternController);
  final systemHealth = await controller.getSystemHealth();
  final onlineHealth = controller.getOnlineMetricsHealth();
  
  return {
    'timestamp': DateTime.now().toIso8601String(),
    'version': 'V4.1-Online-Debug',
    'systemHealth': systemHealth,
    'onlineMetrics': onlineHealth,
    'currentPattern': controller.currentPattern.name,
    'activeProviders': {
      'advancedMetrics': 'active',
      'patternDetector': 'active', 
      'signalRepository': 'active',
      'patternConfig': 'active',
    },
  };
});

/// Repository dispose ê´€ë¦¬ (V4.1)
final signalRepositoryDisposeProvider = Provider.autoDispose<SignalRepository>((ref) {
  final repository = ref.watch(signalRepoProvider);
  
  ref.onDispose(() async {
    await repository.dispose();
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”¥ Signal repository V4.1 disposed - ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ì™„ì „ ì •ë¦¬');
    }
  });
  
  return repository;
});\n\n// ====== lib/core/di/sector_provider.dart ======\n
// lib/core/di/sector_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'volume_provider.dart' show volumeUsecaseProvider;
import 'trade_provider.dart' show marketsProvider;
import '../../domain/entities/volume.dart';
import '../../shared/widgets/sector_classification.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• SECTOR ì „ìš© Providerë“¤ (SectorClassificationProvider ì—°ë™)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ†• ì„¹í„° ë¶„ë¥˜ Provider (SectorClassificationProvider ì—°ë™)
final sectorClassificationProvider = ChangeNotifierProvider<SectorClassificationProvider>(
  (ref) => SectorClassificationProvider(),
);

/// ğŸ†• ì„¹í„° ì‹œê°„ëŒ€ ìƒíƒœ (ë³¼ë¥¨ê³¼ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬)
final sectorTimeFrameIndexProvider = StateProvider<int>((ref) => 0);

final sectorTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(sectorTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m';
});

/// ğŸ†• ì„¹í„°ë³„ ê±°ë˜ëŒ€ê¸ˆ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (SectorClassificationProvider í™œìš©)
final sectorVolumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
  ref.keepAlive();

  try {
    final timeFrame = ref.watch(sectorTimeFrameProvider);
    final usecase = ref.read(volumeUsecaseProvider);
    
    // markets AsyncValue ì²˜ë¦¬
    final marketsAsync = ref.watch(marketsProvider);
    final markets = marketsAsync.when(
      data: (data) => data,
      loading: () => <String>[],
      error: (_, __) => <String>[],
    );

    if (markets.isEmpty) {
      yield <Volume>[];
      return;
    }

    if (AppConfig.enableTradeLog) {
      log.i('Sector volume stream started: $timeFrame, ${markets.length} markets');
    }

    // ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ ë³€í™˜
    yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (coinVolumes) {
          // SectorClassificationProviderì—ì„œ í˜„ì¬ ì„¹í„° ë§¤í•‘ ê°€ì ¸ì˜¤ê¸°
          final sectorProvider = ref.read(sectorClassificationProvider);
          final sectorMapping = sectorProvider.currentSectors;
          
          final sectorVolumes = _aggregateVolumesBySector(coinVolumes, sectorMapping);
          
          if (AppConfig.enableTradeLog) {
            log.d('Sector volumes aggregated: ${sectorVolumes.length} sectors from ${coinVolumes.length} coins');
          }
          
          return sectorVolumes;
        },
        err: (error) {
          log.e('Sector Volume error: ${error.message}');
          return <Volume>[];
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Sector volume stream error: $e', e, stackTrace);
    yield <Volume>[];
  }
});

/// ğŸ¯ í•µì‹¬ ë¡œì§: ê°œë³„ ì½”ì¸ ë³¼ë¥¨ì„ ì„¹í„°ë³„ë¡œ í•©ì‚°
List<Volume> _aggregateVolumesBySector(List<Volume> coinVolumes, Map<String, List<String>> sectorMapping) {
  if (coinVolumes.isEmpty) return [];
  
  final Map<String, double> sectorVolumeMap = {};
  final sampleVolume = coinVolumes.first;
  
  // ê° ì½”ì¸ì„ í•´ë‹¹ ì„¹í„°ì— í•©ì‚°
  for (final coinVolume in coinVolumes) {
    final ticker = coinVolume.market.replaceFirst('KRW-', '');
    final sectors = _findSectorsForCoin(ticker, sectorMapping);
    
    for (final sector in sectors) {
      sectorVolumeMap[sector] = (sectorVolumeMap[sector] ?? 0.0) + coinVolume.totalVolume;
    }
  }
  
  // ë³¼ë¥¨ì´ 0ì¸ ì„¹í„° ì œê±°
  sectorVolumeMap.removeWhere((key, value) => value <= 0);
  
  // Volume ê°ì²´ë¡œ ë³€í™˜
  final sectorVolumes = sectorVolumeMap.entries
      .map((entry) => Volume(
            market: 'SECTOR-${entry.key}', // ì„¹í„° êµ¬ë¶„ìš© prefix
            totalVolume: entry.value,
            lastUpdatedMs: sampleVolume.lastUpdatedMs,
            timeFrame: sampleVolume.timeFrame,
            timeFrameStartMs: sampleVolume.timeFrameStartMs,
          ))
      .toList();
  
  // ë³¼ë¥¨ ìˆœ ì •ë ¬ (ë†’ì€ ìˆœ)
  sectorVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
  return sectorVolumes;
}

/// ğŸ¯ íŠ¹ì • ì½”ì¸ì´ ì†í•œ ì„¹í„°ë“¤ ì°¾ê¸°
List<String> _findSectorsForCoin(String ticker, Map<String, List<String>> sectorMapping) {
  final sectors = <String>[];
  sectorMapping.forEach((sectorName, coins) {
    if (coins.contains(ticker)) {
      sectors.add(sectorName);
    }
  });
  return sectors;
}

/// ğŸ†• ì„¹í„° ì»¨íŠ¸ë¡¤ëŸ¬
final sectorTimeFrameController = Provider((ref) => SectorTimeFrameController(ref));

class SectorTimeFrameController {
  final Ref ref;
  SectorTimeFrameController(this.ref);

  /// ì‹œê°„ëŒ€ ë³€ê²½
  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid sector timeFrame index: $index');
      return;
    }
    
    ref.read(sectorTimeFrameProvider.notifier).state = timeFrame;
    ref.read(sectorTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Sector TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ğŸ†• ì„¹í„° ë¶„ë¥˜ í† ê¸€ (SectorClassificationProvider ì—°ë™)
  void toggleSectorClassification() {
    ref.read(sectorClassificationProvider.notifier).toggleClassificationType();
    
    if (AppConfig.enableTradeLog) {
      final currentName = ref.read(sectorClassificationProvider).currentClassificationName;
      log.i('Sector classification toggled: $currentName');
    }
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€ ì •ë³´
  String get currentTimeFrame => ref.read(sectorTimeFrameProvider);
  int get currentIndex => ref.read(sectorTimeFrameIndexProvider);
  
  /// í˜„ì¬ ì„¹í„° ë¶„ë¥˜ ì •ë³´ (SectorClassificationProvider ì—°ë™)
  bool get isDetailedClassification => ref.read(sectorClassificationProvider).isDetailedClassification;
  String get currentSectorClassificationName => ref.read(sectorClassificationProvider).currentClassificationName;
  int get totalSectors => ref.read(sectorClassificationProvider).currentSectors.length;
  
  /// ê¸°ë³¸ ì •ë³´
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }

  /// ğŸ†• ì„¹í„° ê´€ë ¨ ìœ í‹¸ë¦¬í‹° (SectorClassificationProvider ì—°ë™)
  Map<String, int> getSectorSizes() {
    return ref.read(sectorClassificationProvider).sectorSizes;
  }

  List<String> getCoinsInSector(String sectorName) {
    return ref.read(sectorClassificationProvider).getCoinsInSector(sectorName);
  }

  List<String> getSectorsForCoin(String ticker) {
    return ref.read(sectorClassificationProvider).getSectorsForCoin(ticker);
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (ë³¼ë¥¨ UseCase ì¬ì‚¬ìš©)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Sector volume reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(volumeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Sector volume reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Sector volume reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  DateTime? getNextResetTime() {
    final usecase = ref.read(volumeUsecaseProvider);
    final timeFrame = ref.read(sectorTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get sector reset time failed: ${error.message}');
        return null;
      },
    );
  }
}\n\n// ====== lib/core/di/app_providers.dart ======\n
// lib/core/di/app_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../bridge/signal_bus.dart';

/// â–¶ App lifecycle
export '../utils/app_life_cycle_manager.dart'
    show appLifecycleManagerProvider;

/// â–¶ Settings DI + state
export 'settings_provider.dart'
    show
        sharedPreferencesProvider,
        settingsLocalDSProvider,
        settingsRepositoryProvider,
        settingsUsecaseProvider,
        appSettingsProvider;

/// â–¶ Domain entities
export '../../domain/entities/app_settings.dart'
    show
        DisplayMode,
        SliderPosition;

/// â–¶ WebSocket DI & stats
export 'websocket_provider.dart'
    show
        wsStatusProvider,
        wsClientProvider,
        wsStatsProvider,
        WebSocketStats;

/// â–¶ Trade DI & streams
export 'trade_provider.dart';

/// â–¶ Volume DI & streams
export 'volume_provider.dart'
    show
        volumeRemoteDSProvider,
        volumeRepositoryProvider,
        volumeUsecaseProvider,
        volumeTimeFrameIndexProvider,
        volumeTimeFrameProvider,
        volumeDataProvider,
        volumeTimeFrameController;

/// â–¶ Sector DI & streams
export 'sector_provider.dart'
    show
        sectorClassificationProvider,
        sectorTimeFrameIndexProvider,
        sectorTimeFrameProvider,
        sectorVolumeDataProvider,
        sectorTimeFrameController;

/// â–¶ Signal DI & streams (V4.1 Online)
export 'signal_provider.dart'
    show
        // ğŸ”¥ V4.1 ì˜ì¡´ì„± ì£¼ì…
        advancedMetricsProvider,
        patternConfigProvider,
        patternDetectorProvider,
        signalRepoProvider,
        signalUsecaseProvider,
        
        // ğŸ¯ ìƒíƒœ ê´€ë¦¬
        signalPatternIndexProvider,
        signalPatternTypeProvider,
        signalThresholdProvider,
        signalPatternEnabledProvider,
        
        // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
        signalListProvider,
        allSignalsProvider,
        
        // ğŸ†• V4.1 ëª¨ë‹ˆí„°ë§
        onlineMetricsHealthProvider,
        systemPerformanceProvider,
        
        // ğŸ® V4.1 ì»¨íŠ¸ë¡¤ëŸ¬
        signalPatternController,
        SignalPatternControllerV4,
        
        // ğŸ› ï¸ StateNotifier
        PatternConfigNotifier,
        
        // ğŸ” ë””ë²„ê¹…
        debugSystemStatusProvider;

/// â–¶ Market Mood DI & streams
export 'market_mood_provider.dart'
    show
        coinGeckoApiClientProvider,
        marketMoodRemoteDSProvider,
        marketMoodLocalDSProvider,
        marketMoodRepositoryProvider,
        marketMoodUsecaseProvider,
        exchangeRateProvider,
        marketMoodProvider,
        marketMoodComputedDataProvider, // UIì—ì„œ ë¡œë”©/ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬ë¥¼ ìœ„í•´ export
        volumeComparisonProvider,
        currentMarketMoodProvider,
        marketMoodSummaryProvider,
        marketMoodSystemProvider,
        marketMoodControllerProvider,
        MarketMoodComputedData;

/// â–¶ Market Mood Domain Entities
export '../../domain/entities/market_mood.dart'
    show
        MarketMood,
        VolumeData,
        MarketMoodData,
        ComparisonResult,
        ComparisonData,
        MarketMoodSystemState,
        VolumeConstants;

/// â–¶ Sector ë¶„ë¥˜ ê´€ë¦¬ (shared layer)
export '../../shared/widgets/sector_classification.dart'
    show SectorClassificationProvider;

/// â–¶ ì „ì—­ SnackBar key
final scaffoldMessengerKeyProvider =
    Provider<GlobalKey<ScaffoldMessengerState>>((ref) {
  return GlobalKey<ScaffoldMessengerState>();
});

/// â–¶ BottomTab ì¸ë±ìŠ¤
final selectedTabProvider = StateProvider<int>((ref) => 0);

/// â–¶ SignalBus ì‹±ê¸€í„´
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});\n\n// ====== lib/core/di/notification_provider.dart ======\n
// lib/core/di/notification_provider.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../utils/logger.dart';
import 'app_providers.dart'; // scaffoldMessengerKeyProvider

/// ğŸ”” ì•Œë¦¼ íƒ€ì… enum
enum NotificationType {
  trade,       // ì²´ê²° ì•Œë¦¼
  priceAlert,  // ê°€ê²© ì•Œë¦¼  
  volume,      // ê±°ë˜ëŸ‰ ì•Œë¦¼
  surge,       // ê¸‰ë“±ë½ ì•Œë¦¼
  system,      // ì‹œìŠ¤í…œ ì•Œë¦¼
}

/// ğŸ”” ì•Œë¦¼ ìƒíƒœ enum  
enum NotificationStatus {
  unread,      // ì½ì§€ ì•ŠìŒ
  read,        // ì½ìŒ
  archived,    // ë³´ê´€ë¨
}

/// ğŸ”” ì•Œë¦¼ ë°ì´í„° ëª¨ë¸ (ì„ì‹œ)
class NotificationData {
  final String id;
  final String title;
  final String message;
  final NotificationType type;
  final NotificationStatus status;
  final DateTime createdAt;
  final Map<String, dynamic>? extra;

  const NotificationData({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    this.status = NotificationStatus.unread,
    required this.createdAt,
    this.extra,
  });

  NotificationData copyWith({
    NotificationStatus? status,
    Map<String, dynamic>? extra,
  }) {
    return NotificationData(
      id: id,
      title: title,
      message: message,
      type: type,
      status: status ?? this.status,
      createdAt: createdAt,
      extra: extra ?? this.extra,
    );
  }
}

/// ğŸ”” ì•Œë¦¼ ëª©ë¡ Provider
final notificationListProvider = StateProvider<List<NotificationData>>((ref) => []);

/// ğŸ”” ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
final unreadNotificationCountProvider = Provider<int>((ref) {
  final notifications = ref.watch(notificationListProvider);
  return notifications.where((n) => n.status == NotificationStatus.unread).length;
});

/// ğŸ”” ì•Œë¦¼ í•„í„° Provider
final notificationFilterProvider = StateProvider<NotificationType?>((ref) => null);

/// ğŸ”” í•„í„°ëœ ì•Œë¦¼ ëª©ë¡
final filteredNotificationProvider = Provider<List<NotificationData>>((ref) {
  final notifications = ref.watch(notificationListProvider);
  final filter = ref.watch(notificationFilterProvider);
  
  if (filter == null) return notifications;
  return notifications.where((n) => n.type == filter).toList();
});

/// ğŸ”” ì•Œë¦¼ ê´€ë¦¬ ì„œë¹„ìŠ¤
final notificationServiceProvider = Provider((ref) => NotificationService(ref));

/// ì•Œë¦¼ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// ğŸ†• Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (AppRouterì—ì„œ ì´ë™ë¨)
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // ì•±ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // ì•Œë¦¼ Providerì— ì €ì¥
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBarë¡œë„ í‘œì‹œ
        if (messenger != null) {
          messenger
            ..hideCurrentSnackBar()
            ..showSnackBar(SnackBar(content: Text('${n.title}: ${n.body}')));
        }
      }
    });
    
    // ì•±ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ ì•Œë¦¼ í´ë¦­í•´ì„œ ì•± ì‹œì‘
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          addNotification(
            title: n.title ?? 'ì•Œë¦¼',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆì„ ë•Œ ì•Œë¦¼ í´ë¦­
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    log.i('ğŸ”” Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
  }

  /// Firebase ë©”ì‹œì§€ ë°ì´í„°ë¡œë¶€í„° ì•Œë¦¼ íƒ€ì… ì¶”ë¡ 
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }
  
  /// Firebase ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('ğŸ§¹ Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¨');
  }
  
  /// ì•Œë¦¼ ì¶”ê°€
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('ğŸ”” ì•Œë¦¼ ì¶”ê°€: $title');
  }
  
  /// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ì•Œë¦¼ ì½ìŒ: $notificationId');
  }
  
  /// ì•Œë¦¼ ì œê±°
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ—‘ï¸ ì•Œë¦¼ ì œê±°: $notificationId');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì œê±°
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('ğŸ§¹ ëª¨ë“  ì•Œë¦¼ ì œê±°');
  }
  
  /// í•„í„° ì„¤ì •
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('ğŸ” ì•Œë¦¼ í•„í„°: ${type?.name ?? "ì „ì²´"}');
  }
  
  /// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
// lib/core/di/volume_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import 'trade_provider.dart' show marketsProvider; // ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ì¬ì‚¬ìš©
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart'; // ğŸ†• UseCase import
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import ì¶”ê°€!


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• VOLUME ì „ìš© Providerë“¤ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ¯ ë³¼ë¥¨ ì „ìš© RemoteDataSource (TradeRemoteDataSourceì™€ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤)
final volumeRemoteDSProvider = Provider<TradeRemoteDataSource>((ref) {
 return TradeRemoteDataSource(
   ref.read(wsClientProvider),
   ref.read(signalBusProvider),
   useTestData: AppConfig.useTestDataInDev,
 );
});

/// ğŸ†• VolumeRepository
final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
 return VolumeRepositoryImpl(
   ref.read(volumeRemoteDSProvider),
 );
});

/// ğŸ†• VolumeUsecase
final volumeUsecaseProvider = Provider<VolumeUsecase>((ref) {
 return VolumeUsecase(
   ref.read(volumeRepositoryProvider),
 );
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ìƒíƒœ (ê¸°ë³¸ê°’: 1ë¶„)
final volumeTimeFrameIndexProvider = StateProvider<int>((_) => 0); // 1ë¶„ì´ ê¸°ë³¸ (0:1m, 1:5m, 2:15m)

final volumeTimeFrameProvider = StateProvider<String>((ref) {
 final index = ref.watch(volumeTimeFrameIndexProvider);
 final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 if (index >= 0 && index < timeFrames.length) {
   return timeFrames[index];
 }
 return '1m'; // fallback (ê¸°ë³¸ê°’ 1ë¶„)
});

/// ğŸš€ ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (100ms ë°°ì¹˜ ì—…ë°ì´íŠ¸)
final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
 // Prevent immediate dispose on loss of listeners
 ref.keepAlive();

 try {
   // í˜„ì¬ ì‹œê°„ëŒ€ì™€ marketsë¥¼ ì½ì–´ì„œ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
   final timeFrame = ref.watch(volumeTimeFrameProvider);
   final markets = await ref.watch(marketsProvider.future);
   final usecase = ref.read(volumeUsecaseProvider); // ğŸ†• UseCase ì‚¬ìš©

   if (AppConfig.enableTradeLog) {
     log.i('Volume stream started: $timeFrame, ${markets.length} markets');
   }

   // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ëœ ë³¼ë¥¨ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ (UseCaseë¥¼ í†µí•´)
   yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
     return result.when(
       ok: (volumes) => volumes,
       err: (error) {
         log.e('Volume UseCase error: ${error.message}');
         return <Volume>[]; // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
       },
     );
   });
   
 } catch (e, stackTrace) {
   log.e('Volume stream error: $e', e, stackTrace);
   
   // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
   yield <Volume>[];
 }
});

/// ğŸ†• ë³¼ë¥¨ ì‹œê°„ëŒ€ ì»¨íŠ¸ë¡¤ëŸ¬
final volumeTimeFrameController = Provider((ref) => VolumeTimeFrameController(ref));

class VolumeTimeFrameController {
 final Ref ref;
 VolumeTimeFrameController(this.ref);

 void updateTimeFrame(String timeFrame, int index) {
   final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
   if (index < 0 || index >= timeFrames.length) {
     if (AppConfig.enableTradeLog) log.w('Invalid timeFrame index: $index');
     return;
   }
   
   ref.read(volumeTimeFrameProvider.notifier).state = timeFrame;
   ref.read(volumeTimeFrameIndexProvider.notifier).state = index;
   
   if (AppConfig.enableTradeLog) {
     log.i('Volume TimeFrame updated: $timeFrame (index: $index)');
   }
 }

 /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (UseCaseë¥¼ í†µí•´)
 void resetCurrentTimeFrame() {
   final usecase = ref.read(volumeUsecaseProvider);
   final timeFrame = ref.read(volumeTimeFrameProvider);
   
   final result = usecase.resetTimeFrame(timeFrame);
   result.when(
     ok: (_) {
       if (AppConfig.enableTradeLog) {
         log.i('Volume reset: $timeFrame');
       }
     },
     err: (error) {
       log.e('Volume reset failed: ${error.message}');
     },
   );
 }

 void resetAllTimeFrames() {
   final usecase = ref.read(volumeUsecaseProvider);
   
   final result = usecase.resetAllTimeFrames();
   result.when(
     ok: (_) {
       if (AppConfig.enableTradeLog) {
         log.i('Volume reset: all timeframes');
       }
     },
     err: (error) {
       log.e('Volume reset all failed: ${error.message}');
     },
   );
 }

 /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ (UseCaseë¥¼ í†µí•´)
 DateTime? getNextResetTime() {
   final usecase = ref.read(volumeUsecaseProvider);
   final timeFrame = ref.read(volumeTimeFrameProvider);
   
   final result = usecase.getNextResetTime(timeFrame);
   return result.when(
     ok: (resetTime) => resetTime,
     err: (error) {
       log.e('Get reset time failed: ${error.message}');
       return null;
     },
   );
 }

 /// Getters
 String get currentTimeFrame => ref.read(volumeTimeFrameProvider);
 int get currentIndex => ref.read(volumeTimeFrameIndexProvider);
 List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 
 /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
 String getTimeFrameName(String timeFrame) {
   final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
   return AppConfig.timeFrameNames[minutes] ?? timeFrame;
 }
}\n\n// ====== lib/core/di/market_mood_provider copy.dart ======\n
\n\n// ====== lib/core/di/surge_provider.dart ======\n
// lib/core/di/surge_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import 'trade_provider.dart' show marketsProvider; // ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ì¬ì‚¬ìš©
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/surge_repository_impl.dart';
import '../../domain/repositories/surge_repository.dart';
import '../../domain/usecases/surge_usecase.dart'; // ğŸ†• UseCase import
import '../../domain/entities/surge.dart'; // ğŸ†• Surge ì—”í‹°í‹° import ì¶”ê°€!

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ SURGE ì „ìš© Providerë“¤ (ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê¸°ë°˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ğŸ¯ ê¸‰ë“±/ê¸‰ë½ ì „ìš© RemoteDataSource (TradeRemoteDataSourceì™€ ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤)
final surgeRemoteDSProvider = Provider<TradeRemoteDataSource>((ref) {
  return TradeRemoteDataSource(
    ref.read(wsClientProvider),
    ref.read(signalBusProvider),
    useTestData: AppConfig.useTestDataInDev,
  );
});

/// ğŸš€ SurgeRepository
final surgeRepositoryProvider = Provider<SurgeRepository>((ref) {
  return SurgeRepositoryImpl(
    ref.read(surgeRemoteDSProvider),
  );
});

/// ğŸš€ SurgeUsecase
final surgeUsecaseProvider = Provider<SurgeUsecase>((ref) {
  return SurgeUsecase(
    ref.read(surgeRepositoryProvider),
  );
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì‹œê°„ëŒ€ ìƒíƒœ (ê¸°ë³¸ê°’: 1ë¶„)
final surgeTimeFrameIndexProvider = StateProvider<int>((_) => 0); // 1ë¶„ì´ ê¸°ë³¸ (0:1m, 1:5m, 2:15m)

final surgeTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(surgeTimeFrameIndexProvider);
  final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  if (index >= 0 && index < timeFrames.length) {
    return timeFrames[index];
  }
  return '1m'; // fallback (ê¸°ë³¸ê°’ 1ë¶„)
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (ì‹¤ì‹œê°„ ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
final surgeDataProvider = StreamProvider.autoDispose<List<Surge>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  try {
    // í˜„ì¬ ì‹œê°„ëŒ€ì™€ marketsë¥¼ ì½ì–´ì„œ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    final timeFrame = ref.watch(surgeTimeFrameProvider);
    final markets = await ref.watch(marketsProvider.future);
    final usecase = ref.read(surgeUsecaseProvider); // ğŸš€ UseCase ì‚¬ìš©

    if (AppConfig.enableTradeLog) {
      log.i('Surge stream started: $timeFrame, ${markets.length} markets');
    }

    // ğŸš€ ì‹¤ì‹œê°„ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ (UseCaseë¥¼ í†µí•´)
    yield* usecase.getSurgeRanking(timeFrame, markets).map((result) {
      return result.when(
        ok: (surges) => surges,
        err: (error) {
          log.e('Surge UseCase error: ${error.message}');
          return <Surge>[]; // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
        },
      );
    });
    
  } catch (e, stackTrace) {
    log.e('Surge stream error: $e', e, stackTrace);
    
    // ì—ëŸ¬ ì‹œ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
    yield <Surge>[];
  }
});

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ì‹œê°„ëŒ€ ì»¨íŠ¸ë¡¤ëŸ¬
final surgeTimeFrameController = Provider((ref) => SurgeTimeFrameController(ref));

class SurgeTimeFrameController {
  final Ref ref;
  SurgeTimeFrameController(this.ref);

  void updateTimeFrame(String timeFrame, int index) {
    final timeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid timeFrame index: $index');
      return;
    }
    
    ref.read(surgeTimeFrameProvider.notifier).state = timeFrame;
    ref.read(surgeTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Surge TimeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// ìˆ˜ë™ ë¦¬ì…‹ ë©”ì„œë“œë“¤ (UseCaseë¥¼ í†µí•´)
  void resetCurrentTimeFrame() {
    final usecase = ref.read(surgeUsecaseProvider);
    final timeFrame = ref.read(surgeTimeFrameProvider);
    
    final result = usecase.resetTimeFrame(timeFrame);
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Surge reset: $timeFrame');
        }
      },
      err: (error) {
        log.e('Surge reset failed: ${error.message}');
      },
    );
  }

  void resetAllTimeFrames() {
    final usecase = ref.read(surgeUsecaseProvider);
    
    final result = usecase.resetAllTimeFrames();
    result.when(
      ok: (_) {
        if (AppConfig.enableTradeLog) {
          log.i('Surge reset: all timeframes');
        }
      },
      err: (error) {
        log.e('Surge reset all failed: ${error.message}');
      },
    );
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ (UseCaseë¥¼ í†µí•´)
  DateTime? getNextResetTime() {
    final usecase = ref.read(surgeUsecaseProvider);
    final timeFrame = ref.read(surgeTimeFrameProvider);
    
    final result = usecase.getNextResetTime(timeFrame);
    return result.when(
      ok: (resetTime) => resetTime,
      err: (error) {
        log.e('Get reset time failed: ${error.message}');
        return null;
      },
    );
  }

  /// Getters
  String get currentTimeFrame => ref.read(surgeTimeFrameProvider);
  int get currentIndex => ref.read(surgeTimeFrameIndexProvider);
  List<String> get availableTimeFrames => AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  /// ì‹œê°„ëŒ€ í•œêµ­ì–´ ì´ë¦„
  String getTimeFrameName(String timeFrame) {
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    return AppConfig.timeFrameNames[minutes] ?? timeFrame;
  }
}\n\n// ====== lib/core/di/market_mood_provider.dart ======\n
// lib/core/di/market_mood_provider.dart
// ğŸš€ Performance Optimized Provider - ë©”ëª¨ì´ì œì´ì…˜, ë°°ì¹˜ì²˜ë¦¬, ì„ íƒì  ë¬´íš¨í™”, ì£¼ê¸°ì  ê°±ì‹  ì ìš©

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart'; // ğŸš€ debounceTime, distinctUntilChanged
import 'dart:async';

import '../network/api_client_coingecko.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show hiveServiceProvider;
import '../../data/datasources/market_mood_remote_ds.dart';
import '../../data/datasources/market_mood_local_ds.dart';
import '../../data/repositories/market_mood_repository_impl.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/usecases/market_mood_usecase.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸ Provider
final coinGeckoApiClientProvider = Provider<CoinGeckoApiClient>((ref) {
  return CoinGeckoApiClient();
});

/// ğŸ”¥ Remote DataSource Provider
final marketMoodRemoteDSProvider = Provider<MarketMoodRemoteDataSource>((ref) {
  final client = ref.read(coinGeckoApiClientProvider);
  return MarketMoodRemoteDataSource(client);
});

/// ğŸ”¥ Local DataSource Provider
final marketMoodLocalDSProvider = Provider<MarketMoodLocalDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return MarketMoodLocalDataSource(hive);
});

/// ğŸ”¥ Repository Provider
final marketMoodRepositoryProvider = Provider<MarketMoodRepositoryImpl>((ref) {
  final remoteDS = ref.read(marketMoodRemoteDSProvider);
  final localDS = ref.read(marketMoodLocalDSProvider);
  return MarketMoodRepositoryImpl(remoteDS, localDS);
});

/// ğŸ”¥ UseCase Provider
final marketMoodUsecaseProvider = Provider<MarketMoodUsecase>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  return MarketMoodUsecase(repository);
});

/// ğŸš€ ë©”ëª¨ì´ì œì´ì…˜ëœ í™˜ìœ¨ Provider - ìºì‹œ ìœ ì§€ (TTL í•„ìš” ì‹œ autoDisposeë¡œ ë³€ê²½)
final exchangeRateProvider = FutureProvider.autoDispose<double>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);
  try {
    final rate = await usecase.getExchangeRate();
    log.d('í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate (ìºì‹œë¨)');
    return rate;
  } catch (e, st) {
    log.w('í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ 1400 ì‚¬ìš©: $e', e, st);
    return 1400.0;
  }
});

/// ğŸš€ ìµœì í™”ëœ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ - distinct + debounceTime ì ìš©
final marketMoodProvider = StreamProvider<MarketMoodData>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);

  ref.onDispose(repository.dispose);

  return repository
      .getMarketDataStream()
      .distinct((prev, next) => prev.totalVolumeUsd == next.totalVolumeUsd)
      .debounceTime(const Duration(milliseconds: 100));
});

/// ğŸš€ í†µí•© ê³„ì‚° Provider - ì£¼ê¸°ì  ê°±ì‹  ë° í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ìë™ invalidate ì ìš©
final marketMoodComputedDataProvider = FutureProvider.autoDispose<MarketMoodComputedData>((ref) async {
  // 1) autoDispose ë¹„í™œì„±í™” ë§í¬ (keepAlive)
  final link = ref.keepAlive();

  // 2) 15ë¶„ë§ˆë‹¤ ì¬ê³„ì‚°
  final timer = Timer.periodic(const Duration(minutes: 15), (_) {
    ref.invalidateSelf();
  });

  // 3) ì•± ë³µê·€ ì‹œ ì¬ê³„ì‚°
  ref.onResume(() {
    ref.invalidateSelf();
  });

  // 4) ì¢…ë£Œ ì‹œ ì •ë¦¬
  ref.onDispose(() {
    timer.cancel();
    link.close();
  });

  // ê¸°ì¡´ ë¡œì§
  final moodAsync = ref.watch(marketMoodProvider);
  final exchangeAsync = ref.watch(exchangeRateProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (marketData) async {
      final exchangeRate = exchangeAsync.asData?.value ?? 1400.0;
      try {
        final results = await Future.wait(
          [
            usecase.calculateCurrentMood(marketData.totalVolumeUsd),
            usecase.calculateVolumeComparison(marketData.totalVolumeUsd),
          ],
          eagerError: false,
        );
        final currentMood = results[0] as MarketMood;
        final volumeComparison = results[1] as ComparisonData;
        final moodSummary = usecase.generateMoodSummary(currentMood);

        return MarketMoodComputedData(
          marketData: marketData,
          currentMood: currentMood,
          volumeComparison: volumeComparison,
          moodSummary: moodSummary,
          exchangeRate: exchangeRate,
          computedAt: DateTime.now(),
        );
      } catch (e, st) {
        // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
        log.e('ë°°ì¹˜ ê³„ì‚° ì˜¤ë¥˜: $e', e, st);
        return MarketMoodComputedData.error();
      }
    },
    loading: () async => MarketMoodComputedData.loading(),
    error: (error, stack) async {
      // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
      log.e('ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ì˜¤ë¥˜: $error', error, stack);
      return MarketMoodComputedData.error();
    },
  );
});

/// ğŸ¯ ê°œë³„ ë°ì´í„° ì ‘ê·¼ Providerë“¤ - ë©”ëª¨ì´ì œì´ì…˜ëœ ê²°ê³¼ì—ì„œ ì¶”ì¶œ
final currentMarketMoodProvider = Provider<MarketMood>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.currentMood,
    loading: () => MarketMood.sideways,
    error: (_, __) => MarketMood.sideways,
  );
});

final volumeComparisonProvider = Provider<ComparisonData>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.volumeComparison,
    loading: () => ComparisonData.loading(),
    error: (_, __) => ComparisonData.error(),
  );
});

final marketMoodSummaryProvider = Provider<String>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.moodSummary,
    loading: () => 'ë¡œë”©ì¤‘...',
    error: (_, __) => 'ì˜¤ë¥˜ ë°œìƒ',
  );
});

/// ğŸŒ ìµœì í™”ëœ ì‹œìŠ¤í…œ ìƒíƒœ Provider
final marketMoodSystemProvider = Provider<MarketMoodSystemState>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return computedAsync.when(
    data: (computed) => usecase.createSystemState(
      marketData: computed.marketData,
      comparisonData: computed.volumeComparison,
      currentMood: computed.currentMood,
      exchangeRate: computed.exchangeRate,
      isLoading: false,
      hasError: false,
    ),
    loading: () => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.loading(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: true,
      hasError: false,
    ),
    error: (_, __) => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.error(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: false,
      hasError: true,
    ),
  );
});

/// ğŸ® ìµœì í™”ëœ ë§ˆì¼“ ë¬´ë“œ ì»¨íŠ¸ë¡¤ëŸ¬
final marketMoodControllerProvider = Provider((ref) => OptimizedMarketMoodController(ref));

class OptimizedMarketMoodController {
  final Ref ref;
  DateTime? _lastRefresh;
  static const _refreshCooldown = Duration(seconds: 30);

  OptimizedMarketMoodController(this.ref);

  /// ğŸš€ ìŠ¤ë§ˆíŠ¸ ìƒˆë¡œê³ ì¹¨ - ì¿¨ë‹¤ìš´ ì ìš©
  void refresh() {
    final now = DateTime.now();
    if (_lastRefresh != null && now.difference(_lastRefresh!) < _refreshCooldown) {
      // [ìˆ˜ì •ë¨] + ì—°ì‚°ì ëŒ€ì‹  ì¸ì ‘ ë¬¸ìì—´ ì—°ê²° ì‚¬ìš©
      log.d('ìƒˆë¡œê³ ì¹¨ ì¿¨ë‹¤ìš´ ì¤‘... '
          '${_refreshCooldown.inSeconds - now.difference(_lastRefresh!).inSeconds}ì´ˆ í›„ ê°€ëŠ¥');
      return;
    }

    _lastRefresh = now;
    ref.invalidate(marketMoodProvider);
    ref.invalidate(exchangeRateProvider);
    log.d('ë§ˆì¼“ë¬´ë“œ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ìºì‹œëœ í˜„ì¬ ë¬´ë“œ ì¡°íšŒ
  MarketMood getCurrentMood() => ref.read(currentMarketMoodProvider);

  /// ğŸš€ ìºì‹œëœ ë¹„êµ ë°ì´í„° ì¡°íšŒ
  ComparisonData getComparisonData() => ref.read(volumeComparisonProvider);

  /// ğŸš€ í™˜ìœ¨ë§Œ ì„ íƒì  ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.refreshExchangeRate();
    ref.invalidate(exchangeRateProvider);
    log.d('í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ìºì‹œ í™œìš©)
  Future<Map<String, dynamic>> getSystemHealth() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final state = ref.read(marketMoodSystemProvider);
    return {
      ...await usecase.getSystemHealth(),
      'cached_state': {
        'is_loading': state.isLoading,
        'has_error': state.hasError,
        'last_update': state.marketData?.updatedAt.toIso8601String(),
      }
    };
  }

  /// ğŸš€ ì„±ëŠ¥ í†µê³„ ë¡œê¹…
  Future<void> logSystemStatus() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final computedAsync = ref.read(marketMoodComputedDataProvider);
    await usecase.logSystemStatus();
    computedAsync.whenData((computed) {
      log.i('ì„±ëŠ¥ í†µê³„ - ê³„ì‚° ì‹œê°„: ${DateTime.now().difference(computed.computedAt).inMilliseconds}ms');
    });
  }

  /// ğŸš€ ë©”ëª¨ë¦¬ ì •ë¦¬ (í•„ìš” ì‹œ í˜¸ì¶œ)
  void clearCache() {
    ref.invalidate(marketMoodComputedDataProvider);
    ref.invalidate(exchangeRateProvider);
    ref.invalidate(marketMoodProvider);
    log.d('ìºì‹œ ì •ë¦¬ ì™„ë£Œ');
  }
}

/// ğŸš€ í†µí•© ê³„ì‚° ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤
class MarketMoodComputedData {
  final MarketMoodData? marketData;
  final MarketMood currentMood;
  final ComparisonData volumeComparison;
  final String moodSummary;
  final double exchangeRate;
  final DateTime computedAt;

  const MarketMoodComputedData({
    this.marketData,
    required this.currentMood,
    required this.volumeComparison,
    required this.moodSummary,
    required this.exchangeRate,
    required this.computedAt,
  });

  factory MarketMoodComputedData.loading() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.loading(),
        moodSummary: 'ë¡œë”©ì¤‘...',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  factory MarketMoodComputedData.error() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.error(),
        moodSummary: 'ì˜¤ë¥˜ ë°œìƒ',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  /// ğŸš€ ë°ì´í„° ì‹ ì„ ë„ ì²´í¬ (15ë¶„ ì´ìƒ ì˜¤ë˜ë˜ë©´ ê°±ì‹  í•„ìš”)
  bool get isStale => DateTime.now().difference(computedAt) > const Duration(minutes: 15);

  /// ğŸš€ ì„±ëŠ¥ ë©”íŠ¸ë¦­
  Duration get age => DateTime.now().difference(computedAt);
}\n\n// ====== lib/core/di/settings_provider.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // SystemChromeìš©
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../data/datasources/settings_local_ds.dart';
import '../../data/repositories/settings_repository_impl.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../../domain/usecases/settings_usecase.dart';
import '../utils/logger.dart';

/// 1) SharedPreferences ì¸ìŠ¤í„´ìŠ¤ (main.dartì—ì„œ override)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'main.dartì—ì„œ SharedPreferences.getInstance() í›„ overridesë¡œ ì£¼ì…í•˜ì„¸ìš”.'
  );
});

/// 2) Local DataSource
final settingsLocalDSProvider = Provider<SettingsLocalDataSource>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return SettingsLocalDataSource(prefs);
});

/// 3) Repository
final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
  final ds = ref.watch(settingsLocalDSProvider);
  return SettingsRepositoryImpl(ds);
});

/// 4) UseCase
final settingsUsecaseProvider = Provider<SettingsUsecase>((ref) {
  final repo = ref.watch(settingsRepositoryProvider);
  return SettingsUsecase(repo);
});

/// 5) í†µí•© ì„¤ì • Provider
final appSettingsProvider = StateNotifierProvider<AppSettingsNotifier, AppSettings>((ref) {
  final usecase = ref.watch(settingsUsecaseProvider);
  return AppSettingsNotifier(usecase);
});

/// í†µí•© ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤
class AppSettingsNotifier extends StateNotifier<AppSettings> {
  final SettingsUsecase _usecase;

  AppSettingsNotifier(this._usecase) : super(const AppSettings()) {
    _loadSettings();
  }

  /// ì´ˆê¸° ì„¤ì • ë¡œë“œ
  Future<void> _loadSettings() async {
    try {
      final settings = await _usecase.getSettings();
      state = settings;
      _applyKeepScreen(settings.keepScreenOn);
      _applyOrientationLock(settings.isPortraitLocked);
      log.i('âš™ï¸ ì„¤ì • ë¡œë“œ ì™„ë£Œ: ${settings.toString()}');
    } catch (e, st) {
      log.e('ì„¤ì • ë¡œë“œ ì‹¤íŒ¨', e, st);
    }
  }

  /// í…Œë§ˆ ëª¨ë“œ ë³€ê²½
  Future<void> setThemeMode(ThemeMode mode) async {
    try {
      await _usecase.updateThemeMode(mode);
      state = state.copyWith(themeMode: mode);
      log.i('ğŸ¨ í…Œë§ˆ ëª¨ë“œ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('í…Œë§ˆ ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì •
  Future<void> setKeepScreenOn(bool keep) async {
    try {
      await _usecase.updateKeepScreenOn(keep);
      state = state.copyWith(keepScreenOn: keep);
      _applyKeepScreen(keep);
      log.i('ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°: $keep');
    } catch (e, st) {
      log.e('í™”ë©´ ì¼œê¸° ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½
  Future<void> setSliderPosition(SliderPosition position) async {
    try {
      await _usecase.updateSliderPosition(position);
      state = state.copyWith(sliderPosition: position);
      log.i('ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜: ${position.name}');
    } catch (e, st) {
      log.e('ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setDisplayMode(DisplayMode mode) async {
    try {
      await _usecase.updateDisplayMode(mode);
      state = state.copyWith(displayMode: mode);
      log.i('ğŸ’° ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setAmountDisplayMode(AmountDisplayMode mode) async {
    try {
      await _usecase.updateAmountDisplayMode(mode);
      state = state.copyWith(amountDisplayMode: mode);
      log.i('ğŸ’µ ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ë°˜ì§ì„ íš¨ê³¼ ì„¤ì •
  Future<void> setBlinkEnabled(bool enabled) async {
    try {
      await _usecase.updateBlinkEnabled(enabled);
      state = state.copyWith(blinkEnabled: enabled);
      log.i('âœ¨ ë°˜ì§ì„ íš¨ê³¼: $enabled');
    } catch (e, st) {
      log.e('ë°˜ì§ì„ íš¨ê³¼ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í°íŠ¸ íŒ¨ë°€ë¦¬ ë³€ê²½
  Future<void> setFontFamily(FontFamily font) async {
    try {
      await _usecase.updateFontFamily(font);
      state = state.copyWith(fontFamily: font);
      log.i('ğŸ”¤ í°íŠ¸ ì„¤ì •: ${font.fontName}');
    } catch (e, st) {
      log.e('í°íŠ¸ ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// í–…í‹± í”¼ë“œë°± ì„¤ì •
  Future<void> setHapticEnabled(bool enabled) async {
    try {
      await _usecase.updateHapticEnabled(enabled);
      state = state.copyWith(isHapticEnabled: enabled);
      log.i('ğŸ“³ í–…í‹± í”¼ë“œë°±: $enabled');
    } catch (e, st) {
      log.e('í–…í‹± í”¼ë“œë°± ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì •
  Future<void> setPortraitLocked(bool locked) async {
    try {
      await _usecase.updatePortraitLocked(locked);
      state = state.copyWith(isPortraitLocked: locked);
      _applyOrientationLock(locked);
      log.i('ğŸ”’ í™”ë©´ íšŒì „ ì ê¸ˆ: $locked');
    } catch (e, st) {
      log.e('í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// ìºì‹œ ë¹„ìš°ê¸°
  Future<void> clearCache() async {
    try {
      await _usecase.clearCache();
      log.i('ğŸ—‚ï¸ ìºì‹œ ë¹„ìš°ê¸° ì™„ë£Œ');
      await refresh();
    } catch (e, st) {
      log.e('ìºì‹œ ë¹„ìš°ê¸° ì‹¤íŒ¨', e, st);
    }
  }

  /// ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
  Future<void> resetAllSettings() async {
    try {
      await _usecase.resetSettings();
      state = const AppSettings();
      _applyKeepScreen(false);
      _applyOrientationLock(false);
      log.i('ğŸ”„ ëª¨ë“  ì„¤ì • ì´ˆê¸°í™” ì™„ë£Œ');
    } catch (e, st) {
      log.e('ì„¤ì • ì´ˆê¸°í™” ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ ì¼œê¸° ì‹¤ì œ ì ìš©
  void _applyKeepScreen(bool keep) {
    if (keep) {
      WakelockPlus.enable();
    } else {
      WakelockPlus.disable();
    }
  }

  /// í™”ë©´ íšŒì „ ì ê¸ˆ ì‹¤ì œ ì ìš©
  void _applyOrientationLock(bool locked) {
    if (locked) {
      // ì„¸ë¡œ ëª¨ë“œë§Œ í—ˆìš©
      SystemChrome.setPreferredOrientations([
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
    } else {
      // ëª¨ë“  ë°©í–¥ í—ˆìš©
      SystemChrome.setPreferredOrientations([
        DeviceOrientation.landscapeRight,
        DeviceOrientation.landscapeLeft,
        DeviceOrientation.portraitUp,
        DeviceOrientation.portraitDown,
      ]);
    }
  }

  /// ì„¤ì • ìƒˆë¡œê³ ì¹¨
  Future<void> refresh() async {
    await _loadSettings();
  }
}\n\n// ====== lib/core/di/momentary_provider.dart ======\n
\n\n// ====== lib/core/config/app_config.dart ======\n
// lib/core/config/app_config.dart

import 'dart:collection';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import '../utils/logger.dart';

/// Application-wide configuration and constants,
/// optimized per Upbit REST & WebSocket specifications.
class AppConfig {
  AppConfig._();

  /// Call once at startup to initialize dynamic config (env variables)
  static Future<void> init({String? envPath}) async {
    // Load .env (optional custom path) + validate
    try {
      if (envPath != null && envPath.isNotEmpty) {
        await dotenv.load(fileName: envPath);
      } else {
        await dotenv.load();
      }
      log.i('[AppConfig] .env loaded');
      _loadEnv();
    } catch (e, st) {
      log.e('[AppConfig] âš ï¸ Failed to load required env vars', e, st);
      throw Exception('[AppConfig] âš ï¸ Failed to load required env vars: $e');
    }

    log.i('[AppConfig] initialized (debug=$isDebugMode)');
  }

  static void _loadEnv() {
    const requiredKeys = ['UPBIT_API_KEY', 'UPBIT_API_SECRET'];
    for (final key in requiredKeys) {
      final value = dotenv.env[key];
      if (value == null || value.isEmpty) {
        throw Exception('[AppConfig] Missing required env var: $key');
      }
    }

    _upbitRestBase = dotenv.env['UPBIT_REST_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_REST_URL']!
        : _upbitRestBase;
    _upbitWsUrl = dotenv.env['UPBIT_WS_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_WS_URL']!
        : _upbitWsUrl;

    _apiKey = dotenv.env['UPBIT_API_KEY']!;
    _apiSecret = dotenv.env['UPBIT_API_SECRET']!;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ†• í†µì¼ëœ Bool í•´ì„ ìœ í‹¸ë¦¬í‹° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// í™˜ê²½ë³€ìˆ˜ì—ì„œ boolean ê°’ì„ ì•ˆì „í•˜ê³  ì¼ê´€ë˜ê²Œ íŒŒì‹±
  /// ì§€ì›í•˜ëŠ” true ê°’: 'true', '1', 'yes', 'on'
  /// ì§€ì›í•˜ëŠ” false ê°’: 'false', '0', 'no', 'off', null, ë¹ˆ ë¬¸ìì—´
  static bool _getBool(String key, {bool fallback = false}) {
    final value = dotenv.env[key]?.toLowerCase().trim();
    if (value == null || value.isEmpty) return fallback;
    
    // true ê°’ë“¤
    if (value == 'true' || value == '1' || value == 'yes' || value == 'on') {
      return true;
    }
    
    // false ê°’ë“¤
    if (value == 'false' || value == '0' || value == 'no' || value == 'off') {
      return false;
    }
    
    // ì•Œ ìˆ˜ ì—†ëŠ” ê°’ì´ë©´ fallback ì‚¬ìš©
    return fallback;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ API Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _apiKey = '';
  static String _apiSecret = '';
  static String get apiKey => _apiKey;
  static String get apiSecret => _apiSecret;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Environment Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// `true` when not in Dart VM product mode.
  static const bool isDebugMode = !bool.fromEnvironment('dart.vm.product');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ê°œë°œ ì¤‘ ì¡°ì ˆ ê°€ëŠ¥)
  static Level get logLevel {
    if (!isDebugMode) return Level.warning;
    final envLevel = dotenv.env['LOG_LEVEL']?.toLowerCase();
    switch (envLevel) {
      case 'verbose':
        return Level.verbose;
      case 'debug':
        return Level.debug;
      case 'info':
        return Level.info;
      case 'warning':
        return Level.warning;
      case 'error':
        return Level.error;
      default:
        return Level.debug;
    }
  }

  /// ğŸ”§ íŠ¹ì • ëª¨ë“ˆ ë¡œê·¸ on/off (í†µì¼ëœ ë°©ì‹ ì ìš©)
  static bool get enableSignalBusLog =>
      _getBool('ENABLE_SIGNAL_BUS_LOG', fallback: true);
  static bool get enableWebSocketLog =>
      _getBool('ENABLE_WEBSOCKET_LOG', fallback: true);
  static bool get enableTradeLog =>
      _getBool('ENABLE_TRADE_LOG', fallback: true);
  static bool get enableAdaptiveBackoffLog =>
      _getBool('ENABLE_ADAPTIVE_BACKOFF_LOG', fallback: true);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REST Configuration (ì—…ë¹„íŠ¸ 2025 ìŠ¤í™) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitRestBase = 'https://api.upbit.com/v1';
  static String get upbitRestBase => _upbitRestBase;
  
  /// ğŸ†• ì—…ë¹„íŠ¸ ë°±ì„œ 2025 ê¸°ì¤€ ë ˆì´íŠ¸ë¦¬ë°‹ (ê·¸ë£¹ë³„)
  /// ê³µê°œ API: ì´ˆë‹¹ 30íšŒ / ì‚¬ì  API: ì´ˆë‹¹ 8íšŒ
  static const Map<String, int> rateLimitByGroup = {
    'market': 30,      // ê³µê°œ API: /market/all, /ticker ë“±
    'candles': 30,     // ê³µê°œ API: /candles ë“±  
    'trades': 30,      // ê³µê°œ API: /trades ë“±
    'orderbook': 30,   // ê³µê°œ API: /orderbook ë“±
    'orders': 8,       // ì‚¬ì  API: ì£¼ë¬¸ ê´€ë ¨
    'accounts': 8,     // ì‚¬ì  API: ê³„ì • ê´€ë ¨
    'withdraws': 8,    // ì‚¬ì  API: ì¶œê¸ˆ ê´€ë ¨
    'deposits': 8,     // ì‚¬ì  API: ì…ê¸ˆ ê´€ë ¨
    'default': 8,      // ê¸°ë³¸ê°’: ì‚¬ì  API ê¸°ì¤€
  };
  
  /// ğŸ†• ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì¡°íšŒ
  static int getRateLimitForGroup(String group) {
    return rateLimitByGroup[group] ?? rateLimitByGroup['default']!;
  }
  
  /// ğŸ†• ê²½ë¡œ ê¸°ë°˜ ê·¸ë£¹ ìë™ íŒë³„
  static String getGroupFromPath(String path) {
    final normalizedPath = path.toLowerCase();
    
    // ê³µê°œ API ê·¸ë£¹ë“¤
    if (normalizedPath.contains('/market/')) return 'market';
    if (normalizedPath.contains('/ticker')) return 'market';
    if (normalizedPath.contains('/candles/')) return 'candles';
    if (normalizedPath.contains('/trades')) return 'trades';  
    if (normalizedPath.contains('/orderbook')) return 'orderbook';
    
    // ì‚¬ì  API ê·¸ë£¹ë“¤
    if (normalizedPath.contains('/orders')) return 'orders';
    if (normalizedPath.contains('/accounts')) return 'accounts';
    if (normalizedPath.contains('/withdraws')) return 'withdraws';
    if (normalizedPath.contains('/deposits')) return 'deposits';
    
    // ê¸°ë³¸ê°’ (ì‚¬ì  API)
    return 'default';
  }
  
  /// ë ˆê±°ì‹œ í˜¸í™˜ìš© (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±)
  @Deprecated('Use rateLimitByGroup instead')
  static const int restRateLimitCount = 8; // ì‚¬ì  API ê¸°ì¤€ìœ¼ë¡œ ë³´ìˆ˜ì  ì„¤ì •
  static const Duration restRateLimitPeriod = Duration(seconds: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WebSocket Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitWsUrl = 'wss://api.upbit.com/websocket/v1';
  static String get upbitWsUrl => _upbitWsUrl;
  static const int wsMaxSubscriptionCount = 200;

  // Upbit ê¶Œì¥ íƒ€ì´ë°ìœ¼ë¡œ ë³€ê²½ (30s Ping / 60s Pong):
  static const Duration wsPingInterval = Duration(seconds: 30);
  static const Duration wsPongTimeout = Duration(seconds: 60);

  static const int wsMaxRetryCount = 5;
  static const Duration wsInitialBackoff = Duration(seconds: 1);
  static const Duration wsMaxBackoff = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Aggregation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const int mergeWindowMs = 1000;
  static const Duration globalResetInterval = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dev/Test Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static bool useTestDataInDev = false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trade Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static final List<double> _filters = [
    2e6, 5e6, 1e7, 2e7, 5e7,
    1e8, 2e8, 3e8, 4e8, 5e8,
    1e9,
  ];
  static UnmodifiableListView<double> get tradeFilters =>
      UnmodifiableListView(_filters);

  /// Human-readable labels always in sync with `_filters`
  static Map<double, String> get filterNames => Map.unmodifiable({
        for (final f in _filters) f: _formatFilterLabel(f),
      });

  /// Update the trade filters at runtime (ensures positive & sorted)
  static void updateFilters(List<double> newFilters) {
    _filters
      ..clear()
      ..addAll(newFilters.where((f) => f > 0))
      ..sort();
    log.i('[AppConfig] filters updated â†’ $_filters');
  }

  static String _formatFilterLabel(double f) {
    if (f >= 1e8 && f % 1e8 == 0) return '${(f / 1e8).toInt()}ì–µ';
    if (f >= 1e7 && f % 1e7 == 0) return '${(f / 1e7).toInt()}ì²œë§Œ';
    if (f >= 1e6 && f % 1e6 == 0) return '${(f / 1e6).toInt()}ë°±ë§Œ';
    return f.toStringAsFixed(0);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candle Timeframes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const List<int> timeFrames = [
    1, 5, 15, 30, 60, 120, 240, 480, 720, 1440
  ];
  static final Map<int, String> timeFrameNames = Map.unmodifiable({
    1: '1ë¶„',
    5: '5ë¶„',
    15: '15ë¶„',
    30: '30ë¶„',
    60: '1ì‹œê°„',
    120: '2ì‹œê°„',
    240: '4ì‹œê°„',
    480: '8ì‹œê°„',
    720: '12ì‹œê°„',
    1440: '1ì¼',
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Surge Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const double surgeThresholdPercent = 1.1;
  static const Duration surgeWindowDuration = Duration(minutes: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Signal Detection Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  /// Signal íŒ¨í„´ ëª©ë¡ (ìŠ¬ë¼ì´ë” ìˆœì„œì™€ ë™ì¼)
  static const List<String> signalPatterns = [
    'surge', 'flashFire', 'stackUp', 'stealthIn', 'blackHole', 'reboundShot'
  ];

  /// Signal íŒ¨í„´ í‘œì‹œëª…
  static const Map<String, String> signalPatternNames = {
    'surge': 'ê¸‰ë“±',
    'flashFire': 'ë¶ˆí‹°ğŸ”¥',
    'stackUp': 'ìŠ¤íƒì—…ğŸ’°',
    'stealthIn': 'ì¹¨íˆ¬ìğŸ‘£',
    'blackHole': 'ë¸”ë™í™€ğŸ•³ï¸',
    'reboundShot': 'ì‡¼íŠ¸í„°ì¹˜âš¡',
  };

  /// Signal íŒ¨í„´ ì„¤ëª…
  static const Map<String, String> signalPatternDescriptions = {
    'surge': '1ë¶„ ì „ ëŒ€ë¹„ 1.1% ì´ìƒ ìƒìŠ¹',
    'flashFire': '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ ê°ì§€',
    'stackUp': 'ì—°ì† ë§¤ì§‘ íŒ¨í„´ ê°ì§€',
    'stealthIn': 'ì€ë°€í•œ ìœ ì… ê°ì§€',
    'blackHole': 'ì´ìƒ ì²´ê²° íŒ¨í„´ ê°ì§€',
    'reboundShot': 'ë°˜ë“± íƒ€ì´ë° ê°ì§€',
  };

  /// íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’
  static const Map<String, double> signalThresholds = {
    'surge': 1.1,           // 1.1% ìƒìŠ¹ (ê¸°ì¡´ surgeThresholdPercentì™€ ë™ì¼)
    'flashFire': 2.0,       // 2ë°° ê¸‰ì¦
    'stackUp': 3.0,         // 3ì—°ì†
    'stealthIn': 5000000.0, // 500ë§Œì›
    'blackHole': 0.1,       // 0.1% ë³€ë™
    'reboundShot': 1.5,     // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
  };

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  static const Map<String, int> signalTimeWindows = {
    'surge': 1,       // 1ë¶„
    'flashFire': 3,   // 3ë¶„
    'stackUp': 3,     // 3ë¶„ (1ë¶„ì”© 3ë²ˆ)
    'stealthIn': 5,   // 5ë¶„
    'blackHole': 3,   // 3ë¶„
    'reboundShot': 2, // 2ë¶„ (ê¸‰ë½ 1ë¶„ + ë°˜ë“± 1ë¶„)
  };

  /// Signal ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int maxSignalsPerPattern = 100;
  static const int signalHistorySize = 200;
  static const int signalCacheSize = 1000;
  static const Duration signalHistoryRetention = Duration(minutes: 10);
  static const Duration signalBatchInterval = Duration(milliseconds: 100); // Tradeì™€ ë™ì¼

  /// Signal ë¶„ì„ìš© ìµœì†Œê°’ë“¤
  static const int minTradeCountForAnalysis = 10;
  static const int avgIntervalThreshold = 30; // ì´ˆ
  static const double blackHoleMinAmount = 50000000.0; // 5ì²œë§Œì›

  /// Signal íŒ¨í„´ ì¸ë±ìŠ¤ë¡œ íŒ¨í„´ëª… ì¡°íšŒ
  static String getSignalPatternByIndex(int index) {
    if (index < 0 || index >= signalPatterns.length) {
      return signalPatterns.first; // ê¸°ë³¸ê°’
    }
    return signalPatterns[index];
  }

  /// Signal íŒ¨í„´ëª…ìœ¼ë¡œ ì¸ë±ìŠ¤ ì¡°íšŒ
  static int getSignalPatternIndex(String pattern) {
    final index = signalPatterns.indexOf(pattern);
    return index >= 0 ? index : 0; // ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ íŒ¨í„´
  }

  /// Signal íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  static double getSignalThreshold(String pattern) {
    return signalThresholds[pattern] ?? signalThresholds['surge']!;
  }

  /// Signal íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° ì¡°íšŒ
  static int getSignalTimeWindow(String pattern) {
    return signalTimeWindows[pattern] ?? signalTimeWindows['surge']!;
  }

  /// Signal íŒ¨í„´ í‘œì‹œëª… ì¡°íšŒ
  static String getSignalPatternName(String pattern) {
    return signalPatternNames[pattern] ?? pattern;
  }

  /// Signal íŒ¨í„´ ì„¤ëª… ì¡°íšŒ
  static String getSignalPatternDescription(String pattern) {
    return signalPatternDescriptions[pattern] ?? '';
  }
}\n\n// ====== lib/core/config/trade_config.dart ======\n
\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ì œë„¤ë¦­)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ í”Œë«í¼ë³„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} â†’ $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} â†’ ${msg.substring(0, 100)}â€¦');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/core/network/websocket/ticker_ws_client.dart ======\n
// lib/core/network/websocket/ticker_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜„ì¬ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TickerWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TickerWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'ticker-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'ticker',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/candle_ws_client.dart ======\n
// lib/core/network/websocket/candle_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œìº”ë“¤â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
/// [timeFrame]: e.g. "1m", "5m", "15m", ...
class CandleWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  CandleWsClient({
    required String timeFrame,
    void Function(WsStatus)? onStatusChange,
  }) : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'candle-$timeFrame-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'candles_$timeFrame',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œì²´ê²°â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
// lib/core/network/websocket/base_ws_client.dart

import 'dart:async';
import 'dart:convert';

import 'package:web_socket_channel/web_socket_channel.dart';

import '../../config/app_config.dart';
import '../../error/app_exception.dart';
import '../adaptive_backoff.dart';               // AdaptiveBackoff ì—°ë™
import '../ws_rate_limiter_interceptor.dart';
import '../../utils/logger.dart';                // â† logger import

typedef DecodeFn<T> = T Function(dynamic json);
typedef EncodeFn = String Function(List<String> symbols);

/// WebSocket connection status notifications.
enum WsStatus {
  connecting,
  connected,
  failed,
  disconnected,
  error,
  reconnecting,
  pongTimeout,
  maxRetryExceeded,
}

/// Common WebSocket client: connect, subscribe, reconnect, emit
class BaseWsClient<T> {
  /// Helper to decode a JSON list (or single object) into a List<Map<String, dynamic>>.
  static List<Map<String, dynamic>> decodeJsonList(dynamic raw) {
    final jsonObj = raw is String ? jsonDecode(raw) : raw;
    final list = jsonObj is List ? jsonObj : [jsonObj];
    return list
        .cast<Map<String, dynamic>>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final void Function(WsStatus)? onStatusChange;
  final WsRateLimiter _rateLimiter;
  final AdaptiveBackoffCalculator _backoffCalculator =
      AdaptiveBackoffCalculator();
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  WebSocketChannel? _channel;
  final _controller = StreamController<T>.broadcast();
  List<String> _symbols = [];
  Timer? _pingTimer;
  Timer? _pongTimer;
  bool _disposed = false;
  bool _reconnecting = false;
  int _retryCount = 0;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    WsRateLimiter? rateLimiter,
  }) : _rateLimiter = rateLimiter ?? WsRateLimiter() {
    _startMemoryCleanup();
  }

  /// Start periodic cleanup of inactive subscriptions.
  void _startMemoryCleanup() {
    _memoryCleanupTimer =
        Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
    });
  }

  /// Clean up paused subscriptions to prevent memory leaks.
  void _cleanupInactiveSubscriptions() {
    final toRemove =
        _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      sub.cancel();
      _activeSubscriptions.remove(sub);
    }
    if (toRemove.isNotEmpty) {
      log.d('WSClient: Cleaned up ${toRemove.length} inactive subscriptions');
    }
  }

  /// ğŸ”¥ ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì•ˆì „í•˜ê²Œ ì •ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
  void _cleanupActiveSubscriptions() {
    if (_activeSubscriptions.isNotEmpty) {
      log.d('ğŸ§¹ ê¸°ì¡´ êµ¬ë… ${_activeSubscriptions.length}ê°œ ì •ë¦¬ ì¤‘...');
      
      for (final subscription in _activeSubscriptions) {
        try {
          subscription.cancel();
        } catch (e) {
          log.w('âš ï¸ êµ¬ë… ì·¨ì†Œ ì¤‘ ì—ëŸ¬: $e');
        }
      }
      
      _activeSubscriptions.clear();
      log.d('âœ… êµ¬ë… ì •ë¦¬ ì™„ë£Œ');
    }
  }

  /// Exposed stream of decoded messages.
  Stream<T> get stream => _controller.stream;

  /// Connect or reconnect with a new set of symbols.
  Future<void> connect(List<String> symbols) async {
    _notify(WsStatus.connecting);
    if (_disposed) return;
    _symbols = List.from(symbols);
    
    // ğŸ”¥ ì¬ì—°ê²° ì‹œ ê¸°ì¡´ êµ¬ë…ë“¤ ì •ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
    _cleanupActiveSubscriptions();
    
    await _channel?.sink.close();

    try {
      if (_symbols.length > AppConfig.wsMaxSubscriptionCount) {
        throw const WebSocketException('Subscribe limit exceeded');
      }
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _setupPing();
      _send(encodeSubscribe(_symbols));

      final subscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _retryCount = 0;
      _backoffCalculator.recordSuccess();
      _notify(WsStatus.connected);
      log.i('WS connected to $url (subscriptions: ${_symbols.length})');
    } catch (e, st) {
      log.w('WS connect failed: $e', e, st);
      _backoffCalculator.recordFailure();
      _notify(WsStatus.failed);
      _scheduleReconnect();
    }
  }

  void _handleData(dynamic raw) {
    _pongTimer?.cancel();
    try {
      final text = raw is List<int> ? utf8.decode(raw) : raw.toString();
      final jsonObj = jsonDecode(text);
      final data = decode(jsonObj);
      _controller.add(data);
    } catch (e, st) {
      log.e('WS processing error', e, st);
    }
  }

  void _handleDone() {
    log.i('WS closed by server');
    _notify(WsStatus.disconnected);
    _scheduleReconnect();
  }

  void _handleError(dynamic e) {
    log.e('WS error', e);
    _backoffCalculator.recordFailure();
    _notify(WsStatus.error);
    _scheduleReconnect();
  }

  void _send(String msg) => _rateLimiter.enqueue(() {
        try {
          _channel?.sink.add(msg);
          log.d('WS â–¶ $msg');
        } catch (e, st) {
          log.e('WS send error', e, st);
        }
      });

  void _setupPing() {
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _pingTimer =
        Timer.periodic(AppConfig.wsPingInterval, (_) {
      _send(jsonEncode({'type': 'ping'}));
      _pongTimer = Timer(AppConfig.wsPongTimeout, () {
        log.w('Pong timeout, reconnecting');
        _notify(WsStatus.pongTimeout);
        _scheduleReconnect();
      });
    });
    log.d('WS ping/pong timers set');
  }

  /// Schedule reconnection with adaptive backoff.
  void _scheduleReconnect() {
    if (_disposed || _reconnecting) return;
    _reconnecting = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();

    _backoffCalculator
        .calculateBackoff(
          _retryCount,
          AppConfig.wsInitialBackoff,
          AppConfig.wsMaxBackoff,
        )
        .then((delay) {
      if (_disposed) return;
      Future.delayed(delay, () {
        if (_disposed) return;
        if (_retryCount < AppConfig.wsMaxRetryCount) {
          _retryCount++;
          log.i(
            'Reconnect attempt #$_retryCount after ${delay.inMilliseconds}ms',
          );
          _notify(WsStatus.reconnecting);
          connect(_symbols).whenComplete(() => _reconnecting = false);
        } else {
          log.w('Max WS retries exceeded');
          _notify(WsStatus.maxRetryExceeded);
          _retryCount = 0;
          _reconnecting = false;
        }
      });
    });
  }

  void _notify(WsStatus status) => onStatusChange?.call(status);

  /// Dispose resources: timers, subscriptions, channel, controller, and backoff state.
  Future<void> dispose() async {
    _disposed = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _memoryCleanupTimer?.cancel();

    // ğŸ”¥ dispose ì‹œì—ë„ ì•ˆì „í•˜ê²Œ ì •ë¦¬
    _cleanupActiveSubscriptions();

    _rateLimiter.dispose();
    await _channel?.sink.close();
    await _controller.close();
    _backoffCalculator.recordSuccess(); // reset
    log.i('WSClient disposed');
  }
}\n\n// ====== lib/core/network/websocket/orderbook_ws_client.dart ======\n
// lib/core/network/websocket/orderbook_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜¸ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class OrderbookWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  OrderbookWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'orderbook-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'orderbook',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/api_client_coingecko.dart ======\n
// lib/core/network/api_client_coingecko.dart

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import '../../data/models/market_mood_dto.dart';
import '../error/app_exception.dart';
import '../utils/logger.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸
class CoinGeckoApiClient {
  static const String _baseUrl = 'https://api.coingecko.com/api/v3';
  static const String _pathGlobal = '/global';
  static const String _exchangeRateUrl = 'https://api.exchangerate-api.com/v4/latest/USD';
  static const String _keyRates = 'rates';
  static const String _keyKrw = 'KRW';

  static const Duration _timeout = Duration(seconds: 10);
  
  final Dio _dio;
  
  CoinGeckoApiClient({Dio? dio}) : _dio = dio ?? _createDio();
  
  static Dio _createDio() {
    final dio = Dio(BaseOptions(
      baseUrl: _baseUrl,
      connectTimeout: _timeout,
      receiveTimeout: _timeout,
      sendTimeout: _timeout,
      headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
    ));
    
    if (kDebugMode) {
      dio.interceptors.add(LogInterceptor(
        requestBody: false,
        responseBody: false,
        logPrint: (object) => log.d('[CoinGecko API] $object'),
      ));
    }
    
    return dio;
  }
  
  /// ğŸ¯ ì „ì²´ ì‹œì¥ ë°ì´í„° ì¡°íšŒ
  Future<CoinGeckoGlobalResponseDto> getGlobalMarketData() async {
    try {
      final response = await _dio.get(_pathGlobal);
      if (response.statusCode == 200 && response.data != null) {
        return CoinGeckoGlobalResponseDto.fromJson(response.data);
      } else {
        throw NetworkException(
          'Invalid response from CoinGecko API: ${response.statusCode}',
          statusCode: response.statusCode,
        );
      }
    } on DioException catch (e) {
      log.e('[CoinGecko] DioException: ${e.message}', e);
      throw NetworkException.fromDio(e);
    } catch (e, stackTrace) {
      log.e('[CoinGecko] Unexpected error: $e', e, stackTrace);
      throw AppException('Failed to fetch market data: $e');
    }
  }

  /// ğŸ’± USD â†’ KRW í™˜ìœ¨ ì¡°íšŒ
  Future<double> getUsdToKrwRate() async {
    try {
      final response = await _dio.get(_exchangeRateUrl);
      if (response.statusCode == 200 && response.data != null) {
        final data = response.data as Map<String, dynamic>;
        final rates = data[_keyRates] as Map<String, dynamic>;
        final krwRate = (rates[_keyKrw] ?? 1400.0).toDouble();
        return krwRate;
      } else {
        throw NetworkException('Invalid response from Exchange Rate API: ${response.statusCode}',
          statusCode: response.statusCode,
        );
      }
    } on DioException {
      log.w('[ExchangeRate] DioException, using fallback rate 1400.0');
      return 1400.0;
    } catch (e) {
      log.w('[ExchangeRate] Unexpected error: $e, using fallback rate 1400.0');
      return 1400.0;
    }
  }
}\n\n// ====== lib/core/network/auth_interceptor.dart ======\n
// lib/core/network/auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// Upbit REST API í˜¸ì¶œ ì‹œ JWT ë°©ì‹ì˜ ì¸ì¦ í—¤ë”ë¥¼ ë¶™ì—¬ì¤ë‹ˆë‹¤.
/// - payloadì— access_key, nonce, (query_hash, query_hash_alg)ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.
/// - ì•Œê³ ë¦¬ì¦˜: HS256
class AuthInterceptor extends Interceptor {
  final String apiKey;
  final String apiSecret;

  AuthInterceptor({required this.apiKey, required this.apiSecret});

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    try {
      final nonce = DateTime.now().millisecondsSinceEpoch.toString();
      final payload = <String, dynamic>{
        'access_key': apiKey,
        'nonce': nonce,
      };

      if (options.queryParameters.isNotEmpty || _hasRequestBody(options)) {
        final raw = options.queryParameters.isNotEmpty
            ? Uri(queryParameters: options.queryParameters).query
            : jsonEncode(options.data);
        payload['query_hash'] = sha512.convert(utf8.encode(raw)).toString();
        payload['query_hash_alg'] = 'SHA512';
      }

      // JWT Header and Payload
      const headerMap = {'alg': 'HS256', 'typ': 'JWT'};
      final headerJson = jsonEncode(headerMap);
      final payloadJson = jsonEncode(payload);
      final headerSeg = _base64UrlEncode(headerJson);
      final payloadSeg = _base64UrlEncode(payloadJson);

      // Signature
      final sigBytes = Hmac(sha256, utf8.encode(apiSecret))
          .convert(utf8.encode('$headerSeg.$payloadSeg'))
          .bytes;
      final sigSeg = base64Url.encode(sigBytes).replaceAll('=', '');

      options.headers['Authorization'] =
          'Bearer $headerSeg.$payloadSeg.$sigSeg';
    } catch (e, st) {
      log.e('AuthInterceptor error', e, st);
      return handler.reject(
        DioException(requestOptions: options, error: e),
      );
    }

    handler.next(options);
  }

  bool _hasRequestBody(RequestOptions options) {
    final data = options.data;
    if (data == null) return false;
    if (data is String) return data.isNotEmpty;
    if (data is Iterable || data is Map) return data.isNotEmpty;
    if (data is FormData) return data.fields.isNotEmpty || data.files.isNotEmpty;
    return true;
  }

  String _base64UrlEncode(String input) =>
      base64Url.encode(utf8.encode(input)).replaceAll('=', '');
}
\n\n// ====== lib/core/network/adaptive_backoff.dart ======\n
// lib/core/network/adaptive_backoff.dart

import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../utils/logger.dart';

class AdaptiveBackoffCalculator {
  final Connectivity _connectivity = Connectivity();
  int _consecutiveFailures = 0;
  DateTime? _lastFailureTime;
  
  // ë„¤íŠ¸ì›Œí¬ë³„ ê¸°ë³¸ ì§€í„° ê³„ìˆ˜ (connectivity_plus ì—°ë™)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.8,      // WiFiëŠ” ë¹ ë¥¸ ì¬ì—°ê²°
    ConnectivityResult.mobile: 1.2,    // ëª¨ë°”ì¼ì€ ë³´ìˆ˜ì 
    ConnectivityResult.ethernet: 0.6,  // ìœ ì„ ì€ ê°€ì¥ ë¹ ë¦„
    ConnectivityResult.none: 2.0,      // ì—°ê²° ì—†ìŒì€ ë§¤ìš° ë³´ìˆ˜ì 
  };

  Future<Duration> calculateBackoff(int attempt, Duration baseDelay, Duration maxDelay) async {
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0; // ê¸°ë³¸ê°’
    
    final failurePenalty = _calculateFailurePenalty();
    
    final exponentialMs = baseDelay.inMilliseconds * (1 << attempt);
    final cappedMs = math.min(exponentialMs, maxDelay.inMilliseconds);
    
    // ì§€í„° ë²”ìœ„ 20%ë¡œ ë¹ ë¥¸ ì¬ì—°ê²° ë³´ì¥
    final jitterRange = cappedMs * 0.2;
    final random = math.Random();
    final adaptiveJitter = random.nextDouble() * jitterRange * networkMultiplier * failurePenalty;
    
    final finalMs = math.max(0, cappedMs + adaptiveJitter.round());
    
    log.d('AdaptiveBackoff: attempt=$attempt, network=$connectivityResult, '
          'base=${cappedMs}ms, jitter=${adaptiveJitter.round()}ms, final=${finalMs}ms');
    
    return Duration(milliseconds: finalMs);
  }

  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;
    
    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      _consecutiveFailures = 0;
      return 1.0;
    }
    
    // í˜ë„í‹° ìƒí•œ 1.5ë°°ë¡œ ì¡°ì • (ê·¸ë¡ì˜ ìˆ˜ì •ì‚¬í•­ ìœ ì§€)
    return math.min(1.5, 1.0 + (_consecutiveFailures * 0.2));
  }

  void recordFailure() {
    _consecutiveFailures++;
    _lastFailureTime = DateTime.now();
  }

  void recordSuccess() {
    _consecutiveFailures = 0;
    _lastFailureTime = null;
  }
}\n\n// ====== lib/core/network/retry_interceptor.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 429 í˜¹ì€ 5xx ì—ëŸ¬ì— ëŒ€í•´ ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„° ë°©ì‹ìœ¼ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤.
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialBackoff;
  final Duration maxBackoff;
  final double jitterFactor;

  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialBackoff = const Duration(milliseconds: 500),
    this.maxBackoff = const Duration(seconds: 5),
    this.jitterFactor = 0.2,
  });

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    final options = err.requestOptions;
    final retryCount = (options.extra['retry_count'] as int?) ?? 0;
    final status = err.response?.statusCode;

    if (_shouldRetry(err) && retryCount < maxRetries) {
      final next = retryCount + 1;
      options.extra['retry_count'] = next;

      // 429 ì‘ë‹µì¼ ê²½ìš° ì„œë²„ê°€ ì œê³µí•˜ëŠ” í—¤ë” ìš°ì„  ì‚¬ìš©
      Duration delay;
      if (status == 429) {
        final retryAfter = err.response?.headers.value('Retry-After');
        if (retryAfter != null) {
          final secs = int.tryParse(retryAfter) ?? 0;
          delay = Duration(seconds: secs);
          log.i('Retry #$next after Retry-After header: ${delay.inSeconds}s');
        } else {
          final remaining = err.response?.headers.value('Remaining-Req');
          if (remaining != null) {
            log.d('Remaining-Req header: $remaining');
          }
          delay = _computeBackoff(next);
        }
      } else {
        // 5xx ì—ëŸ¬ëŠ” ê¸°ë³¸ ë°±ì˜¤í”„ ì‚¬ìš©
        delay = _computeBackoff(next);
      }

      log.i('Retry #$next for [${options.method} ${options.path}] in ${delay.inMilliseconds}ms');
      await Future.delayed(delay);

      try {
        final response = await dio.fetch(options);
        return handler.resolve(response);
      } on DioException catch (e) {
        return handler.next(e);
      }
    }

    handler.next(err);
  }

  bool _shouldRetry(DioException err) {
    final status = err.response?.statusCode;
    return err.type == DioExceptionType.badResponse &&
        (status == 429 || (status != null && status >= 500 && status < 600));
  }

  Duration _computeBackoff(int attempt) {
    final expMs = initialBackoff.inMilliseconds * (1 << (attempt - 1));
    final cap = min(expMs, maxBackoff.inMilliseconds);
    final jitter = ((Random().nextDouble() * 2 - 1) * jitterFactor * cap).round();
    final finalMs = max(0, cap + jitter);
    return Duration(milliseconds: finalMs);
  }
}
\n\n// ====== lib/core/network/ws_rate_limiter_interceptor.dart ======\n
// lib/core/network/ws_rate_limiter_interceptor.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../utils/logger.dart';

/// Upbit WebSocket êµ¬ë… ë©”ì‹œì§€ ë°œí–‰ ê°„ ìµœì†Œ ê°„ê²© ë³´ì¥ ìœ í‹¸
class WsRateLimiter {
  final Duration minInterval;
  final Queue<VoidCallback> _queue = Queue<VoidCallback>();
  bool _isFlushing = false;
  DateTime _lastSent = DateTime.fromMillisecondsSinceEpoch(0);

  WsRateLimiter({this.minInterval = const Duration(milliseconds: 500)});

  /// ë©”ì‹œì§€ë¥¼ íì— ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ì „ì†¡ ì‹œë„
  void enqueue(VoidCallback send) {
    _queue.add(send);
    _flushNext();
  }

  void _flushNext() {
    if (_isFlushing || _queue.isEmpty) return;
    _isFlushing = true;

    final now = DateTime.now();
    final elapsed = now.difference(_lastSent);
    final delay = elapsed >= minInterval ? Duration.zero : minInterval - elapsed;

    Timer(delay, () {
      final send = _queue.removeFirst();
      try {
        send();
        _lastSent = DateTime.now();
        log.d('WsRateLimiter sent, next after \${minInterval.inMilliseconds}ms');
      } catch (e, st) {
        log.e('WsRateLimiter send error', e, st);
      } finally {
        _isFlushing = false;
        if (_queue.isNotEmpty) _flushNext();
      }
    });
  }

  /// íë¥¼ ë¹„ìš°ê³  ì‚¬ìš© ì¤‘ì§€
  void dispose() {
    _queue.clear();
  }
}
\n\n// ====== lib/core/network/api_client.dart ======\n
// lib/core/network/api_client.dart

import 'dart:async';
import 'dart:collection';
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';
import 'auth_interceptor.dart';
import 'retry_interceptor.dart';
import 'logging_interceptor.dart';

typedef Json = Map<String, dynamic>;

/// ğŸ†• ì—…ë¹„íŠ¸ ë°±ì„œ 2025 ê¸°ì¤€ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ê´€ë¦¬ì
/// Remaining-Req í—¤ë”ë¥¼ íŒŒì‹±í•˜ì—¬ ê·¸ë£¹ë³„ ì‹¤ì‹œê°„ ìŠ¬ë¡¯ ê³„ì‚°
class _UpbitDynamicRateLimiter {
  final Map<String, _GroupRateLimiter> _groupLimiters = {};
  final Duration _defaultPeriod = const Duration(seconds: 1);
  
  /// ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ ì—…ë°ì´íŠ¸
  /// í˜•ì‹: "Remaining-Req: group=market; min=900; sec=29"
  void updateFromHeaders(Map<String, List<String>> headers) {
    try {
      final remainingReq = headers['remaining-req']?.first ?? 
                          headers['Remaining-Req']?.first;
      if (remainingReq == null) return;
      
      // í—¤ë” íŒŒì‹±: group=market; min=900; sec=29
      final parsedInfo = _parseRemainingReqHeader(remainingReq);
      if (parsedInfo != null) {
        _updateGroupLimiter(
          parsedInfo.group, 
          parsedInfo.remaining, 
          Duration(seconds: parsedInfo.windowSec)
        );
        
        if (AppConfig.enableTradeLog) {
          log.i('Rate limit updated: ${parsedInfo.group}=${parsedInfo.remaining} req in ${parsedInfo.windowSec}s');
        }
      }
      
      // Req-Group í—¤ë”ë„ í™•ì¸ (ê·¸ë£¹ ì •ë³´ë§Œ)
      final reqGroup = headers['req-group']?.first ?? 
                      headers['Req-Group']?.first;
      if (reqGroup != null && _groupLimiters[reqGroup] == null) {
        _initializeGroupLimiter(reqGroup);
      }
      
    } catch (e, st) {
      log.w('Failed to parse rate limit headers: $e', e, st);
    }
  }
  
  /// Remaining-Req í—¤ë” íŒŒì‹±
  _RemainingReqInfo? _parseRemainingReqHeader(String header) {
    try {
      final parts = header.split(';').map((p) => p.trim()).toList();
      String? group;
      int? remaining;
      int? windowSec;
      
      for (final part in parts) {
        final kv = part.split('=');
        if (kv.length != 2) continue;
        
        final key = kv[0].trim().toLowerCase();
        final value = kv[1].trim();
        
        switch (key) {
          case 'group':
            group = value;
            break;
          case 'min':
          case 'remaining':
            remaining = int.tryParse(value);
            break;
          case 'sec':
          case 'window':
            windowSec = int.tryParse(value);
            break;
        }
      }
      
      if (group != null && remaining != null && windowSec != null) {
        return _RemainingReqInfo(group, remaining, windowSec);
      }
    } catch (e) {
      log.w('Failed to parse Remaining-Req header: $header, error: $e');
    }
    return null;
  }
  
  /// ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì´ˆê¸°í™”
  void _initializeGroupLimiter(String group) {
    final maxRequests = AppConfig.getRateLimitForGroup(group);
    _groupLimiters[group] = _GroupRateLimiter(
      group: group,
      maxRequests: maxRequests,
      period: _defaultPeriod,
    );
    
    if (AppConfig.enableTradeLog) {
      log.d('Initialized rate limiter for group: $group ($maxRequests rps)');
    }
  }
  
  /// ê·¸ë£¹ë³„ ë ˆì´íŠ¸ë¦¬ë°‹ ì—…ë°ì´íŠ¸ (ì„œë²„ ì‘ë‹µ ê¸°ë°˜)
  void _updateGroupLimiter(String group, int remaining, Duration window) {
    var limiter = _groupLimiters[group];
    if (limiter == null) {
      _initializeGroupLimiter(group);
      limiter = _groupLimiters[group]!;
    }
    
    // ì„œë²„ì—ì„œ ë°›ì€ ì •ë³´ë¡œ ë™ì  ì—…ë°ì´íŠ¸
    limiter.updateFromServer(remaining, window);
  }
  
  /// íŠ¹ì • ê·¸ë£¹ì˜ throttle ì‹¤í–‰
  Future<void> throttle(String group, String path) async {
    // ê·¸ë£¹ ë¦¬ë°‹ì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
    if (!_groupLimiters.containsKey(group)) {
      _initializeGroupLimiter(group);
    }
    
    final limiter = _groupLimiters[group]!;
    await limiter.throttle(path);
  }
  
  /// ë””ë²„ê·¸ ì •ë³´ ì œê³µ
  Map<String, dynamic> getDebugInfo() {
    return {
      'activeGroups': _groupLimiters.keys.toList(),
      'groupStats': {
        for (final entry in _groupLimiters.entries)
          entry.key: entry.value.getStats(),
      },
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    for (final limiter in _groupLimiters.values) {
      limiter.dispose();
    }
    _groupLimiters.clear();
  }
}

/// í—¤ë” íŒŒì‹± ê²°ê³¼ ì •ë³´
class _RemainingReqInfo {
  final String group;
  final int remaining;
  final int windowSec;
  
  _RemainingReqInfo(this.group, this.remaining, this.windowSec);
}

/// ê°œë³„ ê·¸ë£¹ì˜ ë ˆì´íŠ¸ë¦¬ë°‹ ê´€ë¦¬ì
class _GroupRateLimiter {
  final String group;
  int _maxRequests;
  final Duration _period;
  final Queue<DateTime> _timestamps = Queue<DateTime>();
  
  // ì„œë²„ ê¸°ë°˜ ë™ì  ì •ë³´
  int? _serverRemaining;
  DateTime? _serverUpdateTime;
  Duration? _serverWindow;
  
  _GroupRateLimiter({
    required this.group,
    required int maxRequests,
    required Duration period,
  }) : _maxRequests = maxRequests, _period = period;
  
  /// ì„œë²„ ì‘ë‹µ ê¸°ë°˜ ì—…ë°ì´íŠ¸
  void updateFromServer(int remaining, Duration window) {
    _serverRemaining = remaining;
    _serverUpdateTime = DateTime.now();
    _serverWindow = window;
    
    // ì„œë²„ ì •ë³´ê°€ ë” ì œí•œì ì´ë©´ í´ë¼ì´ì–¸íŠ¸ ì œí•œë„ ì¡°ì •
    if (remaining < _maxRequests) {
      final adjustedMax = (remaining * 0.9).floor(); // 10% ì—¬ìœ 
      if (adjustedMax > 0 && adjustedMax < _maxRequests) {
        log.i('Adjusting rate limit for $group: $_maxRequests â†’ $adjustedMax (server: $remaining)');
        _maxRequests = adjustedMax;
      }
    }
  }
  
  /// throttle ì‹¤í–‰
  Future<void> throttle(String path) async {
    final now = DateTime.now();
    
    // ì„œë²„ ì •ë³´ ê¸°ë°˜ ì¶”ê°€ ì²´í¬
    if (_shouldWaitForServerLimit(now)) {
      final waitTime = _calculateServerWaitTime(now);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for server rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
      }
    }
    
    // í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ë ˆì´íŠ¸ë¦¬ë°‹
    _cleanOldTimestamps(now);
    
    if (_timestamps.length >= _maxRequests) {
      final oldestTime = _timestamps.first;
      final waitTime = _period - now.difference(oldestTime);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for client rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
        _cleanOldTimestamps(DateTime.now());
      }
    }
    
    _timestamps.addLast(DateTime.now());
  }
  
  /// ì„œë²„ ì œí•œ ëŒ€ê¸° í•„ìš” ì—¬ë¶€
  bool _shouldWaitForServerLimit(DateTime now) {
    if (_serverRemaining == null || _serverUpdateTime == null || _serverWindow == null) {
      return false;
    }
    
    // ì„œë²„ ì •ë³´ê°€ 5ë¶„ ì´ìƒ ì˜¤ë˜ëìœ¼ë©´ ë¬´ì‹œ
    if (now.difference(_serverUpdateTime!).inMinutes > 5) {
      return false;
    }
    
    return _serverRemaining! <= 5; // ì„œë²„ ì”ì—¬ ìš”ì²­ì´ 5ê°œ ì´í•˜
  }
  
  /// ì„œë²„ ê¸°ë°˜ ëŒ€ê¸° ì‹œê°„ ê³„ì‚°
  Duration _calculateServerWaitTime(DateTime now) {
    if (_serverUpdateTime == null || _serverWindow == null) {
      return Duration.zero;
    }
    
    final elapsed = now.difference(_serverUpdateTime!);
    final remaining = _serverWindow! - elapsed;
    
    return remaining > Duration.zero ? remaining : Duration.zero;
  }
  
  /// ì˜¤ë˜ëœ íƒ€ì„ìŠ¤íƒ¬í”„ ì •ë¦¬
  void _cleanOldTimestamps(DateTime now) {
    while (_timestamps.isNotEmpty && 
           now.difference(_timestamps.first) > _period) {
      _timestamps.removeFirst();
    }
  }
  
  /// í†µê³„ ì •ë³´
  Map<String, dynamic> getStats() {
    return {
      'group': group,
      'maxRequests': _maxRequests,
      'period': _period.inSeconds,
      'currentRequests': _timestamps.length,
      'serverRemaining': _serverRemaining,
      'serverLastUpdate': _serverUpdateTime?.toIso8601String(),
      'availableSlots': _maxRequests - _timestamps.length,
    };
  }
  
  void dispose() {
    _timestamps.clear();
  }
}

/// In-memory cache entry with timestamp.
class _MemCacheEntry<T> {
  final T data;
  final DateTime ts;
  _MemCacheEntry(this.data) : ts = DateTime.now();

  bool fresh(Duration dur) => DateTime.now().difference(ts) < dur;
}

/// Simple LRU cache based on insertion order, with a maxEntries limit.
class _MemCache {
  final int maxEntries;
  final Map<String, _MemCacheEntry<dynamic>> _box;

  _MemCache({this.maxEntries = 100}) : _box = <String, _MemCacheEntry<dynamic>>{};

  T? get<T>(String key, Duration dur) {
    final entry = _box[key];
    if (entry == null || !entry.fresh(dur)) return null;
    return entry.data as T;
  }

  void put<T>(String key, T data) {
    if (_box.length >= maxEntries) {
      final oldestKey = _box.keys.first;
      _box.remove(oldestKey);
    }
    _box[key] = _MemCacheEntry<T>(data);
  }

  void invalidate(String key) => _box.remove(key);

  void clear() => _box.clear();
}

/// Converts a query map into a stable, sorted query string.
/// Silently skips values that cannot be represented.
String _stableQueryString(Json? query) {
  if (query == null || query.isEmpty) return '';
  try {
    final entries = query.entries
      .where((e) => e.value != null)
      .toList()
      ..sort((a, b) => a.key.compareTo(b.key));
    final params = <String, String>{};
    for (final e in entries) {
      final v = e.value;
      if (v is List) {
        params[e.key] = v.join(',');
      } else {
        params[e.key] = v.toString();
      }
    }
    return Uri(queryParameters: params).query;
  } catch (e, st) {
    log.e('StableQueryString failed', e, st);
    return '';
  }
}

/// ğŸ†• ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ë¥¼ íŒŒì‹±í•˜ëŠ” ì¸í„°ì…‰í„°
class _RateLimitResponseInterceptor extends Interceptor {
  final _UpbitDynamicRateLimiter rateLimiter;
  
  _RateLimitResponseInterceptor(this.rateLimiter);
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // ì—…ë¹„íŠ¸ ì‘ë‹µ í—¤ë”ì—ì„œ ë ˆì´íŠ¸ë¦¬ë°‹ ì •ë³´ ì—…ë°ì´íŠ¸
    rateLimiter.updateFromHeaders(response.headers.map);
    handler.next(response);
  }
}

/// ğŸ”¥ ì™„ì „íˆ ì¬êµ¬í˜„ëœ ApiClient - ì—…ë¹„íŠ¸ ë°±ì„œ 100% ì¤€ìˆ˜
/// - ê·¸ë£¹ë³„ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ (ê³µê°œ 30rps / ì‚¬ì  8rps)
/// - Remaining-Req í—¤ë” ì‹¤ì‹œê°„ íŒŒì‹±
/// - ì„œë²„ ì‘ë‹µ ê¸°ë°˜ ë™ì  ìŠ¬ë¡¯ ì¡°ì •
class ApiClient {
  final Dio _dio;
  final _MemCache _cache;
  final _UpbitDynamicRateLimiter _rateLimiter;

  /// [apiKey], [apiSecret] ëŠ” Upbit Open API ìê²©ì¦ëª…
  ApiClient({
    Dio? dio,
    required String apiKey,
    required String apiSecret,
    int cacheSize = 100,
  })  : _dio = dio ?? Dio(),
        _cache = _MemCache(maxEntries: cacheSize),
        _rateLimiter = _UpbitDynamicRateLimiter() {
    _dio.interceptors.addAll([
      AuthInterceptor(apiKey: apiKey, apiSecret: apiSecret),
      RetryInterceptor(dio: _dio),
      LoggingInterceptor(),
      _RateLimitResponseInterceptor(_rateLimiter), // ğŸ†• ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ì¸í„°ì…‰í„°
    ]);
  }

  /// [method]: GET, POST ë“±
  /// [path]: ì „ì²´ URL ë˜ëŠ” baseUrl ì´í›„ ê²½ë¡œ
  /// [query]: URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
  /// [body]: JSON ë°”ë””
  /// [cacheDur]: nullì´ ì•„ë‹ ë•Œ ìºì‹œ ì‚¬ìš© (ê¸°ê°„ ì§€ì •)
  /// [rateLimitGroup]: ìˆ˜ë™ ê·¸ë£¹ ì§€ì • (ì„ íƒì )
  Future<Result<R, NetworkException>> request<R>({
    required String method,
    required String path,
    Json? query,
    Json? body,
    Duration? cacheDur,
    String? rateLimitGroup,
  }) async {
    // ğŸ”¥ ì—…ë¹„íŠ¸ ë°±ì„œ ê¸°ì¤€ ê·¸ë£¹ë³„ ë™ì  ë ˆì´íŠ¸ë¦¬ë°‹ ì ìš©
    final group = rateLimitGroup ?? AppConfig.getGroupFromPath(path);
    await _rateLimiter.throttle(group, path);

    String? cacheKey;
    if (cacheDur != null) {
      final qstr = _stableQueryString(query);
      cacheKey = '$method|$path|$qstr';
      final cached = _cache.get<R>(cacheKey, cacheDur);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      final response = await _dio.request<R>(
        path,
        queryParameters: query,
        data: body,
        options: Options(method: method),
      );

      final data = response.data;
      if (cacheKey != null && data != null) {
        _cache.put<R>(cacheKey, data as R);
      }

      return Ok(data as R);
    } on DioException catch (dioErr) {
      return Err(NetworkException.fromDio(dioErr));
    } catch (e, st) {
      log.e('ApiClient unexpected error', e, st);
      final ex = e is Exception ? e : Exception(e.toString());
      return Err(NetworkException(e.toString(), originalException: ex));
    }
  }
  
  /// ğŸ†• ë ˆì´íŠ¸ë¦¬ë°‹ ë””ë²„ê·¸ ì •ë³´ ì¡°íšŒ
  Map<String, dynamic> getRateLimitDebugInfo() {
    return _rateLimiter.getDebugInfo();
  }
  
  /// ğŸ†• ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _rateLimiter.dispose();
    _cache.clear();
  }
}\n\n// ====== lib/core/network/logging_interceptor.dart ======\n
// lib/core/network/logging_interceptor.dart

import 'dart:convert';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// ëª¨ë“  REST ìš”ì²­ê³¼ ì‘ë‹µ, ì˜¤ë¥˜ë¥¼ ë¡œê¹…í•©ë‹ˆë‹¤.
/// ğŸ”’ ë³´ì•ˆ: access_key, signature ë“± ë¯¼ê° ì •ë³´ ìë™ ë§ˆìŠ¤í‚¹
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(options.uri);
    log.i('--> ${options.method} $secureUri');
    
    // ğŸ”’ í—¤ë” ë³´ì•ˆ ë§ˆìŠ¤í‚¹ (Authorization í—¤ë”)
    if (options.headers.containsKey('Authorization')) {
      log.d('Headers: Authorization: Bearer ***[MASKED]***');
    }
    
    if (options.data != null && options.data is! String) {
      try {
        final sanitizedData = _sanitizeRequestData(options.data);
        log.d('Request Data:\n${const JsonEncoder.withIndent('  ').convert(sanitizedData)}');
      } catch (e, st) {
        log.d('Request Data serialization failed', e, st);
      }
    }
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(response.requestOptions.uri);
    log.i('<-- ${response.statusCode} $secureUri');
    
    final text = response.data is String
        ? response.data as String
        : response.data.toString();
    if (text.isNotEmpty) {
      log.d(text.length > 500 ? '${text.substring(0, 500)}...' : text);
    }
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // ğŸ”’ URL ë³´ì•ˆ ë§ˆìŠ¤í‚¹
    final secureUri = _sanitizeUri(err.requestOptions.uri);
    log.e('<-- Error ${err.response?.statusCode} $secureUri', err, err.stackTrace);
    handler.next(err);
  }

  /// ğŸ”’ URIì—ì„œ ë¯¼ê° ì •ë³´ ë§ˆìŠ¤í‚¹
  String _sanitizeUri(Uri uri) {
    final uriString = uri.toString();
    return uriString
        .replaceAll(RegExp(r'access_key=[^&?#]+'), 'access_key=***')
        .replaceAll(RegExp(r'signature=[^&?#]+'), 'signature=***')
        .replaceAll(RegExp(r'nonce=[^&?#]+'), 'nonce=***')
        .replaceAll(RegExp(r'api_key=[^&?#]+'), 'api_key=***')
        .replaceAll(RegExp(r'secret=[^&?#]+'), 'secret=***');
  }

  /// ğŸ”’ ìš”ì²­ ë°ì´í„°ì—ì„œ ë¯¼ê° ì •ë³´ ë§ˆìŠ¤í‚¹
  dynamic _sanitizeRequestData(dynamic data) {
    if (data is Map<String, dynamic>) {
      final sanitized = <String, dynamic>{};
      for (final entry in data.entries) {
        final key = entry.key.toLowerCase();
        if (_isSensitiveKey(key)) {
          sanitized[entry.key] = '***[MASKED]***';
        } else {
          sanitized[entry.key] = _sanitizeRequestData(entry.value);
        }
      }
      return sanitized;
    } else if (data is List) {
      return data.map((item) => _sanitizeRequestData(item)).toList();
    }
    return data;
  }

  /// ğŸ”’ ë¯¼ê°í•œ í‚¤ íŒë³„
  bool _isSensitiveKey(String key) {
    const sensitiveKeys = {
      'access_key', 'accesskey', 'api_key', 'apikey',
      'secret', 'signature', 'nonce', 'password', 
      'token', 'auth', 'authorization'
    };
    return sensitiveKeys.contains(key);
  }
}\n\n// ====== lib/core/navigation/app_router.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../config/app_config.dart';
import '../../shared/widgets/notification_service.dart';
import '../../presentation/pages/main_page.dart'; // ğŸ†• MainPage ì‚¬ìš©

/// ğŸ—‘ï¸ ê°œë³„ ë¼ìš°íŠ¸ enum ì œê±° (ì´ì œ MainPageì—ì„œ ê´€ë¦¬)
// enum AppRouteëŠ” ë” ì´ìƒ í•„ìš” ì—†ìŒ

class AppRouter {
  final WidgetRef ref;
  final GlobalKey<NavigatorState> navigatorKey;
  late final GoRouter router;

  AppRouter(this.ref, this.navigatorKey) {
    router = GoRouter(
      navigatorKey: navigatorKey,
      initialLocation: '/', // ë©”ì¸ í˜ì´ì§€ë¡œ ì‹œì‘
      debugLogDiagnostics: AppConfig.isDebugMode,
      routes: [
        // ğŸ†• ë‹¨ì¼ ë©”ì¸ ë¼ìš°íŠ¸ (PageView ê¸°ë°˜)
        GoRoute(
          path: '/',
          name: 'main',
          builder: (context, state) => const MainPage(),
        ),
        
        // ğŸ”§ í•„ìš”ì‹œ ì¶”ê°€ ë¼ìš°íŠ¸ë“¤ (ì„¤ì •, ìƒì„¸ í˜ì´ì§€ ë“±)
        // GoRoute(
        //   path: '/detail/:id',
        //   name: 'detail',
        //   builder: (context, state) => DetailPage(id: state.params['id']!),
        // ),
      ],
    );
  }

  /// ğŸ”§ Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (NotificationServiceì— ìœ„ì„)
  void setupFCMListeners() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.setupFirebaseListeners(navigatorKey);
  }

  /// ğŸ”§ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (NotificationServiceì— ìœ„ì„)
  void dispose() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.dispose();
  }
}\n\n// ====== lib/core/utils/pattern_config.dart ======\n
import '../../domain/entities/signal.dart';

/// ğŸ¯ PatternConfig - íŒ¨í„´ë³„ ì„¤ì •ê°’ ê´€ë¦¬
/// 
/// ê°œì„ ì‚¬í•­:
/// - 4,5ë²ˆ íŒ¨í„´ ì™„í™”ëœ ì„¤ì •ê°’ ì ìš©
/// - íŒ¨í„´ë³„ ê°œë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ê´€ë¦¬
/// - ì„¤ì •ê°’ ìœ íš¨ì„± ê²€ì‚¬
/// - ëŸ°íƒ€ì„ ì„¤ì • ë³€ê²½ ì§€ì›
class PatternConfig {
  
  /// ğŸ“Š íŒ¨í„´ë³„ ê¸°ë³¸ ì„¤ì •ê°’ (4,5ë²ˆ íŒ¨í„´ ì™„í™”ë¨)
  static const Map<PatternType, Map<String, double>> _defaultConfig = {
    PatternType.surge: {
      'priceChangePercent': 0.4,       // ê°€ê²© ë³€ë™ë¥  0.4%
      'zScoreThreshold': 1.7,          // Z-score ì„ê³„ê°’
      'minTradeAmount': 2500000,       // ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ (250ë§Œ)
      'lvThreshold': 500,              // Liquidity Vortex
    },
    
    PatternType.flashFire: {
      'zScoreThreshold': 2.2,          // Z-score ì„ê³„ê°’
      'minTradeAmount': 10000000,      // ìµœì†Œ ê±°ë˜ëŒ€ê¸ˆ (1000ë§Œ)
      'buyRatioMin': 0.7,              // ë§¤ìˆ˜ ë¹„ìœ¨
      'volumeMultiplier': 2.0,         // ê±°ë˜ëŸ‰ ë°°ìˆ˜
      'mbrThreshold': 0.12,            // Micro Burst Radar
      'mrThreshold': 0.15,             // Machine Rush
    },
    
    PatternType.stackUp: {
      'consecutiveMin': 2,             // ìµœì†Œ ì—°ì† íšŸìˆ˜
      'minVolume': 5000000,            // ìµœì†Œ ê±°ë˜ëŸ‰ (500ë§Œ)
      'zScoreThreshold': 1.0,          // Z-score ì„ê³„ê°’
      'volumeMultiplier': 1.5,         // ê±°ë˜ëŸ‰ ë°°ìˆ˜
      'rSquaredMin': 0.35,             // RÂ² ìµœì†Œê°’
    },
    
    // ğŸ†• StealthIn íŒ¨í„´ - ì™„í™”ëœ ì„¤ì • (ê°ì§€ìœ¨ í–¥ìƒ)
    PatternType.stealthIn: {
      'minTradeAmount': 5000000,       // 2000ë§Œ â†’ 500ë§Œ (ëŒ€í­ ì™„í™”)
      'intervalVarianceMax': 900,      // ê±°ë˜ ê°„ê²© ë¶„ì‚° ìµœëŒ€ê°’
      'buyRatioMin': 0.6,              // 0.7 â†’ 0.6 (ì™„í™”)
      'avgTradeSizeRatio': 0.4,        // í‰ê·  ê±°ë˜ í¬ê¸° ë¹„ìœ¨
      'minTradeCount': 20,             // ìµœì†Œ ê±°ë˜ íšŸìˆ˜
      'cvThreshold': 0.05,             // ë³€ë™ê³„ìˆ˜ ì„ê³„ê°’ (5%)
    },
    
    // ğŸ†• BlackHole íŒ¨í„´ - ì™„í™”ëœ ì„¤ì • (ê°ì§€ìœ¨ í–¥ìƒ)
    PatternType.blackHole: {
      'minTradeAmount': 10000000,      // 5000ë§Œ â†’ 1000ë§Œ (ëŒ€í­ ì™„í™”)
      'cvThreshold': 0.02,             // 0.01 â†’ 0.02 (ì™„í™”)
      'buyRatioMin': 0.35,             // 0.4 â†’ 0.35 (ì™„í™”)
      'buyRatioMax': 0.65,             // 0.6 â†’ 0.65 (ì™„í™”)
      'priceZScoreMax': 1.0,           // ê°€ê²© Z-score ìµœëŒ€ê°’
      'stdDevRatio': 0.02,             // í‘œì¤€í¸ì°¨ ë¹„ìœ¨ (2%)
    },
    
    PatternType.reboundShot: {
      'minVolume': 1000000,            // ìµœì†Œ ê±°ë˜ëŸ‰ (100ë§Œ)
      'priceRangeMin': 0.005,          // ìµœì†Œ ê°€ê²© ë²”ìœ„ (0.5%)
      'jumpThreshold': 0,              // Jump Gate ì„ê³„ê°’
    },
  };

  /// ğŸ”’ íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ (ì„±ëŠ¥ ìµœì í™”)
  static const Map<PatternType, Duration> _cooldownPeriods = {
    PatternType.surge: Duration(seconds: 2),        // ë¹ ë¥¸ íŒ¨í„´
    PatternType.flashFire: Duration(seconds: 3),    // ì¤‘ê°„ íŒ¨í„´
    PatternType.stackUp: Duration(seconds: 4),      // ì¤‘ê°„ íŒ¨í„´
    PatternType.stealthIn: Duration(seconds: 8),    // ëŠë¦° íŒ¨í„´ (ë§¤ì§‘ íŠ¹ì„±ìƒ)
    PatternType.blackHole: Duration(seconds: 10),   // ê°€ì¥ ëŠë¦° íŒ¨í„´ (ê°‡í˜ íŠ¹ì„±ìƒ)
    PatternType.reboundShot: Duration(seconds: 3),  // ì¤‘ê°„ íŒ¨í„´
  };

  /// í˜„ì¬ ì„¤ì •ê°’ (ëŸ°íƒ€ì„ ë³€ê²½ ê°€ëŠ¥)
  final Map<PatternType, Map<String, double>> _currentConfig;
  
  /// ìƒì„±ì
  PatternConfig({Map<PatternType, Map<String, double>>? customConfig}) 
    : _currentConfig = customConfig != null 
        ? Map.from(customConfig)
        : _deepCopyConfig(_defaultConfig);

  /// íŒ¨í„´ë³„ ì„¤ì •ê°’ ì¡°íšŒ
  Map<String, double> getPatternConfig(PatternType pattern) {
    return Map.from(_currentConfig[pattern] ?? <String, double>{});
  }

  /// íŠ¹ì • ì„¤ì •ê°’ ì¡°íšŒ
  double getConfigValue(PatternType pattern, String key) {
    return _currentConfig[pattern]?[key] ?? 0.0;
  }

  /// íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„ ì¡°íšŒ
  Duration getCooldownDuration(PatternType pattern) {
    return _cooldownPeriods[pattern] ?? const Duration(seconds: 5);
  }

  /// ğŸ› ï¸ ëŸ°íƒ€ì„ ì„¤ì • ë³€ê²½
  
  /// íŠ¹ì • íŒ¨í„´ì˜ ì„¤ì •ê°’ ì—…ë°ì´íŠ¸
  void updatePatternConfig(PatternType pattern, String key, double value) {
    if (_isValidConfigValue(pattern, key, value)) {
      _currentConfig[pattern] ??= <String, double>{};
      _currentConfig[pattern]![key] = value;
    } else {
      throw ArgumentError('Invalid config value: $key = $value for pattern ${pattern.name}');
    }
  }

  /// íŒ¨í„´ì˜ ì „ì²´ ì„¤ì • ì—…ë°ì´íŠ¸
  void updateFullPatternConfig(PatternType pattern, Map<String, double> config) {
    // ìœ íš¨ì„± ê²€ì‚¬
    for (final entry in config.entries) {
      if (!_isValidConfigValue(pattern, entry.key, entry.value)) {
        throw ArgumentError('Invalid config value: ${entry.key} = ${entry.value} for pattern ${pattern.name}');
      }
    }
    
    _currentConfig[pattern] = Map.from(config);
  }

  /// ì„¤ì •ê°’ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  void resetToDefault(PatternType? pattern) {
    if (pattern != null) {
      _currentConfig[pattern] = Map.from(_defaultConfig[pattern] ?? <String, double>{});
    } else {
      _currentConfig.clear();
      _currentConfig.addAll(_deepCopyConfig(_defaultConfig));
    }
  }

  /// ğŸ” ì„¤ì •ê°’ ìœ íš¨ì„± ê²€ì‚¬
  bool _isValidConfigValue(PatternType pattern, String key, double value) {
    // ìŒìˆ˜ ê°’ ë°©ì§€
    if (value < 0) return false;
    
    // íŒ¨í„´ë³„ íŠ¹ìˆ˜ ê²€ì‚¬
    switch (pattern) {
      case PatternType.surge:
        if (key == 'priceChangePercent' && (value < 0.1 || value > 10.0)) return false;
        if (key == 'zScoreThreshold' && (value < 0.5 || value > 5.0)) return false;
        break;
        
      case PatternType.flashFire:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'volumeMultiplier' && (value < 1.0 || value > 10.0)) return false;
        break;
        
      case PatternType.stackUp:
        if (key == 'consecutiveMin' && (value < 1 || value > 10)) return false;
        if (key == 'rSquaredMin' && (value < 0.0 || value > 1.0)) return false;
        break;
        
      case PatternType.stealthIn:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'cvThreshold' && (value < 0.001 || value > 0.5)) return false;
        break;
        
      case PatternType.blackHole:
        if (key == 'buyRatioMin' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'buyRatioMax' && (value < 0.0 || value > 1.0)) return false;
        if (key == 'cvThreshold' && (value < 0.001 || value > 0.5)) return false;
        break;
        
      case PatternType.reboundShot:
        if (key == 'priceRangeMin' && (value < 0.001 || value > 0.5)) return false;
        break;
    }
    
    return true;
  }

  /// ì„¤ì • ê¹Šì€ ë³µì‚¬
  static Map<PatternType, Map<String, double>> _deepCopyConfig(
    Map<PatternType, Map<String, double>> source
  ) {
    final result = <PatternType, Map<String, double>>{};
    for (final entry in source.entries) {
      result[entry.key] = Map.from(entry.value);
    }
    return result;
  }

  /// ğŸ“Š ì„¤ì •ê°’ ì •ë³´ ì¡°íšŒ
  
  /// ëª¨ë“  íŒ¨í„´ì˜ ì„¤ì •ê°’ ì¡°íšŒ
  Map<PatternType, Map<String, double>> getAllPatternConfigs() {
    return _deepCopyConfig(_currentConfig);
  }

  /// ê¸°ë³¸ê°’ê³¼ í˜„ì¬ê°’ ë¹„êµ
  Map<String, dynamic> getConfigComparison(PatternType pattern) {
    final current = _currentConfig[pattern] ?? <String, double>{};
    final defaultValues = _defaultConfig[pattern] ?? <String, double>{};
    
    final comparison = <String, Map<String, double>>{};
    final allKeys = <String>{...current.keys, ...defaultValues.keys};
    
    for (final key in allKeys) {
      comparison[key] = {
        'current': current[key] ?? 0.0,
        'default': defaultValues[key] ?? 0.0,
        'isModified': (current[key] ?? 0.0) != (defaultValues[key] ?? 0.0) ? 1.0 : 0.0,
      };
    }
    
    return {
      'pattern': pattern.name,
      'cooldownSeconds': getCooldownDuration(pattern).inSeconds,
      'configs': comparison,
      'totalModified': comparison.values
          .where((v) => v['isModified'] == 1.0)
          .length,
    };
  }

  /// ì„¤ì • ìš”ì•½ ì •ë³´
  Map<String, dynamic> getConfigSummary() {
    final summary = <String, dynamic>{
      'version': '4.0',
      'totalPatterns': PatternType.values.length,
      'enhancedPatterns': ['stealthIn', 'blackHole'], // ì™„í™”ëœ íŒ¨í„´ë“¤
    };
    
    // íŒ¨í„´ë³„ ì¿¨ë‹¤ìš´ ì‹œê°„
    final cooldowns = <String, String>{};
    for (final pattern in PatternType.values) {
      cooldowns[pattern.name] = '${getCooldownDuration(pattern).inSeconds}s';
    }
    summary['cooldownPeriods'] = cooldowns;
    
    // ë³€ê²½ëœ ì„¤ì •ê°’ ê°œìˆ˜
    int totalModified = 0;
    for (final pattern in PatternType.values) {
      final current = _currentConfig[pattern] ?? <String, double>{};
      final defaultValues = _defaultConfig[pattern] ?? <String, double>{};
      
      for (final key in current.keys) {
        if (current[key] != defaultValues[key]) {
          totalModified++;
        }
      }
    }
    summary['totalModifiedConfigs'] = totalModified;
    
    // ì™„í™”ëœ ì„¤ì •ê°’ë“¤ (4,5ë²ˆ íŒ¨í„´)
    summary['relaxedSettings'] = {
      'stealthIn': {
        'minTradeAmount': '2000ë§Œ â†’ 500ë§Œ (75% ì™„í™”)',
        'buyRatioMin': '0.7 â†’ 0.6 (14% ì™„í™”)',
        'cvThreshold': 'ì¶”ê°€ë¨ (5%)',
      },
      'blackHole': {
        'minTradeAmount': '5000ë§Œ â†’ 1000ë§Œ (80% ì™„í™”)',
        'cvThreshold': '1% â†’ 2% (100% ì™„í™”)',
        'buyRatioRange': '40-60% â†’ 35-65% (25% í™•ëŒ€)',
      },
    };
    
    return summary;
  }

  /// ğŸ¯ í”„ë¦¬ì…‹ ì„¤ì •

  /// ë³´ìˆ˜ì  ì„¤ì • (False Positive ìµœì†Œí™”)
  void applyConservativePreset() {
    // Surge íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.surge, 'priceChangePercent', 0.6);
    updatePatternConfig(PatternType.surge, 'zScoreThreshold', 2.0);
    
    // FlashFire íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.flashFire, 'zScoreThreshold', 2.5);
    updatePatternConfig(PatternType.flashFire, 'buyRatioMin', 0.75);
    
    // StackUp íŒ¨í„´ ê°•í™”
    updatePatternConfig(PatternType.stackUp, 'consecutiveMin', 3);
    updatePatternConfig(PatternType.stackUp, 'rSquaredMin', 0.5);
    
    // StealthIn íŒ¨í„´ ê°•í™” (í•˜ì§€ë§Œ ì—¬ì „íˆ ê¸°ì¡´ë³´ë‹¤ëŠ” ì™„í™”)
    updatePatternConfig(PatternType.stealthIn, 'minTradeAmount', 8000000); // 800ë§Œ
    updatePatternConfig(PatternType.stealthIn, 'buyRatioMin', 0.65);
    
    // BlackHole íŒ¨í„´ ê°•í™” (í•˜ì§€ë§Œ ì—¬ì „íˆ ê¸°ì¡´ë³´ë‹¤ëŠ” ì™„í™”)
    updatePatternConfig(PatternType.blackHole, 'minTradeAmount', 15000000); // 1500ë§Œ
    updatePatternConfig(PatternType.blackHole, 'cvThreshold', 0.015);
  }

  /// ê³µê²©ì  ì„¤ì • (ê°ì§€ìœ¨ ìµœëŒ€í™”)
  void applyAggressivePreset() {
    // Surge íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.surge, 'priceChangePercent', 0.3);
    updatePatternConfig(PatternType.surge, 'zScoreThreshold', 1.5);
    
    // FlashFire íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.flashFire, 'zScoreThreshold', 2.0);
    updatePatternConfig(PatternType.flashFire, 'buyRatioMin', 0.65);
    
    // StackUp íŒ¨í„´ ì™„í™”
    updatePatternConfig(PatternType.stackUp, 'consecutiveMin', 2);
    updatePatternConfig(PatternType.stackUp, 'rSquaredMin', 0.25);
    
    // StealthIn íŒ¨í„´ ìµœëŒ€ ì™„í™”
    updatePatternConfig(PatternType.stealthIn, 'minTradeAmount', 3000000); // 300ë§Œ
    updatePatternConfig(PatternType.stealthIn, 'buyRatioMin', 0.55);
    
    // BlackHole íŒ¨í„´ ìµœëŒ€ ì™„í™”
    updatePatternConfig(PatternType.blackHole, 'minTradeAmount', 5000000); // 500ë§Œ
    updatePatternConfig(PatternType.blackHole, 'cvThreshold', 0.03);
    updatePatternConfig(PatternType.blackHole, 'buyRatioMin', 0.3);
    updatePatternConfig(PatternType.blackHole, 'buyRatioMax', 0.7);
  }

  /// ê· í˜• ì„¤ì • (ê¸°ë³¸ê°’)
  void applyBalancedPreset() {
    resetToDefault(null); // ëª¨ë“  íŒ¨í„´ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹
  }

  /// ğŸ§ª ë°±í…ŒìŠ¤íŒ…ìš© ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  
  /// ì„¤ì •ì„ JSON í˜•íƒœë¡œ ë‚´ë³´ë‚´ê¸°
  Map<String, dynamic> exportConfig() {
    final export = <String, dynamic>{
      'version': '4.0',
      'timestamp': DateTime.now().toIso8601String(),
      'patterns': <String, dynamic>{},
    };
    
    for (final pattern in PatternType.values) {
      export['patterns'][pattern.name] = {
        'config': getPatternConfig(pattern),
        'cooldownSeconds': getCooldownDuration(pattern).inSeconds,
      };
    }
    
    return export;
  }

  /// JSONì—ì„œ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  void importConfig(Map<String, dynamic> configData) {
    if (configData['version'] != '4.0') {
      throw ArgumentError('Unsupported config version: ${configData['version']}');
    }
    
    final patterns = configData['patterns'] as Map<String, dynamic>?;
    if (patterns == null) return;
    
    for (final pattern in PatternType.values) {
      final patternData = patterns[pattern.name] as Map<String, dynamic>?;
      if (patternData == null) continue;
      
      final config = patternData['config'] as Map<String, dynamic>?;
      if (config == null) continue;
      
      // double íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ì„¤ì • ì ìš©
      final doubleConfig = <String, double>{};
      for (final entry in config.entries) {
        if (entry.value is num) {
          doubleConfig[entry.key] = (entry.value as num).toDouble();
        }
      }
      
      if (doubleConfig.isNotEmpty) {
        updateFullPatternConfig(pattern, doubleConfig);
      }
    }
  }

  /// ğŸ¯ A/B í…ŒìŠ¤íŠ¸ìš© ì„¤ì • ë³€í˜•
  
  /// íŠ¹ì • íŒ¨í„´ë§Œ ì¡°ì •í•œ ë³€í˜• ìƒì„±
  PatternConfig createVariant({
    PatternType? targetPattern,
    String? targetKey,
    double? multiplier,
  }) {
    if (targetPattern == null || targetKey == null || multiplier == null) {
      return PatternConfig(customConfig: getAllPatternConfigs());
    }
    
    final variantConfig = getAllPatternConfigs();
    final currentValue = getConfigValue(targetPattern, targetKey);
    
    if (currentValue > 0) {
      variantConfig[targetPattern] ??= <String, double>{};
      variantConfig[targetPattern]![targetKey] = currentValue * multiplier;
    }
    
    return PatternConfig(customConfig: variantConfig);
  }
}\n\n// ====== lib/core/utils/pattern_strategies.dart ======\n
\n\n// ====== lib/core/utils/date_time.dart ======\n
import 'package:intl/intl.dart';

/// DateTime extension utilities for formatting and comparison.
extension DateTimeX on DateTime {
  /// `2024-05-17 22:05:01` â†’ `22:05:01`
  String hhmmss() => DateFormat('HH:mm:ss').format(this);

  /// `2024-05-17` í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMdd() => DateFormat('yyyy-MM-dd').format(this);

  /// `22:05` í˜•ì‹ì˜ ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String hhmm() => DateFormat('HH:mm').format(this);

  /// `2024-05-17 22:05` í˜•ì‹ì˜ ë‚ ì§œ+ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMddhhmm() => DateFormat('yyyy-MM-dd HH:mm').format(this);

  /// í˜„ì¬ ì‹œê°„ê³¼ì˜ ì°¨ì´ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ í‘œì‹œ
  /// ì˜ˆ: 'ë°©ê¸ˆ ì „', '3ë¶„ ì „', '2ì‹œê°„ ì „', 'ì–´ì œ', '3ì¼ ì „', '2ì£¼ ì „', '5ê°œì›” ì „', '1ë…„ ì „'
  String timeAgo() {
    final now = DateTime.now();
    final diff = now.difference(this);

    if (diff.inSeconds < 60) return 'ë°©ê¸ˆ ì „';
    if (diff.inMinutes < 60) return '${diff.inMinutes}ë¶„ ì „';
    if (diff.inHours < 24) return '${diff.inHours}ì‹œê°„ ì „';
    if (diff.inDays < 2) return 'ì–´ì œ';
    if (diff.inDays < 7) return '${diff.inDays}ì¼ ì „';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}ì£¼ ì „';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}ê°œì›” ì „';
    return '${(diff.inDays / 365).floor()}ë…„ ì „';
  }

  /// UTC ë°€ë¦¬ì´ˆ(ms)ë¥¼ ë¡œì»¬ DateTimeìœ¼ë¡œ ë³€í™˜
  static DateTime fromEpochMs(int ms) =>
      DateTime.fromMillisecondsSinceEpoch(ms, isUtc: true).toLocal();

  /// ISO 8601 ë¬¸ìì—´ì„ ë¡œì»¬ DateTimeìœ¼ë¡œ íŒŒì‹±
  static DateTime parseIso8601(String iso) =>
      DateTime.parse(iso).toLocal();

  /// ë™ì¼í•œ ë‚ ì§œì¸ì§€ í™•ì¸
  bool isSameDay(DateTime other) =>
      year == other.year && month == other.month && day == other.day;

  /// ì˜¤ëŠ˜ì¸ì§€ í™•ì¸
  bool get isToday => isSameDay(DateTime.now());

  /// ì–´ì œì¸ì§€ í™•ì¸
  bool get isYesterday =>
      isSameDay(DateTime.now().subtract(const Duration(days: 1)));
}
\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';
import '../config/app_config.dart';

/// ê¸€ë¡œë²Œ Logger ì¸ìŠ¤í„´ìŠ¤
/// - ê°œë°œ ëª¨ë“œ: AppConfig.logLevelì— ë”°ë¼ ë™ì  ì¡°ì ˆ
/// - í”„ë¡œë•ì…˜ëª¨ë“œ: warning ì´ìƒ ìë™
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 0,      // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    errorMethodCount: 5, // ì˜¤ë¥˜ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120,     // ë¡œê·¸ í•œ ì¤„ ìµœëŒ€ ê¸¸ì´
    colors: true,        // ì»¬ëŸ¬ ì¶œë ¥ (í„°ë¯¸ë„)
    printTime: true,     // íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
  ),
  level: AppConfig.logLevel, // ğŸ”¥ í™˜ê²½ë³€ìˆ˜ë¡œ ë™ì  ì¡°ì ˆ ê°€ëŠ¥
);\n\n// ====== lib/core/utils/pattern_detector copy.dart ======\n
\n\n// ====== lib/core/utils/pattern_detector.dart ======\n
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import 'advanced_metrics.dart';
import 'pattern_config.dart';
import 'market_data_context.dart';

/// ğŸš€ PatternDetector V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// 1. âœ… OnlineAdvancedMetrics ì‚¬ìš©ìœ¼ë¡œ O(1) ì§€í‘œ ê³„ì‚°
/// 2. âœ… ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë³µêµ¬
/// 3. âœ… ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚°
/// 4. âœ… ì‹œí•œí­íƒ„ ë¬¸ì œ ì™„ì „ í•´ê²°
/// 5. âœ… ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜ì„± ìœ ì§€
class PatternDetector {
  final PatternConfig _config;
  final AdvancedMetrics _metrics;
  
  // ğŸ”’ ì¿¨ë‹¤ìš´ ì‹œìŠ¤í…œ (ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë³€ê²½)
  final Map<String, DateTime> _lastSignalTime = {};
  
  PatternDetector({
    PatternConfig? config,
    AdvancedMetrics? metrics,
  }) : _config = config ?? PatternConfig(),
        _metrics = metrics ?? AdvancedMetrics();

  /// ğŸ¯ ë©”ì¸ ê°ì§€ í•¨ìˆ˜ - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
  Signal? detectPattern({
    required PatternType patternType,
    required Trade trade,
    required DateTime timestamp,
    required MarketDataContext context,
  }) {
    // ğŸ”¥ ë¨¼ì € ì˜¨ë¼ì¸ ì§€í‘œ ì—…ë°ì´íŠ¸ (O(1))
    _metrics.updatePrice(
      market: trade.market,
      price: trade.price,
      timestamp: timestamp,
    );
    
    // ğŸ”’ ì¿¨ë‹¤ìš´ ì²´í¬
    if (_isInCooldown(trade.market, patternType, timestamp)) {
      return null;
    }
    
    Signal? signal;
    
    // íŒ¨í„´ë³„ ê°ì§€ ë¡œì§
    switch (patternType) {
      case PatternType.surge:
        signal = _detectSurge(trade, timestamp, context);
        break;
      case PatternType.flashFire:
        signal = _detectFlashFire(trade, timestamp, context);
        break;
      case PatternType.stackUp:
        signal = _detectStackUp(trade, timestamp, context);
        break;
      case PatternType.stealthIn:
        signal = _detectStealthIn(trade, timestamp, context);
        break;
      case PatternType.blackHole:
        signal = _detectBlackHole(trade, timestamp, context);
        break;
      case PatternType.reboundShot:
        signal = _detectReboundShot(trade, timestamp, context);
        break;
    }
    
    if (signal != null) {
      // ğŸ”’ ì¿¨ë‹¤ìš´ ë“±ë¡
      _updateCooldown(trade.market, patternType, timestamp);
      
      // ğŸ†• ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
      signal = _adjustSignalConfidence(signal, context);
    }
    
    return signal;
  }

  /// ğŸ”’ ì¿¨ë‹¤ìš´ ì²´í¬ (íŒ¨í„´ë³„ ê°œë³„ ì¿¨ë‹¤ìš´)
  bool _isInCooldown(String market, PatternType pattern, DateTime timestamp) {
    final cooldownKey = '$market-${pattern.name}';
    final lastTime = _lastSignalTime[cooldownKey];
    if (lastTime == null) return false;
    
    final cooldownDuration = _config.getCooldownDuration(pattern);
    return timestamp.difference(lastTime) < cooldownDuration;
  }
  
  /// ğŸ”’ ì¿¨ë‹¤ìš´ ë“±ë¡
  void _updateCooldown(String market, PatternType pattern, DateTime timestamp) {
    final cooldownKey = '$market-${pattern.name}';
    _lastSignalTime[cooldownKey] = timestamp;
  }

  /// ğŸ¯ 1. Surge íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectSurge(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 60));
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (priceWindow.length < 2 || volumeWindow.isEmpty) return null;

    final config = _config.getPatternConfig(PatternType.surge);
    final currentPrice = trade.price;
    final prevPrice = priceWindow.values[1];
    final changePercent = prevPrice == 0 ? 0.0 : ((currentPrice - prevPrice) / prevPrice) * 100;
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final zScore = priceWindow.zScore(currentPrice);
    final conditions = [
      changePercent.abs() >= config['priceChangePercent']!,
      zScore.abs() >= config['zScoreThreshold']!,
      volumeWindow.sum >= config['minTradeAmount']!,
    ];
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œ ì‚¬ìš© (O(1) ë³µì¡ë„)
    final rsi = _metrics.calculateRSI(market: trade.market);
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ê³ ê¸‰ ì§€í‘œ
    final lv = _metrics.calculateLiquidityVortex(priceWindow, volumeWindow);
    final flashPulse = _metrics.calculateFlashPulse(trade.total, volumeWindow);
    
    final advancedConditions = [
      lv >= config['lvThreshold']!,
      flashPulse > 0,
      // ğŸ†• ì˜¨ë¼ì¸ RSI/MACD ì¡°ê±´ ì¶”ê°€
      _isValidRSIForDirection(rsi, changePercent),
      macd.histogram.abs() > 0.1, // MACD ëª¨ë©˜í…€ ì²´í¬
    ];
    
    if (!conditions.every((c) => c) || !advancedConditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: currentPrice,
      changePercent: changePercent,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.surge,
      patternDetails: {
        'changePercent': changePercent,
        'zScore': zScore,
        'liquidityVortex': lv,
        'flashPulse': flashPulse,
        'rsi': rsi,
        'macd': macd.macd,
        'macdSignal': macd.signal,
        'macdHistogram': macd.histogram,
        'confidence': 0.8,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 2. FlashFire íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectFlashFire(Trade trade, DateTime timestamp, MarketDataContext context) {
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    final buyRatioWindow = context.buyRatioWindow;
    
    if (volumeWindow.length < 10 || buyRatioWindow == null) return null;
    
    final config = _config.getPatternConfig(PatternType.flashFire);
    final volumeZScore = volumeWindow.zScore(trade.total);
    final buyRatio = buyRatioWindow.mean;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final conditions = [
      volumeZScore >= config['zScoreThreshold']!,
      volumeWindow.sum >= config['minTradeAmount']!,
      buyRatio >= config['buyRatioMin']!,
      // ğŸ†• RSI ì˜¤ë²„ë°”ì‰/ì˜¤ë²„ì…€ë§ ë°©ì§€
      rsi > 20 && rsi < 80,
    ];
    
    // ê³ ê¸‰ ì§€í‘œ
    final microBurst = _metrics.calculateMicroBurstRadar(trade.total, volumeWindow);
    final machineRush = _metrics.calculateMachineRush(trade.total, volumeWindow.sum);
    
    final advancedConditions = [
      microBurst >= config['mbrThreshold']!,
      machineRush >= config['mrThreshold']!,
    ];
    
    if (!conditions.every((c) => c) || !advancedConditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.flashFire,
      patternDetails: {
        'volumeZScore': volumeZScore,
        'buyRatio': buyRatio,
        'microBurstRadar': microBurst,
        'machineRush': machineRush,
        'rsi': rsi,
        'confidence': 0.85,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 3. StackUp íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectStackUp(Trade trade, DateTime timestamp, MarketDataContext context) {
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (volumeWindow.length < 4) return null;
    
    final config = _config.getPatternConfig(PatternType.stackUp);
    final consecutiveCount = volumeWindow.consecutiveIncreases;
    final volumeZScore = volumeWindow.zScore(trade.total);
    
    // ğŸ”¥ ì˜¨ë¼ì¸ MACD ì²´í¬
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ê¸°ë³¸ ì¡°ê±´ë“¤
    final conditions = [
      consecutiveCount >= config['consecutiveMin']!,
      volumeWindow.sum >= config['minVolume']!,
      volumeZScore >= config['zScoreThreshold']!,
      // ğŸ†• MACD ìƒìŠ¹ ëª¨ë©˜í…€ ì²´í¬
      macd.histogram > 0, // MACD íˆìŠ¤í† ê·¸ë¨ ìƒìŠ¹
    ];
    
    // ì¶”ì„¸ ë¶„ì„
    final slope = volumeWindow.slope;
    final rSquared = volumeWindow.rSquared;
    final trendOk = slope > 0 && rSquared > config['rSquaredMin']!;
    
    if (!conditions.every((c) => c) || !trendOk) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: volumeWindow.sum,
      detectedAt: timestamp,
      patternType: PatternType.stackUp,
      patternDetails: {
        'consecutiveCount': consecutiveCount,
        'slope': slope,
        'rSquared': rSquared,
        'volumeZScore': volumeZScore,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.75,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ¯ 4. StealthIn íŒ¨í„´ ê°ì§€ (ì™„í™”ëœ ì„¤ì • + ì˜¨ë¼ì¸ ì§€í‘œ)
  Signal? _detectStealthIn(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 300)); // ì¥ê¸° ìœˆë„ìš° ì‚¬ìš©
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 300));
    final buyRatioWindow = context.buyRatioWindow;
    final intervalWindow = context.intervalWindow;
    
    if (volumeWindow.length < 15 || buyRatioWindow == null || intervalWindow == null) {
      return null;
    }
    
    final config = _config.getPatternConfig(PatternType.stealthIn);
    final totalAmount = volumeWindow.sum;
    final buyRatio = buyRatioWindow.mean;
    final priceStability = 1.0 - priceWindow.cv; // ë³€ë™ê³„ìˆ˜ì˜ ì—­ìˆ˜
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI - ì¤‘ë¦½ êµ¬ê°„ ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    
    // ğŸ†• ì™„í™”ëœ ì¡°ê±´ë“¤ + RSI ì²´í¬
    final conditions = [
      // "ì¡°ìš©íˆ ë§¤ì§‘" - ê°€ê²© ì•ˆì •ì„±
      priceStability >= 0.95, // CVê°€ 5% ì´í•˜
      priceWindow.zScore(trade.price).abs() <= 1.0,
      
      // "ê¾¸ì¤€í•œ ë§¤ìˆ˜" - ì™„í™”ëœ ì„ê³„ê°’ë“¤  
      buyRatio >= config['buyRatioMin']!, // 0.6 (ê¸°ì¡´ 0.7ì—ì„œ ì™„í™”)
      totalAmount >= config['minTradeAmount']!, // 500ë§Œ (ê¸°ì¡´ 2000ë§Œì—ì„œ ì™„í™”)
      volumeWindow.length >= config['minTradeCount']!,
      
      // "ê±°ë˜ ê°„ê²© ì¼ì •"
      intervalWindow.variance <= config['intervalVarianceMax']!,
      
      // ğŸ†• RSI ì¤‘ë¦½ êµ¬ê°„ (ì¡°ìš©í•œ ë§¤ì§‘ì‹œ ê·¹ë‹¨ê°’ íšŒí”¼)
      rsi >= 30 && rsi <= 70,
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: totalAmount,
      detectedAt: timestamp,
      patternType: PatternType.stealthIn,
      patternDetails: {
        'totalAmount': totalAmount,
        'buyRatio': buyRatio,
        'priceStability': priceStability,
        'tradeCount': volumeWindow.length,
        'rsi': rsi,
        'confidence': 0.7,
        'enhancement': 'V4.1 - Online + Relaxed Thresholds',
      },
    );
  }

  /// ğŸ¯ 5. BlackHole íŒ¨í„´ ê°ì§€ (ì™„í™”ëœ ì„¤ì • + ì˜¨ë¼ì¸ ì§€í‘œ)
  Signal? _detectBlackHole(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 300)); // ì¥ê¸° ìœˆë„ìš° ì‚¬ìš©
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 300));
    final buyRatioWindow = context.buyRatioWindow;
    
    if (priceWindow.length < 10 || volumeWindow.length < 10 || buyRatioWindow == null) {
      return null;
    }
    
    final config = _config.getPatternConfig(PatternType.blackHole);
    final totalVolume = volumeWindow.sum;
    final cv = priceWindow.cv;
    final buyRatio = buyRatioWindow.mean;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ MACD - íš¡ë³´ êµ¬ê°„ ì²´í¬
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // ğŸ†• ì™„í™”ëœ ì¡°ê±´ë“¤ + MACD ì²´í¬
    final conditions = [
      // "ì—„ì²­ë‚œ ê±°ë˜ëŸ‰" - ì™„í™”ëœ ì„ê³„ê°’
      totalVolume >= config['minTradeAmount']!, // 1000ë§Œ (ê¸°ì¡´ 5000ë§Œì—ì„œ ì™„í™”)
      
      // "ê°€ê²© ê°‡í˜" - ì™„í™”ëœ ë³€ë™ì„± ê¸°ì¤€
      cv <= config['cvThreshold']!, // 2% (ê¸°ì¡´ 1%ì—ì„œ ì™„í™”)
      priceWindow.zScore(trade.price).abs() <= config['priceZScoreMax']!,
      
      // "ë§¤ìˆ˜/ë§¤ë„ ê· í˜•" - ì™„í™”ëœ ë²”ìœ„
      buyRatio >= config['buyRatioMin']! && buyRatio <= config['buyRatioMax']!, // 35-65% (ê¸°ì¡´ 40-60%ì—ì„œ ì™„í™”)
      
      // ğŸ†• MACD íš¡ë³´ êµ¬ê°„ (ê°‡í˜ íŒ¨í„´ íŠ¹ì„±)
      macd.histogram.abs() < 50, // ì‘ì€ MACD íˆìŠ¤í† ê·¸ë¨
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: 0.0,
      volume: trade.volume,
      tradeAmount: totalVolume,
      detectedAt: timestamp,
      patternType: PatternType.blackHole,
      patternDetails: {
        'cv': cv,
        'buyRatio': buyRatio,
        'totalVolume': totalVolume,
        'stabilityIndex': 1.0 - cv,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.8,
        'enhancement': 'V4.1 - Online + Relaxed Thresholds',
      },
    );
  }

  /// ğŸ¯ 6. ReboundShot íŒ¨í„´ ê°ì§€ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Signal? _detectReboundShot(Trade trade, DateTime timestamp, MarketDataContext context) {
    final priceWindow = context.getPriceWindow(const Duration(seconds: 60));
    final volumeWindow = context.getVolumeWindow(const Duration(seconds: 60));
    
    if (priceWindow.length < 5) return null;
    
    final config = _config.getPatternConfig(PatternType.reboundShot);
    final prices = priceWindow.values;
    final low = prices.reduce(min);
    final high = prices.reduce(max);
    final recentVolume = volumeWindow.sum;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ RSI - ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± ì²´í¬
    final rsi = _metrics.calculateRSI(market: trade.market);
    final macd = _metrics.calculateMACD(market: trade.market);
    
    // Jump Gate ê³„ì‚°
    final jumpScore = _metrics.calculateJumpGate(trade.price, low, high, trade.total);
    final priceRange = (high - low) / low;
    
    final conditions = [
      // "ì˜ë¯¸ìˆëŠ” ë°˜ë“± ë²”ìœ„"
      priceRange >= config['priceRangeMin']!,
      
      // "ì í”„í•˜ëŠ” ì›€ì§ì„"
      jumpScore > 0,
      
      // "ê°•ë ¥í•œ ë§¤ìˆ˜ì„¸"
      recentVolume >= config['minVolume']!,
      
      // ğŸ†• RSI ê³¼ë§¤ë„ì—ì„œ ë°˜ë“± or MACD ê³¨ë“ í¬ë¡œìŠ¤
      (rsi < 35 && trade.price > low * 1.01) || // ê³¼ë§¤ë„ ë°˜ë“±
      (macd.histogram > 0 && macd.macd > macd.signal), // MACD ìƒìŠ¹
    ];
    
    if (!conditions.every((c) => c)) {
      return null;
    }
    
    return Signal(
      market: trade.market,
      name: trade.market.replaceAll('KRW-', ''),
      currentPrice: trade.price,
      changePercent: ((trade.price - low) / low) * 100,
      volume: trade.volume,
      tradeAmount: recentVolume,
      detectedAt: timestamp,
      patternType: PatternType.reboundShot,
      patternDetails: {
        'jumpScore': jumpScore,
        'priceRange': priceRange,
        'lowPrice': low,
        'highPrice': high,
        'rsi': rsi,
        'macd': macd.macd,
        'macdHistogram': macd.histogram,
        'confidence': 0.9,
        'version': 'V4.1-Online',
      },
    );
  }

  /// ğŸ†• ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ê¸°ë°˜ ì‹ ë¢°ë„ ì¡°ì •
  Signal _adjustSignalConfidence(Signal signal, MarketDataContext context) {
    try {
      final priceWindow = context.getPriceWindow(const Duration(seconds: 300));
      if (priceWindow.length < 5) return signal; // ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚° ë¶ˆê°€
      
      // ğŸ”¥ ì‹¤ì œ ì˜¨ë¼ì¸ RSI/MACD ì‚¬ìš©í•œ ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
      final divergence = _metrics.detectDivergence(
        market: signal.market,
        prices: priceWindow.values,
        indicator: [], // ì‚¬ìš© ì•ˆí•¨ (ì˜¨ë¼ì¸ RSI ì‚¬ìš©)
      );
      
      // ì‹ ë¢°ë„ ì¡°ì •
      double confidenceMultiplier = 1.0;
      
      if (signal.changePercent > 0 && divergence.isBearish) {
        // ìƒìŠ¹ ì‹ í˜¸ì¸ë° Bearish ë‹¤ì´ë²„ì „ìŠ¤ â†’ ì‹ ë¢°ë„ í•˜ë½
        confidenceMultiplier = max(0.3, 1.0 - (divergence.strength * 0.5));
      } else if (signal.changePercent < 0 && divergence.isBullish) {
        // í•˜ë½ ì‹ í˜¸ì¸ë° Bullish ë‹¤ì´ë²„ì „ìŠ¤ â†’ ì‹ ë¢°ë„ í•˜ë½
        confidenceMultiplier = max(0.3, 1.0 - (divergence.strength * 0.5));
      } else if ((signal.changePercent > 0 && divergence.isBullish) ||
                 (signal.changePercent < 0 && divergence.isBearish)) {
        // ì‹ í˜¸ì™€ ë‹¤ì´ë²„ì „ìŠ¤ ë°©í–¥ ì¼ì¹˜ â†’ ì‹ ë¢°ë„ ìƒìŠ¹
        confidenceMultiplier = min(1.5, 1.0 + (divergence.strength * 0.3));
      }
      
      // ì¡°ì •ëœ ì‹ ë¢°ë„ë¡œ ì‹ í˜¸ ì—…ë°ì´íŠ¸
      final adjustedDetails = Map<String, dynamic>.from(signal.patternDetails);
      adjustedDetails['originalConfidence'] = adjustedDetails['confidence'];
      adjustedDetails['confidenceMultiplier'] = confidenceMultiplier;
      adjustedDetails['finalConfidence'] = 
          (adjustedDetails['confidence'] as double) * confidenceMultiplier;
      adjustedDetails['divergence'] = {
        'isBullish': divergence.isBullish,
        'isBearish': divergence.isBearish,
        'strength': divergence.strength,
        'source': 'online-rsi', // ì˜¨ë¼ì¸ RSI ê¸°ë°˜ì„ì„ ëª…ì‹œ
      };
      
      return Signal(
        market: signal.market,
        name: signal.name,
        currentPrice: signal.currentPrice,
        changePercent: signal.changePercent,
        volume: signal.volume,
        tradeAmount: signal.tradeAmount,
        detectedAt: signal.detectedAt,
        patternType: signal.patternType,
        patternDetails: adjustedDetails,
      );
      
    } catch (e) {
      if (kDebugMode) {
        print('Confidence adjustment failed: $e');
      }
      return signal; // ì‹¤íŒ¨ì‹œ ì›ë³¸ ë°˜í™˜
    }
  }

  /// ğŸ› ï¸ í—¬í¼ í•¨ìˆ˜ë“¤

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì ‘ê·¼ì (Repositoryì—ì„œ ì‚¬ìš©)
  AdvancedMetrics get metrics => _metrics;

  /// RSI ë°©í–¥ì„± ê²€ì¦
  bool _isValidRSIForDirection(double rsi, double changePercent) {
    if (changePercent > 0) {
      // ìƒìŠ¹ì‹œ RSI 80 ì´í•˜ (ê³¼ë§¤ìˆ˜ íšŒí”¼)
      return rsi <= 80;
    } else if (changePercent < 0) {
      // í•˜ë½ì‹œ RSI 20 ì´ìƒ (ê³¼ë§¤ë„ íšŒí”¼)
      return rsi >= 20;
    }
    return true; // ë³€í™” ì—†ìœ¼ë©´ í†µê³¼
  }

  /// ì¿¨ë‹¤ìš´ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getCooldownStatus() {
    final now = DateTime.now();
    final status = <String, dynamic>{};
    
    for (final entry in _lastSignalTime.entries) {
      final parts = entry.key.split('-');
      final market = parts[0];
      final patternName = parts[1];
      
      final pattern = PatternType.values.firstWhere(
        (p) => p.name == patternName,
        orElse: () => PatternType.surge,
      );
      
      final cooldownDuration = _config.getCooldownDuration(pattern);
      final remainingMs = cooldownDuration.inMilliseconds - 
                         now.difference(entry.value).inMilliseconds;
      
      status[entry.key] = {
        'market': market,
        'pattern': patternName,
        'isInCooldown': remainingMs > 0,
        'remainingMs': max(0, remainingMs),
        'cooldownDurationSeconds': cooldownDuration.inSeconds,
      };
    }
    
    return status;
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì¿¨ë‹¤ìš´ í•´ì œ (ë””ë²„ê¹…ìš©)
  void clearCooldown(String market, PatternType pattern) {
    final cooldownKey = '$market-${pattern.name}';
    _lastSignalTime.remove(cooldownKey);
  }

  /// ëª¨ë“  ì¿¨ë‹¤ìš´ í•´ì œ (ë””ë²„ê¹…ìš©)
  void clearAllCooldowns() {
    _lastSignalTime.clear();
  }

  /// ğŸ†• ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Map<String, dynamic> getSystemHealth() {
    final metricsHealth = _metrics.getSystemHealth();
    
    return {
      'version': 'V4.1-Online',
      'patternDetector': {
        'activeCooldowns': _lastSignalTime.length,
        'cooldownEntries': getCooldownStatus(),
      },
      'onlineMetrics': metricsHealth,
      'improvements': [
        'Online RSI/MACD Integration',
        'Stream Gap Auto-Recovery',
        'O(1) Indicator Calculation',
        'Real Divergence Detection',
        'Stale Data Prevention',
      ],
    };
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _lastSignalTime.clear();
    _metrics.dispose();
  }
}\n\n// ====== lib/core/utils/advanced_metrics.dart ======\n
import 'dart:math';
import 'dart:developer' as developer;
import 'rolling_window.dart';

// ==========================================================================
// ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ë™ê¸°í™”ëœ ì˜¨ë¼ì¸ ê³„ì‚°ê¸°ë“¤
// ==========================================================================

/// ìŠ¤íŠ¸ë¦¼ ìƒëª…ì£¼ê¸°ì™€ ë™ê¸°í™”ëœ OnlineRSI
class StreamAwareOnlineRSI {
  final int period;
  final Duration maxGap; // í—ˆìš© ê°€ëŠ¥í•œ ìµœëŒ€ ë°ì´í„° ê°„ê²©
  
  final List<double> _prices = [];
  double _avgGain = 0.0;
  double _avgLoss = 0.0;
  bool _isInitialized = false;
  DateTime? _lastUpdate;
  
  StreamAwareOnlineRSI({
    required this.period, 
    this.maxGap = const Duration(seconds: 10),
  });
  
  void update(double price, DateTime timestamp) {
    // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë¦¬ì…‹
    if (_lastUpdate != null && 
        timestamp.difference(_lastUpdate!).abs() > maxGap) {
      reset();
      if (_prices.isNotEmpty) {
        developer.log('RSI Reset: Stream gap detected (${timestamp.difference(_lastUpdate!).inSeconds}s)', name: 'StreamAwareOnlineRSI');
      }
    }
    
    _lastUpdate = timestamp;
    _prices.add(price);
    
    if (_prices.length < 2) return;
    
    final change = _prices.last - _prices[_prices.length - 2];
    final gain = change > 0 ? change : 0.0;
    final loss = change < 0 ? change.abs() : 0.0;
    
    if (!_isInitialized && _prices.length >= period + 1) {
      // ì´ˆê¸° í‰ê·  ê³„ì‚°
      double gainSum = 0.0;
      double lossSum = 0.0;
      
      for (int i = 1; i <= period; i++) {
        final ch = _prices[i] - _prices[i - 1];
        if (ch > 0) {
          gainSum += ch;
        } else {
          lossSum += ch.abs();
        }
      }
      
      _avgGain = gainSum / period;
      _avgLoss = lossSum / period;
      _isInitialized = true;
    } else if (_isInitialized) {
      // ì§€ìˆ˜ì´ë™í‰ê·  ì—…ë°ì´íŠ¸
      _avgGain = ((_avgGain * (period - 1)) + gain) / period;
      _avgLoss = ((_avgLoss * (period - 1)) + loss) / period;
    }
    
    // ë©”ëª¨ë¦¬ ê´€ë¦¬: ìµœëŒ€ period * 2 ê°œì˜ ê°€ê²©ë§Œ ìœ ì§€
    if (_prices.length > period * 2) {
      _prices.removeAt(0);
    }
  }
  
  double get current {
    if (!_isInitialized || _avgLoss == 0) return 50.0;
    
    final rs = _avgGain / _avgLoss;
    return 100.0 - (100.0 / (1.0 + rs));
  }
  
  bool get isReady => _isInitialized;
  bool get isStale => _lastUpdate != null && 
      DateTime.now().difference(_lastUpdate!).abs() > maxGap;
  
  void reset() {
    _prices.clear();
    _avgGain = 0.0;
    _avgLoss = 0.0;
    _isInitialized = false;
    _lastUpdate = null;
  }
  
  /// ê±´ê°• ìƒíƒœ ì²´í¬
  Map<String, dynamic> getHealthStatus() {
    return {
      'isReady': isReady,
      'isStale': isStale,
      'dataPoints': _prices.length,
      'lastUpdate': _lastUpdate?.toIso8601String(),
      'timeSinceLastUpdate': _lastUpdate != null 
          ? DateTime.now().difference(_lastUpdate!).inSeconds 
          : null,
    };
  }
}

/// ìŠ¤íŠ¸ë¦¼ ë™ê¸°í™”ëœ OnlineMACD
class StreamAwareOnlineMACD {
  final int fastPeriod;
  final int slowPeriod;
  final int signalPeriod;
  final Duration maxGap;
  
  double _fastEMA = 0.0;
  double _slowEMA = 0.0;
  double _signalEMA = 0.0;
  
  final List<double> _macdHistory = [];
  bool _isInitialized = false;
  int _count = 0;
  DateTime? _lastUpdate;
  
  StreamAwareOnlineMACD({
    this.fastPeriod = 12,
    this.slowPeriod = 26,
    this.signalPeriod = 9,
    this.maxGap = const Duration(seconds: 10),
  });
  
  void update(double price, DateTime timestamp) {
    // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ ê°ì§€ ë° ìë™ ë¦¬ì…‹
    if (_lastUpdate != null && 
        timestamp.difference(_lastUpdate!).abs() > maxGap) {
      reset();
      developer.log('MACD Reset: Stream gap detected (${timestamp.difference(_lastUpdate!).inSeconds}s)', name: 'StreamAwareOnlineMACD');
    }
    
    _lastUpdate = timestamp;
    _count++;
    
    final fastAlpha = 2.0 / (fastPeriod + 1);
    final slowAlpha = 2.0 / (slowPeriod + 1);
    final signalAlpha = 2.0 / (signalPeriod + 1);
    
    if (_count == 1) {
      _fastEMA = price;
      _slowEMA = price;
    } else {
      _fastEMA = (price * fastAlpha) + (_fastEMA * (1 - fastAlpha));
      _slowEMA = (price * slowAlpha) + (_slowEMA * (1 - slowAlpha));
    }
    
    if (_count >= slowPeriod) {
      final macd = _fastEMA - _slowEMA;
      _macdHistory.add(macd);
      
      if (_macdHistory.length == 1) {
        _signalEMA = macd;
      } else {
        _signalEMA = (macd * signalAlpha) + (_signalEMA * (1 - signalAlpha));
      }
      
      _isInitialized = _macdHistory.length >= signalPeriod;
      
      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_macdHistory.length > signalPeriod * 2) {
        _macdHistory.removeAt(0);
      }
    }
  }
  
  double get macd => _count >= slowPeriod ? _fastEMA - _slowEMA : 0.0;
  double get signal => _signalEMA;
  double get histogram => macd - signal;
  bool get isReady => _isInitialized;
  bool get isStale => _lastUpdate != null && 
      DateTime.now().difference(_lastUpdate!).abs() > maxGap;
  
  MACDResult get current => MACDResult(
    macd: macd, 
    signal: signal, 
    histogram: histogram
  );
  
  void reset() {
    _fastEMA = 0.0;
    _slowEMA = 0.0;
    _signalEMA = 0.0;
    _macdHistory.clear();
    _isInitialized = false;
    _count = 0;
    _lastUpdate = null;
  }
  
  /// ê±´ê°• ìƒíƒœ ì²´í¬
  Map<String, dynamic> getHealthStatus() {
    return {
      'isReady': isReady,
      'isStale': isStale,
      'dataPoints': _count,
      'macdHistoryLength': _macdHistory.length,
      'lastUpdate': _lastUpdate?.toIso8601String(),
      'timeSinceLastUpdate': _lastUpdate != null 
          ? DateTime.now().difference(_lastUpdate!).inSeconds 
          : null,
    };
  }
}

// ==========================================================================
// ğŸ”¥ ì™„ì „íˆ ì˜¨ë¼ì¸í™”ëœ AdvancedMetrics (ë©”ì¸ í´ë˜ìŠ¤)
// ==========================================================================

/// ì™„ì „íˆ ì˜¨ë¼ì¸í™”ëœ AdvancedMetrics
/// 
/// ê¸°ì¡´ ë¬¸ì œì ë“¤ í•´ê²°:
/// 1. âŒ ìºì‹œ í‚¤ê°€ ë¶€ì •í™• â†’ âœ… ìºì‹œ ì œê±°, ì˜¨ë¼ì¸ ê³„ì‚°
/// 2. âŒ calculateMACD O(nÂ²) â†’ âœ… O(1) ì˜¨ë¼ì¸ ì—…ë°ì´íŠ¸
/// 3. âŒ ë§¤ë²ˆ ì „ì²´ ì¬ê³„ì‚° â†’ âœ… ìƒˆ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸
/// 4. âŒ ìŠ¤íŠ¸ë¦¼ ëŠê¹€ì‹œ ì˜¤ì—¼ â†’ âœ… ìë™ ê°ì§€ ë° ë¦¬ì…‹
class AdvancedMetrics {
  
  // ğŸ¯ ë§ˆì¼“ë³„ ì˜¨ë¼ì¸ ê³„ì‚°ê¸°ë“¤
  final Map<String, StreamAwareOnlineRSI> _rsiCalculators = {};
  final Map<String, StreamAwareOnlineMACD> _macdCalculators = {};
  final Map<String, DateTime> _lastUpdates = {};
  
  // ğŸ”’ ìŠ¤íŠ¸ë¦¼ ê±´ê°•ì„± ê´€ë¦¬
  final Duration maxGap;
  final Duration staleThreshold;
  
  AdvancedMetrics({
    this.maxGap = const Duration(seconds: 10),
    this.staleThreshold = const Duration(seconds: 30),
  });

  // ==========================================================================
  // ğŸ”¥ ë©”ì¸ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ (ìƒˆ ë°ì´í„°ë§Œ ë°›ì•„ì„œ O(1) ì—…ë°ì´íŠ¸)
  // ==========================================================================
  
  /// ìƒˆë¡œìš´ ê°€ê²© ë°ì´í„°ë¡œ ëª¨ë“  ì§€í‘œ ì—…ë°ì´íŠ¸
  void updatePrice({
    required String market,
    required double price,
    required DateTime timestamp,
  }) {
    _lastUpdates[market] = timestamp;
    
    // RSI ì—…ë°ì´íŠ¸ (O(1))
    _getRSICalculator(market).update(price, timestamp);
    
    // MACD ì—…ë°ì´íŠ¸ (O(1))
    _getMACDCalculator(market).update(price, timestamp);
  }
  
  /// RSI ê³„ì‚°ê¸° ì¡°íšŒ/ìƒì„±
  StreamAwareOnlineRSI _getRSICalculator(String market) {
    return _rsiCalculators.putIfAbsent(
      market, 
      () => StreamAwareOnlineRSI(period: 14, maxGap: maxGap)
    );
  }
  
  /// MACD ê³„ì‚°ê¸° ì¡°íšŒ/ìƒì„±
  StreamAwareOnlineMACD _getMACDCalculator(String market) {
    return _macdCalculators.putIfAbsent(
      market,
      () => StreamAwareOnlineMACD(maxGap: maxGap)
    );
  }

  // ==========================================================================
  // ğŸ“Š ì˜¨ë¼ì¸ ì§€í‘œ ì¡°íšŒ (O(1) ë³µì¡ë„ - ì¦‰ì‹œ ë°˜í™˜)
  // ==========================================================================
  
  /// RSI ì¡°íšŒ (ì¦‰ì‹œ ë°˜í™˜)
  double calculateRSI({
    required String market,
    List<double>? prices, // í•˜ìœ„ í˜¸í™˜ì„±ìš© (ì‚¬ìš© ì•ˆí•¨)
    int period = 14,
  }) {
    final calculator = _rsiCalculators[market];
    if (calculator == null || !calculator.isReady || calculator.isStale) {
      return 50.0; // ê¸°ë³¸ê°’
    }
    return calculator.current;
  }
  
  /// MACD ì¡°íšŒ (ì¦‰ì‹œ ë°˜í™˜)
  MACDResult calculateMACD({
    required String market,
    List<double>? prices, // í•˜ìœ„ í˜¸í™˜ì„±ìš© (ì‚¬ìš© ì•ˆí•¨)
    int fastPeriod = 12,
    int slowPeriod = 26,
    int signalPeriod = 9,
  }) {
    final calculator = _macdCalculators[market];
    if (calculator == null || !calculator.isReady || calculator.isStale) {
      return const MACDResult(macd: 0.0, signal: 0.0, histogram: 0.0);
    }
    return calculator.current;
  }
  
  /// ğŸ†• ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ (ì˜¨ë¼ì¸ RSI ê¸°ë°˜)
  DivergenceResult detectDivergence({
    required String market,
    required List<double> prices,
    required List<double> indicator, // ì‚¬ìš© ì•ˆí•¨ (ì˜¨ë¼ì¸ RSI ì‚¬ìš©)
    int lookback = 5,
  }) {
    final rsiCalculator = _rsiCalculators[market];
    
    if (rsiCalculator == null || 
        !rsiCalculator.isReady || 
        prices.length < lookback) {
      return const DivergenceResult(
        isBullish: false,
        isBearish: false,
        strength: 0.0,
      );
    }
    
    // ğŸ”¥ ì‹¤ì œ ì˜¨ë¼ì¸ RSI ì‚¬ìš©
    final currentRSI = rsiCalculator.current;
    final recentPrices = prices.take(lookback).toList();
    
    return _calculateDivergence(recentPrices, currentRSI);
  }
  
  /// ë‹¤ì´ë²„ì „ìŠ¤ ê³„ì‚° (ë‹¨ìˆœí™”ëœ ë²„ì „)
  DivergenceResult _calculateDivergence(List<double> prices, double currentRSI) {
    if (prices.length < 2) {
      return const DivergenceResult(
        isBullish: false,
        isBearish: false, 
        strength: 0.0,
      );
    }
    
    final priceSlope = _calculateSlope(prices);
    
    bool isBullish = false;
    bool isBearish = false;
    double strength = 0.0;
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
    if (priceSlope < -0.1 && currentRSI > 50) {
      // ê°€ê²© í•˜ë½ + RSI ë†’ìŒ â†’ Bullish Divergence ê°€ëŠ¥ì„±
      isBullish = true;
      strength = min(1.0, (currentRSI - 50) / 50);
    } else if (priceSlope > 0.1 && currentRSI < 50) {
      // ê°€ê²© ìƒìŠ¹ + RSI ë‚®ìŒ â†’ Bearish Divergence ê°€ëŠ¥ì„±
      isBearish = true;
      strength = min(1.0, (50 - currentRSI) / 50);
    }
    
    return DivergenceResult(
      isBullish: isBullish,
      isBearish: isBearish,
      strength: strength,
    );
  }

  // ==========================================================================
  // ğŸ¯ ì»¤ìŠ¤í…€ ì§€í‘œë“¤ (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  // ==========================================================================
  
  /// Liquidity Vortex ê³„ì‚°
  double calculateLiquidityVortex(
    RollingWindow<double> priceWindow,
    RollingWindow<double> volumeWindow,
  ) {
    if (priceWindow.length < 3 || volumeWindow.length < 3) return 0.0;
    
    final priceAccel = _calculateSecondDerivative(priceWindow.values);
    final volumeAccel = _calculateSecondDerivative(volumeWindow.values);
    final cps = priceWindow.length / priceWindow.span.inSeconds;
    
    return (priceAccel * volumeAccel * cps).abs();
  }
  
  /// Flash Pulse ê³„ì‚°
  double calculateFlashPulse(double currentVolume, RollingWindow<double> volumeWindow) {
    if (volumeWindow.length < 10) return 0.0;
    
    final recentVolumes = volumeWindow.values.take(10).toList();
    final ema = _calculateEMA(recentVolumes, 10);
    
    return currentVolume / max(ema, 1.0) - 1.0;
  }
  
  /// Micro Burst Radar ê³„ì‚°
  double calculateMicroBurstRadar(double currentVolume, RollingWindow<double> volumeWindow) {
    if (volumeWindow.length < 3) return 0.0;
    
    final recentVolumes = volumeWindow.values.take(3).toList();
    final mean = recentVolumes.reduce((a, b) => a + b) / recentVolumes.length;
    final variance = recentVolumes
        .map((v) => pow(v - mean, 2))
        .reduce((a, b) => a + b) / recentVolumes.length;
    final stdDev = sqrt(variance);
    
    if (stdDev == 0) return 0.0;
    
    return (currentVolume - mean) / stdDev;
  }
  
  /// Machine Rush ê³„ì‚°
  double calculateMachineRush(double currentVolume, double totalVolume) {
    if (totalVolume == 0) return 0.0;
    return currentVolume / totalVolume;
  }
  
  /// Jump Gate ê³„ì‚°
  double calculateJumpGate(double currentPrice, double low, double high, double volume) {
    if (high <= low) return 0.0;
    
    final pricePosition = (currentPrice - low) / (high - low);
    final volumeWeight = log(volume + 1) / 10.0;
    
    return pricePosition * volumeWeight;
  }

  /// ATR ê³„ì‚° (ê¸°ì¡´ ë°©ì‹ ìœ ì§€)
  double calculateATR({
    required List<double> highs,
    required List<double> lows,
    required List<double> closes,
    int period = 14,
  }) {
    if (highs.length < period || lows.length < period || closes.length < period) {
      return 0.0;
    }
    
    final trueRanges = <double>[];
    
    for (int i = 1; i < closes.length; i++) {
      final high = highs[i];
      final low = lows[i];
      final prevClose = closes[i - 1];
      
      final tr1 = high - low;
      final tr2 = (high - prevClose).abs();
      final tr3 = (low - prevClose).abs();
      
      trueRanges.add(max(tr1, max(tr2, tr3)));
    }
    
    if (trueRanges.length < period) return 0.0;
    
    // ì²« ë²ˆì§¸ ATRì€ ë‹¨ìˆœ í‰ê· 
    double atr = trueRanges.take(period).reduce((a, b) => a + b) / period;
    
    // ì´í›„ëŠ” ì§€ìˆ˜ì´ë™í‰ê· 
    for (int i = period; i < trueRanges.length; i++) {
      atr = ((atr * (period - 1)) + trueRanges[i]) / period;
    }
    
    return atr;
  }

  // ==========================================================================
  // ğŸ› ï¸ í—¬í¼ í•¨ìˆ˜ë“¤
  // ==========================================================================
  
  /// EMA ê³„ì‚°
  double _calculateEMA(List<double> values, int period) {
    if (values.isEmpty) return 0.0;
    if (values.length == 1) return values.first;
    
    final alpha = 2.0 / (period + 1);
    double ema = values.first;
    
    for (int i = 1; i < values.length; i++) {
      ema = (values[i] * alpha) + (ema * (1 - alpha));
    }
    
    return ema;
  }
  
  /// 2ì°¨ ë¯¸ë¶„ ê³„ì‚°
  double _calculateSecondDerivative(List<double> values) {
    if (values.length < 3) return 0.0;
    
    final recent = values.take(3).toList();
    return recent[0] - (2 * recent[1]) + recent[2];
  }
  
  /// ì„ í˜• íšŒê·€ ê¸°ìš¸ê¸° ê³„ì‚°
  double _calculateSlope(List<double> values) {
    if (values.length < 2) return 0.0;
    
    final n = values.length;
    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    
    for (int i = 0; i < n; i++) {
      sumX += i;
      sumY += values[i];
      sumXY += i * values[i];
      sumX2 += i * i;
    }
    
    final denominator = n * sumX2 - sumX * sumX;
    if (denominator == 0) return 0.0;
    
    return (n * sumXY - sumX * sumY) / denominator;
  }

  /// ë™ì  ì„ê³„ê°’ ê³„ì‚° (ATR ê¸°ë°˜)
  double calculateDynamicThreshold({
    required double baseThreshold,
    required double atr,
    required double priceAverage,
    double multiplier = 1.0,
  }) {
    if (priceAverage == 0) return baseThreshold;
    
    final atrPercent = (atr / priceAverage) * 100;
    final volatilityFactor = max(0.5, min(2.0, atrPercent / baseThreshold));
    
    return baseThreshold * volatilityFactor * multiplier;
  }

  // ==========================================================================
  // ğŸ” ì‹œìŠ¤í…œ í—¬ìŠ¤ ë° ê´€ë¦¬
  // ==========================================================================
  
  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Map<String, dynamic> getSystemHealth() {
    final now = DateTime.now();
    final healthStatus = <String, dynamic>{
      'totalMarkets': _rsiCalculators.length,
      'staleMarkets': 0,
      'healthyMarkets': 0,
      'markets': <String, dynamic>{},
    };
    
    for (final market in _rsiCalculators.keys) {
      final rsiHealth = _rsiCalculators[market]?.getHealthStatus();
      final macdHealth = _macdCalculators[market]?.getHealthStatus();
      final lastUpdate = _lastUpdates[market];
      
      final isStale = lastUpdate != null && 
          now.difference(lastUpdate).abs() > staleThreshold;
      
      if (isStale) {
        healthStatus['staleMarkets']++;
      } else {
        healthStatus['healthyMarkets']++;
      }
      
      healthStatus['markets'][market] = {
        'rsi': rsiHealth,
        'macd': macdHealth,
        'isStale': isStale,
        'lastUpdate': lastUpdate?.toIso8601String(),
      };
    }
    
    return healthStatus;
  }
  
  /// ì˜¤ë˜ëœ ê³„ì‚°ê¸°ë“¤ ì •ë¦¬
  void cleanup() {
    final now = DateTime.now();
    final marketsToRemove = <String>[];
    
    for (final entry in _lastUpdates.entries) {
      if (now.difference(entry.value).abs() > const Duration(hours: 1)) {
        marketsToRemove.add(entry.key);
      }
    }
    
    for (final market in marketsToRemove) {
      _rsiCalculators.remove(market);
      _macdCalculators.remove(market);
      _lastUpdates.remove(market);
    }
    
    if (marketsToRemove.isNotEmpty) {
      developer.log('AdvancedMetrics: Cleaned up ${marketsToRemove.length} stale market calculators', name: 'AdvancedMetrics');
    }
  }
  
  /// íŠ¹ì • ë§ˆì¼“ ë¦¬ì…‹
  void resetMarket(String market) {
    _rsiCalculators[market]?.reset();
    _macdCalculators[market]?.reset();
    _lastUpdates.remove(market);
  }
  
  /// ì „ì²´ ë¦¬ì…‹
  void resetAll() {
    for (final calculator in _rsiCalculators.values) {
      calculator.reset();
    }
    for (final calculator in _macdCalculators.values) {
      calculator.reset();
    }
    _lastUpdates.clear();
  }
  
  /// ìºì‹œ ì •ë¦¬ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” ë¹ˆ êµ¬í˜„)
  void clearCache() {
    // ì˜¨ë¼ì¸ ê³„ì‚°ì—ì„œëŠ” ìºì‹œê°€ ì—†ìœ¼ë¯€ë¡œ ë¹ˆ êµ¬í˜„
  }
  
  /// ë§Œë£Œëœ ìºì‹œ ì •ë¦¬ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” cleanup í˜¸ì¶œ)
  void cleanupExpiredCache() {
    cleanup();
  }
  
  /// ìºì‹œ í†µê³„ (í•˜ìœ„ í˜¸í™˜ì„±ìš©)
  Map<String, dynamic> getCacheStats() {
    return {
      'mode': 'online',
      'totalMarkets': _rsiCalculators.length,
      'healthyMarkets': getSystemHealth()['healthyMarkets'],
      'staleMarkets': getSystemHealth()['staleMarkets'],
    };
  }
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  void dispose() {
    _rsiCalculators.clear();
    _macdCalculators.clear();
    _lastUpdates.clear();
  }
}

// ==========================================================================
// ğŸ“Š ê²°ê³¼ í´ë˜ìŠ¤ë“¤
// ==========================================================================

/// MACD ê³„ì‚° ê²°ê³¼
class MACDResult {
  final double macd;
  final double signal;
  final double histogram;
  
  const MACDResult({
    required this.macd,
    required this.signal,
    required this.histogram,
  });
  
  @override
  String toString() => 'MACD(macd: $macd, signal: $signal, histogram: $histogram)';
}

/// ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ ê²°ê³¼
class DivergenceResult {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  
  const DivergenceResult({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
  });
  
  bool get hasAnyDivergence => isBullish || isBearish;
  
  @override
  String toString() => 'Divergence(bullish: $isBullish, bearish: $isBearish, strength: $strength)';
}

// ==========================================================================
// ğŸ”¢ ì˜¨ë¼ì¸ ì§€í‘œ ê³„ì‚°ê¸°ë“¤ (í•˜ìœ„ í˜¸í™˜ì„±ìš© - ì‹¤ì œë¡œëŠ” ìœ„ì˜ StreamAware ë²„ì „ ì‚¬ìš©)
// ==========================================================================

/// ì˜¨ë¼ì¸ RSI ê³„ì‚°ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
typedef OnlineRSI = StreamAwareOnlineRSI;

/// ì˜¨ë¼ì¸ MACD ê³„ì‚°ê¸° (í•˜ìœ„ í˜¸í™˜ì„±)
typedef OnlineMACD = StreamAwareOnlineMACD;\n\n// ====== lib/core/utils/rolling_window.dart ======\n
import 'dart:collection';
import 'dart:math' as math;

/// íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë°˜ ë°ì´í„° ì—”íŠ¸ë¦¬
class _Item<T extends num> {
  final T value;
  final DateTime timestamp;
  
  _Item(this.value, this.timestamp);
}

/// ğŸš€ O(1) ì‹œê°„ ë³µì¡ë„ë¡œ ì™„ì „ ìµœì í™”ëœ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
/// ëª¨ë“  í†µê³„ ì§€í‘œë¥¼ O(1)ë¡œ ê³„ì‚° (rSquared í¬í•¨)
class RollingWindow<T extends num> {
  final Duration span;
  final Queue<_Item<T>> _queue = Queue<_Item<T>>();
  
  // ==========================================================================
  // ğŸ“Š O(1) ê³„ì‚°ì„ ìœ„í•œ ëˆ„ì  ë³€ìˆ˜ë“¤ (Complete Set)
  // ==========================================================================
  
  // ê¸°ë³¸ í†µê³„ìš©
  double _sum = 0.0;          // Î£y
  double _sumSq = 0.0;        // Î£yÂ² (ë¶„ì‚°ìš©)
  
  // ì—°ì† ì¦ê°€ ì¶”ì ìš©
  int _incStreak = 0;
  T? _lastValue;
  
  // ì„ í˜• íšŒê·€ + rSquared O(1) ê³„ì‚°ì„ ìœ„í•œ ì™„ì „í•œ 5ë³€ìˆ˜ ì„¸íŠ¸
  double _sx = 0.0;           // Î£x (ì‹œê°„)
  double _sy = 0.0;           // Î£y (ê°’) - _sumê³¼ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´ ìœ ì§€
  double _sxx = 0.0;          // Î£xÂ²
  double _sxy = 0.0;          // Î£xy
  double _syy = 0.0;          // Î£yÂ² - _sumSqì™€ ë™ì¼í•˜ì§€ë§Œ íšŒê·€ìš©ìœ¼ë¡œ ëª…ì‹œì  ê´€ë¦¬
  
  RollingWindow({required this.span});

  // ==========================================================================
  // ğŸ“¥ ë°ì´í„° ì¶”ê°€ (ëª¨ë“  ëˆ„ì ê°’ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸)
  // ==========================================================================
  
  /// ìƒˆ ë°ì´í„° ì¶”ê°€ (ëª¨ë“  ëˆ„ì ê°’ ì¦‰ì‹œ ì—…ë°ì´íŠ¸)
  void add(T value, {DateTime? timestamp}) {
    final now = timestamp ?? DateTime.now();
    _evictOld(now); // ì˜¤ë˜ëœ ë°ì´í„° ë¨¼ì € ì œê±°
    
    // ìƒˆ ë°ì´í„° ì¶”ê°€
    _queue.addLast(_Item(value, now));
    
    // ğŸ”¥ í•µì‹¬: ëª¨ë“  ëˆ„ì ê°’ì„ O(1)ìœ¼ë¡œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
    final x = now.millisecondsSinceEpoch.toDouble();
    final y = value.toDouble();
    
    _sum += y;
    _sumSq += y * y;
    
    // ì„ í˜• íšŒê·€ + rSquaredìš© ì™„ì „í•œ 5ë³€ìˆ˜ ì—…ë°ì´íŠ¸
    _sx += x;
    _sy += y;      // _sumê³¼ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´
    _sxx += x * x;
    _sxy += x * y;
    _syy += y * y; // _sumSqì™€ ë™ì¼í•˜ì§€ë§Œ ëª…í™•ì„±ì„ ìœ„í•´
    
    // ì—°ì† ì¦ê°€ ì¶”ì  (ê°œì„ ëœ ë¡œì§)
    if (length > 1 && _lastValue != null && value > _lastValue!) {
      _incStreak++;
    } else {
      _incStreak = (length == 1) ? 1 : 0; // ì²« ë²ˆì§¸ ë°ì´í„°ë©´ 1, ì•„ë‹ˆë©´ ì´ˆê¸°í™”
    }
    _lastValue = value;
  }

  // ==========================================================================
  // ğŸ—‘ï¸ ë°ì´í„° ì œê±° (ëª¨ë“  ëˆ„ì ê°’ ì‹¤ì‹œê°„ ì°¨ê°)
  // ==========================================================================
  
  /// ì˜¤ë˜ëœ ë°ì´í„° ì œê±° (ëª¨ë“  ëˆ„ì ê°’ ì¦‰ì‹œ ì°¨ê°)
  void _evictOld(DateTime now) {
    final cutoff = now.subtract(span);
    
    while (_queue.isNotEmpty && _queue.first.timestamp.isBefore(cutoff)) {
      final old = _queue.removeFirst();
      
      // ğŸ”¥ í•µì‹¬: ëª¨ë“  ëˆ„ì ê°’ì„ O(1)ìœ¼ë¡œ ì‹¤ì‹œê°„ ì°¨ê°
      final oldX = old.timestamp.millisecondsSinceEpoch.toDouble();
      final oldY = old.value.toDouble();
      
      _sum -= oldY;
      _sumSq -= oldY * oldY;
      
      // ì„ í˜• íšŒê·€ + rSquaredìš© ì™„ì „í•œ 5ë³€ìˆ˜ ì°¨ê°
      _sx -= oldX;
      _sy -= oldY;
      _sxx -= oldX * oldX;
      _sxy -= oldX * oldY;
      _syy -= oldY * oldY;
    }
    
    // ì—°ì† ì¦ê°€ ì¹´ìš´íŠ¸ ì¬ê³„ì‚° (ì œê±° í›„ í•„ìš”ì‹œ)
    _recalculateConsecutiveIncreases();
  }
  
  /// ì—°ì† ì¦ê°€ ì¹´ìš´íŠ¸ ì¬ê³„ì‚° (ë°ì´í„° ì œê±° í›„ í•„ìš”ì‹œ)
  void _recalculateConsecutiveIncreases() {
    if (_queue.length < 2) {
      _incStreak = _queue.length;
      return;
    }
    
    _incStreak = 1;
    final values = _queue.map((item) => item.value).toList();
    
    for (int i = values.length - 2; i >= 0; i--) {
      if (values[i + 1] > values[i]) {
        _incStreak++;
      } else {
        break;
      }
    }
  }

  // ==========================================================================
  // ğŸ“Š O(1)ìœ¼ë¡œ ê³„ì‚°ë˜ëŠ” ëª¨ë“  í†µê³„ ì§€í‘œë“¤
  // ==========================================================================
  
  // ê¸°ë³¸ ì •ë³´
  int get length => _queue.length;
  bool get isEmpty => _queue.isEmpty;
  bool get isNotEmpty => _queue.isNotEmpty;
  
  // ê¸°ë³¸ í†µê³„ (O(1))
  double get sum => _sum;
  double get mean => isEmpty ? 0.0 : _sum / length;
  
  double get variance {
    if (length < 2) return 0.0;
    // ë² ì…€ ë³´ì •ëœ í‘œë³¸ ë¶„ì‚°: sÂ² = (Î£yÂ² - n*Î¼Â²) / (n-1)
    final meanVal = mean;
    final sampleVariance = (_sumSq - length * meanVal * meanVal) / (length - 1);
    return math.max(0.0, sampleVariance); // ìŒìˆ˜ ë°©ì§€
  }
  
  double get stdev => math.sqrt(variance);
  
  int get consecutiveIncreases => _incStreak;
  
  double zScore(num x) {
    final sd = stdev;
    return sd == 0 ? 0.0 : (x - mean) / sd;
  }
  
  double get cv {
    final meanVal = mean;
    return meanVal == 0 ? 0.0 : stdev / meanVal.abs();
  }
  
  // ==========================================================================
  // ğŸš€ ì„ í˜• íšŒê·€ ì§€í‘œë“¤ (O(1) - 5ë³€ìˆ˜ ê³µì‹ í™œìš©)
  // ==========================================================================
  
  /// ì„ í˜• íšŒê·€ ê¸°ìš¸ê¸° (O(1))
  double get slope {
    final n = length;
    if (n < 2) return 0.0;
    
    final denominator = n * _sxx - _sx * _sx;
    return denominator == 0 ? 0.0 : (n * _sxy - _sx * _sy) / denominator;
  }
  
  /// ğŸ¯ ê²°ì •ê³„ìˆ˜ RÂ² (O(1) ì™„ì „ ìµœì í™”!)
  /// ê³µì‹: RÂ² = (n*Î£xy - Î£x*Î£y)Â² / [(n*Î£xÂ² - (Î£x)Â²) * (n*Î£yÂ² - (Î£y)Â²)]
  double get rSquared {
    final n = length;
    if (n < 2) return 0.0;
    
    try {
      final numerator = n * _sxy - _sx * _sy;
      final denomX = n * _sxx - _sx * _sx;
      final denomY = n * _syy - _sy * _sy;
      final denominator = denomX * denomY;
      
      if (denominator <= 0) return 0.0;
      
      final rSquaredValue = (numerator * numerator) / denominator;
      return math.max(0.0, math.min(1.0, rSquaredValue)); // [0, 1] ë²”ìœ„ ë³´ì¥
    } catch (e) {
      return 0.0; // ê³„ì‚° ì˜¤ë¥˜ ì‹œ ì•ˆì „ê°’ ë°˜í™˜
    }
  }
  
  /// ì„ í˜• íšŒê·€ ì ˆí¸ (O(1))
  double get intercept {
    final n = length;
    if (n < 2) return mean;
    
    final xMean = _sx / n;
    final yMean = _sy / n;
    return yMean - slope * xMean;
  }
  
  /// ì„ í˜• íšŒê·€ ìƒê´€ê³„ìˆ˜ (O(1))
  double get correlation {
    return math.sqrt(rSquared) * (slope >= 0 ? 1 : -1);
  }

  // ==========================================================================
  // ğŸ“‹ ë°ì´í„° ì ‘ê·¼ (í•„ìš”ì‹œ ì‚¬ìš©, O(n)ì¼ ìˆ˜ ìˆìŒ)
  // ==========================================================================
  
  List<T> get values => _queue.map((e) => e.value).toList();
  Iterable<DateTime> get timestamps => _queue.map((e) => e.timestamp);
  
  /// ìµœì‹  ê°’
  T? get latest => _queue.isNotEmpty ? _queue.last.value : null;
  
  /// ê°€ì¥ ì˜¤ë˜ëœ ê°’
  T? get oldest => _queue.isNotEmpty ? _queue.first.value : null;
  
  /// ìµœëŒ€ê°’ (O(n) - ìºì‹± ê°€ëŠ¥í•˜ì§€ë§Œ ë³µì¡ë„ ì¦ê°€ë¡œ í˜„ì¬ëŠ” ë‹¨ìˆœ êµ¬í˜„)
  T get max => _queue.isEmpty ? 0 as T : _queue.map((e) => e.value).reduce(math.max);
  
  /// ìµœì†Œê°’ (O(n) - ìºì‹± ê°€ëŠ¥í•˜ì§€ë§Œ ë³µì¡ë„ ì¦ê°€ë¡œ í˜„ì¬ëŠ” ë‹¨ìˆœ êµ¬í˜„)
  T get min => _queue.isEmpty ? 0 as T : _queue.map((e) => e.value).reduce(math.min);

  // ==========================================================================
  // ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë“¤
  // ==========================================================================
  
  /// ìœˆë„ìš° ë°ì´í„° ëª¨ë‘ ì œê±°
  void clear() {
    _queue.clear();
    _sum = 0.0;
    _sumSq = 0.0;
    _incStreak = 0;
    _lastValue = null;
    _sx = 0.0;
    _sy = 0.0;
    _sxx = 0.0;
    _sxy = 0.0;
    _syy = 0.0;
  }
  
  /// íŠ¹ì • ì‹œì ê¹Œì§€ì˜ ë°ì´í„° ê°•ì œ ì œê±°
  void evictBefore(DateTime cutoff) {
    while (_queue.isNotEmpty && _queue.first.timestamp.isBefore(cutoff)) {
      final old = _queue.removeFirst();
      
      final oldX = old.timestamp.millisecondsSinceEpoch.toDouble();
      final oldY = old.value.toDouble();
      
      _sum -= oldY;
      _sumSq -= oldY * oldY;
      _sx -= oldX;
      _sy -= oldY;
      _sxx -= oldX * oldX;
      _sxy -= oldX * oldY;
      _syy -= oldY * oldY;
    }
    
    _recalculateConsecutiveIncreases();
  }
  
  /// ìœˆë„ìš° ìƒíƒœ ì •ë³´ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> get debugInfo => const <String, dynamic>{
    'performance': 'All O(1) optimized',
  }..addAll({
    'length': length,
    'span': '${span.inSeconds}s',
    'sum': _sum,
    'mean': mean,
    'stdev': stdev,
    'variance': variance,
    'cv': cv,
    'slope': slope,
    'rSquared': rSquared,
    'correlation': correlation,
    'consecutiveIncreases': consecutiveIncreases,
    'regressionVariables': <String, double>{
      'sx': _sx,
      'sy': _sy,
      'sxx': _sxx,
      'sxy': _sxy,
      'syy': _syy,
    },
  });
  
  /// ì„±ëŠ¥ ê²€ì¦ (ëª¨ë“  ì§€í‘œê°€ O(1)ì¸ì§€ í™•ì¸)
  Map<String, String> get performanceProfile => const <String, String>{
    'basic_stats': 'O(1) - sum, mean, variance, stdev, cv',
    'regression': 'O(1) - slope, rSquared, intercept, correlation',
    'streak': 'O(1) - consecutiveIncreases',
    'z_score': 'O(1) - zScore calculation',
    'data_access': 'O(n) - values, timestamps, min, max (acceptable)',
    'overall': 'Fully optimized for real-time streaming',
  };
  
  @override
  String toString() {
    return 'RollingWindow(length: $length, span: ${span.inSeconds}s, '
           'mean: ${mean.toStringAsFixed(2)}, RÂ²: ${rSquared.toStringAsFixed(3)})';
  }
}\n\n// ====== lib/core/utils/streaming_market_buffer.dart ======\n
\n\n// ====== lib/core/utils/app_life_cycle_manager.dart ======\n
// lib/core/utils/app_life_cycle_manager.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../utils/logger.dart';

/// ì•± ë¼ì´í”„ì‚¬ì´í´ê³¼ ì£¼ê¸°ì ì¸ ì‘ì—…ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
/// ğŸ¯ Hive BoxëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ í’€ ê¸°ëŠ¥ API ì œê³µ
class AppLifecycleManager extends WidgetsBindingObserver {
  final Ref ref;
  Timer? _globalTimer;
  
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ ìƒíƒœ ê´€ë¦¬
  DateTime? _appStartTime;
  DateTime? _lastResumeTime;
  DateTime? _lastPauseTime;
  int _resumeCount = 0;
  int _pauseCount = 0;
  Duration _totalForegroundTime = Duration.zero;
  Duration _totalBackgroundTime = Duration.zero;
  AppLifecycleState _currentState = AppLifecycleState.resumed;
  
  // ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤
  final List<void Function(AppLifecycleState)> _lifecycleListeners = [];
  
  // ğŸ†• ì„±ëŠ¥ í†µê³„
  final Map<String, dynamic> _performanceStats = {};

  AppLifecycleManager(this.ref) {
    _appStartTime = DateTime.now();
    _lastResumeTime = _appStartTime;
    WidgetsBinding.instance.addObserver(this);
    _startGlobalTimer();
    log.i('ğŸ¬ AppLifecycleManager ì´ˆê¸°í™” ì™„ë£Œ');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ APIë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ğŸ†• í˜„ì¬ ì•± ìƒíƒœ ì¡°íšŒ
  AppLifecycleState get currentState => _currentState;

  /// ğŸ†• ì•± ì‹œì‘ ì‹œê°„
  DateTime? get appStartTime => _appStartTime;

  /// ğŸ†• ì•± ê°€ë™ ì‹œê°„ (ì—…íƒ€ì„)
  Duration get uptime {
    if (_appStartTime == null) return Duration.zero;
    return DateTime.now().difference(_appStartTime!);
  }

  /// ğŸ†• í¬ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalForegroundTime {
    var total = _totalForegroundTime;
    if (_currentState == AppLifecycleState.resumed && _lastResumeTime != null) {
      total += DateTime.now().difference(_lastResumeTime!);
    }
    return total;
  }

  /// ğŸ†• ë°±ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalBackgroundTime {
    var total = _totalBackgroundTime;
    if (_currentState == AppLifecycleState.paused && _lastPauseTime != null) {
      total += DateTime.now().difference(_lastPauseTime!);
    }
    return total;
  }

  /// ğŸ†• ì´ë²¤íŠ¸ ì¹´ìš´í„°ë“¤
  int get resumeCount => _resumeCount;
  int get pauseCount => _pauseCount;

  /// ğŸ†• ë§ˆì§€ë§‰ ìƒíƒœ ë³€ê²½ ì‹œê°„
  DateTime? get lastStateChangeTime {
    switch (_currentState) {
      case AppLifecycleState.resumed:
        return _lastResumeTime;
      case AppLifecycleState.paused:
        return _lastPauseTime;
      default:
        return null;
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
  void addLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.add(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°
  void removeLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.remove(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨/ì •ë¦¬ ì‘ì—… ê°•ì œ ì‹¤í–‰
  void forceRefresh() {
    log.i('ğŸ”„ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
    _performPeriodicTasks();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ê°•ì œ ì‹¤í–‰
  void forceCleanup() {
    log.i('ğŸ§¹ ìˆ˜ë™ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    _performMemoryCleanup();
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
  void updatePerformanceStats(String key, dynamic value) {
    _performanceStats[key] = value;
    _performanceStats['lastUpdated'] = DateTime.now().toIso8601String();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getMemoryStats() {
    return {
      'uptime': uptime.toString(),
      'foregroundTime': totalForegroundTime.toString(),
      'backgroundTime': totalBackgroundTime.toString(),
      'resumeCount': resumeCount,
      'pauseCount': pauseCount,
      'currentState': _currentState.name,
      'lastStateChange': lastStateChangeTime?.toIso8601String(),
      'platformMemoryUsage': _getPlatformMemoryInfo(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì¡°íšŒ
  Map<String, dynamic> getPerformanceStats() {
    return Map.from(_performanceStats)
      ..addAll({
        'uptime': uptime.inSeconds,
        'foregroundTimeSeconds': totalForegroundTime.inSeconds,
        'backgroundTimeSeconds': totalBackgroundTime.inSeconds,
        'resumeCount': resumeCount,
        'pauseCount': pauseCount,
        'currentState': _currentState.name,
      });
  }

  /// ğŸ†• ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> getSystemStatus() {
    return {
      'app': getMemoryStats(),
      'performance': getPerformanceStats(),
      'platform': {
        'os': Platform.operatingSystem,
        'version': Platform.operatingSystemVersion,
        'locale': Platform.localeName,
      },
      'listeners': {
        'lifecycleListeners': _lifecycleListeners.length,
      },
      'timers': {
        'globalTimerActive': _globalTimer?.isActive ?? false,
      },
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ê¸°ì¡´ ë‚´ë¶€ ë¡œì§ë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final previousState = _currentState;
    _currentState = state;
    
    _updateStateTimes(previousState, state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        log.i('â¡ï¸ ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.');
        _resumeCount++;
        _lastResumeTime = DateTime.now();
        _startGlobalTimer();
        _onAppResumed();
        break;
        
      case AppLifecycleState.paused:
        log.i('â¸ï¸ ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.');
        _pauseCount++;
        _lastPauseTime = DateTime.now();
        _stopGlobalTimer();
        _onAppPaused();
        break;
        
      case AppLifecycleState.detached:
        log.i('ğŸ”š ì•±ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        _onAppDetached();
        break;
        
      case AppLifecycleState.inactive:
        log.d('ğŸ˜´ ì•±ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.');
        break;
        
      case AppLifecycleState.hidden:
        log.d('ğŸ«¥ ì•±ì´ ìˆ¨ê¹€ ìƒíƒœì…ë‹ˆë‹¤.');
        break;
    }
    
    // ğŸ†• ì™¸ë¶€ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
    _notifyLifecycleListeners(state);
  }

  /// ğŸ†• ìƒíƒœ ì „í™˜ ì‹œê°„ ì—…ë°ì´íŠ¸
  void _updateStateTimes(AppLifecycleState from, AppLifecycleState to) {
    final now = DateTime.now();
    
    if (from == AppLifecycleState.resumed && _lastResumeTime != null) {
      _totalForegroundTime += now.difference(_lastResumeTime!);
    } else if (from == AppLifecycleState.paused && _lastPauseTime != null) {
      _totalBackgroundTime += now.difference(_lastPauseTime!);
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
  void _notifyLifecycleListeners(AppLifecycleState state) {
    for (final listener in _lifecycleListeners) {
      try {
        listener(state);
      } catch (e, st) {
        log.e('ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜', e, st);
      }
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘
  void _startGlobalTimer() {
    if (_globalTimer == null || !_globalTimer!.isActive) {
      _globalTimer = Timer.periodic(const Duration(seconds: 30), (_) {
        _performPeriodicTasks();
      });
      log.i('â° ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘: 30ì´ˆ ê°„ê²©');
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€
  void _stopGlobalTimer() {
    _globalTimer?.cancel();
    _globalTimer = null;
    log.d('â¹ï¸ ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€');
  }

  /// ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰
  void _performPeriodicTasks() {
    log.d('ğŸ”„ ì „ì—­ íƒ€ì´ë¨¸: ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰');
    
    // ì—¬ê¸°ì— ì£¼ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•  ì‘ì—…ë“¤ ì¶”ê°€
    // ì˜ˆ: ë©”ëª¨ë¦¬ ì •ë¦¬, ìƒíƒœ ì²´í¬, ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ë“±
    
    // ì˜ˆì‹œ: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
    _checkMemoryUsage();
    
    // ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
    updatePerformanceStats('lastPeriodicTaskRun', DateTime.now().toIso8601String());
  }

  /// ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ì„ ë•Œ
  void _onAppResumed() {
    log.i('ğŸ“¦ Hive Box ìœ ì§€ - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ë°ì´í„° ë³´ì¡´ë¨');
    
    // í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì—°ê²° ìƒíƒœ í™•ì¸, ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ë“±
  }

  /// ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆì„ ë•Œ
  void _onAppPaused() {
    log.i('ğŸ’¾ ë°±ê·¸ë¼ìš´ë“œ ì§„ì… - ì¤‘ìš” ë°ì´í„° ë³´ì¡´ ì¤‘');
    
    // ë°±ê·¸ë¼ìš´ë“œ ì§„ì… ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì„ì‹œ ë°ì´í„° ì €ì¥, ì—°ê²° ì •ë¦¬ ë“±
  }

  /// ì•±ì´ ì™„ì „íˆ ì¢…ë£Œë  ë•Œ
  void _onAppDetached() {
    log.i('ğŸ§¹ ì•± ì¢…ë£Œ - ìµœì¢… ì •ë¦¬ ì‘ì—… ìˆ˜í–‰');
    dispose();
  }

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ìš©)
  void _checkMemoryUsage() {
    // ì‹¤ì œ êµ¬í˜„ì€ í”Œë«í¼ë³„ë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
    log.d('ğŸ§  ë©”ëª¨ë¦¬ ìƒíƒœ ì²´í¬ (ê°œë°œ ì¤‘)');
    
    // ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
    final memInfo = _getPlatformMemoryInfo();
    updatePerformanceStats('memoryInfo', memInfo);
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰
  void _performMemoryCleanup() {
    // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë¦¬ ë¡œì§
    log.i('ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    
    // ì˜ˆì‹œ: ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰ (Dartì—ì„œëŠ” ì œí•œì )
    // System.gc() ê°™ì€ ê²ƒì€ ì—†ì§€ë§Œ, ë¶ˆí•„ìš”í•œ ì°¸ì¡° ì •ë¦¬ ë“±ì„ í•  ìˆ˜ ìˆìŒ
  }

  /// ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
  Map<String, dynamic> _getPlatformMemoryInfo() {
    try {
      return {
        'platform': Platform.operatingSystem,
        'availableProcessors': Platform.numberOfProcessors,
        'timestamp': DateTime.now().toIso8601String(),
        // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë³´ëŠ” í”Œë«í¼ ì±„ë„ì„ í†µí•´ êµ¬í˜„ ê°€ëŠ¥
        'note': 'Platform memory info implementation needed'
      };
    } catch (e) {
      return {'error': e.toString()};
    }
  }

  /// ì •ë¦¬ ì‘ì—…
  void dispose() {
    _stopGlobalTimer();
    WidgetsBinding.instance.removeObserver(this);
    _lifecycleListeners.clear();
    log.i('ğŸ§¹ AppLifecycleManager ì •ë¦¬ ì™„ë£Œ');
  }
}

/// AppLifecycleManager í”„ë¡œë°”ì´ë”
final appLifecycleManagerProvider = Provider<AppLifecycleManager>((ref) {
  final manager = AppLifecycleManager(ref);
  ref.onDispose(() => manager.dispose());
  return manager;
});\n\n// ====== lib/core/utils/streaming_stats.dart ======\n
\n\n// ====== lib/core/utils/market_data_context.dart ======\n
import 'rolling_window.dart';
import 'advanced_metrics.dart';

/// ğŸ¯ MarketDataContext - ë§ˆì¼“ ë°ì´í„° í†µí•© ê´€ë¦¬
/// 
/// V4.1 ê°œì„ ì‚¬í•­:
/// - 9ê°œ íŒŒë¼ë¯¸í„° â†’ 1ê°œ ê°ì²´ë¡œ ë‹¨ìˆœí™”
/// - íƒ€ì„í”„ë ˆì„ë³„ ìœˆë„ìš° ê´€ë¦¬
/// - ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™ ì§€ì›
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ìœˆë„ìš° ê´€ë¦¬
/// - ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
class MarketDataContext {
  final String market;
  
  // ğŸ“Š ë©€í‹° íƒ€ì„í”„ë ˆì„ ê°€ê²© ìœˆë„ìš°
  final Map<Duration, RollingWindow<double>> _priceWindows = {};
  
  // ğŸ“Š ë©€í‹° íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš°
  final Map<Duration, RollingWindow<double>> _volumeWindows = {};
  
  // ğŸ“Š ë³´ì¡° ì§€í‘œ ìœˆë„ìš°ë“¤
  final RollingWindow<double>? buyRatioWindow;
  final RollingWindow<double>? intervalWindow;
  
  /// ìƒì„±ì
  MarketDataContext({
    required this.market,
    required Map<Duration, RollingWindow<double>> priceWindows,
    required Map<Duration, RollingWindow<double>> volumeWindows,
    this.buyRatioWindow,
    this.intervalWindow,
  }) {
    _priceWindows.addAll(priceWindows);
    _volumeWindows.addAll(volumeWindows);
    
    // ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
    _validateWindows();
  }

  /// ğŸ—ï¸ íŒ©í† ë¦¬ ìƒì„±ì - í‘œì¤€ íƒ€ì„í”„ë ˆì„ìœ¼ë¡œ ìƒì„±
  factory MarketDataContext.standard({
    required String market,
    required RollingWindow<double> priceWindow30s,
    required RollingWindow<double> priceWindow60s,
    required RollingWindow<double> priceWindow300s,
    required RollingWindow<double> volumeWindow30s,
    required RollingWindow<double> volumeWindow60s,
    required RollingWindow<double> volumeWindow300s,
    RollingWindow<double>? buyRatioWindow,
    RollingWindow<double>? intervalWindow,
  }) {
    return MarketDataContext(
      market: market,
      priceWindows: {
        const Duration(seconds: 30): priceWindow30s,
        const Duration(seconds: 60): priceWindow60s,
        const Duration(seconds: 300): priceWindow300s,
      },
      volumeWindows: {
        const Duration(seconds: 30): volumeWindow30s,
        const Duration(seconds: 60): volumeWindow60s,
        const Duration(seconds: 300): volumeWindow300s,
      },
      buyRatioWindow: buyRatioWindow,
      intervalWindow: intervalWindow,
    );
  }

  /// ğŸ—ï¸ íŒ©í† ë¦¬ ìƒì„±ì - ë¹ˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
  factory MarketDataContext.empty(String market) {
    return MarketDataContext(
      market: market,
      priceWindows: {
        const Duration(seconds: 30): RollingWindow<double>(span: const Duration(seconds: 30)),
        const Duration(seconds: 60): RollingWindow<double>(span: const Duration(seconds: 60)),
        const Duration(seconds: 300): RollingWindow<double>(span: const Duration(seconds: 300)),
      },
      volumeWindows: {
        const Duration(seconds: 30): RollingWindow<double>(span: const Duration(seconds: 30)),
        const Duration(seconds: 60): RollingWindow<double>(span: const Duration(seconds: 60)),
        const Duration(seconds: 300): RollingWindow<double>(span: const Duration(seconds: 300)),
      },
      buyRatioWindow: RollingWindow<double>(span: const Duration(seconds: 180)),
      intervalWindow: RollingWindow<double>(span: const Duration(seconds: 600)),
    );
  }

  /// ğŸ“Š ê°€ê²© ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> getPriceWindow(Duration timeframe) {
    final window = _priceWindows[timeframe];
    if (window == null) {
      throw ArgumentError('Price window not found for timeframe: ${timeframe.inSeconds}s');
    }
    return window;
  }

  /// ğŸ“Š ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> getVolumeWindow(Duration timeframe) {
    final window = _volumeWindows[timeframe];
    if (window == null) {
      throw ArgumentError('Volume window not found for timeframe: ${timeframe.inSeconds}s');
    }
    return window;
  }

  /// ğŸ“Š ì‚¬ìš© ê°€ëŠ¥í•œ íƒ€ì„í”„ë ˆì„ ëª©ë¡
  List<Duration> get availableTimeframes {
    final timeframes = <Duration>{..._priceWindows.keys, ..._volumeWindows.keys}.toList();
    timeframes.sort((a, b) => a.inSeconds.compareTo(b.inSeconds));
    return timeframes;
  }

  /// ğŸ“Š ê°€ì¥ ê¸´ íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get longestPriceWindow {
    if (_priceWindows.isEmpty) {
      throw StateError('No price windows available');
    }
    
    final longestTimeframe = _priceWindows.keys.reduce(
      (a, b) => a.inSeconds > b.inSeconds ? a : b
    );
    return _priceWindows[longestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ê¸´ íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get longestVolumeWindow {
    if (_volumeWindows.isEmpty) {
      throw StateError('No volume windows available');
    }
    
    final longestTimeframe = _volumeWindows.keys.reduce(
      (a, b) => a.inSeconds > b.inSeconds ? a : b
    );
    return _volumeWindows[longestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ì§§ì€ íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get shortestPriceWindow {
    if (_priceWindows.isEmpty) {
      throw StateError('No price windows available');
    }
    
    final shortestTimeframe = _priceWindows.keys.reduce(
      (a, b) => a.inSeconds < b.inSeconds ? a : b
    );
    return _priceWindows[shortestTimeframe]!;
  }

  /// ğŸ“Š ê°€ì¥ ì§§ì€ íƒ€ì„í”„ë ˆì„ ê±°ë˜ëŸ‰ ìœˆë„ìš° ì¡°íšŒ
  RollingWindow<double> get shortestVolumeWindow {
    if (_volumeWindows.isEmpty) {
      throw StateError('No volume windows available');
    }
    
    final shortestTimeframe = _volumeWindows.keys.reduce(
      (a, b) => a.inSeconds < b.inSeconds ? a : b
    );
    return _volumeWindows[shortestTimeframe]!;
  }

  /// ğŸ”„ ë°ì´í„° ì—…ë°ì´íŠ¸
  void updateAllWindows({
    required double price,
    required double volume,
    required DateTime timestamp,
    double? buyRatio,
    double? interval,
  }) {
    // ëª¨ë“  ê°€ê²© ìœˆë„ìš° ì—…ë°ì´íŠ¸
    for (final window in _priceWindows.values) {
      window.add(price, timestamp: timestamp);
    }
    
    // ëª¨ë“  ê±°ë˜ëŸ‰ ìœˆë„ìš° ì—…ë°ì´íŠ¸
    for (final window in _volumeWindows.values) {
      window.add(volume, timestamp: timestamp);
    }
    
    // ë³´ì¡° ìœˆë„ìš° ì—…ë°ì´íŠ¸
    if (buyRatio != null && buyRatioWindow != null) {
      buyRatioWindow!.add(buyRatio, timestamp: timestamp);
    }
    
    if (interval != null && intervalWindow != null) {
      intervalWindow!.add(interval, timestamp: timestamp);
    }
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ë©”ì„œë“œ
  void updateWithOnlineMetrics({
    required double price,
    required double volume,
    required DateTime timestamp,
    double? buyRatio,
    double? interval,
    required AdvancedMetrics onlineMetrics,
  }) {
    // ê¸°ë³¸ ìœˆë„ìš° ì—…ë°ì´íŠ¸
    updateAllWindows(
      price: price,
      volume: volume,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: interval,
    );
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œë„ ë™ì‹œ ì—…ë°ì´íŠ¸
    onlineMetrics.updatePrice(
      market: market,
      price: price,
      timestamp: timestamp,
    );
  }

  /// ğŸ“Š ë‹¤ì¤‘ íƒ€ì„í”„ë ˆì„ íŠ¸ë Œë“œ ë¶„ì„
  Map<String, dynamic> getMultiTimeframeTrend() {
    final trends = <String, Map<String, dynamic>>{};
    
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      if (window.length >= 2) {
        final currentPrice = window.values.first;
        final previousPrice = window.values[1];
        final changePercent = ((currentPrice - previousPrice) / previousPrice) * 100;
        
        trends[timeframe] = {
          'changePercent': changePercent,
          'trend': changePercent > 0.1 ? 'UP' : 
                   changePercent < -0.1 ? 'DOWN' : 'FLAT',
          'volatility': window.cv,
          'dataPoints': window.length,
        };
      }
    }
    
    return {
      'market': market,
      'trends': trends,
      'consensus': _calculateTrendConsensus(trends),
    };
  }

  /// ğŸ¯ íŠ¸ë Œë“œ í•©ì˜ ê³„ì‚°
  String _calculateTrendConsensus(Map<String, Map<String, dynamic>> trends) {
    if (trends.isEmpty) return 'UNKNOWN';
    
    final upCount = trends.values.where((t) => t['trend'] == 'UP').length;
    final downCount = trends.values.where((t) => t['trend'] == 'DOWN').length;
    final flatCount = trends.values.where((t) => t['trend'] == 'FLAT').length;
    
    if (upCount > downCount && upCount > flatCount) return 'BULLISH';
    if (downCount > upCount && downCount > flatCount) return 'BEARISH';
    return 'NEUTRAL';
  }

  /// ğŸ“Š ìœˆë„ìš° ìƒíƒœ ì •ë³´
  Map<String, dynamic> getWindowStats() {
    final stats = <String, dynamic>{
      'market': market,
      'priceWindows': <String, dynamic>{},
      'volumeWindows': <String, dynamic>{},
      'auxWindows': <String, dynamic>{},
    };
    
    // ê°€ê²© ìœˆë„ìš° í†µê³„
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      stats['priceWindows'][timeframe] = {
        'length': window.length,
        'mean': window.length > 0 ? window.mean : 0.0,
        'stdev': window.length > 0 ? window.stdev : 0.0,
        'cv': window.length > 0 ? window.cv : 0.0,
        'min': window.length > 0 ? window.min : 0.0,
        'max': window.length > 0 ? window.max : 0.0,
      };
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° í†µê³„
    for (final entry in _volumeWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      stats['volumeWindows'][timeframe] = {
        'length': window.length,
        'sum': window.length > 0 ? window.sum : 0.0,
        'mean': window.length > 0 ? window.mean : 0.0,
        'stdev': window.length > 0 ? window.stdev : 0.0,
      };
    }
    
    // ë³´ì¡° ìœˆë„ìš° í†µê³„
    if (buyRatioWindow != null) {
      stats['auxWindows']['buyRatio'] = {
        'length': buyRatioWindow!.length,
        'mean': buyRatioWindow!.length > 0 ? buyRatioWindow!.mean : 0.5,
      };
    }
    
    if (intervalWindow != null) {
      stats['auxWindows']['interval'] = {
        'length': intervalWindow!.length,
        'mean': intervalWindow!.length > 0 ? intervalWindow!.mean : 0.0,
        'variance': intervalWindow!.length > 0 ? intervalWindow!.variance : 0.0,
      };
    }
    
    return stats;
  }

  /// ğŸ” ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Map<String, dynamic> getDataQuality({AdvancedMetrics? onlineMetrics}) {
    final quality = <String, dynamic>{
      'market': market,
      'overall': 'GOOD',
      'issues': <String>[],
      'scores': <String, double>{},
    };
    
    double totalScore = 0.0;
    int windowCount = 0;
    
    // ê°€ê²© ìœˆë„ìš° í’ˆì§ˆ ê²€ì‚¬
    for (final entry in _priceWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      double score = 1.0;
      
      if (window.isEmpty) {
        quality['issues'].add('Empty price window: $timeframe');
        score = 0.0;
      } else if (window.length < entry.key.inSeconds / 10) {
        quality['issues'].add('Insufficient data in price window: $timeframe');
        score = 0.5;
      } else if (window.stdev == 0) {
        quality['issues'].add('No price variance in window: $timeframe');
        score = 0.3;
      }
      
      quality['scores']['price_$timeframe'] = score;
      totalScore += score;
      windowCount++;
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° í’ˆì§ˆ ê²€ì‚¬
    for (final entry in _volumeWindows.entries) {
      final timeframe = '${entry.key.inSeconds}s';
      final window = entry.value;
      
      double score = 1.0;
      
      if (window.isEmpty) {
        quality['issues'].add('Empty volume window: $timeframe');
        score = 0.0;
      } else if (window.sum == 0) {
        quality['issues'].add('No volume in window: $timeframe');
        score = 0.0;
      }
      
      quality['scores']['volume_$timeframe'] = score;
      totalScore += score;
      windowCount++;
    }
    
    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í’ˆì§ˆ ê²€ì‚¬
    if (onlineMetrics != null) {
      final metricsHealth = onlineMetrics.getSystemHealth();
      final marketHealth = metricsHealth['markets']?[market];
      
      if (marketHealth != null) {
        double metricsScore = 1.0;
        
        if (marketHealth['isStale'] == true) {
          quality['issues'].add('Online metrics are stale');
          metricsScore = 0.3;
        } else if (marketHealth['rsi']?['isReady'] != true) {
          quality['issues'].add('RSI calculator not ready');
          metricsScore = 0.5;
        } else if (marketHealth['macd']?['isReady'] != true) {
          quality['issues'].add('MACD calculator not ready');
          metricsScore = 0.5;
        }
        
        quality['scores']['online_metrics'] = metricsScore;
        totalScore += metricsScore;
        windowCount++;
        
        // ì˜¨ë¼ì¸ ì§€í‘œ ìƒì„¸ ì •ë³´ ì¶”ê°€
        quality['onlineMetrics'] = {
          'rsi': marketHealth['rsi'],
          'macd': marketHealth['macd'],
          'lastUpdate': marketHealth['lastUpdate'],
        };
      }
    }
    
    // ì „ì²´ í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°
    final overallScore = windowCount > 0 ? totalScore / windowCount : 0.0;
    quality['overallScore'] = overallScore;
    
    if (overallScore >= 0.8) {
      quality['overall'] = 'EXCELLENT';
    } else if (overallScore >= 0.6) {
      quality['overall'] = 'GOOD';
    } else if (overallScore >= 0.4) {
      quality['overall'] = 'FAIR';
    } else {
      quality['overall'] = 'POOR';
    }
    
    return quality;
  }

  /// ğŸ§¹ ìœˆë„ìš° ì •ë¦¬ (ë©”ëª¨ë¦¬ ìµœì í™” + ì˜¨ë¼ì¸ ì§€í‘œ)
  void cleanup({bool force = false, AdvancedMetrics? onlineMetrics}) {
    final now = DateTime.now();
    
    for (final window in _priceWindows.values) {
      if (force || (window.timestamps.isNotEmpty && 
          now.difference(window.timestamps.last).inMinutes > 30)) {
        // ì˜¤ë˜ëœ ë°ì´í„°ë‚˜ force í”Œë˜ê·¸ì‹œ ì •ë¦¬
        window.clear();
      }
    }
    
    for (final window in _volumeWindows.values) {
      if (force || (window.timestamps.isNotEmpty && 
          now.difference(window.timestamps.last).inMinutes > 30)) {
        window.clear();
      }
    }
    
    buyRatioWindow?.clear();
    intervalWindow?.clear();
    
    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œë„ í•¨ê»˜ ì •ë¦¬
    if (onlineMetrics != null && force) {
      onlineMetrics.resetMarket(market);
    }
  }

  /// ğŸ” ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
  void _validateWindows() {
    // ê°€ê²© ìœˆë„ìš° ê²€ì‚¬
    for (final entry in _priceWindows.entries) {
      final timeframe = entry.key;
      final window = entry.value;
      
      if (window.span != timeframe) {
        throw ArgumentError(
          'Price window span mismatch: expected ${timeframe.inSeconds}s, '
          'got ${window.span.inSeconds}s'
        );
      }
    }
    
    // ê±°ë˜ëŸ‰ ìœˆë„ìš° ê²€ì‚¬
    for (final entry in _volumeWindows.entries) {
      final timeframe = entry.key;
      final window = entry.value;
      
      if (window.span != timeframe) {
        throw ArgumentError(
          'Volume window span mismatch: expected ${timeframe.inSeconds}s, '
          'got ${window.span.inSeconds}s'
        );
      }
    }
  }
}\n\n// ====== lib/core/utils/circular_buffer.dart ======\n
\n\n// ====== lib/core/utils/analysis_isolate_manager.dart ======\n
\n\n// ====== lib/core/extensions/result.dart ======\n
import 'package:meta/meta.dart';
import '../error/app_exception.dart';

/// Either ìŠ¤íƒ€ì¼ì˜ ê²°ê³¼ íƒ€ì….
///
/// - `Ok<T, E>`: ì„±ê³µ ì‹œ ë°ì´í„°ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
/// - `Err<T, E>`: ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
@immutable
sealed class Result<T, E extends AppException> {
  const Result();

  /// ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
  R when<R>({
    required R Function(T value) ok,
    required R Function(E error) err,
  }) {
    if (this is Ok<T, E>) {
      return ok((this as Ok<T, E>).value);
    } else {
      return err((this as Err<T, E>).error);
    }
  }

  /// ì„±ê³µ ì—¬ë¶€
  bool get isOk => this is Ok<T, E>;

  /// ì‹¤íŒ¨ ì—¬ë¶€
  bool get isErr => this is Err<T, E>;

  /// ì„±ê³µ ê°’ (ì—†ìœ¼ë©´ null)
  T? get valueOrNull => isOk ? (this as Ok<T, E>).value : null;

  /// ì‹¤íŒ¨ ì˜ˆì™¸ (ì—†ìœ¼ë©´ null)
  E? get errorOrNull => isErr ? (this as Err<T, E>).error : null;

  /// ì„±ê³µ ê°’ì„ ë§¤í•‘í•©ë‹ˆë‹¤.
  Result<U, E> map<U>(U Function(T value) f) {
    if (this is Ok<T, E>) {
      return Ok<U, E>(f((this as Ok<T, E>).value));
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  /// ì‹¤íŒ¨ ì˜ˆì™¸ë¥¼ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
  /// ì„±ê³µ ì‹œì—ë„ ìƒˆë¡œìš´ ì—ëŸ¬ íƒ€ì… F ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤.
  Result<T, F> mapErr<F extends AppException>(F Function(E error) f) {
    if (this is Err<T, E>) {
      final err = (this as Err<T, E>).error;
      return Err<T, F>(f(err));
    }
    return Ok<T, F>((this as Ok<T, E>).value);
  }

  /// ì„±ê³µ ì‹œ ë¹„ë™ê¸° í›„ì† ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  Future<Result<U, E>> thenAsync<U>(Future<U> Function(T value) f) async {
    if (this is Ok<T, E>) {
      final T value = (this as Ok<T, E>).value;
      try {
        final u = await f(value);
        return Ok<U, E>(u);
      } on AppException catch (e) {
        final E errVal = e is E ? e : AppException(e.message) as E;
        return Err<U, E>(errVal);
      } catch (e) {
        final E errVal = AppException(e.toString()) as E;
        return Err<U, E>(errVal);
      }
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  @override
  String toString() {
    if (this is Ok<T, E>) {
      return 'Ok(${(this as Ok<T, E>).value})';
    } else {
      return 'Err(${(this as Err<T, E>).error})';
    }
  }
}

/// ì„±ê³µ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Ok<T, E extends AppException> extends Result<T, E> {
  final T value;
  const Ok(this.value);
}

/// ì‹¤íŒ¨ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Err<T, E extends AppException> extends Result<T, E> {
  final E error;
  const Err(this.error);
}
\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

import 'package:dio/dio.dart';

/// ìµœìƒìœ„ ì•± ì˜ˆì™¸
/// - ëª¨ë“  ì»¤ìŠ¤í…€ ì˜ˆì™¸ëŠ” ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†í•´ì£¼ì„¸ìš”.
class AppException implements Exception {
  /// ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  ë©”ì‹œì§€
  final String message;

  /// ë‚´ë¶€ ë¡œê¹… ë˜ëŠ” ì‹ë³„ìš© ì½”ë“œ (nullable)
  final String? code;

  /// HTTP ìƒíƒœ ì½”ë“œ ë“± ì¶”ê°€ ìƒíƒœ ì •ë³´
  final int? statusCode;

  /// ì›ë³¸ ì˜ˆì™¸(ìˆëŠ” ê²½ìš°)
  final Exception? originalException;

  const AppException(
    this.message, {
    this.code,
    this.statusCode,
    this.originalException,
  });

  @override
  String toString() {
    final parts = <String>[];
    if (code != null) parts.add('code: $code');
    if (statusCode != null) parts.add('status: $statusCode');
    parts.add('message: $message');
    return 'AppException(${parts.join(', ')})';
  }
}

/// REST/HTTP í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class NetworkException extends AppException {
  const NetworkException(
    String message, {
    String? code,
    int? statusCode,
    Exception? originalException,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
          originalException: originalException,
        );

  /// DioException â†’ NetworkException ë³€í™˜ í—¬í¼
  factory NetworkException.fromDio(DioException dioError) {
    final msg = dioError.message ?? dioError.toString();
    return NetworkException(
      msg,
      code: dioError.response?.statusMessage,
      statusCode: dioError.response?.statusCode,
      originalException: dioError,
    );
  }
}

/// WebSocket ì—°ê²°/í†µì‹  ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class WebSocketException extends AppException {
  /// WS ì„œë²„ê°€ ë³´ë‚¸ ì´ìœ  ë¬¸ìì—´ (nullable)
  final String? reason;

  const WebSocketException(
    String message, {
    this.reason,
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );

  @override
  String toString() {
    final parts = <String>[];
    if (reason != null) parts.add('reason: $reason');
    parts.add('message: $message');
    return 'WebSocketException(${parts.join(', ')})';
  }
}

/// ì„œë²„ë¡œë¶€í„° Rate Limit(HTTP 429 ë“±) ì‘ë‹µì„ ë°›ì•˜ì„ ë•Œ
class RateLimitException extends AppException {
  /// ì¬ì‹œë„ê¹Œì§€ ëŒ€ê¸°í•´ì•¼ í•  ì‹œê°„
  final Duration retryAfter;

  const RateLimitException(
    String message, {
    required this.retryAfter,
    String? code,
    int? statusCode,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
        );

  @override
  String toString() =>
      'RateLimitException(retryAfter: ${retryAfter.inSeconds}s, message: $message)';
}

/// JSON íŒŒì‹± ë˜ëŠ” ë°ì´í„° ë³€í™˜ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class DataParsingException extends AppException {
  const DataParsingException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ì¸ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ í‚¤ë¥¼ ì°¾ì§€ ëª»í–ˆì„ ë•Œ
class CacheMissException extends AppException {
  const CacheMissException([String message = 'Cache miss'])
      : super(message);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ë„ë©”ì¸ íŠ¹í™” ì˜ˆì™¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// ì²´ê²°(Trade) ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜
class TradeException extends AppException {
  const TradeException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜¸ê°€(Order Book) ë°ì´í„° ì˜¤ë¥˜
class OrderBookException extends AppException {
  const OrderBookException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ìº”ë“¤(Candle) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class CandleException extends DataParsingException {
  const CandleException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜„ì¬ê°€(Ticker) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class TickerException extends DataParsingException {
  const TickerException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}
\n\n// ====== lib/core/event/app_event.dart ======\n
// lib/core/event/app_event.dart

import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';

typedef Json = Map<String, dynamic>;

/// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì´ë²¤íŠ¸ì˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤
/// - id     : UUID v4
/// - ts     : UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
/// - payload: ììœ  í˜•íƒœ JSON
class AppEvent extends Equatable {
  /// ê³ ìœ  ID (UUID v4)
  final String id;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int ts;

  /// í˜ì´ë¡œë“œ ë°ì´í„° (ë¶ˆë³€)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// í˜„ì¬ ì‹œê°ì„ ê¸°ì¤€ìœ¼ë¡œ idÂ·tsë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: const Uuid().v4(),
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // ë°©ì–´ì  ë³µì‚¬
    );
  }

  /// UTC ms â†’ ë¡œì»¬ DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON ì§ë ¬í™” (payloadë„ ë³µì‚¬í•˜ì—¬ ë…¸ì¶œ)
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON ì—­ì§ë ¬í™”
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  /// ë³µì‚¬ë³¸ ìƒì„± (immutable ìœ ì§€)
  AppEvent copyWith({
    String? id,
    int? ts,
    Json? payload,
  }) =>
      AppEvent(
        id: id ?? this.id,
        ts: ts ?? this.ts,
        payload: payload != null ? Map<String, dynamic>.of(payload) : this.payload,
      );

  @override
  List<Object?> get props => [id, ts, payload];
}
\n\n// ====== lib/core/services/hive_service.dart ======\n
// lib/core/services/hive_service.dart

import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../utils/logger.dart';
import '../../data/models/trade_dto.dart';
import '../../data/models/market_mood_dto.dart'; // ğŸ”¥ MarketMood DTO ì¶”ê°€

/// ğŸ¯ Hive ì „ì—­ ê´€ë¦¬ ì„œë¹„ìŠ¤ (ì‹±ê¸€í†¤)
/// - ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ì´ˆê¸°í™”
/// - ëª¨ë“  TypeAdapter ë“±ë¡ ë° Box ê´€ë¦¬
/// - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ Box ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// - AppConfigì— ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ì™„ì „ ë…ë¦½ ì„œë¹„ìŠ¤
class HiveService {
  // ì‹±ê¸€í†¤ íŒ¨í„´
  HiveService._();
  static final HiveService _instance = HiveService._();
  factory HiveService() => _instance;

  // ğŸ·ï¸ Box ì´ë¦„ ìƒìˆ˜ (HiveService ìì²´ ê´€ë¦¬)
  static const String _tradeBoxName = 'trades';
  static const String _marketMoodVolumeBoxName = 'market_mood_volume'; // ğŸ”¥ ì¶”ê°€
  static const String _marketMoodCacheBoxName = 'market_mood_cache';   // ğŸ”¥ ì¶”ê°€

  // Box ì¸ìŠ¤í„´ìŠ¤ ìºì‹±
  late final Box<TradeDto> _tradeBox;
  late final Box<TimestampedVolume> _marketMoodVolumeBox; // ğŸ”¥ ì¶”ê°€
  late final Box _marketMoodCacheBox; // ğŸ”¥ ì¶”ê°€ (dynamic)
  
  // ì´ˆê¸°í™” ìƒíƒœ ê´€ë¦¬
  bool _initialized = false;
  Future<void>? _initFuture;

  /// ğŸ¯ Trade Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box<TradeDto> get tradeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using tradeBox.'
      );
    }
    return _tradeBox;
  }

  /// ğŸ”¥ MarketMood Volume Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box<TimestampedVolume> get marketMoodVolumeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using marketMoodVolumeBox.'
      );
    }
    return _marketMoodVolumeBox;
  }

  /// ğŸ”¥ MarketMood Cache Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box get marketMoodCacheBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using marketMoodCacheBox.'
      );
    }
    return _marketMoodCacheBox;
  }

  /// ğŸš€ Hive ì´ˆê¸°í™” (ì•± ì‹œì‘ ì‹œ ë‹¨ í•œ ë²ˆë§Œ í˜¸ì¶œ)
  Future<void> init() async {
    if (_initialized) {
      log.i('[HiveService] already initialized, skipping');
      return;
    }

    // ë™ì‹œ í˜¸ì¶œ ë°©ì–´ - race condition ì™„ì „ ì°¨ë‹¨
    if (_initFuture != null) {
      log.d('[HiveService] init already in progress, waiting...');
      return _initFuture;
    }

    _initFuture = _doInit();
    await _initFuture;
  }

  /// ğŸ”§ ì‹¤ì œ ì´ˆê¸°í™” ë¡œì§
  Future<void> _doInit() async {
    try {
      // 1. Hive í”Œë«í¼ ì´ˆê¸°í™”
      await Hive.initFlutter();
      log.i('[HiveService] Hive.initFlutter() completed');

      // 2. TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
      _registerAdapters();

      // 3. ëª¨ë“  Box ì—´ê¸° ë° ìºì‹±
      _tradeBox = await Hive.openBox<TradeDto>(_tradeBoxName);
      log.i('[HiveService] "$_tradeBoxName" box opened and cached');

      _marketMoodVolumeBox = await Hive.openBox<TimestampedVolume>(_marketMoodVolumeBoxName); // ğŸ”¥ ì¶”ê°€
      log.i('[HiveService] "$_marketMoodVolumeBoxName" box opened and cached');

      _marketMoodCacheBox = await Hive.openBox(_marketMoodCacheBoxName); // ğŸ”¥ ì¶”ê°€
      log.i('[HiveService] "$_marketMoodCacheBoxName" box opened and cached');

      _initialized = true;
      log.i('[HiveService] âœ… initialized successfully');
      
    } catch (e, st) {
      log.e('[HiveService] âŒ init failed', e, st);
      _initialized = false;
      rethrow; // ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ìƒìœ„ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡
    } finally {
      // ì´ˆê¸°í™” ì™„ë£Œ í›„ Future í•´ì œ (ì¬ì‹œë„ ê°€ëŠ¥í•˜ë„ë¡)
      _initFuture = null;
    }
  }

  /// ğŸ“‹ ëª¨ë“  TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
  void _registerAdapters() {
    // Trade Adapter
    final tradeAdapter = TradeDtoAdapter();
    if (!Hive.isAdapterRegistered(tradeAdapter.typeId)) {
      Hive.registerAdapter(tradeAdapter);
      log.i('[HiveService] TradeDtoAdapter registered (typeId: ${tradeAdapter.typeId})');
    } else {
      log.d('[HiveService] TradeDtoAdapter already registered');
    }
    
    // ğŸ”¥ TimestampedVolume Adapter ì¶”ê°€
    final volumeAdapter = TimestampedVolumeAdapter();
    if (!Hive.isAdapterRegistered(volumeAdapter.typeId)) {
      Hive.registerAdapter(volumeAdapter);
      log.i('[HiveService] TimestampedVolumeAdapter registered (typeId: ${volumeAdapter.typeId})');
    } else {
      log.d('[HiveService] TimestampedVolumeAdapter already registered');
    }
    
    // ğŸ“ í–¥í›„ ë‹¤ë¥¸ ì–´ëŒ‘í„° ì¶”ê°€ ì‹œ ì—¬ê¸°ì— ì¶”ê°€
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ ì‹¤í–‰)
  /// ì¼ë°˜ì ìœ¼ë¡œ ëª¨ë°”ì¼ ì•±ì—ì„œëŠ” OSê°€ ìë™ ì •ë¦¬í•˜ë¯€ë¡œ í˜¸ì¶œ ë¶ˆí•„ìš”
  Future<void> dispose() async {
    if (!kDebugMode) {
      log.d('[HiveService] dispose skipped in production mode');
      return;
    }
    
    if (!_initialized) {
      log.d('[HiveService] not initialized, skip dispose');
      return;
    }

    try {
      if (_tradeBox.isOpen) {
        await _tradeBox.close();
        log.i('[HiveService] "$_tradeBoxName" box closed');
      }

      // ğŸ”¥ MarketMood Boxë“¤ ì •ë¦¬ ì¶”ê°€
      if (_marketMoodVolumeBox.isOpen) {
        await _marketMoodVolumeBox.close();
        log.i('[HiveService] "$_marketMoodVolumeBoxName" box closed');
      }

      if (_marketMoodCacheBox.isOpen) {
        await _marketMoodCacheBox.close();
        log.i('[HiveService] "$_marketMoodCacheBoxName" box closed');
      }

      await Hive.close();
      log.i('[HiveService] ğŸ§¹ all Hive resources disposed');
      
    } catch (e, st) {
      log.e('[HiveService] dispose failed', e, st);
    } finally {
      _initialized = false;
    }
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: í˜„ì¬ ìƒíƒœ ì •ë³´
  Map<String, Object> get debugInfo => {
    'initialized': _initialized,
    'tradeBox': {
      'name': _tradeBoxName,
      'open': _initialized ? _tradeBox.isOpen : false,
      'length': _initialized ? _tradeBox.length : 0,
    },
    'marketMoodVolumeBox': { // ğŸ”¥ ì¶”ê°€
      'name': _marketMoodVolumeBoxName,
      'open': _initialized ? _marketMoodVolumeBox.isOpen : false,
      'length': _initialized ? _marketMoodVolumeBox.length : 0,
    },
    'marketMoodCacheBox': { // ğŸ”¥ ì¶”ê°€
      'name': _marketMoodCacheBoxName,
      'open': _initialized ? _marketMoodCacheBox.isOpen : false,
      'length': _initialized ? _marketMoodCacheBox.length : 0,
    },
    'initInProgress': _initFuture != null,
  };

  /// ğŸ” ë””ë²„ê¹…ìš©: ìƒíƒœ ë¡œê¹…
  void logStatus() {
    log.d('[HiveService] Status: $debugInfo');
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: Box ìƒì„¸ ì •ë³´ (ê°œë°œ ì‹œ ìœ ìš©)
  void logBoxDetails() {
    if (!_initialized) {
      log.w('[HiveService] Cannot log box details - not initialized');
      return;
    }
    
    log.d('[HiveService] Box Details:');
    log.d('  Trade Box:');
    log.d('    - Name: $_tradeBoxName');
    log.d('    - Length: ${_tradeBox.length}');
    log.d('    - Keys sample: ${_tradeBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_tradeBox.isOpen}');
    
    // ğŸ”¥ MarketMood Box ì •ë³´ ì¶”ê°€
    log.d('  MarketMood Volume Box:');
    log.d('    - Name: $_marketMoodVolumeBoxName');
    log.d('    - Length: ${_marketMoodVolumeBox.length}');
    log.d('    - Keys sample: ${_marketMoodVolumeBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_marketMoodVolumeBox.isOpen}');
    
    log.d('  MarketMood Cache Box:');
    log.d('    - Name: $_marketMoodCacheBoxName');
    log.d('    - Length: ${_marketMoodCacheBox.length}');
    log.d('    - Keys sample: ${_marketMoodCacheBox.keys.take(5).toList()}');
    log.d('    - Is open: ${_marketMoodCacheBox.isOpen}');
  }
}