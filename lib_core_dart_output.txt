\n\n// ====== lib/core/config/app_config.dart ======\n
// lib/core/config/app_config.dart

import 'dart:collection';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:logger/logger.dart';
import '../utils/logger.dart';
import '../../features/trade/data/models/trade_dto.dart';

/// Application-wide configuration and constants,
/// optimized per Upbit REST & WebSocket specifications.
class AppConfig {
  AppConfig._();

  /// Call once at startup to initialize dynamic config (env, Hive, etc.)
  static Future<void> init({String? envPath}) async {
    // 1) Load .env (optional custom path) + validate
    try {
      if (envPath != null && envPath.isNotEmpty) {
        await dotenv.load(fileName: envPath);
      } else {
        await dotenv.load();
      }
      log.i('[AppConfig] .env loaded');
      _loadEnv();
    } catch (e, st) {
      log.e('[AppConfig] âš ï¸ Failed to load required env vars', e, st);
      throw Exception('[AppConfig] âš ï¸ Failed to load required env vars: $e');
    }

    // 2) Initialize Hive, register adapter, and open typed box
    try {
      await Hive.initFlutter();
      if (!Hive.isAdapterRegistered(TradeDtoAdapter().typeId)) {
        Hive.registerAdapter(TradeDtoAdapter());
      }
      if (!Hive.isBoxOpen(_cacheBox)) {
        await Hive.openBox<TradeDto>(_cacheBox);
      }
      log.i('[AppConfig] Hive box "$_cacheBox" opened with TradeDto type');
    } catch (e, st) {
      log.w('[AppConfig] âš ï¸ Hive init error: $e', e, st);
    }

    log.i('[AppConfig] initialized (debug=$isDebugMode)');
  }

  static void _loadEnv() {
    const requiredKeys = ['UPBIT_API_KEY', 'UPBIT_API_SECRET'];
    for (final key in requiredKeys) {
      final value = dotenv.env[key];
      if (value == null || value.isEmpty) {
        throw Exception('[AppConfig] Missing required env var: $key');
      }
    }

    upbitRestBase = dotenv.env['UPBIT_REST_URL']!.isNotEmpty
        ? dotenv.env['UPBIT_REST_URL']!
        : upbitRestBase;
    upbitWsUrl = dotenv.env['UPBIT_WS_URL']!.isNotEmpty
        ? dotenv.env['UPBIT_WS_URL']!
        : upbitWsUrl;

    _apiKey = dotenv.env['UPBIT_API_KEY']!;
    _apiSecret = dotenv.env['UPBIT_API_SECRET']!;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ API Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _apiKey = '';
  static String _apiSecret = '';
  static String get apiKey => _apiKey;
  static String get apiSecret => _apiSecret;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Environment Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// `true` when not in Dart VM product mode.
  static const bool isDebugMode = !bool.fromEnvironment('dart.vm.product');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ê°œë°œ ì¤‘ ì¡°ì ˆ ê°€ëŠ¥)
  static Level get logLevel {
    if (!isDebugMode) return Level.warning; // í”„ë¡œë•ì…˜: warning ì´ìƒë§Œ
    
    // ê°œë°œ ëª¨ë“œì—ì„œ í™˜ê²½ë³€ìˆ˜ë¡œ ì¡°ì ˆ ê°€ëŠ¥
    final envLevel = dotenv.env['LOG_LEVEL']?.toLowerCase();
    switch (envLevel) {
      case 'verbose': return Level.verbose;
      case 'debug': return Level.debug;
      case 'info': return Level.info;
      case 'warning': return Level.warning;
      case 'error': return Level.error;
      default: return Level.debug; // ê¸°ë³¸ê°’
    }
  }
  
  /// íŠ¹ì • ëª¨ë“ˆ ë¡œê·¸ on/off
  static bool get enableSignalBusLog => 
      dotenv.env['ENABLE_SIGNAL_BUS_LOG']?.toLowerCase() != 'false';
  static bool get enableWebSocketLog => 
      dotenv.env['ENABLE_WEBSOCKET_LOG']?.toLowerCase() != 'false';
  static bool get enableTradeLog => 
      dotenv.env['ENABLE_TRADE_LOG']?.toLowerCase() != 'false';
  static bool get enableAdaptiveBackoffLog => 
      dotenv.env['ENABLE_ADAPTIVE_BACKOFF_LOG']?.toLowerCase() != 'false';

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REST Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String upbitRestBase = 'https://api.upbit.com/v1';
  static const int restRateLimitCount = 15;
  static const Duration restRateLimitPeriod = Duration(seconds: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WebSocket Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String upbitWsUrl = 'wss://api.upbit.com/websocket/v1';
  static const int wsMaxSubscriptionCount = 200;

  // Upbit ê¶Œì¥ íƒ€ì´ë°ìœ¼ë¡œ ë³€ê²½:
  static const Duration wsPingInterval = Duration(seconds: 10);
  static const Duration wsPongTimeout = Duration(seconds: 20);

  static const int wsMaxRetryCount = 5;
  static const Duration wsInitialBackoff = Duration(seconds: 1);
  static const Duration wsMaxBackoff = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Aggregation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const int mergeWindowMs = 1000;
  static const Duration globalResetInterval = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dev/Test Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static bool useTestDataInDev = false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trade Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const String _cacheBox = 'trades';

  static final List<double> _filters = [
    2e6, 5e6, 1e7, 2e7, 5e7,
    1e8, 2e8, 3e8, 4e8, 5e8,
    1e9,
  ];
  static UnmodifiableListView<double> get tradeFilters =>
      UnmodifiableListView(_filters);

  /// Human-readable labels always in sync with `_filters`
  static Map<double, String> get filterNames => Map.unmodifiable({
        for (final f in _filters) f: _formatFilterLabel(f),
      });

  /// Update the trade filters at runtime (ensures positive & sorted)
  static void updateFilters(List<double> newFilters) {
    _filters
      ..clear()
      ..addAll(newFilters.where((f) => f > 0))
      ..sort();
    log.i('[AppConfig] filters updated â†’ $_filters');
  }

  static String _formatFilterLabel(double f) {
    if (f >= 1e8 && f % 1e8 == 0) return '${(f / 1e8).toInt()}ì–µ';
    if (f >= 1e7 && f % 1e7 == 0) return '${(f / 1e7).toInt()}ì²œë§Œ';
    if (f >= 1e6 && f % 1e6 == 0) return '${(f / 1e6).toInt()}ë°±ë§Œ';
    return f.toStringAsFixed(0);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candle Timeframes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const List<int> timeFrames = [
    1, 5, 15, 30, 60, 120, 240, 480, 720, 1440
  ];
  static final Map<int, String> timeFrameNames = Map.unmodifiable({
    1: '1ë¶„',
    5: '5ë¶„',
    15: '15ë¶„',
    30: '30ë¶„',
    60: '1ì‹œê°„',
    120: '2ì‹œê°„',
    240: '4ì‹œê°„',
    480: '8ì‹œê°„',
    720: '12ì‹œê°„',
    1440: '1ì¼',
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Surge Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const double surgeThresholdPercent = 1.1;
  static const Duration surgeWindowDuration = Duration(minutes: 1);
}\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';
import '../event/app_event.dart'; // Json typedef
import '../utils/logger.dart'; // log.d ì‚¬ìš©

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('Created type controller for $type');
        return ctrl;
      }).stream;

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('Closed platform controller for $key');
            },
          );
      log.d('Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('Global controller closed, skipping event: $type');
      }

      // Type-specific subscribers
      final ctrl = _typeControllers[type];
      if (ctrl != null && !ctrl.isClosed) {
        ctrl.add(enriched);
      } else if (ctrl != null) {
        log.w('Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      log.d(enriched.toString().length <= 100
          ? 'SignalBus: $type @${platform.name} â†’ $enriched'
          : 'SignalBus: $type @${platform.name} â†’ ${enriched.toString().substring(0, 100)}â€¦');
    } catch (e, st) {
      final msg = 'SignalBus error: $e';
      log.e(msg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(msg);
      } else {
        log.w('Error controller closed, error not dispatched: $msg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    _typeControllers.forEach((type, ctrl) {
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('Closed type controller for $type');
      }
    });
    _typeControllers.clear();

    // Close platform-specific controllers
    _platformControllers.forEach((key, ctrl) {
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('Closed platform controller for $key');
      }
    });
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('Closed error controller');
    }

    log.i('SignalBus fully disposed');
  }
}\n\n// ====== lib/core/network/websocket/ticker_ws_client.dart ======\n
// lib/core/network/websocket/ticker_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜„ì¬ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TickerWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TickerWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'ticker-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'ticker',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/candle_ws_client.dart ======\n
// lib/core/network/websocket/candle_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œìº”ë“¤â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
/// [timeFrame]: e.g. "1m", "5m", "15m", ...
class CandleWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  CandleWsClient({
    required String timeFrame,
    void Function(WsStatus)? onStatusChange,
  }) : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'candle-$timeFrame-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'candles_$timeFrame',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œì²´ê²°â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import '../../config/app_config.dart';
import '../ws_rate_limiter_interceptor.dart';
import '../../error/app_exception.dart';
import '../adaptive_backoff.dart'; // AdaptiveBackoff ì—°ë™

typedef DecodeFn<T> = T Function(dynamic json);
typedef EncodeFn = String Function(List<String> symbols);

/// WebSocket connection status notifications.
enum WsStatus {
  connecting,
  connected,
  failed,
  disconnected,
  error,
  reconnecting,
  pongTimeout,
  maxRetryExceeded,
}

/// Common WebSocket client: connect, subscribe, reconnect, emit
class BaseWsClient<T> {
  /// Helper to decode a JSON list (or single object) into a List<Map<String, dynamic>>.
  static List<Map<String, dynamic>> decodeJsonList(dynamic raw) {
    final jsonObj = raw is String ? jsonDecode(raw) : raw;
    final list = jsonObj is List ? jsonObj : [jsonObj];
    return list
        .cast<Map<String, dynamic>>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final void Function(WsStatus)? onStatusChange;
  final WsRateLimiter _rateLimiter;
  final AdaptiveBackoffCalculator _backoffCalculator = AdaptiveBackoffCalculator();
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  WebSocketChannel? _channel;
  final _controller = StreamController<T>.broadcast();
  List<String> _symbols = [];
  Timer? _pingTimer;
  Timer? _pongTimer;
  bool _disposed = false;
  bool _reconnecting = false;
  int _retryCount = 0;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    WsRateLimiter? rateLimiter,
  }) : _rateLimiter = rateLimiter ?? WsRateLimiter() {
    _startMemoryCleanup();
  }

  /// Start periodic cleanup of inactive subscriptions.
  void _startMemoryCleanup() {
    _memoryCleanupTimer = Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
    });
  }

  /// Clean up paused subscriptions to prevent memory leaks.
  void _cleanupInactiveSubscriptions() {
    final toRemove = _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      sub.cancel();
      _activeSubscriptions.remove(sub);
    }
    if (toRemove.isNotEmpty) {
      debugPrint('WSClient: Cleaned up ${toRemove.length} inactive subscriptions');
    }
  }

  /// Exposed stream of decoded messages.
  Stream<T> get stream => _controller.stream;

  /// Connect or reconnect with a new set of symbols.
  Future<void> connect(List<String> symbols) async {
    _notify(WsStatus.connecting);
    if (_disposed) return;
    _symbols = List.from(symbols);
    await _channel?.sink.close();

    try {
      if (_symbols.length > AppConfig.wsMaxSubscriptionCount) {
        throw const WebSocketException('Subscribe limit exceeded');
      }
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _setupPing();
      _send(encodeSubscribe(_symbols));

      final subscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _retryCount = 0;
      _backoffCalculator.recordSuccess();
      _notify(WsStatus.connected);
    } catch (e) {
      debugPrint('WS connect failed: $e');
      _backoffCalculator.recordFailure();
      _notify(WsStatus.failed);
      _scheduleReconnect();
    }
  }

  void _handleData(dynamic raw) {
    _pongTimer?.cancel();
    try {
      final text = raw is List<int> ? utf8.decode(raw) : raw.toString();
      final jsonObj = jsonDecode(text);
      final data = decode(jsonObj);
      _controller.add(data);
    } catch (e, st) {
      debugPrint('WS processing error: $e\n$st');
    }
  }

  void _handleDone() {
    debugPrint('WS closed');
    _notify(WsStatus.disconnected);
    _scheduleReconnect();
  }

  void _handleError(dynamic e) {
    debugPrint('WS error: $e, details: ${e.toString()}');
    _backoffCalculator.recordFailure();
    _notify(WsStatus.error);
    _scheduleReconnect();
  }

  void _send(String msg) => _rateLimiter.enqueue(() {
        try {
          _channel?.sink.add(msg);
          debugPrint('WS â–¶ $msg');
        } catch (e, st) {
          debugPrint('WS send error: $e\n$st');
        }
      });

  void _setupPing() {
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _pingTimer = Timer.periodic(AppConfig.wsPingInterval, (_) {
      _send(jsonEncode({'type': 'ping'}));
      _pongTimer = Timer(AppConfig.wsPongTimeout, () {
        debugPrint('Pong timeout, reconnecting');
        _notify(WsStatus.pongTimeout);
        _scheduleReconnect();
      });
    });
  }

  /// Schedule reconnection with adaptive backoff.
  void _scheduleReconnect() {
    if (_disposed || _reconnecting) return;
    _reconnecting = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();

    _backoffCalculator
        .calculateBackoff(
          _retryCount,
          AppConfig.wsInitialBackoff,
          AppConfig.wsMaxBackoff,
        )
        .then((adaptiveDelay) {
          if (_disposed) return;
          Future.delayed(adaptiveDelay, () {
            if (_disposed) return;
            if (_retryCount < AppConfig.wsMaxRetryCount) {
              _retryCount++;
              debugPrint(
                  'Reconnect attempt #$_retryCount after ${adaptiveDelay.inMilliseconds}ms');
              _notify(WsStatus.reconnecting);
              connect(_symbols).whenComplete(() => _reconnecting = false);
            } else {
              debugPrint('Max WS retries exceeded');
              _notify(WsStatus.maxRetryExceeded);
              _retryCount = 0;
              _reconnecting = false;
            }
          });
        });
  }

  void _notify(WsStatus status) => onStatusChange?.call(status);

  /// Dispose resources: timers, rate limiter, channel, controller, and backoff calculator.
  Future<void> dispose() async {
    _disposed = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _memoryCleanupTimer?.cancel();

    for (final sub in _activeSubscriptions) {
      await sub.cancel();
    }
    _activeSubscriptions.clear();

    _rateLimiter.dispose();
    await _channel?.sink.close();
    await _controller.close();
    _backoffCalculator.recordSuccess(); // Reset backoff state
    debugPrint('WSClient disposed');
  }
}\n\n// ====== lib/core/network/websocket/orderbook_ws_client.dart ======\n
// lib/core/network/websocket/orderbook_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜¸ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class OrderbookWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  OrderbookWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'orderbook-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'orderbook',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/auth_interceptor.dart ======\n
// lib/core/network/auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// Upbit REST API í˜¸ì¶œ ì‹œ JWT ë°©ì‹ì˜ ì¸ì¦ í—¤ë”ë¥¼ ë¶™ì—¬ì¤ë‹ˆë‹¤.
/// - payloadì— access_key, nonce, (query_hash, query_hash_alg)ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.
/// - ì•Œê³ ë¦¬ì¦˜: HS256
class AuthInterceptor extends Interceptor {
  final String apiKey;
  final String apiSecret;

  AuthInterceptor({required this.apiKey, required this.apiSecret});

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    try {
      final nonce = DateTime.now().millisecondsSinceEpoch.toString();
      final payload = <String, dynamic>{
        'access_key': apiKey,
        'nonce': nonce,
      };

      if (options.queryParameters.isNotEmpty || _hasRequestBody(options)) {
        final raw = options.queryParameters.isNotEmpty
            ? Uri(queryParameters: options.queryParameters).query
            : jsonEncode(options.data);
        payload['query_hash'] = sha512.convert(utf8.encode(raw)).toString();
        payload['query_hash_alg'] = 'SHA512';
      }

      // JWT Header and Payload
      const headerMap = {'alg': 'HS256', 'typ': 'JWT'};
      final headerJson = jsonEncode(headerMap);
      final payloadJson = jsonEncode(payload);
      final headerSeg = _base64UrlEncode(headerJson);
      final payloadSeg = _base64UrlEncode(payloadJson);

      // Signature
      final sigBytes = Hmac(sha256, utf8.encode(apiSecret))
          .convert(utf8.encode('$headerSeg.$payloadSeg'))
          .bytes;
      final sigSeg = base64Url.encode(sigBytes).replaceAll('=', '');

      options.headers['Authorization'] =
          'Bearer $headerSeg.$payloadSeg.$sigSeg';
    } catch (e, st) {
      log.e('AuthInterceptor error', e, st);
      return handler.reject(
        DioException(requestOptions: options, error: e),
      );
    }

    handler.next(options);
  }

  bool _hasRequestBody(RequestOptions options) {
    final data = options.data;
    if (data == null) return false;
    if (data is String) return data.isNotEmpty;
    if (data is Iterable || data is Map) return data.isNotEmpty;
    if (data is FormData) return data.fields.isNotEmpty || data.files.isNotEmpty;
    return true;
  }

  String _base64UrlEncode(String input) =>
      base64Url.encode(utf8.encode(input)).replaceAll('=', '');
}
\n\n// ====== lib/core/network/adaptive_backoff.dart ======\n
// lib/core/network/adaptive_backoff.dart

import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../utils/logger.dart';

class AdaptiveBackoffCalculator {
  final Connectivity _connectivity = Connectivity();
  int _consecutiveFailures = 0;
  DateTime? _lastFailureTime;
  
  // ë„¤íŠ¸ì›Œí¬ë³„ ê¸°ë³¸ ì§€í„° ê³„ìˆ˜ (connectivity_plus ì—°ë™)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.8,      // WiFiëŠ” ë¹ ë¥¸ ì¬ì—°ê²°
    ConnectivityResult.mobile: 1.2,    // ëª¨ë°”ì¼ì€ ë³´ìˆ˜ì 
    ConnectivityResult.ethernet: 0.6,  // ìœ ì„ ì€ ê°€ì¥ ë¹ ë¦„
    ConnectivityResult.none: 2.0,      // ì—°ê²° ì—†ìŒì€ ë§¤ìš° ë³´ìˆ˜ì 
  };

  Future<Duration> calculateBackoff(int attempt, Duration baseDelay, Duration maxDelay) async {
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0; // ê¸°ë³¸ê°’
    
    final failurePenalty = _calculateFailurePenalty();
    
    final exponentialMs = baseDelay.inMilliseconds * (1 << attempt);
    final cappedMs = math.min(exponentialMs, maxDelay.inMilliseconds);
    
    // ì§€í„° ë²”ìœ„ 20%ë¡œ ë¹ ë¥¸ ì¬ì—°ê²° ë³´ì¥
    final jitterRange = cappedMs * 0.2;
    final random = math.Random();
    final adaptiveJitter = random.nextDouble() * jitterRange * networkMultiplier * failurePenalty;
    
    final finalMs = math.max(0, cappedMs + adaptiveJitter.round());
    
    log.d('AdaptiveBackoff: attempt=$attempt, network=$connectivityResult, '
          'base=${cappedMs}ms, jitter=${adaptiveJitter.round()}ms, final=${finalMs}ms');
    
    return Duration(milliseconds: finalMs);
  }

  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;
    
    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      _consecutiveFailures = 0;
      return 1.0;
    }
    
    // í˜ë„í‹° ìƒí•œ 1.5ë°°ë¡œ ì¡°ì • (ê·¸ë¡ì˜ ìˆ˜ì •ì‚¬í•­ ìœ ì§€)
    return math.min(1.5, 1.0 + (_consecutiveFailures * 0.2));
  }

  void recordFailure() {
    _consecutiveFailures++;
    _lastFailureTime = DateTime.now();
  }

  void recordSuccess() {
    _consecutiveFailures = 0;
    _lastFailureTime = null;
  }
}\n\n// ====== lib/core/network/retry_interceptor.dart ======\n
// lib/core/network/retry_interceptor.dart

import 'dart:async';
import 'dart:math';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 429 í˜¹ì€ 5xx ì—ëŸ¬ì— ëŒ€í•´ ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„° ë°©ì‹ìœ¼ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤.
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialBackoff;
  final Duration maxBackoff;
  final double jitterFactor;

  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialBackoff = const Duration(milliseconds: 500),
    this.maxBackoff = const Duration(seconds: 5),
    this.jitterFactor = 0.2,
  });

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    final options = err.requestOptions;
    final retryCount = (options.extra['retry_count'] as int?) ?? 0;

    if (_shouldRetry(err) && retryCount < maxRetries) {
      final next = retryCount + 1;
      options.extra['retry_count'] = next;
      final delay = _computeBackoff(next);
      log.i('Retry #\$next for [\${options.method} \${options.path}] in \${delay.inMilliseconds}ms');
      await Future.delayed(delay);
      try {
        final response = await dio.fetch(options);
        return handler.resolve(response);
      } on DioException catch (e) {
        return handler.next(e);
      }
    }

    handler.next(err);
  }

  bool _shouldRetry(DioException err) {
    final status = err.response?.statusCode;
    return err.type == DioExceptionType.badResponse &&
        (status == 429 || (status != null && status >= 500 && status < 600));
  }

  Duration _computeBackoff(int attempt) {
    final expMs = initialBackoff.inMilliseconds * (1 << (attempt - 1));
    final cap = min(expMs, maxBackoff.inMilliseconds);
    final jitter = ((Random().nextDouble() * 2 - 1) * jitterFactor * cap).round();
    final finalMs = max(0, cap + jitter);
    return Duration(milliseconds: finalMs);
  }
}
\n\n// ====== lib/core/network/ws_rate_limiter_interceptor.dart ======\n
// lib/core/network/ws_rate_limiter_interceptor.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../utils/logger.dart';

/// Upbit WebSocket êµ¬ë… ë©”ì‹œì§€ ë°œí–‰ ê°„ ìµœì†Œ ê°„ê²© ë³´ì¥ ìœ í‹¸
class WsRateLimiter {
  final Duration minInterval;
  final Queue<VoidCallback> _queue = Queue<VoidCallback>();
  bool _isFlushing = false;
  DateTime _lastSent = DateTime.fromMillisecondsSinceEpoch(0);

  WsRateLimiter({this.minInterval = const Duration(milliseconds: 500)});

  /// ë©”ì‹œì§€ë¥¼ íì— ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ì „ì†¡ ì‹œë„
  void enqueue(VoidCallback send) {
    _queue.add(send);
    _flushNext();
  }

  void _flushNext() {
    if (_isFlushing || _queue.isEmpty) return;
    _isFlushing = true;

    final now = DateTime.now();
    final elapsed = now.difference(_lastSent);
    final delay = elapsed >= minInterval ? Duration.zero : minInterval - elapsed;

    Timer(delay, () {
      final send = _queue.removeFirst();
      try {
        send();
        _lastSent = DateTime.now();
        log.d('WsRateLimiter sent, next after \${minInterval.inMilliseconds}ms');
      } catch (e, st) {
        log.e('WsRateLimiter send error', e, st);
      } finally {
        _isFlushing = false;
        if (_queue.isNotEmpty) _flushNext();
      }
    });
  }

  /// íë¥¼ ë¹„ìš°ê³  ì‚¬ìš© ì¤‘ì§€
  void dispose() {
    _queue.clear();
  }
}
\n\n// ====== lib/core/network/api_client.dart ======\n
// lib/core/network/api_client.dart

import 'dart:async';
import 'dart:collection';
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';
import 'auth_interceptor.dart';
import 'retry_interceptor.dart';
import 'logging_interceptor.dart';

typedef Json = Map<String, dynamic>;

/// Upbit REST API ì´ˆë‹¹ í˜¸ì¶œ ì œí•œì„ ê´€ë¦¬í•˜ëŠ” RateLimiter
class _RateLimiter {
  final int maxRequests;
  final Duration period;
  final Queue<DateTime> _timestamps = Queue<DateTime>();

  _RateLimiter({required this.maxRequests, required this.period});

  /// í˜¸ì¶œ ì „ í—ˆìš© ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê³ , í•„ìš” ì‹œ ëŒ€ê¸°í•©ë‹ˆë‹¤.
  Future<void> throttle() async {
    final now = DateTime.now();
    // ê¸°ê°„ ì´ˆê³¼ëœ ê¸°ë¡ ì œê±°
    while (_timestamps.isNotEmpty && now.difference(_timestamps.first) > period) {
      _timestamps.removeFirst();
    }
    if (_timestamps.length >= maxRequests) {
      final earliest = _timestamps.first;
      final wait = period - now.difference(earliest);
      await Future.delayed(wait);
      // ëŒ€ê¸° í›„ ë‹¤ì‹œ ì˜¤ë˜ëœ ê¸°ë¡ ì •ë¦¬
      final now2 = DateTime.now();
      while (_timestamps.isNotEmpty && now2.difference(_timestamps.first) > period) {
        _timestamps.removeFirst();
      }
    }
    _timestamps.addLast(DateTime.now());
  }
}

/// In-memory cache entry with timestamp.
class _MemCacheEntry<T> {
  final T data;
  final DateTime ts;
  _MemCacheEntry(this.data) : ts = DateTime.now();

  bool fresh(Duration dur) => DateTime.now().difference(ts) < dur;
}

/// Simple LRU cache based on insertion order, with a maxEntries limit.
class _MemCache {
  final int maxEntries;
  final Map<String, _MemCacheEntry<dynamic>> _box;

  _MemCache({this.maxEntries = 100}) : _box = <String, _MemCacheEntry<dynamic>>{};

  T? get<T>(String key, Duration dur) {
    final entry = _box[key];
    if (entry == null || !entry.fresh(dur)) return null;
    return entry.data as T;
  }

  void put<T>(String key, T data) {
    if (_box.length >= maxEntries) {
      final oldestKey = _box.keys.first;
      _box.remove(oldestKey);
    }
    _box[key] = _MemCacheEntry<T>(data);
  }

  void invalidate(String key) => _box.remove(key);

  void clear() => _box.clear();
}

/// Converts a query map into a stable, sorted query string.
/// Silently skips values that cannot be represented.
String _stableQueryString(Json? query) {
  if (query == null || query.isEmpty) return '';
  try {
    final entries = query.entries
      .where((e) => e.value != null)
      .toList()
      ..sort((a, b) => a.key.compareTo(b.key));
    final params = <String, String>{};
    for (final e in entries) {
      final v = e.value;
      if (v is List) {
        params[e.key] = v.join(',');
      } else {
        params[e.key] = v.toString();
      }
    }
    return Uri(queryParameters: params).query;
  } catch (e, st) {
    log.e('StableQueryString failed', e, st);
    return '';
  }
}

/// REST í˜¸ì¶œìš© Dio ë˜í¼
/// - Auth/Retry/Logging ì¸í„°ì…‰í„° ìë™ ì—°ê²°
/// - Simple LRU-based in-memory cache ì§€ì›
/// - Upbit REST API rate limit(ì´ˆë‹¹ 15íšŒ) ìë™ ê´€ë¦¬
class ApiClient {
  final Dio _dio;
  final _MemCache _cache;
  final _RateLimiter _rateLimiter;

  /// [apiKey], [apiSecret] ëŠ” Upbit Open API ìê²©ì¦ëª…
  ApiClient({
    Dio? dio,
    required String apiKey,
    required String apiSecret,
    int cacheSize = 100,
  })  : _dio = dio ?? Dio(),
        _cache = _MemCache(maxEntries: cacheSize),
        _rateLimiter = _RateLimiter(
          maxRequests: AppConfig.restRateLimitCount,
          period: AppConfig.restRateLimitPeriod,
        ) {
    _dio.interceptors.addAll([
      AuthInterceptor(apiKey: apiKey, apiSecret: apiSecret),
      RetryInterceptor(dio: _dio),
      LoggingInterceptor(),
    ]);
  }

  /// [method]: GET, POST ë“±
  /// [path]: ì „ì²´ URL ë˜ëŠ” baseUrl ì´í›„ ê²½ë¡œ
  /// [query]: URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
  /// [body]: JSON ë°”ë””
  /// [cacheDur]: nullì´ ì•„ë‹ ë•Œ ìºì‹œ ì‚¬ìš© (ê¸°ê°„ ì§€ì •)
  Future<Result<R, NetworkException>> request<R>({
    required String method,
    required String path,
    Json? query,
    Json? body,
    Duration? cacheDur,
  }) async {
    // Upbit REST rate limit ì ìš©
    await _rateLimiter.throttle();

    String? cacheKey;
    if (cacheDur != null) {
      final qstr = _stableQueryString(query);
      cacheKey = '\$method|\$path|\$qstr';
      final cached = _cache.get<R>(cacheKey, cacheDur);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      final response = await _dio.request<R>(
        path,
        queryParameters: query,
        data: body,
        options: Options(method: method),
      );

      final data = response.data;
      if (cacheKey != null && data != null) {
        _cache.put<R>(cacheKey, data as R);
      }

      return Ok(data as R);
    } on DioException catch (dioErr) {
      return Err(NetworkException.fromDio(dioErr));
    } catch (e, st) {
      log.e('ApiClient unexpected error', e, st);
      final ex = e is Exception ? e : Exception(e.toString());
      return Err(NetworkException(e.toString(), originalException: ex));
    }
  }
}\n\n// ====== lib/core/network/logging_interceptor.dart ======\n
// lib/core/network/logging_interceptor.dart

import 'dart:convert';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// ëª¨ë“  REST ìš”ì²­ê³¼ ì‘ë‹µ, ì˜¤ë¥˜ë¥¼ ë¡œê¹…í•©ë‹ˆë‹¤.
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    log.i('--> ${options.method} ${options.uri}');
    if (options.data != null && options.data is! String) {
      try {
        // ë³€ìˆ˜ ì—†ì´ ë°”ë¡œ inlineí•´ì„œ ì‚¬ìš©
        log.d('Request Data:\n${const JsonEncoder.withIndent('  ').convert(options.data)}');
      } catch (e, st) {
        log.d('Request Data serialization failed', e, st);
      }
    }
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    log.i('<-- ${response.statusCode} ${response.requestOptions.uri}');
    final text = response.data is String
        ? response.data as String
        : response.data.toString();
    if (text.isNotEmpty) {
      log.d(text.length > 500 ? '${text.substring(0, 500)}...' : text);
    }
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // uri/status ì§ì ‘ inline
    log.e('<-- Error ${err.response?.statusCode} ${err.requestOptions.uri}', err, err.stackTrace);
    handler.next(err);
  }
}
\n\n// ====== lib/core/navigation/app_router.dart ======\n
// lib/core/navigation/app_router.dart

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

import '../config/app_config.dart';
import '../../features/settings/presentation/pages/settings_page.dart';
import '../../features/trade/presentation/pages/trade_page.dart';
import '../../app.dart'; // scaffoldMessengerKeyProvider, selectedTabProvider

/// Available application routes.
enum AppRoute { trade, settings, notification }

/// Extension to provide path and label for each route.
extension AppRouteExtension on AppRoute {
  String get path {
    switch (this) {
      case AppRoute.trade:
        return '/';
      case AppRoute.settings:
        return '/settings';
      case AppRoute.notification:
        return '/notification';
    }
  }

  String get label {
    switch (this) {
      case AppRoute.trade:
        return 'ì²´ê²°';
      case AppRoute.settings:
        return 'ì„¤ì •';
      case AppRoute.notification:
        return 'ì•Œë¦¼';
    }
  }
}

/// ì „ì²´ ì•± ë¼ìš°í„° ë° FCM í•¸ë“¤ëŸ¬ ê´€ë¦¬
class AppRouter {
  final WidgetRef ref;
  final GlobalKey<NavigatorState> navigatorKey;
  late final GoRouter router;

  /// Bottom navigation routes
  static const bottomRoutes = [AppRoute.trade, AppRoute.settings];

  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;

  AppRouter(this.ref, this.navigatorKey) {
    router = GoRouter(
      navigatorKey: navigatorKey,
      initialLocation: AppRoute.trade.path,
      debugLogDiagnostics: AppConfig.isDebugMode,
      routes: [
        ShellRoute(
          builder: (context, state, child) {
            final idx = ref.watch(selectedTabProvider);
            return Scaffold(
              body: child,
              bottomNavigationBar: BottomNavigationBar(
                type: BottomNavigationBarType.fixed,
                currentIndex: idx.clamp(0, bottomRoutes.length - 1),
                onTap: (i) {
                  ref.read(selectedTabProvider.notifier).state = i;
                  context.go(bottomRoutes[i].path);
                },
                items: bottomRoutes.map((route) {
                  return BottomNavigationBarItem(
                    icon: Icon(
                      route == AppRoute.trade
                          ? Icons.show_chart
                          : Icons.settings,
                    ),
                    label: route.label,
                  );
                }).toList(),
              ),
            );
          },
          routes: [
            GoRoute(
              path: AppRoute.trade.path,
              name: AppRoute.trade.name,
              builder: (context, state) => const TradePage(),
            ),
            GoRoute(
              path: AppRoute.settings.path,
              name: AppRoute.settings.name,
              builder: (context, state) => const SettingsPage(),
            ),
          ],
        ),
        GoRoute(
          path: AppRoute.notification.path,
          name: AppRoute.notification.name,
          builder: (context, state) {
            final data = state.extra as Map<String, dynamic>?;
            return Scaffold(
              appBar: AppBar(title: const Text('ì•Œë¦¼ ìƒì„¸')),
              body: Padding(
                padding: const EdgeInsets.all(16),
                child: Text(data?.toString() ?? 'ë°ì´í„° ì—†ìŒ'),
              ),
            );
          },
        ),
      ],
    );
  }

  /// Register FCM listeners and keep subscriptions for cleanup.
  void setupFCMListeners() {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;

    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null && messenger != null) {
        messenger
          ..hideCurrentSnackBar()
          ..showSnackBar(SnackBar(content: Text('${n.title}: ${n.body}')));
      }
    });

    // Initial message (cold start)
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        router.go(AppRoute.notification.path, extra: msg.data);
      }
    });

    _onMessageOpenedSub =
        FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      router.go(AppRoute.notification.path, extra: msg.data);
    });
  }

  /// Cleanup subscriptions when router is disposed.
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
  }
}
\n\n// ====== lib/core/utils/date_time.dart ======\n
import 'package:intl/intl.dart';

/// DateTime extension utilities for formatting and comparison.
extension DateTimeX on DateTime {
  /// `2024-05-17 22:05:01` â†’ `22:05:01`
  String hhmmss() => DateFormat('HH:mm:ss').format(this);

  /// `2024-05-17` í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMdd() => DateFormat('yyyy-MM-dd').format(this);

  /// `22:05` í˜•ì‹ì˜ ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String hhmm() => DateFormat('HH:mm').format(this);

  /// `2024-05-17 22:05` í˜•ì‹ì˜ ë‚ ì§œ+ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMddhhmm() => DateFormat('yyyy-MM-dd HH:mm').format(this);

  /// í˜„ì¬ ì‹œê°„ê³¼ì˜ ì°¨ì´ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ í‘œì‹œ
  /// ì˜ˆ: 'ë°©ê¸ˆ ì „', '3ë¶„ ì „', '2ì‹œê°„ ì „', 'ì–´ì œ', '3ì¼ ì „', '2ì£¼ ì „', '5ê°œì›” ì „', '1ë…„ ì „'
  String timeAgo() {
    final now = DateTime.now();
    final diff = now.difference(this);

    if (diff.inSeconds < 60) return 'ë°©ê¸ˆ ì „';
    if (diff.inMinutes < 60) return '${diff.inMinutes}ë¶„ ì „';
    if (diff.inHours < 24) return '${diff.inHours}ì‹œê°„ ì „';
    if (diff.inDays < 2) return 'ì–´ì œ';
    if (diff.inDays < 7) return '${diff.inDays}ì¼ ì „';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}ì£¼ ì „';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}ê°œì›” ì „';
    return '${(diff.inDays / 365).floor()}ë…„ ì „';
  }

  /// UTC ë°€ë¦¬ì´ˆ(ms)ë¥¼ ë¡œì»¬ DateTimeìœ¼ë¡œ ë³€í™˜
  static DateTime fromEpochMs(int ms) =>
      DateTime.fromMillisecondsSinceEpoch(ms, isUtc: true).toLocal();

  /// ISO 8601 ë¬¸ìì—´ì„ ë¡œì»¬ DateTimeìœ¼ë¡œ íŒŒì‹±
  static DateTime parseIso8601(String iso) =>
      DateTime.parse(iso).toLocal();

  /// ë™ì¼í•œ ë‚ ì§œì¸ì§€ í™•ì¸
  bool isSameDay(DateTime other) =>
      year == other.year && month == other.month && day == other.day;

  /// ì˜¤ëŠ˜ì¸ì§€ í™•ì¸
  bool get isToday => isSameDay(DateTime.now());

  /// ì–´ì œì¸ì§€ í™•ì¸
  bool get isYesterday =>
      isSameDay(DateTime.now().subtract(const Duration(days: 1)));
}
\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';
import '../config/app_config.dart';

/// ê¸€ë¡œë²Œ Logger ì¸ìŠ¤í„´ìŠ¤
/// - ê°œë°œ ëª¨ë“œ: AppConfig.logLevelì— ë”°ë¼ ë™ì  ì¡°ì ˆ
/// - í”„ë¡œë•ì…˜ëª¨ë“œ: warning ì´ìƒ ìë™
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 0,      // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    errorMethodCount: 5, // ì˜¤ë¥˜ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120,     // ë¡œê·¸ í•œ ì¤„ ìµœëŒ€ ê¸¸ì´
    colors: true,        // ì»¬ëŸ¬ ì¶œë ¥ (í„°ë¯¸ë„)
    printTime: true,     // íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
  ),
  level: AppConfig.logLevel, // ğŸ”¥ í™˜ê²½ë³€ìˆ˜ë¡œ ë™ì  ì¡°ì ˆ ê°€ëŠ¥
);\n\n// ====== lib/core/utils/app_life_cycle_manager.dart ======\n
\n\n// ====== lib/core/extensions/result.dart ======\n
import 'package:meta/meta.dart';
import '../error/app_exception.dart';

/// Either ìŠ¤íƒ€ì¼ì˜ ê²°ê³¼ íƒ€ì….
///
/// - `Ok<T, E>`: ì„±ê³µ ì‹œ ë°ì´í„°ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
/// - `Err<T, E>`: ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
@immutable
sealed class Result<T, E extends AppException> {
  const Result();

  /// ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
  R when<R>({
    required R Function(T value) ok,
    required R Function(E error) err,
  }) {
    if (this is Ok<T, E>) {
      return ok((this as Ok<T, E>).value);
    } else {
      return err((this as Err<T, E>).error);
    }
  }

  /// ì„±ê³µ ì—¬ë¶€
  bool get isOk => this is Ok<T, E>;

  /// ì‹¤íŒ¨ ì—¬ë¶€
  bool get isErr => this is Err<T, E>;

  /// ì„±ê³µ ê°’ (ì—†ìœ¼ë©´ null)
  T? get valueOrNull => isOk ? (this as Ok<T, E>).value : null;

  /// ì‹¤íŒ¨ ì˜ˆì™¸ (ì—†ìœ¼ë©´ null)
  E? get errorOrNull => isErr ? (this is Err<T, E> ? (this as Err<T, E>).error : null) : null;

  /// ì„±ê³µ ê°’ì„ ë§¤í•‘í•©ë‹ˆë‹¤.
  Result<U, E> map<U>(U Function(T value) f) {
    if (this is Ok<T, E>) {
      return Ok<U, E>(f((this as Ok<T, E>).value));
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  /// ì‹¤íŒ¨ ì˜ˆì™¸ë¥¼ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
  /// ì„±ê³µ ì‹œì—ë„ ìƒˆë¡œìš´ ì—ëŸ¬ íƒ€ì… F ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤.
  Result<T, F> mapErr<F extends AppException>(F Function(E error) f) {
    if (this is Err<T, E>) {
      return Err<T, F>(f((this as Err<T, E>).error));
    }
    // ì„±ê³µ ì¼€ì´ìŠ¤ì—ì„œëŠ” ê¸°ì¡´ ê°’ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    return Ok<T, F>((this as Ok<T, E>).value);
  }

  /// ì„±ê³µ ì‹œ ë¹„ë™ê¸° í›„ì† ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  Future<Result<U, E>> thenAsync<U>(Future<U> Function(T value) f) async {
    if (this is Ok<T, E>) {
      final T value = (this as Ok<T, E>).value;
      try {
        final u = await f(value);
        return Ok<U, E>(u);
      } on AppException catch (e) {
        // E íƒ€ì…ì˜ ì—ëŸ¬ë¼ë©´ ê·¸ëŒ€ë¡œ, ì•„ë‹ˆë©´ ìƒˆë¡œìš´ AppException ìœ¼ë¡œ ë˜í•‘
        final E errVal = e is E ? e : AppException(e.message) as E;
        return Err<U, E>(errVal);
      } catch (e) {
        final E errVal = AppException(e.toString()) as E;
        return Err<U, E>(errVal);
      }
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  @override
  String toString() {
    if (this is Ok<T, E>) {
      return 'Ok(${(this as Ok<T, E>).value})';
    } else {
      return 'Err(${(this as Err<T, E>).error})';
    }
  }
}

/// ì„±ê³µ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Ok<T, E extends AppException> extends Result<T, E> {
  final T value;
  const Ok(this.value);
}

/// ì‹¤íŒ¨ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Err<T, E extends AppException> extends Result<T, E> {
  final E error;
  const Err(this.error);
}
\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

import 'package:dio/dio.dart';

/// ìµœìƒìœ„ ì•± ì˜ˆì™¸
/// - ëª¨ë“  ì»¤ìŠ¤í…€ ì˜ˆì™¸ëŠ” ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†í•´ì£¼ì„¸ìš”.
class AppException implements Exception {
  /// ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  ë©”ì‹œì§€
  final String message;

  /// ë‚´ë¶€ ë¡œê¹… ë˜ëŠ” ì‹ë³„ìš© ì½”ë“œ (nullable)
  final String? code;

  /// HTTP ìƒíƒœ ì½”ë“œ ë“± ì¶”ê°€ ìƒíƒœ ì •ë³´
  final int? statusCode;

  /// ì›ë³¸ ì˜ˆì™¸(ìˆëŠ” ê²½ìš°)
  final Exception? originalException;

  const AppException(
    this.message, {
    this.code,
    this.statusCode,
    this.originalException,
  });

  @override
  String toString() {
    final parts = <String>[];
    if (code != null) parts.add('code: $code');
    if (statusCode != null) parts.add('status: $statusCode');
    parts.add('message: $message');
    return 'AppException(${parts.join(', ')})';
  }
}

/// REST/HTTP í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class NetworkException extends AppException {
  const NetworkException(
    String message, {
    String? code,
    int? statusCode,
    Exception? originalException,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
          originalException: originalException,
        );

  /// DioException â†’ NetworkException ë³€í™˜ í—¬í¼
  factory NetworkException.fromDio(DioException dioError) {
    final msg = dioError.message ?? dioError.toString();
    return NetworkException(
      msg,
      code: dioError.response?.statusMessage,
      statusCode: dioError.response?.statusCode,
      originalException: dioError,
    );
  }
}

/// WebSocket ì—°ê²°/í†µì‹  ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class WebSocketException extends AppException {
  /// WS ì„œë²„ê°€ ë³´ë‚¸ ì´ìœ  ë¬¸ìì—´ (nullable)
  final String? reason;

  const WebSocketException(
    String message, {
    this.reason,
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );

  @override
  String toString() {
    final parts = <String>[];
    if (reason != null) parts.add('reason: $reason');
    parts.add('message: $message');
    return 'WebSocketException(${parts.join(', ')})';
  }
}

/// ì„œë²„ë¡œë¶€í„° Rate Limit(HTTP 429 ë“±) ì‘ë‹µì„ ë°›ì•˜ì„ ë•Œ
class RateLimitException extends AppException {
  /// ì¬ì‹œë„ê¹Œì§€ ëŒ€ê¸°í•´ì•¼ í•  ì‹œê°„
  final Duration retryAfter;

  const RateLimitException(
    String message, {
    required this.retryAfter,
    String? code,
    int? statusCode,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
        );

  @override
  String toString() =>
      'RateLimitException(retryAfter: ${retryAfter.inSeconds}s, message: $message)';
}

/// JSON íŒŒì‹± ë˜ëŠ” ë°ì´í„° ë³€í™˜ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class DataParsingException extends AppException {
  const DataParsingException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ì¸ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ í‚¤ë¥¼ ì°¾ì§€ ëª»í–ˆì„ ë•Œ
class CacheMissException extends AppException {
  const CacheMissException([String message = 'Cache miss'])
      : super(message);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ë„ë©”ì¸ íŠ¹í™” ì˜ˆì™¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// ì²´ê²°(Trade) ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜
class TradeException extends AppException {
  const TradeException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜¸ê°€(Order Book) ë°ì´í„° ì˜¤ë¥˜
class OrderBookException extends AppException {
  const OrderBookException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ìº”ë“¤(Candle) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class CandleException extends DataParsingException {
  const CandleException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜„ì¬ê°€(Ticker) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class TickerException extends DataParsingException {
  const TickerException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}
\n\n// ====== lib/core/event/app_event.dart ======\n
// lib/core/event/app_event.dart

import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';

typedef Json = Map<String, dynamic>;

/// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì´ë²¤íŠ¸ì˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤
/// - id     : UUID v4
/// - ts     : UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
/// - payload: ììœ  í˜•íƒœ JSON
class AppEvent extends Equatable {
  /// ê³ ìœ  ID (UUID v4)
  final String id;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int ts;

  /// í˜ì´ë¡œë“œ ë°ì´í„° (ë¶ˆë³€)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// í˜„ì¬ ì‹œê°ì„ ê¸°ì¤€ìœ¼ë¡œ idÂ·tsë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: const Uuid().v4(),
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // ë°©ì–´ì  ë³µì‚¬
    );
  }

  /// UTC ms â†’ ë¡œì»¬ DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON ì§ë ¬í™” (payloadë„ ë³µì‚¬í•˜ì—¬ ë…¸ì¶œ)
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON ì—­ì§ë ¬í™”
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  /// ë³µì‚¬ë³¸ ìƒì„± (immutable ìœ ì§€)
  AppEvent copyWith({
    String? id,
    int? ts,
    Json? payload,
  }) =>
      AppEvent(
        id: id ?? this.id,
        ts: ts ?? this.ts,
        payload: payload != null ? Map<String, dynamic>.of(payload) : this.payload,
      );

  @override
  List<Object?> get props => [id, ts, payload];
}
