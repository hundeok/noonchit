\n\n// ====== lib/core/di/trade_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../services/hive_service.dart';          // ğŸ¯ NEW
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider; // ğŸ†• WebSocket import
import '../../data/datasources/trade_cache_ds.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/app_settings.dart'; // âœ… DisplayMode import
import '../../domain/usecases/trade_usecase.dart';

/// ğŸ†• ë§ˆì¼“ ì •ë³´ í´ë˜ìŠ¤
class MarketInfo {
  final String market;      // KRW-BTC
  final String koreanName;  // ë¹„íŠ¸ì½”ì¸
  final String englishName; // Bitcoin

  const MarketInfo({
    required this.market,
    required this.koreanName,
    required this.englishName,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      market: json['market'] ?? '',
      koreanName: json['korean_name'] ?? '',
      englishName: json['english_name'] ?? '',
    );
  }
}

/// 0) REST API client
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient(
      apiKey: AppConfig.apiKey,
      apiSecret: AppConfig.apiSecret,
    ));

/// ğŸ¯ HiveService Provider (main.dartì—ì„œ override)
final hiveServiceProvider = Provider<HiveService>((ref) {
  throw UnimplementedError('HiveService must be provided via main.dart override');
});

/// ğŸ†• ë§ˆì¼“ ì •ë³´ Provider (1ì‹œê°„ ìºì‹œ)
final marketInfoProvider = FutureProvider<Map<String, MarketInfo>>((ref) async {
  final client = ref.read(apiClientProvider);
  
  try {
    final result = await client.request<List<dynamic>>(
      method: 'GET',
      path: '${AppConfig.upbitRestBase}/market/all',
      cacheDur: const Duration(hours: 1), // 1ì‹œê°„ ìºì‹œ
    );
    
    return result.when(
      ok: (markets) {
        final Map<String, MarketInfo> marketMap = {};
        for (final market in markets) {
          if (market is Map<String, dynamic>) {
            final info = MarketInfo.fromJson(market);
            marketMap[info.market] = info;
          }
        }
        if (AppConfig.enableTradeLog) {
          log.i('ë§ˆì¼“ ì •ë³´ ë¡œë“œë¨: ${marketMap.length}ê°œ');
        }
        return marketMap;
      },
      err: (error) {
        log.w('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: $error');
        return <String, MarketInfo>{};
      },
    );
  } catch (e) {
    log.e('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e');
    return <String, MarketInfo>{};
  }
});

/// ğŸ†• í‘œì‹œ ëª¨ë“œ Provider (ì„¤ì •ì—ì„œ ê´€ë¦¬ë  ì˜ˆì •)
final displayModeProvider = StateProvider<DisplayMode>((ref) => DisplayMode.ticker);

/// ğŸ†• ì½”ì¸ëª… í‘œì‹œ í—¬í¼ í•¨ìˆ˜
String getDisplayName(String market, MarketInfo? marketInfo, DisplayMode mode) {
  final ticker = market.replaceFirst('KRW-', '');
  
  switch (mode) {
    case DisplayMode.ticker:
      return ticker;
    case DisplayMode.korean:
      return marketInfo?.koreanName ?? ticker;
    case DisplayMode.english:
      return marketInfo?.englishName ?? ticker;
  }
}

/// 1) KRW market list (top 199 by volume + essentials)
final marketsProvider = FutureProvider<List<String>>((ref) async {
  final client = ref.read(apiClientProvider);

  // fetch all markets (cache 5 minutes)
  final marketResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/market/all',
    cacheDur: const Duration(minutes: 5),
  );
  final allMarkets =
      marketResult.when(ok: (v) => v, err: (_) => <dynamic>[]);

  // filter KRW markets
  final krwMarkets = allMarkets
      .whereType<Map<String, dynamic>>()
      .map((m) => m['market'] as String)
      .where((code) => code.startsWith('KRW-'))
      .toList();

  // pick top by 24h volume (or acc_trade_price when outside 9â€“10am)
  final now = DateTime.now();
  final isEarly = now.hour >= 9 && now.hour < 10;
  final key = isEarly ? 'acc_trade_price_24h' : 'acc_trade_price';

  // real-time ticker lookup (no cache)
  final tickerResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/ticker',
    query: {'markets': krwMarkets.join(',')},
    cacheDur: null,
  );
  final tickers = tickerResult
      .when(ok: (v) => v, err: (_) => <dynamic>[])  
      .whereType<Map<String, dynamic>>()
      .toList()
    ..sort((a, b) =>
        ((b[key] as num?) ?? 0).compareTo((a[key] as num?) ?? 0));

  // â”€â”€â”€ WS êµ¬ë… ì¢…ëª© ìŠ¬ë¼ì´ì‹± ë¡œì§ (essentials ìš°ì„  + ì¤‘ë³µ ì œê±° í›„ ìƒìœ„ 199ê°œ) â”€â”€â”€
  const essentials = ['KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL'];
  final sortedMarkets = tickers.map((e) => e['market'] as String).toList();
  final combined = [
    ...essentials,
    ...sortedMarkets.where((m) => !essentials.contains(m)),
  ];
  return combined.take(199).toList();
});

final cacheDSProvider = Provider<TradeCacheDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return TradeCacheDataSource(hive.tradeBox);
});

final remoteDSProvider = Provider((ref) => TradeRemoteDataSource(
      ref.read(wsClientProvider), // ğŸ”„ websocket_providerì—ì„œ import
      ref.read(signalBusProvider),
      useTestData: AppConfig.useTestDataInDev,
    ));

final repoProvider = Provider((ref) => TradeRepositoryImpl(
      ref.read(remoteDSProvider),
      ref.read(cacheDSProvider),
    ));

final usecaseProvider = Provider((ref) => TradeUsecase(ref.read(repoProvider)));

/// 3) Filter state
final tradeFilterIndexProvider = StateProvider<int>((_) => 0);
final tradeFilterThresholdProvider = StateProvider<double>((ref) =>
    AppConfig.tradeFilters.firstWhere(
      (f) => f >= 20000000,
      orElse: () => AppConfig.tradeFilters.last,
    ));

/// 4) Filtered trades stream
final tradeListProvider = StreamProvider.autoDispose<List<Trade>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // í˜„ì¬ threshold ê°’ê³¼ marketsë¥¼ ì½ì–´ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  final threshold = ref.watch(tradeFilterThresholdProvider);
  final markets = await ref.watch(marketsProvider.future);
  final repository = ref.read(repoProvider);

  // threshold ë³€ê²½ ì‹œ Repositoryì—ë„ ì—…ë°ì´íŠ¸
  ref.listen<double>(tradeFilterThresholdProvider, (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i(
          'Threshold changed: ${prev.toStringAsFixed(0)} â†’ ${next.toStringAsFixed(0)}',
        );
      }
      repository.updateThreshold(next);
    }
  });

  // ì‹¤ì œ í•„í„°ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°©ì¶œ
  yield* repository.watchFilteredTrades(threshold, markets);
});

/// 5) Aggregated trades stream
final aggregatedTradeProvider = StreamProvider.autoDispose<Trade>((ref) {
  // Prevent dispose on background
  ref.keepAlive();
  final repository = ref.read(repoProvider);
  return repository.watchAggregatedTrades();
});

/// 6) Helper to change threshold & index
final tradeThresholdController = Provider((ref) => TradeThresholdController(ref));

class TradeThresholdController {
  final Ref ref;
  TradeThresholdController(this.ref);

  void updateThreshold(double threshold, int index) {
    final options =
        AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    if (index < 0 || index >= options.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid threshold index: $index');
      return;
    }
    ref.read(tradeFilterThresholdProvider.notifier).state = threshold;
    ref.read(tradeFilterIndexProvider.notifier).state = index;
    AppConfig.updateFilters(options);
    if (AppConfig.enableTradeLog) {
      log.i(
        'Threshold updated: ${threshold.toStringAsFixed(0)} (index: $index)',
      );
    }
  }

  double get currentThreshold => ref.read(tradeFilterThresholdProvider);
  int get currentIndex => ref.read(tradeFilterIndexProvider);
  List<double> get availableThresholds =>
      AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
}\n\n// ====== lib/core/di/websocket_provider.dart ======\n
// lib/core/di/websocket_provider.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../network/websocket/trade_ws_client.dart';
import '../network/websocket/base_ws_client.dart'; // WsStatus enum
import '../utils/logger.dart';
import '../bridge/signal_bus.dart';

/// ğŸ†• WebSocket ìƒì„¸ í†µê³„ í´ë˜ìŠ¤ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸° ì¤‘ì‹¬)
class WebSocketStats {
  final DateTime? connectTime;
  final int reconnectCount;
  final int totalSessions;
  final Duration cumulativeConnectTime;
  final int connectionAttempts;
  final DateTime? lastStateChangeTime;
  
  const WebSocketStats({
    this.connectTime,
    this.reconnectCount = 0,
    this.totalSessions = 0,
    this.cumulativeConnectTime = Duration.zero,
    this.connectionAttempts = 0,
    this.lastStateChangeTime,
  });

  /// ì—°ê²° ì§€ì† ì‹œê°„ ê³„ì‚°
  Duration? get uptime {
    if (connectTime == null) return null;
    return DateTime.now().difference(connectTime!);
  }

  /// í‰ê·  ì—°ê²° ì§€ì† ì‹œê°„
  Duration get averageSessionDuration {
    if (totalSessions == 0) return Duration.zero;
    return Duration(
      milliseconds: cumulativeConnectTime.inMilliseconds ~/ totalSessions,
    );
  }

  /// ì—°ê²° ì„±ê³µë¥  (%)
  double get connectionSuccessRate {
    if (connectionAttempts == 0) return 0.0;
    return (totalSessions / connectionAttempts) * 100;
  }
}

/// ğŸ”„ SignalBus Provider (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});

/// ğŸ†• WebSocket ìƒíƒœ ê´€ë¦¬
final wsStatusProvider = StateProvider<WsStatus>((ref) => WsStatus.disconnected);

/// ğŸ†• WebSocket í†µê³„ ê´€ë¦¬ (ê°œë³„ Providerë“¤ - ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
final wsConnectTimeProvider = StateProvider<DateTime?>((ref) => null);
final wsReconnectCountProvider = StateProvider<int>((ref) => 0);
final wsTotalSessionsProvider = StateProvider<int>((ref) => 0);
final wsCumulativeConnectTimeProvider = StateProvider<Duration>((ref) => Duration.zero);
final wsConnectionAttemptsProvider = StateProvider<int>((ref) => 0);
final wsLastStateChangeTimeProvider = StateProvider<DateTime?>((ref) => null);

/// ğŸ†• í†µí•© WebSocket í†µê³„ Provider (ê°œë³„ Providerë“¤ì„ ì¡°í•©)
final wsStatsProvider = Provider<WebSocketStats>((ref) {
  final connectTime = ref.watch(wsConnectTimeProvider);
  final reconnectCount = ref.watch(wsReconnectCountProvider);
  final totalSessions = ref.watch(wsTotalSessionsProvider);
  final cumulativeConnectTime = ref.watch(wsCumulativeConnectTimeProvider);
  final connectionAttempts = ref.watch(wsConnectionAttemptsProvider);
  final lastStateChangeTime = ref.watch(wsLastStateChangeTimeProvider);

  return WebSocketStats(
    connectTime: connectTime,
    reconnectCount: reconnectCount,
    totalSessions: totalSessions,
    cumulativeConnectTime: cumulativeConnectTime,
    connectionAttempts: connectionAttempts,
    lastStateChangeTime: lastStateChangeTime,
  );
});

/// ğŸ†• WebSocket í´ë¼ì´ì–¸íŠ¸ (ê¸°ë³¸ - ê¸°ì¡´ ê·¸ëŒ€ë¡œ)
final wsClientProvider = Provider<TradeWsClient>((ref) {
  return TradeWsClient(
    onStatusChange: (status) {
      final now = DateTime.now();
      ref.read(wsStatusProvider.notifier).state = status;
      ref.read(wsLastStateChangeTimeProvider.notifier).state = now;
      
      // ê°„ë‹¨í•œ í†µê³„ ì—…ë°ì´íŠ¸ (ì‹œê°„/ì—°ê²°/ì•±ìƒëª…ì£¼ê¸°)
      switch (status) {
        case WsStatus.connecting:
          // ì—°ê²° ì‹œë„ ì¹´ìš´íŠ¸
          final attempts = ref.read(wsConnectionAttemptsProvider);
          ref.read(wsConnectionAttemptsProvider.notifier).state = attempts + 1;
          break;
          
        case WsStatus.connected:
          // ì—°ê²° ì„±ê³µ
          ref.read(wsConnectTimeProvider.notifier).state = now;
          
          // ì´ ì„¸ì…˜ ìˆ˜ ì¦ê°€
          final sessions = ref.read(wsTotalSessionsProvider);
          ref.read(wsTotalSessionsProvider.notifier).state = sessions + 1;
          break;
          
        case WsStatus.reconnecting:
          // ì¬ì—°ê²° ì¹´ìš´íŠ¸
          final currentCount = ref.read(wsReconnectCountProvider);
          ref.read(wsReconnectCountProvider.notifier).state = currentCount + 1;
          break;
          
        case WsStatus.disconnected:
          // ì—°ê²° ì¢…ë£Œ ì‹œ ëˆ„ì  ì‹œê°„ ì—…ë°ì´íŠ¸
          final connectTime = ref.read(wsConnectTimeProvider);
          if (connectTime != null) {
            final sessionDuration = now.difference(connectTime);
            final cumulative = ref.read(wsCumulativeConnectTimeProvider);
            ref.read(wsCumulativeConnectTimeProvider.notifier).state = 
                cumulative + sessionDuration;
          }
          ref.read(wsConnectTimeProvider.notifier).state = null;
          break;
          
        default:
          break;
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('WebSocket status changed: $status');
      }
    },
  );
});\n\n// ====== lib/core/di/app_providers.dart ======\n
// lib/core/di/app_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../bridge/signal_bus.dart';

/// â–¶ App lifecycle (sliderPositionProvider ì œê±°ë¨)
export '../utils/app_life_cycle_manager.dart'
    show appLifecycleManagerProvider;

/// â–¶ Settings DI + state (settingsProvider â†’ appSettingsProvider)
export 'settings_provider.dart'
    show
        sharedPreferencesProvider,
        settingsLocalDSProvider,
        settingsRepositoryProvider,
        settingsUsecaseProvider,
        appSettingsProvider; // ğŸ”§ ì´ë¦„ ë³€ê²½!

/// â–¶ Domain entities (DisplayMode ë“± enum export)
export '../../domain/entities/app_settings.dart'
    show
        DisplayMode, // ğŸ†• DisplayMode enum export
        SliderPosition; // ê¸°ì¡´ SliderPositionë„ ëª…ì‹œì  export

/// â–¶ WebSocket DI & stats (ğŸ†• ìƒˆë¡œ ì¶”ê°€)
export 'websocket_provider.dart'
    show
        wsStatusProvider,
        wsClientProvider,
        wsStatsProvider,
        WebSocketStats;

/// â–¶ Trade DI & streams
export 'trade_provider.dart';

/// â–¶ Trade í™”ë©´ ë¡œì§
export '../../presentation/controllers/trade_controller.dart'
    show tradeControllerProvider;

/// â–¶ ì „ì—­ SnackBar key
final scaffoldMessengerKeyProvider =
    Provider<GlobalKey<ScaffoldMessengerState>>((ref) {
  return GlobalKey<ScaffoldMessengerState>();
});

/// â–¶ BottomTab ì¸ë±ìŠ¤
final selectedTabProvider = StateProvider<int>((ref) => 0);

/// â–¶ SignalBus ì‹±ê¸€í„´
/// Riverpodì´ dispose ì‹œì ì— ìë™ìœ¼ë¡œ SignalBus.dispose() í˜¸ì¶œ
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});\n\n// ====== lib/core/di/notification_provider.dart ======\n
// lib/core/di/notification_provider.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../utils/logger.dart';
import 'app_providers.dart'; // scaffoldMessengerKeyProvider

/// ğŸ”” ì•Œë¦¼ íƒ€ì… enum
enum NotificationType {
  trade,       // ì²´ê²° ì•Œë¦¼
  priceAlert,  // ê°€ê²© ì•Œë¦¼  
  volume,      // ê±°ë˜ëŸ‰ ì•Œë¦¼
  surge,       // ê¸‰ë“±ë½ ì•Œë¦¼
  system,      // ì‹œìŠ¤í…œ ì•Œë¦¼
}

/// ğŸ”” ì•Œë¦¼ ìƒíƒœ enum  
enum NotificationStatus {
  unread,      // ì½ì§€ ì•ŠìŒ
  read,        // ì½ìŒ
  archived,    // ë³´ê´€ë¨
}

/// ğŸ”” ì•Œë¦¼ ë°ì´í„° ëª¨ë¸ (ì„ì‹œ)
class NotificationData {
  final String id;
  final String title;
  final String message;
  final NotificationType type;
  final NotificationStatus status;
  final DateTime createdAt;
  final Map<String, dynamic>? extra;

  const NotificationData({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    this.status = NotificationStatus.unread,
    required this.createdAt,
    this.extra,
  });

  NotificationData copyWith({
    NotificationStatus? status,
    Map<String, dynamic>? extra,
  }) {
    return NotificationData(
      id: id,
      title: title,
      message: message,
      type: type,
      status: status ?? this.status,
      createdAt: createdAt,
      extra: extra ?? this.extra,
    );
  }
}

/// ğŸ”” ì•Œë¦¼ ëª©ë¡ Provider
final notificationListProvider = StateProvider<List<NotificationData>>((ref) => []);

/// ğŸ”” ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
final unreadNotificationCountProvider = Provider<int>((ref) {
  final notifications = ref.watch(notificationListProvider);
  return notifications.where((n) => n.status == NotificationStatus.unread).length;
});

/// ğŸ”” ì•Œë¦¼ í•„í„° Provider
final notificationFilterProvider = StateProvider<NotificationType?>((ref) => null);

/// ğŸ”” í•„í„°ëœ ì•Œë¦¼ ëª©ë¡
final filteredNotificationProvider = Provider<List<NotificationData>>((ref) {
  final notifications = ref.watch(notificationListProvider);
  final filter = ref.watch(notificationFilterProvider);
  
  if (filter == null) return notifications;
  return notifications.where((n) => n.type == filter).toList();
});

/// ğŸ”” ì•Œë¦¼ ê´€ë¦¬ ì„œë¹„ìŠ¤
final notificationServiceProvider = Provider((ref) => NotificationService(ref));

/// ì•Œë¦¼ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// ğŸ†• Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (AppRouterì—ì„œ ì´ë™ë¨)
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // ì•±ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // ì•Œë¦¼ Providerì— ì €ì¥
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBarë¡œë„ í‘œì‹œ
        if (messenger != null) {
          messenger
            ..hideCurrentSnackBar()
            ..showSnackBar(SnackBar(content: Text('${n.title}: ${n.body}')));
        }
      }
    });
    
    // ì•±ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ ì•Œë¦¼ í´ë¦­í•´ì„œ ì•± ì‹œì‘
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          addNotification(
            title: n.title ?? 'ì•Œë¦¼',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆì„ ë•Œ ì•Œë¦¼ í´ë¦­
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        addNotification(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // TODO: ë‚˜ì¤‘ì— íŠ¹ì • ì•Œë¦¼ ëª¨ë‹¬ ìë™ ì—´ê¸° ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    log.i('ğŸ”” Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
  }

  /// Firebase ë©”ì‹œì§€ ë°ì´í„°ë¡œë¶€í„° ì•Œë¦¼ íƒ€ì… ì¶”ë¡ 
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }
  
  /// Firebase ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('ğŸ§¹ Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¨');
  }
  
  /// ì•Œë¦¼ ì¶”ê°€
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('ğŸ”” ì•Œë¦¼ ì¶”ê°€: $title');
  }
  
  /// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ì•Œë¦¼ ì½ìŒ: $notificationId');
  }
  
  /// ì•Œë¦¼ ì œê±°
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ—‘ï¸ ì•Œë¦¼ ì œê±°: $notificationId');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì œê±°
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('ğŸ§¹ ëª¨ë“  ì•Œë¦¼ ì œê±°');
  }
  
  /// í•„í„° ì„¤ì •
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('ğŸ” ì•Œë¦¼ í•„í„°: ${type?.name ?? "ì „ì²´"}');
  }
  
  /// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
\n\n// ====== lib/core/di/surge_provider.dart ======\n
\n\n// ====== lib/core/di/settings_provider.dart ======\n
// 1ï¸âƒ£ lib/core/di/settings_provider.dart (ìˆ˜ì •)
// ==========================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../data/datasources/settings_local_ds.dart';
import '../../data/repositories/settings_repository_impl.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../../domain/usecases/settings_usecase.dart';
import '../utils/logger.dart';

/// 1) SharedPreferences ì¸ìŠ¤í„´ìŠ¤ (main.dartì—ì„œ override)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'main.dartì—ì„œ SharedPreferences.getInstance() í›„ overridesë¡œ ì£¼ì…í•˜ì„¸ìš”.'
  );
});

/// 2) Local DataSource
final settingsLocalDSProvider = Provider<SettingsLocalDataSource>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return SettingsLocalDataSource(prefs);
});

/// 3) Repository
final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
  final ds = ref.watch(settingsLocalDSProvider);
  return SettingsRepositoryImpl(ds);
});

/// 4) UseCase
final settingsUsecaseProvider = Provider<SettingsUsecase>((ref) {
  final repo = ref.watch(settingsRepositoryProvider);
  return SettingsUsecase(repo);
});

/// 5) ğŸ†• í†µí•© ì„¤ì • Provider (ì´ê²ƒë§Œ ì‚¬ìš©!)
final appSettingsProvider = StateNotifierProvider<AppSettingsNotifier, AppSettings>((ref) {
  final usecase = ref.watch(settingsUsecaseProvider);
  return AppSettingsNotifier(usecase);
});

/// ğŸ†• í†µí•© ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤
class AppSettingsNotifier extends StateNotifier<AppSettings> {
  final SettingsUsecase _usecase;

  AppSettingsNotifier(this._usecase) : super(const AppSettings()) {
    _loadSettings();
  }

  /// ì´ˆê¸° ì„¤ì • ë¡œë“œ
  Future<void> _loadSettings() async {
    try {
      final settings = await _usecase.getSettings();
      state = settings;
      
      // ì´ˆê¸° í™”ë©´ ì¼œê¸° ìƒíƒœ ì ìš©
      _applyKeepScreen(settings.keepScreenOn);
      
      log.i('âš™ï¸ ì„¤ì • ë¡œë“œ ì™„ë£Œ: ${settings.toString()}');
    } catch (e, st) {
      log.e('ì„¤ì • ë¡œë“œ ì‹¤íŒ¨', e, st);
    }
  }

  /// í…Œë§ˆ ëª¨ë“œ ë³€ê²½
  Future<void> setThemeMode(ThemeMode mode) async {
    try {
      await _usecase.updateThemeMode(mode);
      state = state.copyWith(themeMode: mode);
      log.i('ğŸ¨ í…Œë§ˆ ëª¨ë“œ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('í…Œë§ˆ ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì •
  Future<void> setKeepScreenOn(bool keep) async {
    try {
      await _usecase.updateKeepScreenOn(keep);
      state = state.copyWith(keepScreenOn: keep);
      _applyKeepScreen(keep);
      log.i('ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°: $keep');
    } catch (e, st) {
      log.e('í™”ë©´ ì¼œê¸° ì„¤ì • ì‹¤íŒ¨', e, st);
    }
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½
  Future<void> setSliderPosition(SliderPosition position) async {
    try {
      await _usecase.updateSliderPosition(position);
      state = state.copyWith(sliderPosition: position);
      log.i('ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜: ${position.name}');
    } catch (e, st) {
      log.e('ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setDisplayMode(DisplayMode mode) async {
    try {
      await _usecase.updateDisplayMode(mode);
      state = state.copyWith(displayMode: mode);
      log.i('ğŸ’° ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½
  Future<void> setAmountDisplayMode(AmountDisplayMode mode) async {
    try {
      await _usecase.updateAmountDisplayMode(mode);
      state = state.copyWith(amountDisplayMode: mode);
      log.i('ğŸ’µ ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½: ${mode.name}');
    } catch (e, st) {
      log.e('ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ë³€ê²½ ì‹¤íŒ¨', e, st);
    }
  }

  /// í™”ë©´ ì¼œê¸° ì‹¤ì œ ì ìš©
  void _applyKeepScreen(bool keep) {
    if (keep) {
      WakelockPlus.enable();
    } else {
      WakelockPlus.disable();
    }
  }

  /// ì„¤ì • ìƒˆë¡œê³ ì¹¨
  Future<void> refresh() async {
    await _loadSettings();
  }
}\n\n// ====== lib/core/di/momentary_provider.dart ======\n
\n\n// ====== lib/core/config/app_config.dart ======\n
// lib/core/config/app_config.dart

import 'dart:collection';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import '../utils/logger.dart';

/// Application-wide configuration and constants,
/// optimized per Upbit REST & WebSocket specifications.
class AppConfig {
  AppConfig._();

  /// Call once at startup to initialize dynamic config (env variables)
  static Future<void> init({String? envPath}) async {
    // Load .env (optional custom path) + validate
    try {
      if (envPath != null && envPath.isNotEmpty) {
        await dotenv.load(fileName: envPath);
      } else {
        await dotenv.load();
      }
      log.i('[AppConfig] .env loaded');
      _loadEnv();
    } catch (e, st) {
      log.e('[AppConfig] âš ï¸ Failed to load required env vars', e, st);
      throw Exception('[AppConfig] âš ï¸ Failed to load required env vars: $e');
    }

    log.i('[AppConfig] initialized (debug=$isDebugMode)');
  }

  static void _loadEnv() {
    const requiredKeys = ['UPBIT_API_KEY', 'UPBIT_API_SECRET'];
    for (final key in requiredKeys) {
      final value = dotenv.env[key];
      if (value == null || value.isEmpty) {
        throw Exception('[AppConfig] Missing required env var: $key');
      }
    }

    _upbitRestBase = dotenv.env['UPBIT_REST_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_REST_URL']!
        : _upbitRestBase;
    _upbitWsUrl = dotenv.env['UPBIT_WS_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_WS_URL']!
        : _upbitWsUrl;

    _apiKey = dotenv.env['UPBIT_API_KEY']!;
    _apiSecret = dotenv.env['UPBIT_API_SECRET']!;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ğŸ†• í†µì¼ëœ Bool í•´ì„ ìœ í‹¸ë¦¬í‹° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// í™˜ê²½ë³€ìˆ˜ì—ì„œ boolean ê°’ì„ ì•ˆì „í•˜ê³  ì¼ê´€ë˜ê²Œ íŒŒì‹±
  /// ì§€ì›í•˜ëŠ” true ê°’: 'true', '1', 'yes', 'on'
  /// ì§€ì›í•˜ëŠ” false ê°’: 'false', '0', 'no', 'off', null, ë¹ˆ ë¬¸ìì—´
  static bool _getBool(String key, {bool fallback = false}) {
    final value = dotenv.env[key]?.toLowerCase().trim();
    if (value == null || value.isEmpty) return fallback;
    
    // true ê°’ë“¤
    if (value == 'true' || value == '1' || value == 'yes' || value == 'on') {
      return true;
    }
    
    // false ê°’ë“¤
    if (value == 'false' || value == '0' || value == 'no' || value == 'off') {
      return false;
    }
    
    // ì•Œ ìˆ˜ ì—†ëŠ” ê°’ì´ë©´ fallback ì‚¬ìš©
    return fallback;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ API Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _apiKey = '';
  static String _apiSecret = '';
  static String get apiKey => _apiKey;
  static String get apiSecret => _apiSecret;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Environment Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// `true` when not in Dart VM product mode.
  static const bool isDebugMode = !bool.fromEnvironment('dart.vm.product');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ê°œë°œ ì¤‘ ì¡°ì ˆ ê°€ëŠ¥)
  static Level get logLevel {
    if (!isDebugMode) return Level.warning;
    final envLevel = dotenv.env['LOG_LEVEL']?.toLowerCase();
    switch (envLevel) {
      case 'verbose':
        return Level.verbose;
      case 'debug':
        return Level.debug;
      case 'info':
        return Level.info;
      case 'warning':
        return Level.warning;
      case 'error':
        return Level.error;
      default:
        return Level.debug;
    }
  }

  /// ğŸ”§ íŠ¹ì • ëª¨ë“ˆ ë¡œê·¸ on/off (í†µì¼ëœ ë°©ì‹ ì ìš©)
  static bool get enableSignalBusLog =>
      _getBool('ENABLE_SIGNAL_BUS_LOG', fallback: true);
  static bool get enableWebSocketLog =>
      _getBool('ENABLE_WEBSOCKET_LOG', fallback: true);
  static bool get enableTradeLog =>
      _getBool('ENABLE_TRADE_LOG', fallback: true);
  static bool get enableAdaptiveBackoffLog =>
      _getBool('ENABLE_ADAPTIVE_BACKOFF_LOG', fallback: true);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ REST Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitRestBase = 'https://api.upbit.com/v1';
  static String get upbitRestBase => _upbitRestBase;
  static const int restRateLimitCount = 15;
  static const Duration restRateLimitPeriod = Duration(seconds: 1);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WebSocket Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static String _upbitWsUrl = 'wss://api.upbit.com/websocket/v1';
  static String get upbitWsUrl => _upbitWsUrl;
  static const int wsMaxSubscriptionCount = 200;

  // Upbit ê¶Œì¥ íƒ€ì´ë°ìœ¼ë¡œ ë³€ê²½ (30s Ping / 60s Pong):
  static const Duration wsPingInterval = Duration(seconds: 30);
  static const Duration wsPongTimeout = Duration(seconds: 60);

  static const int wsMaxRetryCount = 5;
  static const Duration wsInitialBackoff = Duration(seconds: 1);
  static const Duration wsMaxBackoff = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Aggregation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const int mergeWindowMs = 1000;
  static const Duration globalResetInterval = Duration(seconds: 30);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dev/Test Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static bool useTestDataInDev = false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trade Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static final List<double> _filters = [
    2e6, 5e6, 1e7, 2e7, 5e7,
    1e8, 2e8, 3e8, 4e8, 5e8,
    1e9,
  ];
  static UnmodifiableListView<double> get tradeFilters =>
      UnmodifiableListView(_filters);

  /// Human-readable labels always in sync with `_filters`
  static Map<double, String> get filterNames => Map.unmodifiable({
        for (final f in _filters) f: _formatFilterLabel(f),
      });

  /// Update the trade filters at runtime (ensures positive & sorted)
  static void updateFilters(List<double> newFilters) {
    _filters
      ..clear()
      ..addAll(newFilters.where((f) => f > 0))
      ..sort();
    log.i('[AppConfig] filters updated â†’ $_filters');
  }

  static String _formatFilterLabel(double f) {
    if (f >= 1e8 && f % 1e8 == 0) return '${(f / 1e8).toInt()}ì–µ';
    if (f >= 1e7 && f % 1e7 == 0) return '${(f / 1e7).toInt()}ì²œë§Œ';
    if (f >= 1e6 && f % 1e6 == 0) return '${(f / 1e6).toInt()}ë°±ë§Œ';
    return f.toStringAsFixed(0);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candle Timeframes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const List<int> timeFrames = [
    1, 5, 15, 30, 60, 120, 240, 480, 720, 1440
  ];
  static final Map<int, String> timeFrameNames = Map.unmodifiable({
    1: '1ë¶„',
    5: '5ë¶„',
    15: '15ë¶„',
    30: '30ë¶„',
    60: '1ì‹œê°„',
    120: '2ì‹œê°„',
    240: '4ì‹œê°„',
    480: '8ì‹œê°„',
    720: '12ì‹œê°„',
    1440: '1ì¼',
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Surge Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static const double surgeThresholdPercent = 1.1;
  static const Duration surgeWindowDuration = Duration(minutes: 1);
}\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// âš ï¸ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ (ì œë„¤ë¦­)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// ğŸ†• íƒ€ì… ì•ˆì „í•œ í”Œë«í¼ë³„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for raw payloads
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Emitters for AppEvent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal dispatch logic
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} â†’ $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} â†’ ${msg.substring(0, 100)}â€¦');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/core/network/websocket/ticker_ws_client.dart ======\n
// lib/core/network/websocket/ticker_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜„ì¬ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TickerWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TickerWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'ticker-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'ticker',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/candle_ws_client.dart ======\n
// lib/core/network/websocket/candle_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œìº”ë“¤â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
/// [timeFrame]: e.g. "1m", "5m", "15m", ...
class CandleWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  CandleWsClient({
    required String timeFrame,
    void Function(WsStatus)? onStatusChange,
  }) : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'candle-$timeFrame-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'candles_$timeFrame',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œì²´ê²°â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
// lib/core/network/websocket/base_ws_client.dart

import 'dart:async';
import 'dart:convert';

import 'package:web_socket_channel/web_socket_channel.dart';

import '../../config/app_config.dart';
import '../../error/app_exception.dart';
import '../adaptive_backoff.dart';               // AdaptiveBackoff ì—°ë™
import '../ws_rate_limiter_interceptor.dart';
import '../../utils/logger.dart';                // â† logger import

typedef DecodeFn<T> = T Function(dynamic json);
typedef EncodeFn = String Function(List<String> symbols);

/// WebSocket connection status notifications.
enum WsStatus {
  connecting,
  connected,
  failed,
  disconnected,
  error,
  reconnecting,
  pongTimeout,
  maxRetryExceeded,
}

/// Common WebSocket client: connect, subscribe, reconnect, emit
class BaseWsClient<T> {
  /// Helper to decode a JSON list (or single object) into a List<Map<String, dynamic>>.
  static List<Map<String, dynamic>> decodeJsonList(dynamic raw) {
    final jsonObj = raw is String ? jsonDecode(raw) : raw;
    final list = jsonObj is List ? jsonObj : [jsonObj];
    return list
        .cast<Map<String, dynamic>>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final void Function(WsStatus)? onStatusChange;
  final WsRateLimiter _rateLimiter;
  final AdaptiveBackoffCalculator _backoffCalculator =
      AdaptiveBackoffCalculator();
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  WebSocketChannel? _channel;
  final _controller = StreamController<T>.broadcast();
  List<String> _symbols = [];
  Timer? _pingTimer;
  Timer? _pongTimer;
  bool _disposed = false;
  bool _reconnecting = false;
  int _retryCount = 0;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    WsRateLimiter? rateLimiter,
  }) : _rateLimiter = rateLimiter ?? WsRateLimiter() {
    _startMemoryCleanup();
  }

  /// Start periodic cleanup of inactive subscriptions.
  void _startMemoryCleanup() {
    _memoryCleanupTimer =
        Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
    });
  }

  /// Clean up paused subscriptions to prevent memory leaks.
  void _cleanupInactiveSubscriptions() {
    final toRemove =
        _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      sub.cancel();
      _activeSubscriptions.remove(sub);
    }
    if (toRemove.isNotEmpty) {
      log.d('WSClient: Cleaned up ${toRemove.length} inactive subscriptions');
    }
  }

  /// Exposed stream of decoded messages.
  Stream<T> get stream => _controller.stream;

  /// Connect or reconnect with a new set of symbols.
  Future<void> connect(List<String> symbols) async {
    _notify(WsStatus.connecting);
    if (_disposed) return;
    _symbols = List.from(symbols);
    await _channel?.sink.close();

    try {
      if (_symbols.length > AppConfig.wsMaxSubscriptionCount) {
        throw const WebSocketException('Subscribe limit exceeded');
      }
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _setupPing();
      _send(encodeSubscribe(_symbols));

      final subscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _retryCount = 0;
      _backoffCalculator.recordSuccess();
      _notify(WsStatus.connected);
      log.i('WS connected to $url (subscriptions: ${_symbols.length})');
    } catch (e, st) {
      log.w('WS connect failed: $e', e, st);
      _backoffCalculator.recordFailure();
      _notify(WsStatus.failed);
      _scheduleReconnect();
    }
  }

  void _handleData(dynamic raw) {
    _pongTimer?.cancel();
    try {
      final text = raw is List<int> ? utf8.decode(raw) : raw.toString();
      final jsonObj = jsonDecode(text);
      final data = decode(jsonObj);
      _controller.add(data);
    } catch (e, st) {
      log.e('WS processing error', e, st);
    }
  }

  void _handleDone() {
    log.i('WS closed by server');
    _notify(WsStatus.disconnected);
    _scheduleReconnect();
  }

  void _handleError(dynamic e) {
    log.e('WS error', e);
    _backoffCalculator.recordFailure();
    _notify(WsStatus.error);
    _scheduleReconnect();
  }

  void _send(String msg) => _rateLimiter.enqueue(() {
        try {
          _channel?.sink.add(msg);
          log.d('WS â–¶ $msg');
        } catch (e, st) {
          log.e('WS send error', e, st);
        }
      });

  void _setupPing() {
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _pingTimer =
        Timer.periodic(AppConfig.wsPingInterval, (_) {
      _send(jsonEncode({'type': 'ping'}));
      _pongTimer = Timer(AppConfig.wsPongTimeout, () {
        log.w('Pong timeout, reconnecting');
        _notify(WsStatus.pongTimeout);
        _scheduleReconnect();
      });
    });
    log.d('WS ping/pong timers set');
  }

  /// Schedule reconnection with adaptive backoff.
  void _scheduleReconnect() {
    if (_disposed || _reconnecting) return;
    _reconnecting = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();

    _backoffCalculator
        .calculateBackoff(
          _retryCount,
          AppConfig.wsInitialBackoff,
          AppConfig.wsMaxBackoff,
        )
        .then((delay) {
      if (_disposed) return;
      Future.delayed(delay, () {
        if (_disposed) return;
        if (_retryCount < AppConfig.wsMaxRetryCount) {
          _retryCount++;
          log.i(
            'Reconnect attempt #$_retryCount after ${delay.inMilliseconds}ms',
          );
          _notify(WsStatus.reconnecting);
          connect(_symbols).whenComplete(() => _reconnecting = false);
        } else {
          log.w('Max WS retries exceeded');
          _notify(WsStatus.maxRetryExceeded);
          _retryCount = 0;
          _reconnecting = false;
        }
      });
    });
  }

  void _notify(WsStatus status) => onStatusChange?.call(status);

  /// Dispose resources: timers, subscriptions, channel, controller, and backoff state.
  Future<void> dispose() async {
    _disposed = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _memoryCleanupTimer?.cancel();

    for (final sub in _activeSubscriptions) {
      await sub.cancel();
    }
    _activeSubscriptions.clear();

    _rateLimiter.dispose();
    await _channel?.sink.close();
    await _controller.close();
    _backoffCalculator.recordSuccess(); // reset
    log.i('WSClient disposed');
  }
}
\n\n// ====== lib/core/network/websocket/orderbook_ws_client.dart ======\n
// lib/core/network/websocket/orderbook_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œí˜¸ê°€â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class OrderbookWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  OrderbookWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'orderbook-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'orderbook',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/auth_interceptor.dart ======\n
// lib/core/network/auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// Upbit REST API í˜¸ì¶œ ì‹œ JWT ë°©ì‹ì˜ ì¸ì¦ í—¤ë”ë¥¼ ë¶™ì—¬ì¤ë‹ˆë‹¤.
/// - payloadì— access_key, nonce, (query_hash, query_hash_alg)ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.
/// - ì•Œê³ ë¦¬ì¦˜: HS256
class AuthInterceptor extends Interceptor {
  final String apiKey;
  final String apiSecret;

  AuthInterceptor({required this.apiKey, required this.apiSecret});

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    try {
      final nonce = DateTime.now().millisecondsSinceEpoch.toString();
      final payload = <String, dynamic>{
        'access_key': apiKey,
        'nonce': nonce,
      };

      if (options.queryParameters.isNotEmpty || _hasRequestBody(options)) {
        final raw = options.queryParameters.isNotEmpty
            ? Uri(queryParameters: options.queryParameters).query
            : jsonEncode(options.data);
        payload['query_hash'] = sha512.convert(utf8.encode(raw)).toString();
        payload['query_hash_alg'] = 'SHA512';
      }

      // JWT Header and Payload
      const headerMap = {'alg': 'HS256', 'typ': 'JWT'};
      final headerJson = jsonEncode(headerMap);
      final payloadJson = jsonEncode(payload);
      final headerSeg = _base64UrlEncode(headerJson);
      final payloadSeg = _base64UrlEncode(payloadJson);

      // Signature
      final sigBytes = Hmac(sha256, utf8.encode(apiSecret))
          .convert(utf8.encode('$headerSeg.$payloadSeg'))
          .bytes;
      final sigSeg = base64Url.encode(sigBytes).replaceAll('=', '');

      options.headers['Authorization'] =
          'Bearer $headerSeg.$payloadSeg.$sigSeg';
    } catch (e, st) {
      log.e('AuthInterceptor error', e, st);
      return handler.reject(
        DioException(requestOptions: options, error: e),
      );
    }

    handler.next(options);
  }

  bool _hasRequestBody(RequestOptions options) {
    final data = options.data;
    if (data == null) return false;
    if (data is String) return data.isNotEmpty;
    if (data is Iterable || data is Map) return data.isNotEmpty;
    if (data is FormData) return data.fields.isNotEmpty || data.files.isNotEmpty;
    return true;
  }

  String _base64UrlEncode(String input) =>
      base64Url.encode(utf8.encode(input)).replaceAll('=', '');
}
\n\n// ====== lib/core/network/adaptive_backoff.dart ======\n
// lib/core/network/adaptive_backoff.dart

import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../utils/logger.dart';

class AdaptiveBackoffCalculator {
  final Connectivity _connectivity = Connectivity();
  int _consecutiveFailures = 0;
  DateTime? _lastFailureTime;
  
  // ë„¤íŠ¸ì›Œí¬ë³„ ê¸°ë³¸ ì§€í„° ê³„ìˆ˜ (connectivity_plus ì—°ë™)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.8,      // WiFiëŠ” ë¹ ë¥¸ ì¬ì—°ê²°
    ConnectivityResult.mobile: 1.2,    // ëª¨ë°”ì¼ì€ ë³´ìˆ˜ì 
    ConnectivityResult.ethernet: 0.6,  // ìœ ì„ ì€ ê°€ì¥ ë¹ ë¦„
    ConnectivityResult.none: 2.0,      // ì—°ê²° ì—†ìŒì€ ë§¤ìš° ë³´ìˆ˜ì 
  };

  Future<Duration> calculateBackoff(int attempt, Duration baseDelay, Duration maxDelay) async {
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0; // ê¸°ë³¸ê°’
    
    final failurePenalty = _calculateFailurePenalty();
    
    final exponentialMs = baseDelay.inMilliseconds * (1 << attempt);
    final cappedMs = math.min(exponentialMs, maxDelay.inMilliseconds);
    
    // ì§€í„° ë²”ìœ„ 20%ë¡œ ë¹ ë¥¸ ì¬ì—°ê²° ë³´ì¥
    final jitterRange = cappedMs * 0.2;
    final random = math.Random();
    final adaptiveJitter = random.nextDouble() * jitterRange * networkMultiplier * failurePenalty;
    
    final finalMs = math.max(0, cappedMs + adaptiveJitter.round());
    
    log.d('AdaptiveBackoff: attempt=$attempt, network=$connectivityResult, '
          'base=${cappedMs}ms, jitter=${adaptiveJitter.round()}ms, final=${finalMs}ms');
    
    return Duration(milliseconds: finalMs);
  }

  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;
    
    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      _consecutiveFailures = 0;
      return 1.0;
    }
    
    // í˜ë„í‹° ìƒí•œ 1.5ë°°ë¡œ ì¡°ì • (ê·¸ë¡ì˜ ìˆ˜ì •ì‚¬í•­ ìœ ì§€)
    return math.min(1.5, 1.0 + (_consecutiveFailures * 0.2));
  }

  void recordFailure() {
    _consecutiveFailures++;
    _lastFailureTime = DateTime.now();
  }

  void recordSuccess() {
    _consecutiveFailures = 0;
    _lastFailureTime = null;
  }
}\n\n// ====== lib/core/network/retry_interceptor.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 429 í˜¹ì€ 5xx ì—ëŸ¬ì— ëŒ€í•´ ì§€ìˆ˜ ë°±ì˜¤í”„ + ì§€í„° ë°©ì‹ìœ¼ë¡œ ì¬ì‹œë„í•©ë‹ˆë‹¤.
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialBackoff;
  final Duration maxBackoff;
  final double jitterFactor;

  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialBackoff = const Duration(milliseconds: 500),
    this.maxBackoff = const Duration(seconds: 5),
    this.jitterFactor = 0.2,
  });

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    final options = err.requestOptions;
    final retryCount = (options.extra['retry_count'] as int?) ?? 0;
    final status = err.response?.statusCode;

    if (_shouldRetry(err) && retryCount < maxRetries) {
      final next = retryCount + 1;
      options.extra['retry_count'] = next;

      // 429 ì‘ë‹µì¼ ê²½ìš° ì„œë²„ê°€ ì œê³µí•˜ëŠ” í—¤ë” ìš°ì„  ì‚¬ìš©
      Duration delay;
      if (status == 429) {
        final retryAfter = err.response?.headers.value('Retry-After');
        if (retryAfter != null) {
          final secs = int.tryParse(retryAfter) ?? 0;
          delay = Duration(seconds: secs);
          log.i('Retry #$next after Retry-After header: ${delay.inSeconds}s');
        } else {
          final remaining = err.response?.headers.value('Remaining-Req');
          if (remaining != null) {
            log.d('Remaining-Req header: $remaining');
          }
          delay = _computeBackoff(next);
        }
      } else {
        // 5xx ì—ëŸ¬ëŠ” ê¸°ë³¸ ë°±ì˜¤í”„ ì‚¬ìš©
        delay = _computeBackoff(next);
      }

      log.i('Retry #$next for [${options.method} ${options.path}] in ${delay.inMilliseconds}ms');
      await Future.delayed(delay);

      try {
        final response = await dio.fetch(options);
        return handler.resolve(response);
      } on DioException catch (e) {
        return handler.next(e);
      }
    }

    handler.next(err);
  }

  bool _shouldRetry(DioException err) {
    final status = err.response?.statusCode;
    return err.type == DioExceptionType.badResponse &&
        (status == 429 || (status != null && status >= 500 && status < 600));
  }

  Duration _computeBackoff(int attempt) {
    final expMs = initialBackoff.inMilliseconds * (1 << (attempt - 1));
    final cap = min(expMs, maxBackoff.inMilliseconds);
    final jitter = ((Random().nextDouble() * 2 - 1) * jitterFactor * cap).round();
    final finalMs = max(0, cap + jitter);
    return Duration(milliseconds: finalMs);
  }
}
\n\n// ====== lib/core/network/ws_rate_limiter_interceptor.dart ======\n
// lib/core/network/ws_rate_limiter_interceptor.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../utils/logger.dart';

/// Upbit WebSocket êµ¬ë… ë©”ì‹œì§€ ë°œí–‰ ê°„ ìµœì†Œ ê°„ê²© ë³´ì¥ ìœ í‹¸
class WsRateLimiter {
  final Duration minInterval;
  final Queue<VoidCallback> _queue = Queue<VoidCallback>();
  bool _isFlushing = false;
  DateTime _lastSent = DateTime.fromMillisecondsSinceEpoch(0);

  WsRateLimiter({this.minInterval = const Duration(milliseconds: 500)});

  /// ë©”ì‹œì§€ë¥¼ íì— ì¶”ê°€í•˜ê³  ì¦‰ì‹œ ì „ì†¡ ì‹œë„
  void enqueue(VoidCallback send) {
    _queue.add(send);
    _flushNext();
  }

  void _flushNext() {
    if (_isFlushing || _queue.isEmpty) return;
    _isFlushing = true;

    final now = DateTime.now();
    final elapsed = now.difference(_lastSent);
    final delay = elapsed >= minInterval ? Duration.zero : minInterval - elapsed;

    Timer(delay, () {
      final send = _queue.removeFirst();
      try {
        send();
        _lastSent = DateTime.now();
        log.d('WsRateLimiter sent, next after \${minInterval.inMilliseconds}ms');
      } catch (e, st) {
        log.e('WsRateLimiter send error', e, st);
      } finally {
        _isFlushing = false;
        if (_queue.isNotEmpty) _flushNext();
      }
    });
  }

  /// íë¥¼ ë¹„ìš°ê³  ì‚¬ìš© ì¤‘ì§€
  void dispose() {
    _queue.clear();
  }
}
\n\n// ====== lib/core/network/api_client.dart ======\n
// lib/core/network/api_client.dart

import 'dart:async';
import 'dart:collection';
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';
import 'auth_interceptor.dart';
import 'retry_interceptor.dart';
import 'logging_interceptor.dart';

typedef Json = Map<String, dynamic>;

/// Upbit REST API ì´ˆë‹¹ í˜¸ì¶œ ì œí•œì„ ê´€ë¦¬í•˜ëŠ” RateLimiter
class _RateLimiter {
  final int maxRequests;
  final Duration period;
  final Queue<DateTime> _timestamps = Queue<DateTime>();

  _RateLimiter({required this.maxRequests, required this.period});

  /// í˜¸ì¶œ ì „ í—ˆìš© ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê³ , í•„ìš” ì‹œ ëŒ€ê¸°í•©ë‹ˆë‹¤.
  Future<void> throttle() async {
    final now = DateTime.now();
    // ê¸°ê°„ ì´ˆê³¼ëœ ê¸°ë¡ ì œê±°
    while (_timestamps.isNotEmpty && now.difference(_timestamps.first) > period) {
      _timestamps.removeFirst();
    }
    if (_timestamps.length >= maxRequests) {
      final earliest = _timestamps.first;
      final wait = period - now.difference(earliest);
      await Future.delayed(wait);
      // ëŒ€ê¸° í›„ ë‹¤ì‹œ ì˜¤ë˜ëœ ê¸°ë¡ ì •ë¦¬
      final now2 = DateTime.now();
      while (_timestamps.isNotEmpty && now2.difference(_timestamps.first) > period) {
        _timestamps.removeFirst();
      }
    }
    _timestamps.addLast(DateTime.now());
  }
}

/// In-memory cache entry with timestamp.
class _MemCacheEntry<T> {
  final T data;
  final DateTime ts;
  _MemCacheEntry(this.data) : ts = DateTime.now();

  bool fresh(Duration dur) => DateTime.now().difference(ts) < dur;
}

/// Simple LRU cache based on insertion order, with a maxEntries limit.
class _MemCache {
  final int maxEntries;
  final Map<String, _MemCacheEntry<dynamic>> _box;

  _MemCache({this.maxEntries = 100}) : _box = <String, _MemCacheEntry<dynamic>>{};

  T? get<T>(String key, Duration dur) {
    final entry = _box[key];
    if (entry == null || !entry.fresh(dur)) return null;
    return entry.data as T;
  }

  void put<T>(String key, T data) {
    if (_box.length >= maxEntries) {
      final oldestKey = _box.keys.first;
      _box.remove(oldestKey);
    }
    _box[key] = _MemCacheEntry<T>(data);
  }

  void invalidate(String key) => _box.remove(key);

  void clear() => _box.clear();
}

/// Converts a query map into a stable, sorted query string.
/// Silently skips values that cannot be represented.
String _stableQueryString(Json? query) {
  if (query == null || query.isEmpty) return '';
  try {
    final entries = query.entries
      .where((e) => e.value != null)
      .toList()
      ..sort((a, b) => a.key.compareTo(b.key));
    final params = <String, String>{};
    for (final e in entries) {
      final v = e.value;
      if (v is List) {
        params[e.key] = v.join(',');
      } else {
        params[e.key] = v.toString();
      }
    }
    return Uri(queryParameters: params).query;
  } catch (e, st) {
    log.e('StableQueryString failed', e, st);
    return '';
  }
}

/// REST í˜¸ì¶œìš© Dio ë˜í¼
/// - Auth/Retry/Logging ì¸í„°ì…‰í„° ìë™ ì—°ê²°
/// - Simple LRU-based in-memory cache ì§€ì›
/// - Upbit REST API rate limit(ì´ˆë‹¹ 15íšŒ) ìë™ ê´€ë¦¬
class ApiClient {
  final Dio _dio;
  final _MemCache _cache;
  final _RateLimiter _rateLimiter;

  /// [apiKey], [apiSecret] ëŠ” Upbit Open API ìê²©ì¦ëª…
  ApiClient({
    Dio? dio,
    required String apiKey,
    required String apiSecret,
    int cacheSize = 100,
  })  : _dio = dio ?? Dio(),
        _cache = _MemCache(maxEntries: cacheSize),
        _rateLimiter = _RateLimiter(
          maxRequests: AppConfig.restRateLimitCount,
          period: AppConfig.restRateLimitPeriod,
        ) {
    _dio.interceptors.addAll([
      AuthInterceptor(apiKey: apiKey, apiSecret: apiSecret),
      RetryInterceptor(dio: _dio),
      LoggingInterceptor(),
    ]);
  }

  /// [method]: GET, POST ë“±
  /// [path]: ì „ì²´ URL ë˜ëŠ” baseUrl ì´í›„ ê²½ë¡œ
  /// [query]: URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
  /// [body]: JSON ë°”ë””
  /// [cacheDur]: nullì´ ì•„ë‹ ë•Œ ìºì‹œ ì‚¬ìš© (ê¸°ê°„ ì§€ì •)
  Future<Result<R, NetworkException>> request<R>({
    required String method,
    required String path,
    Json? query,
    Json? body,
    Duration? cacheDur,
  }) async {
    // Upbit REST rate limit ì ìš©
    await _rateLimiter.throttle();

    String? cacheKey;
    if (cacheDur != null) {
      final qstr = _stableQueryString(query);
      cacheKey = '$method|$path|$qstr';
      final cached = _cache.get<R>(cacheKey, cacheDur);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      final response = await _dio.request<R>(
        path,
        queryParameters: query,
        data: body,
        options: Options(method: method),
      );

      final data = response.data;
      if (cacheKey != null && data != null) {
        _cache.put<R>(cacheKey, data as R);
      }

      return Ok(data as R);
    } on DioException catch (dioErr) {
      return Err(NetworkException.fromDio(dioErr));
    } catch (e, st) {
      log.e('ApiClient unexpected error', e, st);
      final ex = e is Exception ? e : Exception(e.toString());
      return Err(NetworkException(e.toString(), originalException: ex));
    }
  }
}\n\n// ====== lib/core/network/logging_interceptor.dart ======\n
// lib/core/network/logging_interceptor.dart

import 'dart:convert';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// ëª¨ë“  REST ìš”ì²­ê³¼ ì‘ë‹µ, ì˜¤ë¥˜ë¥¼ ë¡œê¹…í•©ë‹ˆë‹¤.
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    log.i('--> ${options.method} ${options.uri}');
    if (options.data != null && options.data is! String) {
      try {
        // ë³€ìˆ˜ ì—†ì´ ë°”ë¡œ inlineí•´ì„œ ì‚¬ìš©
        log.d('Request Data:\n${const JsonEncoder.withIndent('  ').convert(options.data)}');
      } catch (e, st) {
        log.d('Request Data serialization failed', e, st);
      }
    }
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    log.i('<-- ${response.statusCode} ${response.requestOptions.uri}');
    final text = response.data is String
        ? response.data as String
        : response.data.toString();
    if (text.isNotEmpty) {
      log.d(text.length > 500 ? '${text.substring(0, 500)}...' : text);
    }
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // uri/status ì§ì ‘ inline
    log.e('<-- Error ${err.response?.statusCode} ${err.requestOptions.uri}', err, err.stackTrace);
    handler.next(err);
  }
}
\n\n// ====== lib/core/navigation/app_router.dart ======\n
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

import '../config/app_config.dart';
import '../di/app_providers.dart';
import '../../shared/widgets/notification_service.dart';
import '../../presentation/pages/main_page.dart'; // ğŸ†• MainPage ì‚¬ìš©

/// ğŸ—‘ï¸ ê°œë³„ ë¼ìš°íŠ¸ enum ì œê±° (ì´ì œ MainPageì—ì„œ ê´€ë¦¬)
// enum AppRouteëŠ” ë” ì´ìƒ í•„ìš” ì—†ìŒ

class AppRouter {
  final WidgetRef ref;
  final GlobalKey<NavigatorState> navigatorKey;
  late final GoRouter router;

  AppRouter(this.ref, this.navigatorKey) {
    router = GoRouter(
      navigatorKey: navigatorKey,
      initialLocation: '/', // ë©”ì¸ í˜ì´ì§€ë¡œ ì‹œì‘
      debugLogDiagnostics: AppConfig.isDebugMode,
      routes: [
        // ğŸ†• ë‹¨ì¼ ë©”ì¸ ë¼ìš°íŠ¸ (PageView ê¸°ë°˜)
        GoRoute(
          path: '/',
          name: 'main',
          builder: (context, state) => const MainPage(),
        ),
        
        // ğŸ”§ í•„ìš”ì‹œ ì¶”ê°€ ë¼ìš°íŠ¸ë“¤ (ì„¤ì •, ìƒì„¸ í˜ì´ì§€ ë“±)
        // GoRoute(
        //   path: '/detail/:id',
        //   name: 'detail',
        //   builder: (context, state) => DetailPage(id: state.params['id']!),
        // ),
      ],
    );
  }

  /// ğŸ”§ Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì • (NotificationServiceì— ìœ„ì„)
  void setupFCMListeners() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.setupFirebaseListeners(navigatorKey);
  }

  /// ğŸ”§ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (NotificationServiceì— ìœ„ì„)
  void dispose() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.dispose();
  }
}\n\n// ====== lib/core/utils/date_time.dart ======\n
import 'package:intl/intl.dart';

/// DateTime extension utilities for formatting and comparison.
extension DateTimeX on DateTime {
  /// `2024-05-17 22:05:01` â†’ `22:05:01`
  String hhmmss() => DateFormat('HH:mm:ss').format(this);

  /// `2024-05-17` í˜•ì‹ì˜ ë‚ ì§œ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMdd() => DateFormat('yyyy-MM-dd').format(this);

  /// `22:05` í˜•ì‹ì˜ ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String hhmm() => DateFormat('HH:mm').format(this);

  /// `2024-05-17 22:05` í˜•ì‹ì˜ ë‚ ì§œ+ì‹œê°„ ë¬¸ìì—´ ë°˜í™˜
  String yyyyMMddhhmm() => DateFormat('yyyy-MM-dd HH:mm').format(this);

  /// í˜„ì¬ ì‹œê°„ê³¼ì˜ ì°¨ì´ë¥¼ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ í‘œì‹œ
  /// ì˜ˆ: 'ë°©ê¸ˆ ì „', '3ë¶„ ì „', '2ì‹œê°„ ì „', 'ì–´ì œ', '3ì¼ ì „', '2ì£¼ ì „', '5ê°œì›” ì „', '1ë…„ ì „'
  String timeAgo() {
    final now = DateTime.now();
    final diff = now.difference(this);

    if (diff.inSeconds < 60) return 'ë°©ê¸ˆ ì „';
    if (diff.inMinutes < 60) return '${diff.inMinutes}ë¶„ ì „';
    if (diff.inHours < 24) return '${diff.inHours}ì‹œê°„ ì „';
    if (diff.inDays < 2) return 'ì–´ì œ';
    if (diff.inDays < 7) return '${diff.inDays}ì¼ ì „';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}ì£¼ ì „';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}ê°œì›” ì „';
    return '${(diff.inDays / 365).floor()}ë…„ ì „';
  }

  /// UTC ë°€ë¦¬ì´ˆ(ms)ë¥¼ ë¡œì»¬ DateTimeìœ¼ë¡œ ë³€í™˜
  static DateTime fromEpochMs(int ms) =>
      DateTime.fromMillisecondsSinceEpoch(ms, isUtc: true).toLocal();

  /// ISO 8601 ë¬¸ìì—´ì„ ë¡œì»¬ DateTimeìœ¼ë¡œ íŒŒì‹±
  static DateTime parseIso8601(String iso) =>
      DateTime.parse(iso).toLocal();

  /// ë™ì¼í•œ ë‚ ì§œì¸ì§€ í™•ì¸
  bool isSameDay(DateTime other) =>
      year == other.year && month == other.month && day == other.day;

  /// ì˜¤ëŠ˜ì¸ì§€ í™•ì¸
  bool get isToday => isSameDay(DateTime.now());

  /// ì–´ì œì¸ì§€ í™•ì¸
  bool get isYesterday =>
      isSameDay(DateTime.now().subtract(const Duration(days: 1)));
}
\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';
import '../config/app_config.dart';

/// ê¸€ë¡œë²Œ Logger ì¸ìŠ¤í„´ìŠ¤
/// - ê°œë°œ ëª¨ë“œ: AppConfig.logLevelì— ë”°ë¼ ë™ì  ì¡°ì ˆ
/// - í”„ë¡œë•ì…˜ëª¨ë“œ: warning ì´ìƒ ìë™
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 0,      // ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    errorMethodCount: 5, // ì˜¤ë¥˜ ì‹œ í‘œì‹œí•  ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¼ì¸ ìˆ˜
    lineLength: 120,     // ë¡œê·¸ í•œ ì¤„ ìµœëŒ€ ê¸¸ì´
    colors: true,        // ì»¬ëŸ¬ ì¶œë ¥ (í„°ë¯¸ë„)
    printTime: true,     // íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
  ),
  level: AppConfig.logLevel, // ğŸ”¥ í™˜ê²½ë³€ìˆ˜ë¡œ ë™ì  ì¡°ì ˆ ê°€ëŠ¥
);\n\n// ====== lib/core/utils/app_life_cycle_manager.dart ======\n
// lib/core/utils/app_life_cycle_manager.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../utils/logger.dart';

/// ì•± ë¼ì´í”„ì‚¬ì´í´ê³¼ ì£¼ê¸°ì ì¸ ì‘ì—…ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
/// ğŸ¯ Hive BoxëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ í’€ ê¸°ëŠ¥ API ì œê³µ
class AppLifecycleManager extends WidgetsBindingObserver {
  final Ref ref;
  Timer? _globalTimer;
  
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ì„ ìœ„í•œ ìƒíƒœ ê´€ë¦¬
  DateTime? _appStartTime;
  DateTime? _lastResumeTime;
  DateTime? _lastPauseTime;
  int _resumeCount = 0;
  int _pauseCount = 0;
  Duration _totalForegroundTime = Duration.zero;
  Duration _totalBackgroundTime = Duration.zero;
  AppLifecycleState _currentState = AppLifecycleState.resumed;
  
  // ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤
  final List<void Function(AppLifecycleState)> _lifecycleListeners = [];
  
  // ğŸ†• ì„±ëŠ¥ í†µê³„
  final Map<String, dynamic> _performanceStats = {};

  AppLifecycleManager(this.ref) {
    _appStartTime = DateTime.now();
    _lastResumeTime = _appStartTime;
    WidgetsBinding.instance.addObserver(this);
    _startGlobalTimer();
    log.i('ğŸ¬ AppLifecycleManager ì´ˆê¸°í™” ì™„ë£Œ');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ†• ì™¸ë¶€ ì ‘ê·¼ APIë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ğŸ†• í˜„ì¬ ì•± ìƒíƒœ ì¡°íšŒ
  AppLifecycleState get currentState => _currentState;

  /// ğŸ†• ì•± ì‹œì‘ ì‹œê°„
  DateTime? get appStartTime => _appStartTime;

  /// ğŸ†• ì•± ê°€ë™ ì‹œê°„ (ì—…íƒ€ì„)
  Duration get uptime {
    if (_appStartTime == null) return Duration.zero;
    return DateTime.now().difference(_appStartTime!);
  }

  /// ğŸ†• í¬ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalForegroundTime {
    var total = _totalForegroundTime;
    if (_currentState == AppLifecycleState.resumed && _lastResumeTime != null) {
      total += DateTime.now().difference(_lastResumeTime!);
    }
    return total;
  }

  /// ğŸ†• ë°±ê·¸ë¼ìš´ë“œ ì´ ì‹œê°„
  Duration get totalBackgroundTime {
    var total = _totalBackgroundTime;
    if (_currentState == AppLifecycleState.paused && _lastPauseTime != null) {
      total += DateTime.now().difference(_lastPauseTime!);
    }
    return total;
  }

  /// ğŸ†• ì´ë²¤íŠ¸ ì¹´ìš´í„°ë“¤
  int get resumeCount => _resumeCount;
  int get pauseCount => _pauseCount;

  /// ğŸ†• ë§ˆì§€ë§‰ ìƒíƒœ ë³€ê²½ ì‹œê°„
  DateTime? get lastStateChangeTime {
    switch (_currentState) {
      case AppLifecycleState.resumed:
        return _lastResumeTime;
      case AppLifecycleState.paused:
        return _lastPauseTime;
      default:
        return null;
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
  void addLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.add(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°
  void removeLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.remove(listener);
    log.d('ğŸ§ ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì œê±°ë¨ (ì´ ${_lifecycleListeners.length}ê°œ)');
  }

  /// ğŸ†• ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨/ì •ë¦¬ ì‘ì—… ê°•ì œ ì‹¤í–‰
  void forceRefresh() {
    log.i('ğŸ”„ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
    _performPeriodicTasks();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ê°•ì œ ì‹¤í–‰
  void forceCleanup() {
    log.i('ğŸ§¹ ìˆ˜ë™ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    _performMemoryCleanup();
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
  void updatePerformanceStats(String key, dynamic value) {
    _performanceStats[key] = value;
    _performanceStats['lastUpdated'] = DateTime.now().toIso8601String();
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ìƒíƒœ ì¡°íšŒ
  Map<String, dynamic> getMemoryStats() {
    return {
      'uptime': uptime.toString(),
      'foregroundTime': totalForegroundTime.toString(),
      'backgroundTime': totalBackgroundTime.toString(),
      'resumeCount': resumeCount,
      'pauseCount': pauseCount,
      'currentState': _currentState.name,
      'lastStateChange': lastStateChangeTime?.toIso8601String(),
      'platformMemoryUsage': _getPlatformMemoryInfo(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// ğŸ†• ì„±ëŠ¥ í†µê³„ ì¡°íšŒ
  Map<String, dynamic> getPerformanceStats() {
    return Map.from(_performanceStats)
      ..addAll({
        'uptime': uptime.inSeconds,
        'foregroundTimeSeconds': totalForegroundTime.inSeconds,
        'backgroundTimeSeconds': totalBackgroundTime.inSeconds,
        'resumeCount': resumeCount,
        'pauseCount': pauseCount,
        'currentState': _currentState.name,
      });
  }

  /// ğŸ†• ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> getSystemStatus() {
    return {
      'app': getMemoryStats(),
      'performance': getPerformanceStats(),
      'platform': {
        'os': Platform.operatingSystem,
        'version': Platform.operatingSystemVersion,
        'locale': Platform.localeName,
      },
      'listeners': {
        'lifecycleListeners': _lifecycleListeners.length,
      },
      'timers': {
        'globalTimerActive': _globalTimer?.isActive ?? false,
      },
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ê¸°ì¡´ ë‚´ë¶€ ë¡œì§ë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final previousState = _currentState;
    _currentState = state;
    
    _updateStateTimes(previousState, state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        log.i('â¡ï¸ ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.');
        _resumeCount++;
        _lastResumeTime = DateTime.now();
        _startGlobalTimer();
        _onAppResumed();
        break;
        
      case AppLifecycleState.paused:
        log.i('â¸ï¸ ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.');
        _pauseCount++;
        _lastPauseTime = DateTime.now();
        _stopGlobalTimer();
        _onAppPaused();
        break;
        
      case AppLifecycleState.detached:
        log.i('ğŸ”š ì•±ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        _onAppDetached();
        break;
        
      case AppLifecycleState.inactive:
        log.d('ğŸ˜´ ì•±ì´ ë¹„í™œì„± ìƒíƒœì…ë‹ˆë‹¤.');
        break;
        
      case AppLifecycleState.hidden:
        log.d('ğŸ«¥ ì•±ì´ ìˆ¨ê¹€ ìƒíƒœì…ë‹ˆë‹¤.');
        break;
    }
    
    // ğŸ†• ì™¸ë¶€ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
    _notifyLifecycleListeners(state);
  }

  /// ğŸ†• ìƒíƒœ ì „í™˜ ì‹œê°„ ì—…ë°ì´íŠ¸
  void _updateStateTimes(AppLifecycleState from, AppLifecycleState to) {
    final now = DateTime.now();
    
    if (from == AppLifecycleState.resumed && _lastResumeTime != null) {
      _totalForegroundTime += now.difference(_lastResumeTime!);
    } else if (from == AppLifecycleState.paused && _lastPauseTime != null) {
      _totalBackgroundTime += now.difference(_lastPauseTime!);
    }
  }

  /// ğŸ†• ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆë“¤ì—ê²Œ ì•Œë¦¼
  void _notifyLifecycleListeners(AppLifecycleState state) {
    for (final listener in _lifecycleListeners) {
      try {
        listener(state);
      } catch (e, st) {
        log.e('ë¼ì´í”„ì‚¬ì´í´ ë¦¬ìŠ¤ë„ˆ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜', e, st);
      }
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘
  void _startGlobalTimer() {
    if (_globalTimer == null || !_globalTimer!.isActive) {
      _globalTimer = Timer.periodic(const Duration(seconds: 30), (_) {
        _performPeriodicTasks();
      });
      log.i('â° ì „ì—­ íƒ€ì´ë¨¸ ì‹œì‘: 30ì´ˆ ê°„ê²©');
    }
  }

  /// ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€
  void _stopGlobalTimer() {
    _globalTimer?.cancel();
    _globalTimer = null;
    log.d('â¹ï¸ ì „ì—­ íƒ€ì´ë¨¸ ì¤‘ì§€');
  }

  /// ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰
  void _performPeriodicTasks() {
    log.d('ğŸ”„ ì „ì—­ íƒ€ì´ë¨¸: ì£¼ê¸°ì  ì‘ì—… ì‹¤í–‰');
    
    // ì—¬ê¸°ì— ì£¼ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•  ì‘ì—…ë“¤ ì¶”ê°€
    // ì˜ˆ: ë©”ëª¨ë¦¬ ì •ë¦¬, ìƒíƒœ ì²´í¬, ë°±ê·¸ë¼ìš´ë“œ ë™ê¸°í™” ë“±
    
    // ì˜ˆì‹œ: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ)
    _checkMemoryUsage();
    
    // ğŸ†• ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
    updatePerformanceStats('lastPeriodicTaskRun', DateTime.now().toIso8601String());
  }

  /// ì•±ì´ í¬ê·¸ë¼ìš´ë“œë¡œ ëŒì•„ì™”ì„ ë•Œ
  void _onAppResumed() {
    log.i('ğŸ“¦ Hive Box ìœ ì§€ - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ë°ì´í„° ë³´ì¡´ë¨');
    
    // í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì—°ê²° ìƒíƒœ í™•ì¸, ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ë“±
  }

  /// ì•±ì´ ë°±ê·¸ë¼ìš´ë“œë¡œ ì´ë™í–ˆì„ ë•Œ
  void _onAppPaused() {
    log.i('ğŸ’¾ ë°±ê·¸ë¼ìš´ë“œ ì§„ì… - ì¤‘ìš” ë°ì´í„° ë³´ì¡´ ì¤‘');
    
    // ë°±ê·¸ë¼ìš´ë“œ ì§„ì… ì‹œ í•„ìš”í•œ ì‘ì—…ë“¤
    // ì˜ˆ: ì„ì‹œ ë°ì´í„° ì €ì¥, ì—°ê²° ì •ë¦¬ ë“±
  }

  /// ì•±ì´ ì™„ì „íˆ ì¢…ë£Œë  ë•Œ
  void _onAppDetached() {
    log.i('ğŸ§¹ ì•± ì¢…ë£Œ - ìµœì¢… ì •ë¦¬ ì‘ì—… ìˆ˜í–‰');
    dispose();
  }

  /// ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬ (ë””ë²„ê·¸ìš©)
  void _checkMemoryUsage() {
    // ì‹¤ì œ êµ¬í˜„ì€ í”Œë«í¼ë³„ë¡œ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
    log.d('ğŸ§  ë©”ëª¨ë¦¬ ìƒíƒœ ì²´í¬ (ê°œë°œ ì¤‘)');
    
    // ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
    final memInfo = _getPlatformMemoryInfo();
    updatePerformanceStats('memoryInfo', memInfo);
  }

  /// ğŸ†• ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰
  void _performMemoryCleanup() {
    // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë¦¬ ë¡œì§
    log.i('ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ ì‹¤í–‰');
    
    // ì˜ˆì‹œ: ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰ (Dartì—ì„œëŠ” ì œí•œì )
    // System.gc() ê°™ì€ ê²ƒì€ ì—†ì§€ë§Œ, ë¶ˆí•„ìš”í•œ ì°¸ì¡° ì •ë¦¬ ë“±ì„ í•  ìˆ˜ ìˆìŒ
  }

  /// ğŸ†• í”Œë«í¼ë³„ ë©”ëª¨ë¦¬ ì •ë³´ ìˆ˜ì§‘
  Map<String, dynamic> _getPlatformMemoryInfo() {
    try {
      return {
        'platform': Platform.operatingSystem,
        'availableProcessors': Platform.numberOfProcessors,
        'timestamp': DateTime.now().toIso8601String(),
        // ì‹¤ì œ ë©”ëª¨ë¦¬ ì •ë³´ëŠ” í”Œë«í¼ ì±„ë„ì„ í†µí•´ êµ¬í˜„ ê°€ëŠ¥
        'note': 'Platform memory info implementation needed'
      };
    } catch (e) {
      return {'error': e.toString()};
    }
  }

  /// ì •ë¦¬ ì‘ì—…
  void dispose() {
    _stopGlobalTimer();
    WidgetsBinding.instance.removeObserver(this);
    _lifecycleListeners.clear();
    log.i('ğŸ§¹ AppLifecycleManager ì •ë¦¬ ì™„ë£Œ');
  }
}

/// AppLifecycleManager í”„ë¡œë°”ì´ë”
final appLifecycleManagerProvider = Provider<AppLifecycleManager>((ref) {
  final manager = AppLifecycleManager(ref);
  ref.onDispose(() => manager.dispose());
  return manager;
});\n\n// ====== lib/core/extensions/result.dart ======\n
import 'package:meta/meta.dart';
import '../error/app_exception.dart';

/// Either ìŠ¤íƒ€ì¼ì˜ ê²°ê³¼ íƒ€ì….
///
/// - `Ok<T, E>`: ì„±ê³µ ì‹œ ë°ì´í„°ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
/// - `Err<T, E>`: ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
@immutable
sealed class Result<T, E extends AppException> {
  const Result();

  /// ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬í•©ë‹ˆë‹¤.
  R when<R>({
    required R Function(T value) ok,
    required R Function(E error) err,
  }) {
    if (this is Ok<T, E>) {
      return ok((this as Ok<T, E>).value);
    } else {
      return err((this as Err<T, E>).error);
    }
  }

  /// ì„±ê³µ ì—¬ë¶€
  bool get isOk => this is Ok<T, E>;

  /// ì‹¤íŒ¨ ì—¬ë¶€
  bool get isErr => this is Err<T, E>;

  /// ì„±ê³µ ê°’ (ì—†ìœ¼ë©´ null)
  T? get valueOrNull => isOk ? (this as Ok<T, E>).value : null;

  /// ì‹¤íŒ¨ ì˜ˆì™¸ (ì—†ìœ¼ë©´ null)
  E? get errorOrNull => isErr ? (this as Err<T, E>).error : null;

  /// ì„±ê³µ ê°’ì„ ë§¤í•‘í•©ë‹ˆë‹¤.
  Result<U, E> map<U>(U Function(T value) f) {
    if (this is Ok<T, E>) {
      return Ok<U, E>(f((this as Ok<T, E>).value));
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  /// ì‹¤íŒ¨ ì˜ˆì™¸ë¥¼ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
  /// ì„±ê³µ ì‹œì—ë„ ìƒˆë¡œìš´ ì—ëŸ¬ íƒ€ì… F ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•©ë‹ˆë‹¤.
  Result<T, F> mapErr<F extends AppException>(F Function(E error) f) {
    if (this is Err<T, E>) {
      final err = (this as Err<T, E>).error;
      return Err<T, F>(f(err));
    }
    return Ok<T, F>((this as Ok<T, E>).value);
  }

  /// ì„±ê³µ ì‹œ ë¹„ë™ê¸° í›„ì† ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
  Future<Result<U, E>> thenAsync<U>(Future<U> Function(T value) f) async {
    if (this is Ok<T, E>) {
      final T value = (this as Ok<T, E>).value;
      try {
        final u = await f(value);
        return Ok<U, E>(u);
      } on AppException catch (e) {
        final E errVal = e is E ? e : AppException(e.message) as E;
        return Err<U, E>(errVal);
      } catch (e) {
        final E errVal = AppException(e.toString()) as E;
        return Err<U, E>(errVal);
      }
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  @override
  String toString() {
    if (this is Ok<T, E>) {
      return 'Ok(${(this as Ok<T, E>).value})';
    } else {
      return 'Err(${(this as Err<T, E>).error})';
    }
  }
}

/// ì„±ê³µ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Ok<T, E extends AppException> extends Result<T, E> {
  final T value;
  const Ok(this.value);
}

/// ì‹¤íŒ¨ ê²°ê³¼ë¥¼ ë‹´ìŠµë‹ˆë‹¤.
class Err<T, E extends AppException> extends Result<T, E> {
  final E error;
  const Err(this.error);
}
\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

import 'package:dio/dio.dart';

/// ìµœìƒìœ„ ì•± ì˜ˆì™¸
/// - ëª¨ë“  ì»¤ìŠ¤í…€ ì˜ˆì™¸ëŠ” ì´ í´ë˜ìŠ¤ë¥¼ ìƒì†í•´ì£¼ì„¸ìš”.
class AppException implements Exception {
  /// ì‚¬ìš©ìì—ê²Œ ë…¸ì¶œí•  ë©”ì‹œì§€
  final String message;

  /// ë‚´ë¶€ ë¡œê¹… ë˜ëŠ” ì‹ë³„ìš© ì½”ë“œ (nullable)
  final String? code;

  /// HTTP ìƒíƒœ ì½”ë“œ ë“± ì¶”ê°€ ìƒíƒœ ì •ë³´
  final int? statusCode;

  /// ì›ë³¸ ì˜ˆì™¸(ìˆëŠ” ê²½ìš°)
  final Exception? originalException;

  const AppException(
    this.message, {
    this.code,
    this.statusCode,
    this.originalException,
  });

  @override
  String toString() {
    final parts = <String>[];
    if (code != null) parts.add('code: $code');
    if (statusCode != null) parts.add('status: $statusCode');
    parts.add('message: $message');
    return 'AppException(${parts.join(', ')})';
  }
}

/// REST/HTTP í˜¸ì¶œ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class NetworkException extends AppException {
  const NetworkException(
    String message, {
    String? code,
    int? statusCode,
    Exception? originalException,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
          originalException: originalException,
        );

  /// DioException â†’ NetworkException ë³€í™˜ í—¬í¼
  factory NetworkException.fromDio(DioException dioError) {
    final msg = dioError.message ?? dioError.toString();
    return NetworkException(
      msg,
      code: dioError.response?.statusMessage,
      statusCode: dioError.response?.statusCode,
      originalException: dioError,
    );
  }
}

/// WebSocket ì—°ê²°/í†µì‹  ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class WebSocketException extends AppException {
  /// WS ì„œë²„ê°€ ë³´ë‚¸ ì´ìœ  ë¬¸ìì—´ (nullable)
  final String? reason;

  const WebSocketException(
    String message, {
    this.reason,
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );

  @override
  String toString() {
    final parts = <String>[];
    if (reason != null) parts.add('reason: $reason');
    parts.add('message: $message');
    return 'WebSocketException(${parts.join(', ')})';
  }
}

/// ì„œë²„ë¡œë¶€í„° Rate Limit(HTTP 429 ë“±) ì‘ë‹µì„ ë°›ì•˜ì„ ë•Œ
class RateLimitException extends AppException {
  /// ì¬ì‹œë„ê¹Œì§€ ëŒ€ê¸°í•´ì•¼ í•  ì‹œê°„
  final Duration retryAfter;

  const RateLimitException(
    String message, {
    required this.retryAfter,
    String? code,
    int? statusCode,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
        );

  @override
  String toString() =>
      'RateLimitException(retryAfter: ${retryAfter.inSeconds}s, message: $message)';
}

/// JSON íŒŒì‹± ë˜ëŠ” ë°ì´í„° ë³€í™˜ ì¤‘ ë°œìƒí•œ ì˜ˆì™¸
class DataParsingException extends AppException {
  const DataParsingException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ì¸ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ í‚¤ë¥¼ ì°¾ì§€ ëª»í–ˆì„ ë•Œ
class CacheMissException extends AppException {
  const CacheMissException([String message = 'Cache miss'])
      : super(message);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ë„ë©”ì¸ íŠ¹í™” ì˜ˆì™¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// ì²´ê²°(Trade) ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ì˜¤ë¥˜
class TradeException extends AppException {
  const TradeException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜¸ê°€(Order Book) ë°ì´í„° ì˜¤ë¥˜
class OrderBookException extends AppException {
  const OrderBookException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// ìº”ë“¤(Candle) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class CandleException extends DataParsingException {
  const CandleException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// í˜„ì¬ê°€(Ticker) ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜
class TickerException extends DataParsingException {
  const TickerException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}
\n\n// ====== lib/core/event/app_event.dart ======\n
// lib/core/event/app_event.dart

import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';

typedef Json = Map<String, dynamic>;

/// ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì´ë²¤íŠ¸ì˜ ë² ì´ìŠ¤ í´ë˜ìŠ¤
/// - id     : UUID v4
/// - ts     : UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
/// - payload: ììœ  í˜•íƒœ JSON
class AppEvent extends Equatable {
  /// ê³ ìœ  ID (UUID v4)
  final String id;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int ts;

  /// í˜ì´ë¡œë“œ ë°ì´í„° (ë¶ˆë³€)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// í˜„ì¬ ì‹œê°ì„ ê¸°ì¤€ìœ¼ë¡œ idÂ·tsë¥¼ ìë™ ìƒì„±í•©ë‹ˆë‹¤.
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: const Uuid().v4(),
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // ë°©ì–´ì  ë³µì‚¬
    );
  }

  /// UTC ms â†’ ë¡œì»¬ DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON ì§ë ¬í™” (payloadë„ ë³µì‚¬í•˜ì—¬ ë…¸ì¶œ)
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON ì—­ì§ë ¬í™”
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  /// ë³µì‚¬ë³¸ ìƒì„± (immutable ìœ ì§€)
  AppEvent copyWith({
    String? id,
    int? ts,
    Json? payload,
  }) =>
      AppEvent(
        id: id ?? this.id,
        ts: ts ?? this.ts,
        payload: payload != null ? Map<String, dynamic>.of(payload) : this.payload,
      );

  @override
  List<Object?> get props => [id, ts, payload];
}
\n\n// ====== lib/core/services/hive_service.dart ======\n
// lib/core/services/hive_service.dart

import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../utils/logger.dart';
import '../../data/models/trade_dto.dart';

/// ğŸ¯ Hive ì „ì—­ ê´€ë¦¬ ì„œë¹„ìŠ¤ (ì‹±ê¸€í†¤)
/// - ì•± ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ì´ˆê¸°í™”
/// - ëª¨ë“  TypeAdapter ë“±ë¡ ë° Box ê´€ë¦¬
/// - ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ Box ìœ ì§€ (ë‹«ì§€ ì•ŠìŒ)
/// - AppConfigì— ì˜ì¡´í•˜ì§€ ì•ŠëŠ” ì™„ì „ ë…ë¦½ ì„œë¹„ìŠ¤
class HiveService {
  // ì‹±ê¸€í†¤ íŒ¨í„´
  HiveService._();
  static final HiveService _instance = HiveService._();
  factory HiveService() => _instance;

  // ğŸ·ï¸ Box ì´ë¦„ ìƒìˆ˜ (HiveService ìì²´ ê´€ë¦¬)
  static const String _tradeBoxName = 'trades';

  // Box ì¸ìŠ¤í„´ìŠ¤ ìºì‹±
  late final Box<TradeDto> _tradeBox;
  
  // ì´ˆê¸°í™” ìƒíƒœ ê´€ë¦¬
  bool _initialized = false;
  Future<void>? _initFuture;

  /// ğŸ¯ Trade Box getter (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  Box<TradeDto> get tradeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using tradeBox.'
      );
    }
    return _tradeBox;
  }

  /// ğŸš€ Hive ì´ˆê¸°í™” (ì•± ì‹œì‘ ì‹œ ë‹¨ í•œ ë²ˆë§Œ í˜¸ì¶œ)
  Future<void> init() async {
    if (_initialized) {
      log.i('[HiveService] already initialized, skipping');
      return;
    }

    // ë™ì‹œ í˜¸ì¶œ ë°©ì–´ - race condition ì™„ì „ ì°¨ë‹¨
    if (_initFuture != null) {
      log.d('[HiveService] init already in progress, waiting...');
      return _initFuture;
    }

    _initFuture = _doInit();
    await _initFuture;
  }

  /// ğŸ”§ ì‹¤ì œ ì´ˆê¸°í™” ë¡œì§
  Future<void> _doInit() async {
    try {
      // 1. Hive í”Œë«í¼ ì´ˆê¸°í™”
      await Hive.initFlutter();
      log.i('[HiveService] Hive.initFlutter() completed');

      // 2. TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
      _registerAdapters();

      // 3. Trade Box ì—´ê¸° ë° ìºì‹±
      _tradeBox = await Hive.openBox<TradeDto>(_tradeBoxName);
      log.i('[HiveService] "$_tradeBoxName" box opened and cached');

      _initialized = true;
      log.i('[HiveService] âœ… initialized successfully');
      
    } catch (e, st) {
      log.e('[HiveService] âŒ init failed', e, st);
      _initialized = false;
      rethrow; // ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ìƒìœ„ì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡
    } finally {
      // ì´ˆê¸°í™” ì™„ë£Œ í›„ Future í•´ì œ (ì¬ì‹œë„ ê°€ëŠ¥í•˜ë„ë¡)
      _initFuture = null;
    }
  }

  /// ğŸ“‹ ëª¨ë“  TypeAdapter ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
  void _registerAdapters() {
    final adapter = TradeDtoAdapter();
    if (!Hive.isAdapterRegistered(adapter.typeId)) {
      Hive.registerAdapter(adapter);
      log.i('[HiveService] TradeDtoAdapter registered (typeId: ${adapter.typeId})');
    } else {
      log.d('[HiveService] TradeDtoAdapter already registered');
    }
    
    // ğŸ“ í–¥í›„ ë‹¤ë¥¸ ì–´ëŒ‘í„° ì¶”ê°€ ì‹œ ì—¬ê¸°ì— ì¶”ê°€
    // if (!Hive.isAdapterRegistered(AnotherDtoAdapter().typeId)) {
    //   Hive.registerAdapter(AnotherDtoAdapter());
    //   log.i('[HiveService] AnotherDtoAdapter registered');
    // }
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ ì‹¤í–‰)
  /// ì¼ë°˜ì ìœ¼ë¡œ ëª¨ë°”ì¼ ì•±ì—ì„œëŠ” OSê°€ ìë™ ì •ë¦¬í•˜ë¯€ë¡œ í˜¸ì¶œ ë¶ˆí•„ìš”
  Future<void> dispose() async {
    if (!kDebugMode) {
      log.d('[HiveService] dispose skipped in production mode');
      return;
    }
    
    if (!_initialized) {
      log.d('[HiveService] not initialized, skip dispose');
      return;
    }

    try {
      if (_tradeBox.isOpen) {
        await _tradeBox.close();
        log.i('[HiveService] "$_tradeBoxName" box closed');
      }

      await Hive.close();
      log.i('[HiveService] ğŸ§¹ all Hive resources disposed');
      
    } catch (e, st) {
      log.e('[HiveService] dispose failed', e, st);
    } finally {
      _initialized = false;
    }
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: í˜„ì¬ ìƒíƒœ ì •ë³´
  Map<String, Object> get debugInfo => {
    'initialized': _initialized,
    'boxName': _tradeBoxName,
    'boxOpen': _initialized ? _tradeBox.isOpen : false,
    'boxLength': _initialized ? _tradeBox.length : 0,
    'initInProgress': _initFuture != null,
  };

  /// ğŸ” ë””ë²„ê¹…ìš©: ìƒíƒœ ë¡œê¹…
  void logStatus() {
    log.d('[HiveService] Status: $debugInfo');
  }

  /// ğŸ” ë””ë²„ê¹…ìš©: Box ìƒì„¸ ì •ë³´ (ê°œë°œ ì‹œ ìœ ìš©)
  void logBoxDetails() {
    if (!_initialized) {
      log.w('[HiveService] Cannot log box details - not initialized');
      return;
    }
    
    log.d('[HiveService] Box Details:');
    log.d('  - Name: $_tradeBoxName');
    log.d('  - Length: ${_tradeBox.length}');
    log.d('  - Keys sample: ${_tradeBox.keys.take(5).toList()}');
    log.d('  - Is open: ${_tradeBox.isOpen}');
  }
}\n\n// ====== lib/firebase_options.dart ======\n
// File generated by FlutterFire CLI and modified for .env
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;
import 'package:flutter_dotenv/flutter_dotenv.dart';

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static FirebaseOptions get web {
    _checkEnvKeys([
      'FIREBASE_WEB_API_KEY',
      'FIREBASE_WEB_APP_ID',
      'FIREBASE_WEB_MESSAGING_SENDER_ID',
      'FIREBASE_WEB_PROJECT_ID',
      'FIREBASE_WEB_AUTH_DOMAIN',
      'FIREBASE_WEB_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_WEB_API_KEY']!,
      appId: dotenv.env['FIREBASE_WEB_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_WEB_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_WEB_PROJECT_ID']!,
      authDomain: dotenv.env['FIREBASE_WEB_AUTH_DOMAIN']!,
      storageBucket: dotenv.env['FIREBASE_WEB_STORAGE_BUCKET']!,
    );
  }

  static FirebaseOptions get android {
    _checkEnvKeys([
      'FIREBASE_ANDROID_API_KEY',
      'FIREBASE_ANDROID_APP_ID',
      'FIREBASE_ANDROID_MESSAGING_SENDER_ID',
      'FIREBASE_ANDROID_PROJECT_ID',
      'FIREBASE_ANDROID_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_ANDROID_API_KEY']!,
      appId: dotenv.env['FIREBASE_ANDROID_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_ANDROID_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_ANDROID_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_ANDROID_STORAGE_BUCKET']!,
    );
  }

  static FirebaseOptions get ios {
    _checkEnvKeys([
      'FIREBASE_IOS_API_KEY',
      'FIREBASE_IOS_APP_ID',
      'FIREBASE_IOS_MESSAGING_SENDER_ID',
      'FIREBASE_IOS_PROJECT_ID',
      'FIREBASE_IOS_STORAGE_BUCKET',
      'FIREBASE_IOS_BUNDLE_ID',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_IOS_API_KEY']!,
      appId: dotenv.env['FIREBASE_IOS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_IOS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_IOS_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_IOS_STORAGE_BUCKET']!,
      iosBundleId: dotenv.env['FIREBASE_IOS_BUNDLE_ID']!,
    );
  }

  static FirebaseOptions get macos {
    _checkEnvKeys([
      'FIREBASE_MACOS_API_KEY',
      'FIREBASE_MACOS_APP_ID',
      'FIREBASE_MACOS_MESSAGING_SENDER_ID',
      'FIREBASE_MACOS_PROJECT_ID',
      'FIREBASE_MACOS_STORAGE_BUCKET',
      'FIREBASE_MACOS_BUNDLE_ID',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_MACOS_API_KEY']!,
      appId: dotenv.env['FIREBASE_MACOS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_MACOS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_MACOS_PROJECT_ID']!,
      storageBucket: dotenv.env['FIREBASE_MACOS_STORAGE_BUCKET']!,
      iosBundleId: dotenv.env['FIREBASE_MACOS_BUNDLE_ID']!,
    );
  }

  static FirebaseOptions get windows {
    _checkEnvKeys([
      'FIREBASE_WINDOWS_API_KEY',
      'FIREBASE_WINDOWS_APP_ID',
      'FIREBASE_WINDOWS_MESSAGING_SENDER_ID',
      'FIREBASE_WINDOWS_PROJECT_ID',
      'FIREBASE_WINDOWS_AUTH_DOMAIN',
      'FIREBASE_WINDOWS_STORAGE_BUCKET',
    ]);
    return FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_WINDOWS_API_KEY']!,
      appId: dotenv.env['FIREBASE_WINDOWS_APP_ID']!,
      messagingSenderId: dotenv.env['FIREBASE_WINDOWS_MESSAGING_SENDER_ID']!,
      projectId: dotenv.env['FIREBASE_WINDOWS_PROJECT_ID']!,
      authDomain: dotenv.env['FIREBASE_WINDOWS_AUTH_DOMAIN']!,
      storageBucket: dotenv.env['FIREBASE_WINDOWS_STORAGE_BUCKET']!,
    );
  }

  static void _checkEnvKeys(List<String> keys) {
    for (var key in keys) {
      if (dotenv.env[key] == null) {
        throw Exception('$key is missing in .env file');
      }
    }
  }
}\n\n// ====== lib/shared/theme/app_theme.dart ======\n
import 'package:flutter/material.dart';
import '../../core/bridge/signal_bus.dart'; // ExchangePlatform ì„í¬íŠ¸

/// ì•±ì˜ í…Œë§ˆ ì„¤ì •ì„ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤
class AppTheme {
  AppTheme._(); // private ìƒì„±ì
  
  // ê³µí†µ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸
  static const Color neutralWhite = Colors.white;
  static const Color neutralBlack = Colors.black;
  static const Color neutralGrey = Colors.grey;
  static const Color accentOrange = Colors.orange;
  
  // í”Œë«í¼ë³„ í¬ì¸íŠ¸ ì»¬ëŸ¬
  static Color getPrimaryColor(ExchangePlatform platform) {
    switch (platform) {
      case ExchangePlatform.upbit:
        return accentOrange;
      case ExchangePlatform.binance:
        return const Color(0xFFF0B90B); // ë°”ì´ë‚¸ìŠ¤ ë…¸ë‘
      case ExchangePlatform.bybit:
        return const Color(0xFF00C087); // ë°”ì´ë¹— ì´ˆë¡
      case ExchangePlatform.bithumb:
        return const Color(0xFF1A3C34); // ë¹—ì¸ ì´ˆë¡
    }
  }

  static Color getSecondaryColor(ExchangePlatform platform) {
    switch (platform) {
      case ExchangePlatform.upbit:
        return Colors.orangeAccent;
      case ExchangePlatform.binance:
        return const Color(0xFFF3BA2F); // ë°”ì´ë‚¸ìŠ¤ ë°ì€ ë…¸ë‘
      case ExchangePlatform.bybit:
        return const Color(0xFF00D4B1); // ë°”ì´ë¹— ë°ì€ ì´ˆë¡
      case ExchangePlatform.bithumb:
        return const Color(0xFF2A5D52); // ë¹—ì¸ ë°ì€ ì´ˆë¡
    }
  }
  
  // ê¸°ë³¸ í…Œë§ˆ ì„¤ì • (ì‹œìŠ¤í…œ ëª¨ë“œ ë˜ëŠ” ê¸°ë³¸ê°’ìš©)
  static ThemeData light({ExchangePlatform platform = ExchangePlatform.upbit}) {
    final primaryColor = getPrimaryColor(platform);
    final secondaryColor = getSecondaryColor(platform);
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.light,
        primary: primaryColor,
        secondary: secondaryColor,
      ),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        selectedItemColor: primaryColor,
        unselectedItemColor: neutralGrey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
      textTheme: const TextTheme(
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
        titleLarge: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          foregroundColor: neutralWhite,
          backgroundColor: primaryColor,
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
  
  // ë‹¤í¬ í…Œë§ˆ
  static ThemeData dark({ExchangePlatform platform = ExchangePlatform.upbit}) {
    final primaryColor = getPrimaryColor(platform);
    final secondaryColor = getSecondaryColor(platform);
    
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.fromSeed(
        seedColor: primaryColor,
        brightness: Brightness.dark,
        primary: primaryColor,
        secondary: secondaryColor,
      ),
      appBarTheme: const AppBarTheme(
        centerTitle: true,
        elevation: 0,
      ),
      cardTheme: CardTheme(
        elevation: 2,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        selectedItemColor: primaryColor,
        unselectedItemColor: neutralGrey,
        showUnselectedLabels: true,
        type: BottomNavigationBarType.fixed,
      ),
      textTheme: const TextTheme(
        bodyLarge: TextStyle(fontSize: 16),
        bodyMedium: TextStyle(fontSize: 14),
        titleLarge: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          foregroundColor: neutralBlack,
          backgroundColor: primaryColor,
          textStyle: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
        ),
      ),
    );
  }
  
  // ì‹œìŠ¤í…œ í…Œë§ˆ (ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ ë¼ì´íŠ¸/ë‹¤í¬ ê²°ì •)
  static ThemeData system(BuildContext context, {ExchangePlatform platform = ExchangePlatform.upbit}) {
    final brightness = MediaQuery.of(context).platformBrightness;
    return brightness == Brightness.light
        ? light(platform: platform)
        : dark(platform: platform);
  }
}\n\n// ====== lib/shared/widgets/slider_position_segment.dart ======\n
import 'package:flutter/material.dart';
import '../../domain/entities/app_settings.dart'; // SliderPosition enum

class SliderPositionSegment extends StatelessWidget {
  final SliderPosition value;
  final ValueChanged<SliderPosition> onChanged;

  const SliderPositionSegment({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return SegmentedButton<SliderPosition>(
      // âœ… ìŠ¤íƒ€ì¼ë¡œ í¬ê¸° ì¡°ì •
      style: SegmentedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6), // âœ… íŒ¨ë”© ì¤„ì´ê¸°
        minimumSize: const Size(40, 32), // âœ… ìµœì†Œ í¬ê¸° ì¤„ì´ê¸° (ë” ì‘ê²Œ)
        textStyle: const TextStyle(fontSize: 11), // âœ… 9 â†’ 10
      ),
      segments: [
        ButtonSegment(
          value: SliderPosition.top,
          icon: _buildSliderIcon(isTop: true),
          label: const Text('ìœ„'),
        ),
        ButtonSegment(
          value: SliderPosition.bottom,
          icon: _buildSliderIcon(isTop: false),
          label: const Text('ì•„ë˜'),
        ),
      ],
      selected: <SliderPosition>{value},
      onSelectionChanged: (newSelection) {
        onChanged(newSelection.first);
      },
    );
  }

  Widget _buildSliderIcon({required bool isTop}) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (isTop) ...[
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 6, // âœ… 8 â†’ 6 (ì‘ê²Œ)
                height: 6, // âœ… 8 â†’ 6 (ì‘ê²Œ)
                decoration: const BoxDecoration(
                  shape: BoxShape.circle, 
                  color: Colors.orange
                )
              ),
              const SizedBox(width: 1), // âœ… 2 â†’ 1 (ê°„ê²© ì¤„ì´ê¸°)
              Container(
                width: 12, // âœ… 16 â†’ 12 (ì‘ê²Œ)
                height: 1.5, // âœ… 2 â†’ 1.5 (ì–‡ê²Œ)
                color: Colors.orange
              ),
            ],
          ),
          const SizedBox(height: 2), // âœ… 4 â†’ 2 (ê°„ê²© ì¤„ì´ê¸°)
          Row(
            mainAxisSize: MainAxisSize.min,
            children: List.generate(4, (i) => Padding(
              padding: const EdgeInsets.symmetric(horizontal: 0.5), // âœ… 1 â†’ 0.5 (ê°„ê²© ì¤„ì´ê¸°)
              child: Container(
                width: 3, // âœ… 4 â†’ 3 (ì‘ê²Œ)
                height: 1.5, // âœ… 2 â†’ 1.5 (ì–‡ê²Œ)
                color: Colors.grey
              ),
            )),
          ),
        ] else ...[
          Row(
            mainAxisSize: MainAxisSize.min,
            children: List.generate(4, (i) => Padding(
              padding: const EdgeInsets.symmetric(horizontal: 0.5), // âœ… 1 â†’ 0.5 (ê°„ê²© ì¤„ì´ê¸°)
              child: Container(
                width: 3, // âœ… 4 â†’ 3 (ì‘ê²Œ)
                height: 1.5, // âœ… 2 â†’ 1.5 (ì–‡ê²Œ)
                color: Colors.grey
              ),
            )),
          ),
          const SizedBox(height: 2), // âœ… 4 â†’ 2 (ê°„ê²© ì¤„ì´ê¸°)
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Container(
                width: 6, // âœ… 8 â†’ 6 (ì‘ê²Œ)
                height: 6, // âœ… 8 â†’ 6 (ì‘ê²Œ)
                decoration: const BoxDecoration(
                  shape: BoxShape.circle, 
                  color: Colors.orange
                )
              ),
              const SizedBox(width: 1), // âœ… 2 â†’ 1 (ê°„ê²© ì¤„ì´ê¸°)
              Container(
                width: 12, // âœ… 16 â†’ 12 (ì‘ê²Œ)
                height: 1.5, // âœ… 2 â†’ 1.5 (ì–‡ê²Œ)
                color: Colors.orange
              ),
            ],
          ),
        ],
      ],
    );
  }
}\n\n// ====== lib/shared/widgets/amount_display_widget.dart ======\n
// lib/shared/widgets/amount_display_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../core/di/settings_provider.dart';
import '../../domain/entities/app_settings.dart';

/// ê±°ë˜ ê¸ˆì•¡ í‘œì‹œ ìœ„ì ¯ (ìˆ«ì â†” ì•„ì´ì½˜)
class AmountDisplayWidget extends ConsumerWidget {
  final double totalAmount; // ì´ ê±°ë˜ ê¸ˆì•¡ (ì› ë‹¨ìœ„)
  final bool isBuy; // ë§¤ìˆ˜/ë§¤ë„ êµ¬ë¶„ (ìƒ‰ìƒìš©)
  final double fontSize;
  final FontWeight fontWeight;
  
  // í¬ë§·í„° ìºì‹±
  static final _integerFormat = NumberFormat('#,###');
  
  const AmountDisplayWidget({
    Key? key,
    required this.totalAmount,
    required this.isBuy,
    this.fontSize = 16,
    this.fontWeight = FontWeight.bold,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final amountDisplayMode = ref.watch(appSettingsProvider).amountDisplayMode;
    
    return amountDisplayMode == AmountDisplayMode.icon
        ? _buildAmountIcon(context)
        : _buildAmountText(context);
  }

  /// ìˆ«ìë¡œ ê¸ˆì•¡ í‘œì‹œ
  Widget _buildAmountText(BuildContext context) {
    return Text(
      '${_integerFormat.format(totalAmount / 10000)}ë§Œ',
      style: TextStyle(
        fontWeight: fontWeight,
        color: isBuy ? Colors.green : Colors.red,
        fontSize: fontSize,
      ),
      overflow: TextOverflow.ellipsis,
      maxLines: 1,
    );
  }

  /// ì•„ì´ì½˜ìœ¼ë¡œ ê¸ˆì•¡ í‘œì‹œ (1000ë§Œ ~ 100ì–µì›)
  Widget _buildAmountIcon(BuildContext context) {
    final amountInMan = (totalAmount / 10000).round(); // ë§Œì› ë‹¨ìœ„
    
    // 1000ë§Œì› ë¯¸ë§Œì´ë©´ ìˆ«ìë¡œ í‘œì‹œ
    if (amountInMan < 1000) {
      return _buildAmountText(context);
    }
    
    final assetPath = _getIconPath(amountInMan);
    
    return Image.asset(
      assetPath,
      width: 64,
      height: 40,
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) {
        // ì•„ì´ì½˜ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ìˆ«ìë¡œ fallback
        return _buildAmountText(context);
      },
    );
  }

  /// ê¸ˆì•¡ì— ë”°ë¥¸ ì•„ì´ì½˜ ê²½ë¡œ ê²°ì •
  String _getIconPath(int amountInMan) {
    if (amountInMan >= 1000 && amountInMan < 5000) {
      return _get1000SeriesPath(amountInMan);
    } else if (amountInMan >= 5000 && amountInMan < 100000) {
      return _get5000SeriesPath(amountInMan);
    } else if (amountInMan >= 100000 && amountInMan <= 1000000) {
      return _get10000SeriesPath(amountInMan);
    } else {
      // 100ì–µ ì´ˆê³¼ì‹œ ìµœëŒ€ê°’ìœ¼ë¡œ
      return 'assets/icons/money/money_10000_10.png';
    }
  }

  /// ğŸ”§ 1000 ì‹œë¦¬ì¦ˆ (1000ë§Œ ~ 4999ë§Œ) - ì„¸ë ¨ëœ ê³„ì‚°ì‹
  String _get1000SeriesPath(int amountInMan) {
    // 1000ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”í•˜ê³  1000ë§Œì› ë‹¨ìœ„ë¡œ ë ˆë²¨ ê²°ì •
    final normalizedAmount = amountInMan - 1000; // 1000ë§Œì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    final level = (normalizedAmount / 1000).floor() + 1; // 1000ë§Œì› ë‹¨ìœ„ë¡œ ë ˆë²¨ ê³„ì‚°
    final clampedLevel = level.clamp(1, 4); // 1~4 ë²”ìœ„ë¡œ ì œí•œ
    
    return 'assets/icons/money/money_1000_$clampedLevel.png';
    
    // ìˆ˜í•™ì  ë§¤í•‘:
    // 1000~1999ë§Œ â†’ (0~999)/1000 + 1 = 1 â†’ money_1000_1.png
    // 2000~2999ë§Œ â†’ (1000~1999)/1000 + 1 = 2 â†’ money_1000_2.png
    // 3000~3999ë§Œ â†’ (2000~2999)/1000 + 1 = 3 â†’ money_1000_3.png
    // 4000~4999ë§Œ â†’ (3000~3999)/1000 + 1 = 4 â†’ money_1000_4.png
  }

  /// ğŸ”§ 5000 ì‹œë¦¬ì¦ˆ (5000ë§Œ ~ 9ì–µ9999ë§Œ) - ì •í™•í•œ êµ¬ê°„ ë§¤í•‘
  String _get5000SeriesPath(int amountInMan) {
    // 5000ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
    final normalizedAmount = amountInMan - 5000; // 5000ë§Œì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    
    // 5000ë§Œì› ë‹¨ìœ„ì™€ 1000ë§Œì› ë‚˜ë¨¸ì§€ ê³„ì‚°
    final fiveThousandUnits = (normalizedAmount / 5000).floor(); // 5ì²œë§Œ ì¶”ê°€ ê°œìˆ˜
    final remainder = normalizedAmount % 5000; // 1000ë§Œì› ë‹¨ìœ„ ë‚˜ë¨¸ì§€
    
    // ì´ 5ì²œë§Œ ê°œìˆ˜ (ê¸°ë³¸ 1ê°œ + ì¶”ê°€ ê°œìˆ˜)
    final totalFiveThousands = fiveThousandUnits + 1;
    
    if (remainder == 0) {
      // ì •í™•íˆ 5ì²œë§Œ ë°°ìˆ˜: 5000ë§Œ, 1ì–µ, 1ì–µ5ì²œë§Œ, 2ì–µ...
      final clampedCount = totalFiveThousands.clamp(1, 19);
      return 'assets/icons/money/money_5000_$clampedCount.png';
    } else {
      // 5ì²œë§Œ + ì²œë§Œ ì¡°í•©
      final thousandLevel = _getThousandLevel(remainder); // ğŸ”§ ì •í™•í•œ êµ¬ê°„ ë§¤í•‘
      
      if (totalFiveThousands <= 3) {
        // ì¡°í•© ì§€ì›: 1~3ì¥ê¹Œì§€
        return 'assets/icons/money/money_5000_${totalFiveThousands}_1000_$thousandLevel.png';
      } else {
        // 4ì¥ ì´ìƒì€ ì¡°í•© ë¯¸ì§€ì›, ìŠ¤ë§ˆíŠ¸ ë°˜ì˜¬ë¦¼
        final roundedFiveThousands = remainder >= 2500 
          ? (totalFiveThousands + 1).clamp(4, 19)  // 2500ë§Œ ì´ìƒì´ë©´ ì˜¬ë¦¼
          : totalFiveThousands.clamp(4, 19);       // ë¯¸ë§Œì´ë©´ ë²„ë¦¼
        return 'assets/icons/money/money_5000_$roundedFiveThousands.png';
      }
    }
    
    // ì •í™•í•œ ë§¤í•‘ ì˜ˆì‹œ:
    // 5000ë§Œ â†’ money_5000_1.png
    // 6200ë§Œ â†’ remainder=1200 â†’ level=1 â†’ money_5000_1_1000_1.png âœ…
    // 7800ë§Œ â†’ remainder=2800 â†’ level=2 â†’ money_5000_1_1000_2.png âœ…
    // 8300ë§Œ â†’ remainder=3300 â†’ level=3 â†’ money_5000_1_1000_3.png âœ…
    // 8560ë§Œ â†’ remainder=3560 â†’ level=3 â†’ money_5000_1_1000_3.png âœ…
    // 9200ë§Œ â†’ remainder=4200 â†’ level=4 â†’ money_5000_1_1000_4.png âœ…
  }
  
  /// ğŸ”§ ì²œë§Œì› ë‚˜ë¨¸ì§€ë¥¼ ì •í™•í•œ ë ˆë²¨ë¡œ ë§¤í•‘
  int _getThousandLevel(int remainder) {
    if (remainder >= 1000 && remainder < 2000) return 1; // 1000~1999ë§Œ â†’ level 1
    if (remainder >= 2000 && remainder < 3000) return 2; // 2000~2999ë§Œ â†’ level 2  
    if (remainder >= 3000 && remainder < 4000) return 3; // 3000~3999ë§Œ â†’ level 3
    return 4; // 4000ë§Œ ì´ìƒ â†’ level 4
  }

  /// ğŸ”§ 10000 ì‹œë¦¬ì¦ˆ (10ì–µ ~ 100ì–µì›) - ì„¸ë ¨ëœ ê³„ì‚°ì‹
  String _get10000SeriesPath(int amountInMan) {
    // 10ì–µì›(100000ë§Œ) ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”
    final normalizedAmount = amountInMan - 100000; // 10ì–µì›ì„ 0ìœ¼ë¡œ ë§ì¶¤
    
    // 10ì–µì› ë‹¨ìœ„ì™€ ë‚˜ë¨¸ì§€ ê³„ì‚°
    final tenBillionUnits = (normalizedAmount / 100000).floor(); // 10ì–µ ì¶”ê°€ ê°œìˆ˜
    final remainder = normalizedAmount % 100000; // 10ì–µ ë¯¸ë§Œ ë‚˜ë¨¸ì§€
    
    // ì´ 10ì–µ ê°œìˆ˜ (ê¸°ë³¸ 1ê°œ + ì¶”ê°€ ê°œìˆ˜)
    final totalTenBillions = tenBillionUnits + 1;
    
    if (remainder == 0) {
      // ì •í™•íˆ 10ì–µ ë°°ìˆ˜: 10ì–µ, 20ì–µ, 30ì–µ...
      final clampedCount = totalTenBillions.clamp(1, 10);
      return 'assets/icons/money/money_10000_$clampedCount.png';
    } else {
      // 10ì–µ + ë‚˜ë¨¸ì§€ ì¡°í•©
      if (totalTenBillions <= 2) {
        // ì¡°í•© ì§€ì›: 1~2ì¥ê¹Œì§€
        // ë‚˜ë¨¸ì§€ë¥¼ 5ì²œë§Œ ë‹¨ìœ„ë¡œ ë³€í™˜ (ì •ë°€í•œ ë§¤í•‘)
        final fiveThousandCount = _calculateFiveThousandLevel(remainder);
        final clampedFiveThousand = fiveThousandCount.clamp(1, 19);
        return 'assets/icons/money/money_10000_${totalTenBillions}_5000_$clampedFiveThousand.png';
      } else {
        // 3ì¥ ì´ìƒì€ ì¡°í•© ë¯¸ì§€ì›, ìŠ¤ë§ˆíŠ¸ ë°˜ì˜¬ë¦¼
        final roundedTenBillions = remainder >= 50000 
          ? (totalTenBillions + 1).clamp(3, 10)  // 5ì–µ ì´ìƒì´ë©´ ì˜¬ë¦¼
          : totalTenBillions.clamp(3, 10);       // ë¯¸ë§Œì´ë©´ ë²„ë¦¼
        return 'assets/icons/money/money_10000_$roundedTenBillions.png';
      }
    }
    
    // ìˆ˜í•™ì  ë§¤í•‘ ì˜ˆì‹œ:
    // 10ì–µ â†’ normalized=0, total=1 â†’ money_10000_1.png
    // 15ì–µ â†’ normalized=50000, total=1, fiveThousand=10 â†’ money_10000_1_5000_10.png
    // 23ì–µ â†’ normalized=130000, total=2, remainder=30000, fiveThousand=6 â†’ money_10000_2_5000_6.png
    // 35ì–µ â†’ normalized=250000, total=3, remainder>=50000 â†’ money_10000_4.png (ì˜¬ë¦¼)
  }
  
  /// ë‚˜ë¨¸ì§€ ê¸ˆì•¡ì„ 5ì²œë§Œ ë ˆë²¨ë¡œ ì •ë°€ ë³€í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
  int _calculateFiveThousandLevel(int remainder) {
    // 5ì²œë§Œì› ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê³ , 2500ë§Œì› ê¸°ì¤€ìœ¼ë¡œ ë°˜ì˜¬ë¦¼
    final exactLevel = remainder / 5000; // ì •í™•í•œ 5ì²œë§Œ ë ˆë²¨
    return exactLevel.round(); // ë°˜ì˜¬ë¦¼ìœ¼ë¡œ ê°€ì¥ ê°€ê¹Œìš´ ì •ìˆ˜
    
    // ì˜ˆì‹œ:
    // 2500ë§Œì› â†’ 2500/5000 = 0.5 â†’ round() = 1 â†’ 5ì²œë§Œ 1ì¥
    // 7500ë§Œì› â†’ 7500/5000 = 1.5 â†’ round() = 2 â†’ 5ì²œë§Œ 2ì¥
    // 12000ë§Œì› â†’ 12000/5000 = 2.4 â†’ round() = 2 â†’ 5ì²œë§Œ 2ì¥
    // 13000ë§Œì› â†’ 13000/5000 = 2.6 â†’ round() = 3 â†’ 5ì²œë§Œ 3ì¥
  }
}\n\n// ====== lib/shared/widgets/ws_status_indicator.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart'; // ğŸ”§ ìˆ˜ì •: app_providersë¡œ í†µí•©
import '../../core/network/websocket/base_ws_client.dart';
import 'websocket_modal.dart'; // ğŸ†• WebSocket ëª¨ë‹¬ import

class WsStatusIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const WsStatusIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false, // ğŸ”§ ê¸°ë³¸ê°’ì„ falseë¡œ ë³€ê²½ (ë¡±í”„ë ˆìŠ¤ ëª¨ë‹¬ê³¼ ì¶©ëŒ ë°©ì§€)
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final status = ref.watch(wsStatusProvider);
    
    Widget indicator = _buildStatusIcon(context, ref, status);
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildStatusIcon(BuildContext context, WidgetRef ref, WsStatus status) {
    Widget statusIcon = _getStatusIcon(status);
    
    // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜ ì¶”ê°€
    return GestureDetector(
      onLongPressStart: (details) => _showWebSocketModal(context, ref, details.globalPosition),
      onLongPressEnd: (_) => _hideWebSocketModal(),
      onLongPressCancel: () => _hideWebSocketModal(),
      child: statusIcon,
    );
  }

  /// WebSocket ìƒì„¸ ëª¨ë‹¬ í‘œì‹œ
  void _showWebSocketModal(BuildContext context, WidgetRef ref, Offset globalPosition) {
    // ê¸°ì¡´ íˆ´íŒ ìˆ¨ê¸°ê¸°
    Tooltip.dismissAllToolTips();
    
    // í™”ë©´ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = size * 4.2 * 1.8; // ì˜ˆìƒ ëª¨ë‹¬ ë„ˆë¹„
    
    // í™”ë©´ ê²½ê³„ ê³ ë ¤í•œ ìœ„ì¹˜ ê³„ì‚°
    double adjustedX = globalPosition.dx - (modalWidth / 2); // ì¤‘ì•™ ì •ë ¬
    double adjustedY = globalPosition.dy - (size * 3); // ìœ„ìª½ìœ¼ë¡œ
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16; // ìµœì†Œ ì—¬ë°±
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16; // ìš°ì¸¡ ì—¬ë°± í™•ë³´
    }
    
    // ìƒë‹¨ ê²½ê³„ ì²´í¬
    if (adjustedY < 50) {
      adjustedY = globalPosition.dy + size + 8; // ì•„ë˜ìª½ìœ¼ë¡œ ì´ë™
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    WebSocketStatsOverlay.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
    );
  }

  /// WebSocket ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  void _hideWebSocketModal() {
    WebSocketStatsOverlay.hide();
  }

  Widget _getStatusIcon(WsStatus status) {
    switch (status) {
      case WsStatus.connected:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.green,
          tooltip: showTooltip ? 'ì‹¤ì‹œê°„ ì—°ê²°ë¨ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.pulse,
          size: size,
        );
        
      case WsStatus.connecting:
        return _AnimatedStatusIcon(
          icon: Icons.refresh,
          color: Colors.blue,
          tooltip: showTooltip ? 'ì—°ê²° ì¤‘... (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.rotate,
          size: size,
        );
        
      case WsStatus.reconnecting:
        return _AnimatedStatusIcon(
          icon: Icons.refresh,
          color: Colors.orange,
          tooltip: showTooltip ? 'ì¬ì—°ê²° ì¤‘... (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.rotate,
          size: size,
        );
        
      case WsStatus.disconnected:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.grey,
          tooltip: showTooltip ? 'ì—°ê²° ëŠê¹€ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.none,
          size: size,
        );
        
      case WsStatus.pongTimeout:
        return _AnimatedStatusIcon(
          icon: Icons.circle,
          color: Colors.red,
          tooltip: showTooltip ? 'ping íƒ€ì„ì•„ì›ƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.blink,
          size: size,
        );
        
      case WsStatus.failed:
      case WsStatus.error:
        return _AnimatedStatusIcon(
          icon: Icons.error_outline,
          color: Colors.red,
          tooltip: showTooltip ? (status == WsStatus.failed ? 'ì—°ê²° ì‹¤íŒ¨ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : 'ì—ëŸ¬ ë°œìƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)') : null,
          animationType: AnimationType.blink,
          size: size,
        );
        
      case WsStatus.maxRetryExceeded:
        return _AnimatedStatusIcon(
          icon: Icons.warning,
          color: Colors.deepOrange,
          tooltip: showTooltip ? 'ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: AnimationType.blink,
          size: size,
        );
    }
  }
}

enum AnimationType { none, pulse, rotate, blink }

class _AnimatedStatusIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final AnimationType animationType;
  final double size;

  const _AnimatedStatusIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedStatusIcon> createState() => _AnimatedStatusIconState();
}

class _AnimatedStatusIconState extends State<_AnimatedStatusIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case AnimationType.pulse:
        _controller = AnimationController(
          duration: const Duration(seconds: 2),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case AnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case AnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case AnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedStatusIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case AnimationType.pulse:
          case AnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value,
                child: icon,
              ),
            );
            
          case AnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case AnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/shared/widgets/notification_service.dart ======\n
// lib/shared/widgets/notification_service.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../../core/utils/logger.dart';
import '../../core/di/app_providers.dart';
import '../../core/di/notification_provider.dart'; // ğŸ†• Provider ë¶„ë¦¬

/// ğŸ”” Firebase + ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ì•Œë¦¼ ì„œë¹„ìŠ¤
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// Firebase ë¦¬ìŠ¤ë„ˆ ì„¤ì •
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // ì•±ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œ ì•Œë¦¼ ìˆ˜ì‹ 
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // ğŸ¯ Providerë¥¼ í†µí•´ ì•Œë¦¼ ì¶”ê°€
        _addNotificationToProvider(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBarë¡œë„ í‘œì‹œ
        _showNotificationSnackBar(messenger, n, msg.data);
      }
    });
    
    // ì•±ì´ ì¢…ë£Œëœ ìƒíƒœì—ì„œ ì•Œë¦¼ í´ë¦­í•´ì„œ ì•± ì‹œì‘
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          _addNotificationToProvider(
            title: n.title ?? 'ì•Œë¦¼',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
      }
    });
    
    // ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆì„ ë•Œ ì•Œë¦¼ í´ë¦­
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        _addNotificationToProvider(
          title: n.title ?? 'ì•Œë¦¼',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
      }
    });
    
    log.i('ğŸ”” Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ');
  }

  /// Providerë¥¼ í†µí•œ ì•Œë¦¼ ì¶”ê°€ (ë‚´ë¶€ ë©”ì„œë“œ)
  void _addNotificationToProvider({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('ğŸ”” ì•Œë¦¼ ì¶”ê°€: $title (${type.name})');
  }

  /// SnackBar í‘œì‹œ
  void _showNotificationSnackBar(
    ScaffoldMessengerState? messenger,
    RemoteNotification notification,
    Map<String, dynamic>? data,
  ) {
    if (messenger == null) return;
    
    final type = _getNotificationType(data);
    messenger
      ..hideCurrentSnackBar()
      ..showSnackBar(SnackBar(
        content: Row(
          children: [
            Icon(_getIconForType(type), color: Colors.white, size: 20),
            const SizedBox(width: 8),
            Expanded(child: Text('${notification.title}: ${notification.body}')),
          ],
        ),
        backgroundColor: _getColorForType(type),
        duration: const Duration(seconds: 3),
        action: SnackBarAction(
          label: 'ë³´ê¸°',
          textColor: Colors.white,
          onPressed: () {
            // TODO: ì•Œë¦¼ ëª¨ë‹¬ ì—´ê¸°
            log.i('ğŸ“± ì•Œë¦¼ ìƒì„¸ë³´ê¸° ìš”ì²­');
          },
        ),
      ));
  }

  /// Firebase ë©”ì‹œì§€ ë°ì´í„°ë¡œë¶€í„° ì•Œë¦¼ íƒ€ì… ì¶”ë¡ 
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }

  /// ğŸ†• íƒ€ì…ë³„ ì•„ì´ì½˜ ë°˜í™˜ (NotificationService ë‚´ë¶€ ë©”ì„œë“œ)
  IconData _getIconForType(NotificationType type) {
    switch (type) {
      case NotificationType.trade:
        return Icons.show_chart;
      case NotificationType.priceAlert:
        return Icons.attach_money;
      case NotificationType.volume:
        return Icons.bar_chart;
      case NotificationType.surge:
        return Icons.trending_up;
      case NotificationType.system:
        return Icons.settings;
    }
  }

  /// ğŸ†• íƒ€ì…ë³„ ìƒ‰ìƒ ë°˜í™˜ (NotificationService ë‚´ë¶€ ë©”ì„œë“œ)  
  Color _getColorForType(NotificationType type) {
    switch (type) {
      case NotificationType.trade:
        return Colors.blue;
      case NotificationType.priceAlert:
        return Colors.green;
      case NotificationType.volume:
        return Colors.purple;
      case NotificationType.surge:
        return Colors.red;
      case NotificationType.system:
        return Colors.grey;
    }
  }

  /// ğŸ¯ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ ì•Œë¦¼ ì¶”ê°€ (ê³µê°œ ë©”ì„œë“œ)
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    _addNotificationToProvider(
      title: title,
      message: message,
      type: type,
      extra: extra,
    );
  }
  
  /// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ì•Œë¦¼ ì½ìŒ: $notificationId');
  }
  
  /// ì•Œë¦¼ ì œê±°
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ—‘ï¸ ì•Œë¦¼ ì œê±°: $notificationId');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('ğŸ‘ï¸ ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');
  }
  
  /// ëª¨ë“  ì•Œë¦¼ ì œê±°
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('ğŸ§¹ ëª¨ë“  ì•Œë¦¼ ì œê±°');
  }
  
  /// í•„í„° ì„¤ì •
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('ğŸ” ì•Œë¦¼ í•„í„°: ${type?.name ?? "ì „ì²´"}');
  }
  
  /// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }

  /// Firebase ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('ğŸ§¹ Firebase ì•Œë¦¼ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¨');
  }
}

/// ğŸ”” ì•Œë¦¼ ì„œë¹„ìŠ¤ Provider
final notificationServiceProvider = Provider((ref) => NotificationService(ref));\n\n// ====== lib/shared/widgets/common_app_bar.dart ======\n
// lib/shared/widgets/common_app_bar.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedbackìš©
import 'package:flutter_riverpod/flutter_riverpod.dart'; // âœ… ì¶”ê°€
import 'ws_status_indicator.dart';
import 'notification_modal.dart';
import 'settings_modal.dart';
import 'slide_indicator.dart'; // âœ… íŒŒì¼ëª… ì •í™•íˆ í™•ì¸
import '../../presentation/pages/main_page.dart';

/// ê³µí†µ ìƒë‹¨ë°” + ì•Œë¦¼/ì„¤ì • ì•„ì´ì½˜ + ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°
class CommonAppBar extends ConsumerWidget implements PreferredSizeWidget { // âœ… ConsumerWidgetìœ¼ë¡œ ë³€ê²½
  const CommonAppBar({
    super.key,
    required this.title,
    this.leading,
    this.actions,
    this.centerTitle = true,
    this.elevation = 0,
    // ğŸ†• ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°ìš© íŒŒë¼ë¯¸í„°ë“¤
    this.pages,
    this.pageController,
    this.animationController,
  });

  final String title;
  final Widget? leading;
  final List<Widget>? actions;
  final bool centerTitle;
  final double elevation;
  
  // ğŸ†• ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° ê´€ë ¨
  final List<PageInfo>? pages;
  final PageController? pageController;
  final AnimationController? animationController;

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context, WidgetRef ref) { // âœ… WidgetRef íŒŒë¼ë¯¸í„° ì¶”ê°€
    return AppBar(
      title: _buildTitle(),
      centerTitle: centerTitle,
      elevation: elevation,
      leading: leading ?? IconButton(
        icon: const Icon(Icons.notifications),
        onPressed: () {
          HapticFeedback.lightImpact(); // ğŸ¯ ì•Œë¦¼ ë²„íŠ¼ í–…í‹±
          NotificationModal.show(context);
        },
        tooltip: 'ì•Œë¦¼',
      ),
      actions: actions ?? [
        // WebSocket ìƒíƒœ ì•„ì´ì½˜
        const WsStatusIndicator(
          size: 16,
          padding: EdgeInsets.only(right: 8),
        ),
        // ì„¤ì • ë²„íŠ¼
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: () {
            HapticFeedback.lightImpact(); // ğŸ¯ ì„¤ì • ë²„íŠ¼ í–…í‹±
            SettingsModal.show(context);
          },
          tooltip: 'ì„¤ì •',
        ),
      ],
    );
  }

  /// ğŸ¨ íƒ€ì´í‹€ ë¶€ë¶„ êµ¬ì„± (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° ë˜ëŠ” í…ìŠ¤íŠ¸)
  Widget _buildTitle() {
    // ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° íŒŒë¼ë¯¸í„°ë“¤ì´ ëª¨ë‘ ìˆìœ¼ë©´ ì¸ë””ì¼€ì´í„° í‘œì‹œ
    if (pages != null && pageController != null && animationController != null) {
      return SlideIndicator(
        pages: pages!,
        pageController: pageController!,
        animationController: animationController!,
      );
    }
    // íŒŒë¼ë¯¸í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ í…ìŠ¤íŠ¸ í‘œì‹œ
    return Text(title);
  }
}\n\n// ====== lib/shared/widgets/notification_modal.dart ======\n
// lib/shared/widgets/notification_modal.dart
import 'package:flutter/material.dart';

class NotificationModal {
  /// ì•Œë¦¼ ëª¨ë‹¬ í‘œì‹œ
  static void show(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black54,
      builder: (context) => _NotificationModalContent(),
    );
  }
}

class _NotificationModalContent extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.1),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // ğŸ¨ ì•Œë¦¼ ëª¨ë‹¬ í—¤ë”
          _buildHeader(context),
          
          // êµ¬ë¶„ì„ 
          Divider(color: Colors.grey.shade300, height: 1),
          
          // ğŸ¯ ì•Œë¦¼ placeholder ë‚´ìš©
          _buildContent(context),
          
          // í•˜ë‹¨ ì—¬ë°±
          SizedBox(height: MediaQuery.of(context).padding.bottom + 20),
        ],
      ),
    );
  }

  /// í—¤ë” (ì œëª© + ë‹«ê¸° ë²„íŠ¼)
  Widget _buildHeader(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Column(
        children: [
          // ë‹¹ê¹€ í•¸ë“¤
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey.shade400,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(height: 12),
          // ì œëª©ê³¼ ë‹«ê¸° ë²„íŠ¼
          Row(
            children: [
              const SizedBox(width: 16),
              const Icon(Icons.notifications, color: Colors.orange),
              const SizedBox(width: 8),
              const Text(
                'ì•Œë¦¼',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ì•Œë¦¼ ì»¨í…ì¸  (placeholder)
  Widget _buildContent(BuildContext context) {
    return Container(
      constraints: const BoxConstraints(maxHeight: 400),
      padding: const EdgeInsets.all(24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // ì•Œë¦¼ ì•„ì´ì½˜
          Icon(
            Icons.notifications_outlined,
            size: 80,
            color: Colors.orange.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 24),
          
          // ì œëª©
          const Text(
            'ì•Œë¦¼ ê¸°ëŠ¥',
            style: TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Colors.orange,
            ),
          ),
          const SizedBox(height: 12),
          
          // ì„¤ëª…
          Text(
            'ì‹¤ì‹œê°„ ì²´ê²° ì•Œë¦¼ê³¼\nê°€ê²© ë³€ë™ ì•Œë¦¼ì„ ë°›ì•„ë³´ì„¸ìš”',
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey.shade600,
              height: 1.4,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),
          
          // ì¤€ë¹„ ì¤‘ ë°°ì§€
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            decoration: BoxDecoration(
              color: Colors.orange.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.orange.withValues(alpha: 0.3)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.construction,
                  size: 16,
                  color: Colors.orange.shade700,
                ),
                const SizedBox(width: 6),
                Text(
                  'ê³§ ì¶œì‹œ ì˜ˆì •!',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w600,
                    color: Colors.orange.shade700,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          
          // ê¸°ëŠ¥ ë¯¸ë¦¬ë³´ê¸°
          Text(
            'â€¢ ì‹¤ì‹œê°„ ì²´ê²° ì•Œë¦¼\nâ€¢ ê¸‰ë“±ë½ ì•Œë¦¼\nâ€¢ ê±°ë˜ëŸ‰ ê¸‰ì¦ ì•Œë¦¼\nâ€¢ ë§ì¶¤ ê°€ê²© ì•Œë¦¼',
            style: TextStyle(
              fontSize: 13,
              color: Colors.grey.shade500,
              height: 1.6,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}\n\n// ====== lib/shared/widgets/settings_modal.dart ======\n
// lib/shared/widgets/settings_modal.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedback ì¶”ê°€
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import 'theme_mode_segment.dart';
import 'slider_position_segment.dart';

class SettingsModal {
  /// ì„¤ì • ëª¨ë‹¬ í‘œì‹œ
  static void show(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      barrierColor: Colors.black54,
      builder: (context) => const _SettingsModalContent(),
    );
  }
}

class _SettingsModalContent extends ConsumerWidget {
  const _SettingsModalContent();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(appSettingsProvider);
    final controller = ref.read(appSettingsProvider.notifier);

    return Container(
      margin: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).scaffoldBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(20),
          topRight: Radius.circular(20),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.1),
            blurRadius: 10,
            spreadRadius: 2,
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // ğŸ¨ ì„¤ì • ëª¨ë‹¬ í—¤ë”
          _buildHeader(context),
          
          // êµ¬ë¶„ì„ 
          Divider(color: Colors.grey.shade300, height: 1),
          
          // ğŸ¯ ì„¤ì • ë‚´ìš©
          _buildContent(context, settings, controller),
          
          // í•˜ë‹¨ ì—¬ë°±
          SizedBox(height: MediaQuery.of(context).padding.bottom + 20),
        ],
      ),
    );
  }

  /// í—¤ë” (ì œëª© + ë‹«ê¸° ë²„íŠ¼)
  Widget _buildHeader(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Column(
        children: [
          // ë‹¹ê¹€ í•¸ë“¤
          Container(
            width: 40,
            height: 4,
            decoration: BoxDecoration(
              color: Colors.grey.shade400,
              borderRadius: BorderRadius.circular(2),
            ),
          ),
          const SizedBox(height: 12),
          // ì œëª©ê³¼ ë‹«ê¸° ë²„íŠ¼
          Row(
            children: [
              const SizedBox(width: 16),
              const Icon(Icons.settings, color: Colors.orange),
              const SizedBox(width: 8),
              const Text(
                'ì„¤ì •',
                style: TextStyle(
                  fontSize: 19,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
        ],
      ),
    );
  }

  /// ì„¤ì • ì»¨í…ì¸ 
  Widget _buildContent(BuildContext context, AppSettings settings, dynamic controller) {
    return Container(
      constraints: const BoxConstraints(maxHeight: 550),
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // ğŸ¨ í…Œë§ˆ ì„¤ì •
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.palette, color: Colors.orange),
                title: const Text(
                  'í…Œë§ˆ',
                  style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
                ),
                trailing: ThemeModeSegment(
                  value: settings.themeMode,
                  onChanged: (ThemeMode mode) {
                    HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± ì¶”ê°€
                    controller.setThemeMode(mode);
                  },
                ),
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸ’° ì½”ì¸ëª… í‘œì‹œ ë°©ì‹
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.monetization_on, color: Colors.orange),
                title: const Text(
                  'ì½”ì¸ëª… í‘œì‹œ',
                  style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  _getDisplayModeDescription(settings.displayMode),
                  style: const TextStyle(fontSize: 11),
                ),
                trailing: _DisplayModeSegment(
                  value: settings.displayMode,
                  onChanged: (DisplayMode mode) {
                    HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± ì¶”ê°€
                    controller.setDisplayMode(mode);
                  },
                ),
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸ’µ ê¸ˆì•¡ í‘œì‹œ ë°©ì‹
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.account_balance_wallet, color: Colors.orange),
                title: const Text(
                  'ê¸ˆì•¡ í‘œì‹œ',
                  style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  _getAmountDisplayModeDescription(settings.amountDisplayMode),
                  style: const TextStyle(fontSize: 11),
                ),
                trailing: _AmountDisplayModeSegment(
                  value: settings.amountDisplayMode,
                  onChanged: (AmountDisplayMode mode) {
                    HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± ì¶”ê°€
                    controller.setAmountDisplayMode(mode);
                  },
                ),
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°
            Card(
              elevation: 2,
              child: SwitchListTile(
                secondary: const Icon(Icons.screen_lock_rotation, color: Colors.orange),
                title: const Text(
                  'í™”ë©´ í•­ìƒ ì¼œê¸°',
                  style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  settings.keepScreenOn
                    ? 'í™”ë©´ì´ ìë™ìœ¼ë¡œ êº¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤'
                    : 'ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ í™”ë©´ì´ êº¼ì§‘ë‹ˆë‹¤',
                  style: const TextStyle(fontSize: 11),
                ),
                value: settings.keepScreenOn,
                onChanged: (bool value) {
                  HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± ì¶”ê°€
                  controller.setKeepScreenOn(value);
                },
                activeColor: Colors.orange,
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.tune, color: Colors.orange),
                title: const Text(
                  'ìŠ¬ë¼ì´ë” ìœ„ì¹˜',
                  style: TextStyle(fontSize: 15, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  'ìŠ¬ë¼ì´ë”ë¥¼ ${_getSliderPositionText(settings.sliderPosition)}ì— í‘œì‹œ',
                  style: const TextStyle(fontSize: 11),
                ),
                trailing: SliderPositionSegment(
                  value: settings.sliderPosition,
                  onChanged: (SliderPosition position) {
                    HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± ì¶”ê°€
                    controller.setSliderPosition(position);
                  },
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ğŸ†• í‘œì‹œ ëª¨ë“œ ì„¤ëª… í…ìŠ¤íŠ¸
  String _getDisplayModeDescription(DisplayMode mode) {
    switch (mode) {
      case DisplayMode.ticker:
        return 'BTC, ETH, XRP\ní˜•íƒœë¡œ í‘œì‹œ';
      case DisplayMode.korean:
        return 'ë¹„íŠ¸ì½”ì¸, ì´ë”ë¦¬ì›€, ë¦¬í”Œ\ní˜•íƒœë¡œ í‘œì‹œ';
      case DisplayMode.english:
        return 'Bitcoin, Ethereum, Ripple\ní˜•íƒœë¡œ í‘œì‹œ';
    }
  }

  /// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì„¤ëª… í…ìŠ¤íŠ¸
  String _getAmountDisplayModeDescription(AmountDisplayMode mode) {
    switch (mode) {
      case AmountDisplayMode.number:
        return '1,234ë§Œ\nìˆ«ìë¡œ í‘œì‹œ';
      case AmountDisplayMode.icon:
        return 'ğŸ’µ ì§€í ì•„ì´ì½˜\nìœ¼ë¡œ í‘œì‹œ';
    }
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ í…ìŠ¤íŠ¸
  String _getSliderPositionText(SliderPosition position) {
    return position.name == 'top' ? 'ìƒë‹¨' : 'í•˜ë‹¨';
  }
}

/// ğŸ†• í‘œì‹œ ëª¨ë“œ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _DisplayModeSegment extends StatelessWidget {
  final DisplayMode value;
  final ValueChanged<DisplayMode> onChanged;

  const _DisplayModeSegment({
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentButton(
            context: context,
            mode: DisplayMode.ticker,
            label: 'í‹°ì»¤',
            icon: Icons.code,
          ),
          _buildDivider(),
          _buildSegmentButton(
            context: context,
            mode: DisplayMode.korean,
            label: 'í•œê¸€',
            icon: Icons.language,
          ),
          _buildDivider(),
          _buildSegmentButton(
            context: context,
            mode: DisplayMode.english,
            label: 'ì˜ë¬¸',
            icon: Icons.translate,
          ),
        ],
      ),
    );
  }

  Widget _buildSegmentButton({
    required BuildContext context,
    required DisplayMode mode,
    required String label,
    required IconData icon,
  }) {
    final isSelected = value == mode;
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    final backgroundColor = isSelected ? Colors.orange.withValues(alpha: 0.1) : Colors.transparent;

    return GestureDetector(
      onTap: () => onChanged(mode),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 16, color: color),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                fontSize: 10,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDivider() {
    return Container(
      width: 1,
      height: 30,
      color: Colors.grey.shade300,
    );
  }
}

/// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì„¸ê·¸ë¨¼íŠ¸ ìœ„ì ¯
class _AmountDisplayModeSegment extends StatelessWidget {
  final AmountDisplayMode value;
  final ValueChanged<AmountDisplayMode> onChanged;

  const _AmountDisplayModeSegment({
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey.shade300),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentButton(
            context: context,
            mode: AmountDisplayMode.number,
            label: 'ìˆ«ì',
            icon: Icons.format_list_numbered,
          ),
          _buildDivider(),
          _buildSegmentButton(
            context: context,
            mode: AmountDisplayMode.icon,
            label: 'ì•„ì´ì½˜',
            icon: Icons.account_balance_wallet,
          ),
        ],
      ),
    );
  }

  Widget _buildSegmentButton({
    required BuildContext context,
    required AmountDisplayMode mode,
    required String label,
    required IconData icon,
  }) {
    final isSelected = value == mode;
    final color = isSelected ? Colors.orange : Colors.grey.shade600;
    final backgroundColor = isSelected ? Colors.orange.withValues(alpha: 0.1) : Colors.transparent;

    return GestureDetector(
      onTap: () => onChanged(mode),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(6),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 18, color: color),
            const SizedBox(height: 2),
            Text(
              label,
              style: TextStyle(
                fontSize: 11,
                color: color,
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDivider() {
    return Container(
      width: 1,
      height: 36,
      color: Colors.grey.shade300,
    );
  }
}\n\n// ====== lib/shared/widgets/slide_indicator.dart ======\n
// lib/shared/widgets/slide_indicator.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedbackìš© ì¶”ê°€
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/pages/main_page.dart';

/// ğŸ¨ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° - iOS ìŠ¤íƒ€ì¼ì˜ í˜ì´ì§€ ì¸ë””ì¼€ì´í„°
class SlideIndicator extends ConsumerStatefulWidget {
  final List<PageInfo> pages;
  final PageController pageController;
  final AnimationController animationController;

  const SlideIndicator({
    Key? key,
    required this.pages,
    required this.pageController,
    required this.animationController,
  }) : super(key: key);

  @override
  ConsumerState<SlideIndicator> createState() => _SlideIndicatorState();
}

class _SlideIndicatorState extends ConsumerState<SlideIndicator>
    with TickerProviderStateMixin {
  
  late List<AnimationController> _iconControllers;
  late List<Animation<double>> _scaleAnimations;
  late List<Animation<Color?>> _colorAnimations;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
  }

  /// ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
  void _setupAnimations() {
    _iconControllers = List.generate(
      widget.pages.length,
      (index) => AnimationController(
        duration: const Duration(milliseconds: 250),
        vsync: this,
      ),
    );

    _scaleAnimations = _iconControllers.map((controller) {
      return Tween<double>(
        begin: 0.8, // ì‘ì€ í¬ê¸°
        end: 1.2,   // í° í¬ê¸°
      ).animate(CurvedAnimation(
        parent: controller,
        curve: Curves.easeOutBack, // í†µí†µ íŠ€ëŠ” ì• ë‹ˆë©”ì´ì…˜
      ));
    }).toList();

    _colorAnimations = _iconControllers.map((controller) {
      return ColorTween(
        begin: Colors.grey.shade400,     // ë¹„í™œì„± ìƒ‰ìƒ
        end: Colors.orange,              // í™œì„± ìƒ‰ìƒ
      ).animate(CurvedAnimation(
        parent: controller,
        curve: Curves.easeInOut,
      ));
    }).toList();

    // ì´ˆê¸° ì„ íƒëœ í˜ì´ì§€ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ì²´ê²° í˜ì´ì§€ = index 1)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _iconControllers[1].forward();
    });
  }

  @override
  void dispose() {
    for (final controller in _iconControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final currentIndex = ref.watch(selectedTabProvider);
    
    // í˜ì´ì§€ ë³€ê²½ ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
    _updateAnimations(currentIndex);

    return SizedBox( // âœ… Container â†’ SizedBox ë³€ê²½
      height: 40,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: widget.pages.asMap().entries.map((entry) {
          final index = entry.key;
          final page = entry.value;
          
          return _buildAnimatedIcon(index, page, currentIndex);
        }).toList(),
      ),
    );
  }

  /// ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
  void _updateAnimations(int currentIndex) {
    for (int i = 0; i < _iconControllers.length; i++) {
      if (i == currentIndex) {
        _iconControllers[i].forward();
      } else {
        _iconControllers[i].reverse();
      }
    }
  }

  /// ì• ë‹ˆë©”ì´ì…˜ ì•„ì´ì½˜ ìƒì„±
  Widget _buildAnimatedIcon(int index, PageInfo page, int currentIndex) {
    final isSelected = index == currentIndex;
    
    return AnimatedBuilder(
      animation: Listenable.merge([
        _scaleAnimations[index],
        _colorAnimations[index],
      ]),
      builder: (context, child) {
        return GestureDetector(
          onTap: () => _onIconTap(index),
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 4),
            padding: const EdgeInsets.all(8),
            child: Transform.scale(
              scale: _scaleAnimations[index].value,
              child: Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected 
                    ? Colors.orange.withValues(alpha: 0.1)
                    : Colors.transparent,
                  border: isSelected 
                    ? Border.all(color: Colors.orange.withValues(alpha: 0.3), width: 1)
                    : null,
                ),
                child: Icon(
                  page.icon,
                  size: isSelected ? 20 : 16,
                  color: _colorAnimations[index].value,
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  /// ì•„ì´ì½˜ í´ë¦­ ì²˜ë¦¬
  void _onIconTap(int index) {
    // í–…í‹± í”¼ë“œë°± ë¨¼ì € ì‹¤í–‰
    HapticFeedback.lightImpact(); // ğŸ¯ í–…í‹± í™œì„±í™”!
    
    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(selectedTabProvider.notifier).state = index;
    
    // í˜ì´ì§€ ì´ë™
    widget.pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
    
    debugPrint('ğŸ¯ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° í´ë¦­: ${widget.pages[index].title}');
  }
}

/// ğŸ¨ ê°„ë‹¨ ë²„ì „ ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° (ì• ë‹ˆë©”ì´ì…˜ ì—†ìŒ)
class SimpleSlideIndicator extends ConsumerWidget {
  final List<PageInfo> pages;
  final PageController pageController;

  const SimpleSlideIndicator({
    Key? key,
    required this.pages,
    required this.pageController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final currentIndex = ref.watch(selectedTabProvider);

    return SizedBox( // âœ… Container â†’ SizedBox ë³€ê²½
      height: 40,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: pages.asMap().entries.map((entry) {
          final index = entry.key;
          final page = entry.value;
          final isSelected = index == currentIndex;
          
          return GestureDetector(
            onTap: () {
              HapticFeedback.lightImpact(); // ğŸ¯ ê°„ë‹¨ ë²„ì „ì—ë„ í–…í‹± ì¶”ê°€!
              
              ref.read(selectedTabProvider.notifier).state = index;
              pageController.animateToPage(
                index,
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeInOut,
              );
            },
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 4),
              padding: const EdgeInsets.all(8),
              child: Container(
                width: 32,
                height: 32,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected 
                    ? Colors.orange.withValues(alpha: 0.1)
                    : Colors.transparent,
                  border: isSelected 
                    ? Border.all(color: Colors.orange.withValues(alpha: 0.3), width: 1)
                    : null,
                ),
                child: Icon(
                  page.icon,
                  size: isSelected ? 20 : 16,
                  color: isSelected ? Colors.orange : Colors.grey.shade400,
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}\n\n// ====== lib/shared/widgets/websocket_modal.dart ======\n
// lib/shared/widgets/websocket_modal.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';

/// WebSocket ìƒì„¸ ì •ë³´ íŒì—… ì˜¤ë²„ë ˆì´
class WebSocketStatsOverlay {
  static OverlayEntry? _overlayEntry;

  /// ë¡±í”„ë ˆìŠ¤ ì‹œ íŒì—… í‘œì‹œ
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
  }) {
    hide(); // ê¸°ì¡´ íŒì—… ì œê±°

    _overlayEntry = OverlayEntry(
      builder: (context) => _WebSocketStatsPopup(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// íŒì—… ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

class _WebSocketStatsPopup extends StatefulWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;

  const _WebSocketStatsPopup({
    required this.position,
    required this.statusIconSize,
    required this.ref,
  });

  @override
  State<_WebSocketStatsPopup> createState() => _WebSocketStatsPopupState();
}

class _WebSocketStatsPopupState extends State<_WebSocketStatsPopup>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: const Interval(0.0, 0.5),
    ));

    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => WebSocketStatsOverlay.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½ (íƒ­í•˜ë©´ ë‹«í˜)
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ íŒì—…
            AnimatedBuilder(
              animation: _controller,
              builder: (context, child) {
                return Positioned(
                  left: widget.position.dx,
                  top: widget.position.dy,
                  child: Transform.scale(
                    scale: _scaleAnimation.value,
                    alignment: Alignment.center,
                    child: Opacity(
                      opacity: _opacityAnimation.value,
                      child: _buildPopupContent(),
                    ),
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPopupContent() {
    // ê¸°ë³¸ í¬ê¸° ê³„ì‚° (ìƒíƒœ ì•„ì´ì½˜ì˜ 4ë°° ì •ë„)
    final baseSize = widget.statusIconSize * 4.2;
    
    return Container(
      constraints: BoxConstraints(
        minWidth: baseSize,
        maxWidth: baseSize * 1.8,
        minHeight: baseSize,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.08),
            blurRadius: 16,
            offset: const Offset(0, 6),
            spreadRadius: 2,
          ),
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.04),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
        border: Border.all(
          color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
          width: 0.8,
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // í†µê³„ ë‚´ìš© (í—¤ë” ì œê±°)
            _buildStatsContent(),
          ],
        ),
      ),
    );
  }

  Widget _buildStatsContent() {
    final stats = widget.ref.read(wsStatsProvider);
    
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // â° ì‹œê°„ ì •ë³´
        _buildSectionTitle('ì‹œê°„ ì •ë³´', Icons.access_time),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.link,
          label: 'í˜„ì¬ ì—°ê²°',
          value: stats.connectTime != null && stats.uptime != null
              ? _formatDuration(stats.uptime!)
              : 'ë¯¸ì—°ê²°',
          isHighlight: stats.connectTime != null,
        ),
        
        if (stats.lastStateChangeTime != null)
          _buildStatRow(
            icon: Icons.schedule,
            label: 'ë§ˆì§€ë§‰ ë³€ê²½',
            value: _formatTimeAgo(stats.lastStateChangeTime!),
          ),
        
        const SizedBox(height: 8),
        
        // ğŸ”„ ì—°ê²° í†µê³„
        _buildSectionTitle('ì—°ê²° í†µê³„', Icons.analytics),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.refresh,
          label: 'ì¬ì—°ê²°',
          value: '${stats.reconnectCount}íšŒ',
          isWarning: stats.reconnectCount > 5,
        ),
        
        _buildStatRow(
          icon: Icons.play_arrow,
          label: 'ì´ ì„¸ì…˜',
          value: '${stats.totalSessions}íšŒ',
        ),
        
        if (stats.connectionAttempts > 0)
          _buildStatRow(
            icon: Icons.trending_up,
            label: 'ì„±ê³µë¥ ',
            value: '${stats.connectionSuccessRate.toStringAsFixed(1)}%',
            isHighlight: stats.connectionSuccessRate > 90,
            isWarning: stats.connectionSuccessRate < 70,
          ),
        
        const SizedBox(height: 8),
        
        // ğŸ“± ì•± ìƒëª…ì£¼ê¸°
        _buildSectionTitle('ì•± ìƒëª…ì£¼ê¸°', Icons.timeline),
        const SizedBox(height: 4),
        
        _buildStatRow(
          icon: Icons.hourglass_full,
          label: 'ëˆ„ì  ì‹œê°„',
          value: _formatDuration(stats.cumulativeConnectTime),
        ),
        
        if (stats.totalSessions > 0)
          _buildStatRow(
            icon: Icons.timer_outlined,
            label: 'í‰ê·  ì„¸ì…˜',
            value: _formatDuration(stats.averageSessionDuration),
          ),
      ],
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Theme.of(context).colorScheme.primary;
      if (isWarning) return Theme.of(context).colorScheme.tertiary;
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight 
            ? Theme.of(context).colorScheme.primary.withValues(alpha: 0.08)
            : isWarning
            ? Theme.of(context).colorScheme.tertiary.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }

  String _formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);
    
    if (difference.inSeconds < 60) {
      return 'ë°©ê¸ˆ ì „';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}ë¶„ ì „';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}ì‹œê°„ ì „';
    } else {
      return '${difference.inDays}ì¼ ì „';
    }
  }

  String _formatDuration(Duration duration) {
    if (duration == Duration.zero) return 'ì—†ìŒ';
    
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    
    if (duration.inHours > 0) {
      final hours = twoDigits(duration.inHours);
      final minutes = twoDigits(duration.inMinutes.remainder(60));
      final seconds = twoDigits(duration.inSeconds.remainder(60));
      return '$hours:$minutes:$seconds';
    } else if (duration.inMinutes > 0) {
      final minutes = duration.inMinutes;
      final seconds = twoDigits(duration.inSeconds.remainder(60));
      return '$minutesë¶„ $secondsì´ˆ';
    } else {
      return '${duration.inSeconds}ì´ˆ';
    }
  }
}\n\n// ====== lib/shared/widgets/theme_mode_segment.dart ======\n
import 'package:flutter/material.dart';

class ThemeModeSegment extends StatelessWidget {
  final ThemeMode value;
  final ValueChanged<ThemeMode> onChanged;

  const ThemeModeSegment({
    super.key,
    required this.value,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return SegmentedButton<ThemeMode>(
      // âœ… ìŠ¤íƒ€ì¼ë¡œ í¬ê¸° ì¡°ì •
      style: SegmentedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6), // âœ… íŒ¨ë”© ì¤„ì´ê¸°
        minimumSize: const Size(50, 32), // âœ… ìµœì†Œ í¬ê¸° ì¤„ì´ê¸°
        textStyle: const TextStyle(fontSize: 11), // âœ… 9 â†’ 10
        iconSize: 14, // âœ… ì•„ì´ì½˜ í¬ê¸° ì¤„ì´ê¸°
      ),
      segments: const [
        ButtonSegment(
          value: ThemeMode.light,
          icon: Icon(Icons.wb_sunny),
          label: Text('ë¼ì´íŠ¸'),
        ),
        ButtonSegment(
          value: ThemeMode.system,
          icon: Icon(Icons.phone_iphone),
          label: Text('ì‹œìŠ¤í…œ'),
        ),
        ButtonSegment(
          value: ThemeMode.dark,
          icon: Icon(Icons.nightlight_round),
          label: Text('ë‹¤í¬'),
        ),
      ],
      selected: <ThemeMode>{value},
      onSelectionChanged: (newSelection) {
        onChanged(newSelection.first);
      },
    );
  }
}\n\n// ====== lib/main.dart ======\n
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'core/config/app_config.dart';
import 'core/services/hive_service.dart';
import 'core/bridge/signal_bus.dart';
import 'core/di/app_providers.dart';
import 'app.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 1) í™˜ê²½ ì„¤ì • (Hive ì œì™¸)
  await AppConfig.init(envPath: '.env');
  await Firebase.initializeApp();

  // 2) Hive ë‹¨ì¼ ì´ˆê¸°í™” ğŸ¯
  final hive = HiveService();
  await hive.init();

  // 3) SharedPreferences, SignalBus ì¤€ë¹„
  final prefs = await SharedPreferences.getInstance();
  final signalBus = SignalBus();

  // 4) ProviderContainer ìƒì„± ë° ì˜¤ë²„ë¼ì´ë“œ
  final container = ProviderContainer(
    observers: [AppProviderObserver()],
    overrides: [
      hiveServiceProvider.overrideWithValue(hive),           // ğŸ¯ NEW
      sharedPreferencesProvider.overrideWithValue(prefs),
      signalBusProvider.overrideWithValue(signalBus),
    ],
  );

  // 5) ì•± ì‹¤í–‰
  runApp(
    UncontrolledProviderScope(
      container: container,
      child: ProviderInitializer(
        child: MyApp(navigatorKey: GlobalKey<NavigatorState>()),
      ),
    ),
  );
}\n\n// ====== lib/data/datasources/trade_cache_ds.dart ======\n
// lib/data/datasources/trade_cache_ds.dart

import 'package:hive/hive.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Hive ê¸°ë°˜ ê°„ë‹¨ ê±°ë˜ ìºì‹œ ë°ì´í„°ì†ŒìŠ¤
/// - HiveServiceì—ì„œ ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ì•„ ì‚¬ìš©
/// - Box ìƒëª…ì£¼ê¸° ê´€ë¦¬ëŠ” HiveServiceê°€ ë‹´ë‹¹
class TradeCacheDataSource {
  static const _maxCacheSize = 1000;

  /// ğŸ¯ ì£¼ì…ë°›ì€ Box (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  final Box<TradeDto> _box;
  
  /// ìƒì„±ì: ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ìŒ
  TradeCacheDataSource(this._box);

  /// Tradeë¥¼ DTOë¡œ ë³€í™˜í•´ ì €ì¥, ì‚¬ì´ì¦ˆ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª© ì œê±°
  Future<void> cacheTrade(Trade trade) async {
    final dto = TradeDto(
      market: trade.market,
      price: trade.price,
      volume: trade.volume,
      side: trade.side,
      changePrice: trade.changePrice,
      changeState: trade.changeState,
      timestampMs: trade.timestampMs,
      sequentialId: trade.sequentialId,
    );
    
    await _box.put(trade.sequentialId, dto);
    
    // ìµœëŒ€ ìºì‹œ ì‚¬ì´ì¦ˆ ê´€ë¦¬
    if (_box.length > _maxCacheSize) {
      final toRemove = _box.keys.take(_box.length - _maxCacheSize);
      await _box.deleteAll(toRemove);
    }
  }

  /// ìºì‹œëœ Trade ì „ë¶€ ë°˜í™˜
  List<Trade> getCachedTrades() =>
      _box.values.map((dto) => dto.toEntity()).toList();

  /// ìºì‹œ í´ë¦¬ì–´
  Future<void> clearCache() => _box.clear();

  // ğŸ—‘ï¸ Box lifecycle ê´€ë¦¬ ë©”ì„œë“œë“¤ ì œê±°:
  // - init() : HiveServiceê°€ ë‹´ë‹¹
  // - dispose() : HiveServiceê°€ ë‹´ë‹¹
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// Fetches a live trade stream; on error falls back to synthetic data.
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  StreamController<Trade>? _controller;
  StreamSubscription<List<Map<String, dynamic>>>? _wsSub;
  bool _disposed = false; // ğŸ¯ dispose ìƒíƒœ ì¶”ê°€

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData;

  /// Starts streaming trades for the given markets.
  Stream<Trade> watch(List<String> markets) {
    if (_useTestData) return _testStream();

    // ğŸ”§ dispose í›„ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ì´ˆê¸°í™”
    if (_disposed) {
      debugPrint('TradeRemoteDataSource: resetting after dispose');
      _disposed = false;
    }

    // clean up any previous stream/subscription
    _controller?.close();
    _wsSub?.cancel();

    _controller = StreamController<Trade>.broadcast(
      onListen: () {
        if (!_disposed) _start(markets);
      },
      onCancel: () {
        _wsSub?.cancel();
        // ğŸš¨ controller.close()ëŠ” dispose()ì—ì„œë§Œ í˜¸ì¶œ
      },
    );

    return _controller!.stream;
  }

  Future<void> _start(List<String> markets) async {
    if (_disposed) return; // ğŸ”§ dispose ì²´í¬ ì¶”ê°€

    try {
      await _ws.connect(markets);
      _wsSub = _ws.stream.listen(
        (rawBatch) {
          // ğŸ¯ í•µì‹¬ ìˆ˜ì •: controllerê°€ ë‹«í˜”ê±°ë‚˜ disposedë©´ ì²˜ë¦¬ ì•ˆí•¨
          if (_disposed || _controller == null || _controller!.isClosed) {
            debugPrint('TradeRemoteDataSource: skipping data - disposed or closed');
            return;
          }

          for (final item in rawBatch) {
            final dto = TradeDto.tryParse(item);
            if (dto == null) continue;
            final entity = dto.toEntity();
            
            // ğŸ”§ ì•ˆì „í•œ add: controller ìƒíƒœ ì¬í™•ì¸
            if (!_disposed && _controller != null && !_controller!.isClosed) {
              _controller!.add(entity);
            }

            // dispatch as AppEvent with metadata
            final event = AppEvent.now(dto.toMap());
            _signalBus.fireTradeEvent(event);
          }
        },
        onError: (error, stackTrace) {
          debugPrint('WebSocket error: $error');
          if (!_disposed && _controller != null && !_controller!.isClosed) {
            _controller!.addStream(_testStream());
          }
        },
        onDone: () {
          debugPrint('WebSocket done');
          if (!_disposed && _controller != null && !_controller!.isClosed) {
            _controller!.addStream(_testStream());
          }
        },
        cancelOnError: false,
      );
    } catch (e) {
      debugPrint('WS connection failed: $e');
      if (!_disposed && _controller != null && !_controller!.isClosed) {
        _controller!.addStream(_testStream());
      }
    }
  }

  /// Synthetic fallback stream for dev/test.
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'KRW-BTC', 'KRW-ETH', 'KRW-XRP',
      'KRW-DOGE', 'KRW-SOL', 'KRW-ADA',
      'KRW-LINK', 'KRW-DOT', 'KRW-AVAX',
      'KRW-MATIC',
    ];

    while (!_disposed) { // ğŸ”§ dispose ì²´í¬ ì¶”ê°€
      await Future.delayed(const Duration(milliseconds: 500));
      if (_disposed) break; // ğŸ”§ loop ì¤‘ì—ë„ ì²´í¬
      
      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final dto = TradeDto(
        market: symbols[rnd.nextInt(symbols.length)],
        price: (rnd.nextDouble() * 1000).roundToDouble(),
        volume: rnd.nextDouble(),
        side: rnd.nextBool() ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: nowMs,
        sequentialId: 'test-$nowMs-${rnd.nextInt(1000)}',
      );
      yield dto.toEntity();
      _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
    }
  }

  /// Clean up resources when no longer needed.
  Future<void> dispose() async {
    if (_disposed) return; // ğŸ”§ ì¤‘ë³µ dispose ë°©ì§€
    
    _disposed = true; // ğŸ¯ disposed í”Œë˜ê·¸ ë¨¼ì € ì„¤ì •
    
    debugPrint('TradeRemoteDataSource: disposing...');
    
    // WebSocket subscription ì •ë¦¬
    await _wsSub?.cancel();
    _wsSub = null;
    
    // StreamController ì •ë¦¬ (ë°ì´í„° ìˆ˜ì‹  ì™„ì „ ì°¨ë‹¨ í›„)
    if (_controller != null && !_controller!.isClosed) {
      await _controller!.close();
    }
    _controller = null;
    
    debugPrint('TradeRemoteDataSource: disposed');
    
    // do not dispose shared ws client here
  }
}\n\n// ====== lib/data/datasources/settings_local_ds.dart ======\n
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../domain/entities/app_settings.dart';

class SettingsLocalDataSource {
  final SharedPreferences prefs;

  SettingsLocalDataSource(this.prefs);

  // í…Œë§ˆ ëª¨ë“œ ê´€ë¦¬
  ThemeMode getThemeMode() {
    final themeName = prefs.getString('themeMode') ?? 'system';
    return switch (themeName) {
      'light' => ThemeMode.light,
      'dark' => ThemeMode.dark,
      _ => ThemeMode.system,
    };
  }

  Future<void> saveThemeMode(ThemeMode mode) async {
    await prefs.setString('themeMode', mode.name);
  }

  // í™”ë©´ í•­ìƒ ì¼œê¸° ê´€ë¦¬
  bool getKeepScreenOn() {
    return prefs.getBool('keepScreenOn') ?? false;
  }

  Future<void> saveKeepScreenOn(bool value) async {
    await prefs.setBool('keepScreenOn', value);
  }

  // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ê´€ë¦¬ (enum)
  SliderPosition getSliderPosition() {
    final raw = prefs.getString('sliderPosition') ?? 'top';
    return raw == 'bottom' ? SliderPosition.bottom : SliderPosition.top;
  }

  Future<void> saveSliderPosition(SliderPosition position) async {
    await prefs.setString('sliderPosition', position.name);
  }

  // ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ê´€ë¦¬
  DisplayMode getDisplayMode() {
    final raw = prefs.getString('displayMode') ?? 'ticker';
    return switch (raw) {
      'korean' => DisplayMode.korean,
      'english' => DisplayMode.english,
      _ => DisplayMode.ticker, // ê¸°ë³¸ê°’: ticker
    };
  }

  Future<void> saveDisplayMode(DisplayMode mode) async {
    await prefs.setString('displayMode', mode.name);
  }

  // ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ê´€ë¦¬
  AmountDisplayMode getAmountDisplayMode() {
    final raw = prefs.getString('amountDisplayMode') ?? 'number';
    return switch (raw) {
      'icon' => AmountDisplayMode.icon,
      _ => AmountDisplayMode.number, // ê¸°ë³¸ê°’: number
    };
  }

  Future<void> saveAmountDisplayMode(AmountDisplayMode mode) async {
    await prefs.setString('amountDisplayMode', mode.name);
  }
}\n\n// ====== lib/data/repositories/settings_repository_impl.dart ======\n
import 'package:flutter/material.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../datasources/settings_local_ds.dart';

class SettingsRepositoryImpl implements SettingsRepository {
  final SettingsLocalDataSource dataSource;

  SettingsRepositoryImpl(this.dataSource);

  @override
  Future<AppSettings> getSettings() async {
    return AppSettings(
      themeMode: dataSource.getThemeMode(),
      keepScreenOn: dataSource.getKeepScreenOn(),
      sliderPosition: dataSource.getSliderPosition(),
      displayMode: dataSource.getDisplayMode(), // ğŸ†• DisplayMode ë¡œë“œ
      amountDisplayMode: dataSource.getAmountDisplayMode(), // ğŸ’° AmountDisplayMode ë¡œë“œ
    );
  }

  @override
  Future<void> updateThemeMode(ThemeMode mode) async {
    await dataSource.saveThemeMode(mode);
  }

  @override
  Future<void> updateKeepScreenOn(bool value) async {
    await dataSource.saveKeepScreenOn(value);
  }

  @override
  Future<void> updateSliderPosition(SliderPosition position) async {
    await dataSource.saveSliderPosition(position);
  }

  @override
  Future<void> updateDisplayMode(DisplayMode mode) async {
    await dataSource.saveDisplayMode(mode); // ğŸ†• DisplayMode ì €ì¥
  }

  @override
  Future<void> updateAmountDisplayMode(AmountDisplayMode mode) async {
    await dataSource.saveAmountDisplayMode(mode); // ğŸ’° AmountDisplayMode ì €ì¥
  }
}\n\n// ====== lib/data/repositories/surge_repository_impl.dart ======\n
\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_cache_ds.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹ì˜ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ì ìš©í•œ Repository
class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remote;
  final TradeCacheDataSource _cache;
  final TradeAggregator _aggregator;

  // ğŸ“Š ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ TradeNotifier ë°©ì‹)
  final Map<double, List<Trade>> _filterLists = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
  final StreamController<List<Trade>> _filteredController = StreamController<List<Trade>>.broadcast();
  final StreamController<Trade> _aggregatedController = StreamController<Trade>.broadcast();
  
  // ğŸ”¥ í•µì‹¬: ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _masterStream;
  StreamSubscription<Trade>? _masterSubscription;
  Timer? _periodicFlushTimer;
  Timer? _batchUpdateTimer;
  
  // ğŸ¯ ë™ì  ì„ê³„ê°’ ê´€ë¦¬
  double _currentThreshold = 20000000.0; // ê¸°ë³¸ê°’: 2ì²œë§Œì›
  
  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxTrades = 200;
  static const int _maxCacheSize = 1000;
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

  TradeRepositoryImpl(this._remote, this._cache)
      : _aggregator = TradeAggregator() {
    
    // í•„í„° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
    for (final filter in AppConfig.tradeFilters) {
      _filterLists[filter] = [];
    }
    
    // ì£¼ê¸°ì  í”ŒëŸ¬ì‹œ íƒ€ì´ë¨¸
    _periodicFlushTimer = Timer.periodic(
      AppConfig.globalResetInterval,
      (_) => _aggregator.flushTrades(onTradeProcessed: _handleProcessedTrade),
    );
  }

  /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ í˜¸ì¶œ)
  void _initializeMasterStream(List<String> markets) {
    if (_masterStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
    
    debugPrint('TradeRepositoryImpl: initializing master stream for ${markets.length} markets');
    
    // ğŸ¯ ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    _masterStream = _remote.watch(markets).asBroadcastStream();
    
    // ğŸ¯ ë‹¨ì¼ êµ¬ë…ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì²˜ë¦¬
    _masterSubscription = _masterStream!.listen(
      _processRawTrade,
      onError: (error, stackTrace) {
        debugPrint('Master stream error: $error');
        debugPrint('StackTrace: $stackTrace');
      },
      onDone: () {
        debugPrint('Master stream done');
      },
    );
  }

  @override
  Stream<Trade> watchTrades(List<String> markets) {
    debugPrint('TradeRepositoryImpl: watchTrades() - ${markets.length} markets');
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì¶”ê°€ êµ¬ë… ì—†ìŒ)
    return _masterStream!;
  }

  @override
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
    debugPrint('TradeRepositoryImpl: watchFilteredTrades() - threshold: $threshold');
    
    // ğŸ¯ ìˆ˜ì •: ì„ê³„ê°’ ì—…ë°ì´íŠ¸
    _currentThreshold = threshold;
    
    // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
    _initializeMasterStream(markets);
    
    // ì„ê³„ê°’ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì¬í•„í„°ë§
    _scheduleBatchUpdate();
    
    // ë°°ì¹˜ ì²˜ë¦¬ëœ ê²°ê³¼ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
    return _filteredController.stream;
  }

  @override
  Stream<Trade> watchAggregatedTrades() {
    return _aggregatedController.stream;
  }

  /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  @override
  void updateThreshold(double threshold) {
    if (_currentThreshold != threshold) {
      _currentThreshold = threshold;
      debugPrint('ğŸ¯ Threshold updated to: ${threshold.toStringAsFixed(0)}');
      
      // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
      _scheduleBatchUpdate();
    }
  }
  
  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹)
  void _processRawTrade(Trade trade) async {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
      if (!_seenIds.add(key)) return;

      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ìºì‹œ ì €ì¥
      await _cache.cacheTrade(trade);

      // ğŸ”„ Aggregatorë¥¼ í†µí•œ ê±°ë˜ ì²˜ë¦¬
      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleProcessedTrade,
      );
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTrade error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }
  
  /// ğŸ¯ ì§‘ê³„ëœ ê±°ë˜ ì²˜ë¦¬ ë° í•„í„°ë§ (í•µì‹¬ ë¡œì§)
  void _handleProcessedTrade(Map<String, dynamic> processedTrade) {
    try {
      // Trade ì—”í‹°í‹°ë¡œ ë³€í™˜
      final trade = Trade(
        market: processedTrade['market'] as String,
        price: processedTrade['price'] as double,
        volume: processedTrade['volume'] as double,
        side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: processedTrade['timestamp'] as int,
        sequentialId: processedTrade['sequential_id'] as String,
      );
      
      // ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€
      if (!_aggregatedController.isClosed) {
        _aggregatedController.add(trade);
      }
      
      final total = trade.total;
      
      // ğŸ“‹ ê° í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê±°ë˜ ì¶”ê°€
      for (final filter in AppConfig.tradeFilters) {
        if (total >= filter) {
          final list = _filterLists[filter]!;
          list.insert(0, trade);
          
          // ìµœëŒ€ ê±°ë˜ ìˆ˜ ìœ ì§€
          if (list.length > _maxTrades) {
            list.removeLast();
          }
        }
      }
      
      // ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ê³¼ë„í•œ UI ì—…ë°ì´íŠ¸ ë°©ì§€)
      _scheduleBatchUpdate();
      
    } catch (e, stackTrace) {
      debugPrint('_handleProcessedTrade error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }
  
  /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ì˜ˆì „ í”„ë¡œì íŠ¸ì˜ _updateFilteredTrades ë°©ì‹)
  void _scheduleBatchUpdate() {
    // ì´ë¯¸ ìŠ¤ì¼€ì¤„ëœ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ë¦¬ì…‹
    _batchUpdateTimer?.cancel();
    
    _batchUpdateTimer = Timer(_batchUpdateInterval, () {
      _updateFilteredTrades();
    });
  }
  
  /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ì—…ë°ì´íŠ¸ (UI ì—…ë°ì´íŠ¸)
  void _updateFilteredTrades() {
    try {
      // ğŸ¯ ìˆ˜ì •: ë™ì  ì„ê³„ê°’ ì‚¬ìš©
      final threshold = _currentThreshold;
      
      final merged = <Trade>[];
      final seen = <String>{};

      // ğŸ” ì„ê³„ê°’ ì´ìƒì˜ ëª¨ë“  í•„í„°ì—ì„œ ê±°ë˜ ìˆ˜ì§‘
      for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
        for (final trade in _filterLists[filter] ?? <Trade>[]) {
          final id = '${trade.sequentialId}-${trade.timestampMs}';
          if (trade.total >= threshold && seen.add(id)) {
            merged.add(trade);
          }
        }
      }

      // ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹  ìˆœ)
      merged.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
      
      // ìµœëŒ€ ê±°ë˜ ìˆ˜ë¡œ ì œí•œ
      final result = merged.take(_maxTrades).toList();
      
      // ğŸš€ UIì— ì—…ë°ì´íŠ¸ ì „ì†¡
      if (!_filteredController.isClosed) {
        _filteredController.add(result);
        
        if (kDebugMode && result.isNotEmpty) {
          debugPrint('ğŸ¯ Batch update: ${result.length} filtered trades (threshold: ${threshold.toStringAsFixed(0)})');
        }
      }
      
    } catch (e, stackTrace) {
      debugPrint('_updateFilteredTrades error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  @override
  Future<void> dispose() async {
    debugPrint('TradeRepositoryImpl: dispose() called');
    
    // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
    _periodicFlushTimer?.cancel();
    _batchUpdateTimer?.cancel();
    
    // ë§ˆìŠ¤í„° êµ¬ë… ì •ë¦¬
    await _masterSubscription?.cancel();
    _masterStream = null;
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    await _filteredController.close();
    await _aggregatedController.close();
    
    // ë°ì´í„°ì†ŒìŠ¤ ì •ë¦¬ (remoteë§Œ)
    await _remote.dispose();
    
    // ğŸ—‘ï¸ TradeCacheDataSource.dispose() ì œê±° (HiveServiceê°€ Box ìƒëª…ì£¼ê¸° ê´€ë¦¬)
    // await _cache.dispose();  // â† ì œê±°ë¨
    
    // Aggregator í”ŒëŸ¬ì‹œ
    _aggregator.flushTrades(onTradeProcessed: (_) {});
  }
}\n\n// ====== lib/data/repositories/momentary_repository_impl.dart ======\n
\n\n// ====== lib/data/models/momentary_dto.dart ======\n
\n\n// ====== lib/data/models/trade_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trade_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TradeDtoAdapter extends TypeAdapter<TradeDto> {
  @override
  final int typeId = 0;

  @override
  TradeDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TradeDto(
      market: fields[0] as String,
      price: fields[1] as double,
      volume: fields[2] as double,
      side: fields[3] as String,
      changePrice: fields[4] as double,
      changeState: fields[5] as String,
      timestampMs: fields[6] as int,
      sequentialId: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TradeDto obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.market)
      ..writeByte(1)
      ..write(obj.price)
      ..writeByte(2)
      ..write(obj.volume)
      ..writeByte(3)
      ..write(obj.side)
      ..writeByte(4)
      ..write(obj.changePrice)
      ..writeByte(5)
      ..write(obj.changeState)
      ..writeByte(6)
      ..write(obj.timestampMs)
      ..writeByte(7)
      ..write(obj.sequentialId);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TradeDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/volume_dto.dart ======\n
\n\n// ====== lib/data/models/trade_dto.dart ======\n
// lib/data/models/trade_dto.dart

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

part 'trade_dto.g.dart';

@HiveType(typeId: 0)
class TradeDto {
  @HiveField(0)
  final String market;

  @HiveField(1)
  final double price;

  @HiveField(2)
  final double volume;

  @HiveField(3)
  final String side;

  @HiveField(4)
  final double changePrice;

  @HiveField(5)
  final String changeState;

  @HiveField(6)
  final int timestampMs;

  @HiveField(7)
  final String sequentialId;

  TradeDto({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  Trade toEntity() => Trade(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestampMs,
        sequentialId: sequentialId,
      );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜ (camelCase í‚¤ ì‚¬ìš©ìœ¼ë¡œ ì‹œìŠ¤í…œ í†µì¼)
  Map<String, dynamic> toMap() => {
        'market': market,
        'price': price,
        'volume': volume,
        'side': side,
        'changePrice': changePrice,
        'changeState': changeState,
        'timestampMs': timestampMs,
        'sequentialId': sequentialId,
      };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (ì—¬ëŸ¬ í‚¤ ë„¤ì´ë° ì§€ì›)
  static TradeDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      log.d('TradeDto.tryParse: ${m.toString().substring(0, m.toString().length.clamp(0, 100))}');

      String parseString(dynamic v, [String fallback = '']) =>
          v != null ? v.toString() : fallback;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch
                              : DateTime.now().millisecondsSinceEpoch;
      }

      final market = parseString(m['market'] ?? m['symbol'] ?? m['code'], 'UNKNOWN');
      final price = parseDouble(m['price'] ?? m['trade_price']);
      final volume = parseDouble(m['volume'] ?? m['trade_volume']);
      final side = parseString(m['side'] ?? m['ask_bid'], 'UNKNOWN');

      final changePrice = parseDouble(m['changePrice'] ?? m['change_price']);
      final changeState = parseString(m['changeState'] ?? m['change_state'], 'EVEN');
      final timestamp = parseInt(m['timestampMs'] ?? m['timestamp_ms'] ?? m['timestamp']);
      final sequentialId = parseString(
        m['sequentialId'] ?? m['sequential_id'] ?? m['sid'], 
        timestamp.toString(),
      );

      return TradeDto(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestamp,
        sequentialId: sequentialId,
      );
    } catch (e) {
      log.w('TradeDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TradeDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TradeDto(
        market: 'ERROR',
        price: 0.0,
        volume: 0.0,
        side: 'UNKNOWN',
        changePrice: 0.0,
        changeState: 'UNKNOWN',
        timestampMs: DateTime.now().millisecondsSinceEpoch,
        sequentialId: 'ERROR',
      );
}
\n\n// ====== lib/data/models/surge_dto.dart ======\n
\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/features/trade/data/utils/trade_aggregator.dart
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ì™€ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Map<String, dynamic>> _lastTrades = {};
  final int mergeWindow = AppConfig.mergeWindowMs;

  /// ê±°ë˜ ì²˜ë¦¬ ë° ë³‘í•© ë¡œì§
  void processTrade(
    Map<String, dynamic> trade, {
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      // ì•ˆì „í•œ null ì²´í¬ì™€ íƒ€ì… ìºìŠ¤íŒ…
      final market = trade['market'] as String? ?? '';
      final price = trade['price'] as double? ?? 0.0;
      final volume = trade['volume'] as double? ?? 0.0;
      final timestamp = trade['timestamp'] as int? ?? 0;
      final isBuy = trade['isBuy'] as bool? ?? true;
      final sequentialId = trade['sequential_id'] as String? ?? '';

      // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (market.isEmpty || price <= 0 || volume <= 0 || timestamp <= 0) {
        if (kDebugMode) {
          debugPrint('TradeAggregator: Invalid trade data, skipping: market=$market, price=$price, volume=$volume, timestamp=$timestamp');
        }
        return;
      }

      final total = price * volume;

      if (_lastTrades.containsKey(market)) {
        final lastTrade = _lastTrades[market]!;
        final lastTs = lastTrade['timestamp'] as int;

        // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê±°ë˜ë©´ ë³‘í•©
        if (timestamp - lastTs <= mergeWindow) {
          final lastTotal = lastTrade['total'] as double;
          final lastVolume = lastTrade['volume'] as double;
          final newTotal = lastTotal + total;
          final newVolume = lastVolume + volume;

          // ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°
          final avgPrice = newTotal / newVolume;

          // ë³‘í•©ëœ ê±°ë˜ ì •ë³´ ì—…ë°ì´íŠ¸
          lastTrade['price'] = avgPrice;
          lastTrade['volume'] = newVolume;
          lastTrade['total'] = newTotal;
          lastTrade['timestamp'] = timestamp; // ìµœì‹  ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          lastTrade['sequential_id'] = sequentialId;
          lastTrade['isBuy'] = isBuy; // ìµœì‹  ê±°ë˜ì˜ ë°©í–¥ ì‚¬ìš©

          if (kDebugMode) {
            debugPrint(
              'Merged trade: $market, total: ${newTotal.toStringAsFixed(0)}, avg_price: ${avgPrice.toStringAsFixed(2)}',
            );
          }
        } else {
          // ì‹œê°„ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚˜ë©´ ì´ì „ ê±°ë˜ ì²˜ë¦¬í•˜ê³  ìƒˆ ê±°ë˜ë¡œ êµì²´
          onTradeProcessed(Map<String, dynamic>.from(lastTrade));
          _lastTrades[market] = {
            'market': market,
            'price': price,
            'volume': volume,
            'total': total,
            'timestamp': timestamp,
            'isBuy': isBuy,
            'sequential_id': sequentialId,
          };
        }
      } else {
        // ìƒˆë¡œìš´ ë§ˆì¼“ì˜ ì²« ê±°ë˜
        final newTrade = {
          'market': market,
          'price': price,
          'volume': volume,
          'total': total,
          'timestamp': timestamp,
          'isBuy': isBuy,
          'sequential_id': sequentialId,
        };
        _lastTrades[market] = newTrade;
        // ğŸ”¥ ì¤‘ìš”: ì²« ê±°ë˜ë„ ë°”ë¡œ ì²˜ë¦¬í•˜ì—¬ UIì— ë°˜ì˜
        onTradeProcessed(Map<String, dynamic>.from(newTrade));
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator processTrade error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í”ŒëŸ¬ì‹œ
  void flushTrades({
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      final tradesCount = _lastTrades.length;
      for (final trade in _lastTrades.values) {
        onTradeProcessed(Map<String, dynamic>.from(trade));
      }
      _lastTrades.clear();
      
      if (kDebugMode) {
        debugPrint('TradeAggregator: $tradesCount trades flushed');
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator flushTrades error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê¹…ìš©)
  Map<String, dynamic>? getPendingTrade(String market) {
    return _lastTrades[market] != null
        ? Map<String, dynamic>.from(_lastTrades[market]!)
        : null;
  }

  /// í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _lastTrades.length;

  /// ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _lastTrades.clear();
  }
}\n\n// ====== lib/domain/repositories/surge_repository.dart ======\n
\n\n// ====== lib/domain/repositories/momentary_repository.dart ======\n
\n\n// ====== lib/domain/repositories/settings_repository.dart ======\n
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';

abstract class SettingsRepository {
  /// í˜„ì¬ ì•± ì„¤ì • ê°€ì ¸ì˜¤ê¸°
  Future<AppSettings> getSettings();

  /// í…Œë§ˆ ëª¨ë“œ ì—…ë°ì´íŠ¸
  Future<void> updateThemeMode(ThemeMode mode);

  /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì • ì—…ë°ì´íŠ¸
  Future<void> updateKeepScreenOn(bool value);

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì—…ë°ì´íŠ¸
  Future<void> updateSliderPosition(SliderPosition position);

  /// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
  Future<void> updateDisplayMode(DisplayMode mode);

  /// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
  Future<void> updateAmountDisplayMode(AmountDisplayMode mode);
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart
import '../entities/trade.dart';

/// Provides streams of trade data and handles resource cleanup.
abstract class TradeRepository {
  /// Streams raw [Trade] events for the given list of market codes.
  Stream<Trade> watchTrades(List<String> markets);
  
  /// Streams lists of [Trade] filtered by a minimum total trade value.
  /// => markets íŒŒë¼ë¯¸í„° ì¶”ê°€
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);
  
  /// Streams aggregated [Trade] events over a merge window.
  Stream<Trade> watchAggregatedTrades();
  
  /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updateThreshold(double threshold);
  
  /// Releases any held resources (e.g., WebSocket connections, Hive boxes).
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
\n\n// ====== lib/domain/usecases/momentary_usecase.dart ======\n
\n\n// ====== lib/domain/usecases/settings_usecase.dart ======\n
// lib/domain/usecases/settings_usecase.dart
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';
import '../repositories/settings_repository.dart';

/// ì•± ì„¤ì • ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class SettingsUsecase {
  final SettingsRepository _repo;

  SettingsUsecase(this._repo);

  Future<AppSettings> getSettings() {
    return _repo.getSettings();
  }

  Future<void> updateThemeMode(ThemeMode mode) {
    return _repo.updateThemeMode(mode);
  }

  Future<void> updateKeepScreenOn(bool on) {
    return _repo.updateKeepScreenOn(on);
  }

  Future<void> updateSliderPosition(SliderPosition pos) {
    return _repo.updateSliderPosition(pos);
  }

  /// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
  Future<void> updateDisplayMode(DisplayMode mode) {
    return _repo.updateDisplayMode(mode);
  }

  /// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
  Future<void> updateAmountDisplayMode(AmountDisplayMode mode) {
    return _repo.updateAmountDisplayMode(mode);
  }
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
\n\n// ====== lib/domain/usecases/surge_usecase.dart ======\n
\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// Trade ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  /// thresholdì™€ marketsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<List<Trade>, AppException>> filterTrades(
    double threshold,
    List<String> markets,
  ) {
    return _repository
        .watchFilteredTrades(threshold, markets)
        .transform(_wrap<List<Trade>>('Filter trades failed'));
  }

  /// ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<Trade, AppException>> aggregateTrades() {
    return _repository
        .watchAggregatedTrades()
        .transform(_wrap<Trade>('Aggregate trades failed'));
  }

  StreamTransformer<T, Result<T, AppException>> _wrap<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/services/trade_filter_service.dart ======\n
\n\n// ====== lib/domain/entities/app_settings.dart ======\n
import 'package:flutter/material.dart';
import 'package:equatable/equatable.dart';

/// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë¥¼ í‘œí˜„í•˜ëŠ” enum
enum SliderPosition { top, bottom }

/// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum DisplayMode {
  ticker, // BTC, ETH, XRP
  korean, // ë¹„íŠ¸ì½”ì¸, ì´ë”ë¦¬ì›€, ë¦¬í”Œ
  english, // Bitcoin, Ethereum, Ripple
}

/// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum AmountDisplayMode {
  number, // 1,234ë§Œ (ìˆ«ì)
  icon,   // ğŸ’µ (ì•„ì´ì½˜)
}

class AppSettings extends Equatable {
  final ThemeMode themeMode;
  final bool keepScreenOn;
  final SliderPosition sliderPosition;
  final DisplayMode displayMode; // ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì¶”ê°€
  final AmountDisplayMode amountDisplayMode; // ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì¶”ê°€

  const AppSettings({
    this.themeMode = ThemeMode.system,
    this.keepScreenOn = false,
    this.sliderPosition = SliderPosition.top,
    this.displayMode = DisplayMode.ticker, // ğŸ†• ê¸°ë³¸ê°’: í‹°ì»¤
    this.amountDisplayMode = AmountDisplayMode.number, // ğŸ’° ê¸°ë³¸ê°’: ìˆ«ì
  });

  AppSettings copyWith({
    ThemeMode? themeMode,
    bool? keepScreenOn,
    SliderPosition? sliderPosition,
    DisplayMode? displayMode, // ğŸ†• íŒŒë¼ë¯¸í„° ì¶”ê°€
    AmountDisplayMode? amountDisplayMode, // ğŸ’° íŒŒë¼ë¯¸í„° ì¶”ê°€
  }) =>
      AppSettings(
        themeMode: themeMode ?? this.themeMode,
        keepScreenOn: keepScreenOn ?? this.keepScreenOn,
        sliderPosition: sliderPosition ?? this.sliderPosition,
        displayMode: displayMode ?? this.displayMode, // ğŸ†• ë³µì‚¬ ë¡œì§ ì¶”ê°€
        amountDisplayMode: amountDisplayMode ?? this.amountDisplayMode, // ğŸ’° ë³µì‚¬ ë¡œì§ ì¶”ê°€
      );

  @override
  List<Object?> get props => [
        themeMode,
        keepScreenOn,
        sliderPosition,
        displayMode, // ğŸ†• equality ë¹„êµì— ì¶”ê°€
        amountDisplayMode, // ğŸ’° equality ë¹„êµì— ì¶”ê°€
      ];
}\n\n// ====== lib/domain/entities/momentary.dart ======\n
\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨
class Trade extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;

  /// ì²´ê²° ë‹¨ê°€
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰
  final double volume;

  /// 'BID' ë˜ëŠ” 'ASK'
  final String side;

  /// ê°€ê²© ë³€ë™ëŸ‰
  final double changePrice;

  /// ë³€ë™ ìƒíƒœ ('RISE'/'FALL'/'EVEN')
  final String changeState;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int timestampMs;

  /// ì¤‘ë³µ ì œê±°ìš© ê³ ìœ  ID
  final String sequentialId;

  const Trade({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  @override
  List<Object?> get props => [
        market,
        price,
        volume,
        side,
        changePrice,
        changeState,
        timestampMs,
        sequentialId,
      ];

  /// ì´ ì²´ê²° ê¸ˆì•¡
  double get total => price * volume;

  /// ë§¤ìˆ˜ ì—¬ë¶€
  bool get isBuy => side == 'BID';

  /// DateTime ë³€í™˜
  DateTime get timestamp => DateTime.fromMillisecondsSinceEpoch(timestampMs);
}
\n\n// ====== lib/domain/entities/surge.dart ======\n
\n\n// ====== lib/domain/entities/volume.dart ======\n
\n\n// ====== lib/app.dart ======\n
// lib/app.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Core
import 'core/config/app_config.dart';
import 'core/navigation/app_router.dart';
// Shared UI
import 'shared/theme/app_theme.dart';
// All app-level providers
import 'core/di/app_providers.dart';

/// Entry widget for the application
class MyApp extends ConsumerStatefulWidget {
  final GlobalKey<NavigatorState> navigatorKey;
  
  const MyApp({required this.navigatorKey, Key? key}) : super(key: key);

  @override
  ConsumerState<MyApp> createState() => _MyAppState();
}

class _MyAppState extends ConsumerState<MyApp> {
  late final AppRouter _appRouter;

  @override
  void initState() {
    super.initState();
    _appRouter = AppRouter(ref, widget.navigatorKey)
      ..setupFCMListeners();
  }

  @override
  void dispose() {
    _appRouter.dispose();
    ref.read(signalBusProvider).dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ğŸ†• í†µí•© ì„¤ì • ì‚¬ìš©
    final settings = ref.watch(appSettingsProvider);
    // ğŸ”§ ê¸°ë³¸ upbit í”Œë«í¼ ì‚¬ìš© (platformProvider ì—†ìœ¼ë¯€ë¡œ)

    return MaterialApp.router(
      title: 'ì½”ì¸ í¬ì°© ì•±',
      debugShowCheckedModeBanner: AppConfig.isDebugMode,
      
      // ğŸ†• ê¸°ë³¸ upbit í…Œë§ˆ ì ìš©
      theme: AppTheme.light(), // ê¸°ë³¸ê°’ ì‚¬ìš©
      darkTheme: AppTheme.dark(), // ê¸°ë³¸ê°’ ì‚¬ìš©
      themeMode: settings.themeMode, // ğŸ¯ ì‹¤ì‹œê°„ í…Œë§ˆ ì ìš©!
      
      routerConfig: _appRouter.router,
      scaffoldMessengerKey: ref.watch(scaffoldMessengerKeyProvider),
    );
  }
}

/// ProviderObserver for logging state changes
class AppProviderObserver extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase provider,
    Object? value,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] ğŸ†• Provider Added: ${provider.name ?? provider.runtimeType}');
    }
  }

  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] ğŸ”„ Provider Updated: ${provider.name ?? provider.runtimeType}');
    }
  }

  @override
  void didDisposeProvider(
    ProviderBase provider,
    ProviderContainer container,
  ) {
    if (AppConfig.isDebugMode) {
      debugPrint('[Observer] â™»ï¸ Provider Disposed: ${provider.name ?? provider.runtimeType}');
    }
  }
}

/// Initializes critical providers on app start
class ProviderInitializer extends ConsumerWidget {
  final Widget child;
  
  const ProviderInitializer({required this.child, Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (AppConfig.isDebugMode) {
        debugPrint('[Initializer] âš¡ Initializing providers...');
      }
      
      // ğŸ†• í†µí•© ì„¤ì • ì´ˆê¸°í™”
      ref.read(appSettingsProvider);
      
      // ğŸ†• ì•± ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬ì ì´ˆê¸°í™” (ìŠ¬ë¼ì´ë” ê´€ë ¨ ì½”ë“œ ì œê±°ëœ ë²„ì „)
      ref.read(appLifecycleManagerProvider);
      
      if (AppConfig.isDebugMode) {
        debugPrint('[Initializer] âœ… Provider initialization complete.');
      }
    });
    
    return child;
  }
}\n\n// ====== lib/presentation/providers/trade_provider.dart ======\n
\n\n// ====== lib/presentation/providers/volume_provider.dart ======\n
\n\n// ====== lib/presentation/providers/market_providers.dart ======\n
\n\n// ====== lib/presentation/providers/surge_provider.dart ======\n
\n\n// ====== lib/presentation/providers/settings_provider.dart ======\n
\n\n// ====== lib/presentation/providers/momentary_provider.dart ======\n
\n\n// ====== lib/presentation/controllers/surge_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/main_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/settings_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/momentary_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/volume_controller.dart ======\n
\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart'; // usecaseProvider, repoProvider
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// í™”ë©´ ìƒíƒœë¥¼ ìº¡ìŠí™”í•˜ëŠ” immutable ëª¨ë¸
class TradeState {
  final List<Trade> trades;
  final bool isLoading;
  final bool isConnected;
  final double threshold;
  final int selectedIndex;
  final String? errorMessage;

  const TradeState({
    this.trades = const [],
    this.isLoading = false,
    this.isConnected = false,
    this.threshold = 20000000,
    this.selectedIndex = 0,
    this.errorMessage,
  });

  TradeState copyWith({
    List<Trade>? trades,
    bool? isLoading,
    bool? isConnected,
    double? threshold,
    int? selectedIndex,
    String? errorMessage,
  }) {
    return TradeState(
      trades: trades ?? this.trades,
      isLoading: isLoading ?? this.isLoading,
      isConnected: isConnected ?? this.isConnected,
      threshold: threshold ?? this.threshold,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      errorMessage: errorMessage,
    );
  }
}

/// Trade í™”ë©´ ì „ìš© ViewModel
class TradeController extends StateNotifier<TradeState> {
  final TradeUsecase _usecase;
  final Ref _ref;  // ğŸ”¥ ì¶”ê°€: Repository ì ‘ê·¼ì„ ìœ„í•œ ref
  StreamSubscription<Result<List<Trade>, AppException>>? _subscription;

  TradeController(this._usecase, this._ref) : super(const TradeState());  // ğŸ”¥ ìˆ˜ì •: ref ë§¤ê°œë³€ìˆ˜ ì¶”ê°€

  /// ì„ê³„ê°’ ë° ì¸ë±ìŠ¤ ì„¤ì • í›„ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
  void setThreshold(double threshold, int index, List<String> markets) {
    // ğŸ”¥ ì¶”ê°€: Repositoryì˜ updateThreshold í˜¸ì¶œ (í•µì‹¬ ëˆ„ë½ ë¶€ë¶„)
    final repository = _ref.read(repoProvider);
    repository.updateThreshold(threshold);
    
    state = state.copyWith(
      threshold: threshold,
      selectedIndex: index,
      isLoading: true,
      errorMessage: null,
    );
    _subscription?.cancel();
    _subscription = _usecase
        .filterTrades(threshold, markets)
        .listen(_handleResult);
  }

  void _handleResult(Result<List<Trade>, AppException> result) {
    result.when(
      ok: (trades) {
        state = state.copyWith(
          trades: trades,
          isLoading: false,
          isConnected: true,
          errorMessage: null,
        );
      },
      err: (e) {
        state = state.copyWith(
          isLoading: false,
          isConnected: false,
          errorMessage: e.message,
        );
      },
    );
  }

  /// ì¬ì—°ê²°/ìƒˆë¡œê³ ì¹¨: marketsë§Œ ë°›ì•„ì„œ ë‚´ë¶€ì ìœ¼ë¡œ setThreshold í˜¸ì¶œ
  void refresh(List<String> markets) {
    setThreshold(state.threshold, state.selectedIndex, markets);
  }

  /// ê±°ë˜ ëª©ë¡ ì¶”ê°€ í•„í„° (ì‹œì¥ëª…)
  List<Trade> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.trades;
    }
    final upper = marketFilter.toUpperCase();
    return state.trades.where((t) => t.market.contains(upper)).toList();
  }

  /// ê±°ë˜ ëª©ë¡ ì •ë ¬
  void sortTrades(String field, bool ascending) {
    final list = [...state.trades];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'volume':
          aValue = a.volume;
          bValue = b.volume;
          break;
        case 'total':
          aValue = a.total;
          bValue = b.total;
          break;
        case 'timestamp':
          aValue = a.timestampMs;
          bValue = b.timestampMs;
          break;
        default:
          aValue = a.timestampMs;
          bValue = b.timestampMs;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(trades: list);
  }

  /// ê±°ë˜ ëª©ë¡ í•„í„°ë§/ì •ë ¬ ì ìš©
  List<Trade> apply(List<Trade> trades) {
    // í˜„ì¬ thresholdë¡œ í•„í„°ë§
    final filtered = trades.where((trade) => trade.total >= state.threshold).toList();
    // ê¸°ë³¸ ì •ë ¬ (timestampMs ë‚´ë¦¼ì°¨ìˆœ)
    filtered.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return filtered;
  }

  /// ì‚¬ìš© ê°€ëŠ¥í•œ ì„ê³„ê°’ ì˜µì…˜ë“¤
  List<double> get availableThresholds =>
    AppConfig.tradeFilters.where((f) => f >= 20000000).toList();

  @override
  void dispose() {
    _subscription?.cancel();
    super.dispose();
  }
}

/// Provider ì„ ì–¸
final tradeControllerProvider =
    StateNotifierProvider<TradeController, TradeState>((ref) {
  final usecase = ref.read(usecaseProvider);
  return TradeController(usecase, ref);  // ğŸ”¥ ìˆ˜ì •: refë„ í•¨ê»˜ ì „ë‹¬
});\n\n// ====== lib/presentation/pages/main_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // ğŸ¯ HapticFeedbackìš©
import '../../core/di/app_providers.dart';
import '../../shared/widgets/common_app_bar.dart';
import 'trade_page.dart';

/// ğŸ¯ ë©”ì¸ í˜ì´ì§€ - PageViewë¡œ 4ê°œ í™”ë©´ ê´€ë¦¬
class MainPage extends ConsumerStatefulWidget {
  const MainPage({Key? key}) : super(key: key);

  @override
  ConsumerState<MainPage> createState() => _MainPageState();
}

class _MainPageState extends ConsumerState<MainPage> with TickerProviderStateMixin {
  late PageController _pageController;
  late AnimationController _animationController;
  
  // âœ… TradePageì˜ ScrollControllerë¥¼ ìœ„í•œ ê° í˜ì´ì§€ë³„ ê´€ë¦¬
  final Map<int, ScrollController> _pageScrollControllers = {};
  
  // 4ê°œ í˜ì´ì§€ ì •ë³´
  final List<PageInfo> _pages = [
    PageInfo(
      index: 0,
      title: 'ê¸‰ë“±ë½',
      icon: Icons.trending_up, // âœ… ê·¸ëŒ€ë¡œ ìœ ì§€
      builder: (scrollController) => _buildPlaceholderPage('ê¸‰ë“±ë½', Icons.trending_up, 'ê¸‰ë“±ë½ ëª¨ë‹ˆí„°ë§ í˜ì´ì§€'),
    ),
    PageInfo(
      index: 1,
      title: 'ì²´ê²°',
      icon: Icons.monetization_on, // âœ… ë³€ê²½: show_chart â†’ monetization_on ğŸ’°
      builder: (scrollController) => TradePage(scrollController: scrollController), // âœ… ScrollController ì „ë‹¬
    ),
    PageInfo(
      index: 2,
      title: 'ë³¼ë¥¨',
      icon: Icons.bar_chart, // âœ… ê·¸ëŒ€ë¡œ ìœ ì§€
      builder: (scrollController) => _buildPlaceholderPage('ë³¼ë¥¨', Icons.bar_chart, 'ê±°ë˜ëŸ‰ ë¶„ì„ í˜ì´ì§€'),
    ),
    PageInfo(
      index: 3,
      title: 'ì„¹í„°',
      icon: Icons.pie_chart, // âœ… ë³€ê²½: business â†’ pie_chart ğŸ¥§
      builder: (scrollController) => _buildPlaceholderPage('ì„¹í„°', Icons.pie_chart, 'ì„¹í„°ë³„ ì¢…ëª© ë¶„ì„ í˜ì´ì§€'),
    ),
  ];

  @override
  void initState() {
    super.initState();
    
    // PageController ì´ˆê¸°í™” (ì²´ê²° í˜ì´ì§€ë¥¼ ê¸°ë³¸ìœ¼ë¡œ)
    _pageController = PageController(initialPage: 1);
    
    // ì• ë‹ˆë©”ì´ì…˜ ì»¨íŠ¸ë¡¤ëŸ¬ ì´ˆê¸°í™” 
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    
    // âœ… ê° í˜ì´ì§€ë³„ ScrollController ì´ˆê¸°í™”
    for (int i = 0; i < _pages.length; i++) {
      _pageScrollControllers[i] = ScrollController();
    }
    
    // ì´ˆê¸° í˜ì´ì§€ ì¸ë±ìŠ¤ ì„¤ì •
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(selectedTabProvider.notifier).state = 1; // ì²´ê²° í˜ì´ì§€
    });
  }

  @override
  void dispose() {
    _pageController.dispose();
    _animationController.dispose();
    // âœ… ëª¨ë“  ScrollController í•´ì œ
    for (final controller in _pageScrollControllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final currentIndex = ref.watch(selectedTabProvider);
    
    // âœ… GestureDetector ì œê±° - ìˆœìˆ˜í•˜ê²Œ PrimaryScrollControllerê°€ ìƒíƒœë°” í„°ì¹˜ ì²˜ë¦¬
    return Scaffold(
      appBar: CommonAppBar(
        title: '', // ë¹ˆ ì œëª© (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„°ê°€ ë“¤ì–´ê°ˆ ìë¦¬)
        pages: _pages,
        pageController: _pageController,
        animationController: _animationController,
      ),
      body: SafeArea( // âœ… SafeArea ì¶”ê°€
        child: PageView.builder(
          controller: _pageController,
          onPageChanged: _onPageChanged,
          itemCount: _pages.length,
          // âœ… iOS ìŠ¤íƒ€ì¼ physics + ìŠ¤í¬ë¡¤ ì¶©ëŒ ë°©ì§€
          physics: const BouncingScrollPhysics(
            parent: AlwaysScrollableScrollPhysics(),
          ),
          // âœ… ìŠ¤í¬ë¡¤ ë°©í–¥ ëª…ì‹œ (ìˆ˜í‰ ìŠ¤ì™€ì´í”„)
          scrollDirection: Axis.horizontal,
          itemBuilder: (context, index) {
            // âœ… ê° í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ScrollController ì „ë‹¬
            final scrollController = _pageScrollControllers[index]!;
            return _pages[index].builder(scrollController);
          },
        ),
      ),
    );
  }

  /// í˜ì´ì§€ ë³€ê²½ ì²˜ë¦¬
  void _onPageChanged(int index) {
    HapticFeedback.heavyImpact(); // ğŸ¯ ìŠ¤ì™€ì´í”„ í–…í‹± ì¶”ê°€!

    // Provider ìƒíƒœ ì—…ë°ì´íŠ¸
    ref.read(selectedTabProvider.notifier).state = index;
    
    // ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±°
    _animationController.forward().then((_) {
      _animationController.reset();
    });
    
    debugPrint('ğŸ“± í˜ì´ì§€ ë³€ê²½: ${_pages[index].title} (index: $index)');
  }

  /// ğŸ¯ ì™¸ë¶€ì—ì„œ í˜ì´ì§€ ì´ë™ (ìŠ¬ë¼ì´ë“œ ì¸ë””ì¼€ì´í„° í´ë¦­ ì‹œ)
  void goToPage(int index) {
    if (index >= 0 && index < _pages.length) {
      _pageController.animateToPage(
        index,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  /// í”Œë ˆì´ìŠ¤í™€ë” í˜ì´ì§€ ìƒì„±
  static Widget _buildPlaceholderPage(String title, IconData icon, String description) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 80,
            color: Colors.orange.withValues(alpha: 0.5),
          ),
          const SizedBox(height: 24),
          Text(
            title,
            style: const TextStyle(
              fontSize: 28,
              fontWeight: FontWeight.bold,
              color: Colors.orange,
            ),
          ),
          const SizedBox(height: 12),
          Text(
            description,
            style: TextStyle(
              fontSize: 16,
              color: Colors.grey.shade600,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 40),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            decoration: BoxDecoration(
              color: Colors.orange.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.orange.withValues(alpha: 0.3)),
            ),
            child: const Text(
              'ğŸš§ ê°œë°œ ì˜ˆì •',
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.w500,
                color: Colors.orange,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// ğŸ“„ í˜ì´ì§€ ì •ë³´ í´ë˜ìŠ¤
class PageInfo {
  final int index;
  final String title;
  final IconData icon;
  final Widget Function(ScrollController scrollController) builder; // âœ… ScrollController íŒŒë¼ë¯¸í„° ì¶”ê°€

  const PageInfo({
    required this.index,
    required this.title,
    required this.icon,
    required this.builder,
  });
}\n\n// ====== lib/presentation/pages/momentary_page.dart ======\n
\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/services.dart'; // HapticFeedbackìš©
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart';
import '../../core/di/settings_provider.dart'; // ğŸ†• ì„¤ì • provider ì¶”ê°€
import '../../domain/entities/app_settings.dart'; // ğŸ†• SliderPosition enum
import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';
// âœ‚ï¸ CommonAppBar import ì œê±° (MainPageì—ì„œ ì²˜ë¦¬)

class TradePage extends ConsumerWidget {
  final ScrollController scrollController; // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ëŠ” ScrollController
  
  const TradePage({
    Key? key,
    required this.scrollController, // âœ… í•„ìˆ˜ íŒŒë¼ë¯¸í„°
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1) Threshold ìƒíƒœ ë° ì»¨íŠ¸ë¡¤ëŸ¬
    final thresholds = AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    final index = ref.watch(tradeFilterIndexProvider);
    final thresholdCtrl = ref.read(tradeThresholdController);
    
    // 2) ê±°ë˜ ìŠ¤íŠ¸ë¦¼
    final tradesAsync = ref.watch(tradeListProvider);
    
    // 3) UI ìƒíƒœ ì»¨íŠ¸ë¡¤ëŸ¬ (í•„í„°/ì •ë ¬)
    final uiController = ref.watch(tradeControllerProvider.notifier);
    
    // 4) ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì„¤ì • ì½ê¸°
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… MainPageì—ì„œ ì „ë‹¬ë°›ì€ ScrollController ì‚¬ìš© (ë¡œì»¬ ìƒì„± ì œê±°)

    // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
    final sliderWidget = _buildSliderWidget(thresholds, index, thresholdCtrl);
    
    // ğŸ†• ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„±
    final tradeListWidget = _buildTradeList(tradesAsync, uiController, scrollController, thresholds, index, context);

    // âœ… PrimaryScrollControllerë¡œ ìƒíƒœë°” í„°ì¹˜ í™œì„±í™” + ì •í™•í•œ ScrollController ì—°ê²°
    return PrimaryScrollController(
      controller: scrollController, // âœ… ì´ì œ MainPageì™€ ê°™ì€ ì¸ìŠ¤í„´ìŠ¤!
      child: Column(
        children: [
          // ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ ë°°ì¹˜ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.top) sliderWidget,
          
          // ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (í•­ìƒ ì¤‘ê°„)
          Expanded(child: tradeListWidget),
          
          // ğŸ†• ìŠ¬ë¼ì´ë”ê°€ í•˜ë‹¨ì¼ ë•Œ (enum ì§ì ‘ ë¹„êµ)
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// ğŸ†• ìŠ¬ë¼ì´ë” ìœ„ì ¯ ìƒì„±
  Widget _buildSliderWidget(List<double> thresholds, int index, dynamic thresholdCtrl) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'ìµœì†Œ ê±°ë˜ ê¸ˆì•¡: ${AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0)}',
            style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
          ),
          Slider(
            value: index.toDouble(),
            min: 0,
            max: (thresholds.length - 1).toDouble(),
            divisions: thresholds.length - 1,
            label: AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0),
            onChanged: (v) {
              HapticFeedback.mediumImpact(); // ğŸ¯ ì—¬ê¸°ì— ì¶”ê°€!  
              final i = v.round();
              thresholdCtrl.updateThreshold(thresholds[i], i);
            },
          ),
        ],
      ),
    );
  }

  /// ğŸ†• ê±°ë˜ ë¦¬ìŠ¤íŠ¸ ìœ„ì ¯ ìƒì„± - ìŠ¤í¬ë¡¤ë°” ë“œë˜ê·¸ ê¸°ëŠ¥ ê°•í™”
  Widget _buildTradeList(
    AsyncValue tradesAsync, 
    dynamic uiController, 
    ScrollController scrollController,
    List<double> thresholds,
    int index,
    BuildContext context,
  ) {
    return tradesAsync.when(
      data: (list) {
        final viewList = uiController.apply(list);
        if (viewList.isEmpty) {
          return Center(
            child: Text(
              'í¬ì°©ëœ ì²´ê²°ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì„ê³„ê°’: ${AppConfig.filterNames[thresholds[index]] ?? thresholds[index].toStringAsFixed(0)})',
              textAlign: TextAlign.center,
              style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
            ),
          );
        }

        // ğŸ¯ ë” ê°•ë ¥í•œ ë“œë˜ê·¸ ê°€ëŠ¥í•œ ìŠ¤í¬ë¡¤ë°”
        return RawScrollbar(
          controller: scrollController,
          thumbVisibility: true,
          trackVisibility: true, // íŠ¸ë™ í‘œì‹œ
          thickness: 8, // âœ… ë‘ê»˜ ì¤„ì´ê¸° (16 â†’ 8)
          radius: const Radius.circular(4), // âœ… ë°˜ì§€ë¦„ë„ ì¡°ì •
          thumbColor: Colors.orange.withValues(alpha: 0.5), // âœ… ê¸°ì¡´ ì£¼í™© ë°˜íˆ¬ëª…
          trackColor: Colors.transparent, // âœ… íŠ¸ë™ì€ íˆ¬ëª…í•˜ê²Œ
          interactive: true, // ë“œë˜ê·¸ ê°€ëŠ¥
          minThumbLength: 50, // ìµœì†Œ ì¸ ê¸¸ì´
          child: ListView.builder(
            controller: scrollController,
            // ğŸ iOS ìŠ¤íƒ€ì¼ ìŠ¤í¬ë¡¤ ë¬¼ë¦¬ íš¨ê³¼
            physics: const BouncingScrollPhysics(
              parent: AlwaysScrollableScrollPhysics(),
            ),
            padding: const EdgeInsets.only(left: 16, right: 24, top: 16, bottom: 16), // âœ… ìš°ì¸¡ íŒ¨ë”© ì¤„ì´ê¸°
            itemCount: viewList.length,
            itemBuilder: (_, i) => TradeTile(trade: viewList[i]),
          ),
        );
      },
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('ì²´ê²° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e')),
    );
  }
}\n\n// ====== lib/presentation/pages/splash_page.dart ======\n
// lib/presentation/pages/splash_page.dart

import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';
import 'main_page.dart';

class SplashPage extends StatefulWidget {
  const SplashPage({Key? key}) : super(key: key);

  @override
  State<SplashPage> createState() => _SplashPageState();
}

class _SplashPageState extends State<SplashPage> {
  VideoPlayerController? _controller;
  bool _isVideoInitialized = false;
  bool _hasNavigated = false;

  @override
  void initState() {
    super.initState();
    _initializeVideo();
    
    // ì•ˆì „ë§: 5ì´ˆ í›„ ê°•ì œ ì´ë™ (ë¹„ë””ì˜¤ ë¬¸ì œ ì‹œ)
    Future.delayed(const Duration(seconds: 5), () {
      if (!_hasNavigated && mounted) {
        _navigateToMain();
      }
    });
  }

  Future<void> _initializeVideo() async {
    try {
      _controller = VideoPlayerController.asset('assets/noonchit_intro_84frames.mp4');
      
      await _controller!.initialize();
      
      if (mounted) {
        setState(() {
          _isVideoInitialized = true;
        });
        
        // ë¹„ë””ì˜¤ ì„¤ì •
        _controller!.setVolume(0.0); // ìŒì†Œê±°
        _controller!.setLooping(false);
        
        // ì¬ìƒ ì™„ë£Œ ë¦¬ìŠ¤ë„ˆ
        _controller!.addListener(_videoListener);
        
        // ì¬ìƒ ì‹œì‘
        _controller!.play();
      }
    } catch (e) {
      // ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ ë©”ì¸ìœ¼ë¡œ ì´ë™
      debugPrint('Video initialization failed: $e');
      if (mounted) {
        _navigateToMain();
      }
    }
  }

  void _videoListener() {
    if (_controller != null && _controller!.value.position >= _controller!.value.duration) {
      // ë¹„ë””ì˜¤ ì¬ìƒ ì™„ë£Œ
      _navigateToMain();
    }
  }

  void _navigateToMain() {
    if (_hasNavigated) return;
    _hasNavigated = true;
    
    if (mounted) {
      Navigator.of(context).pushReplacement(
        PageRouteBuilder(
          pageBuilder: (context, animation, secondaryAnimation) => const MainPage(),
          transitionDuration: const Duration(milliseconds: 300),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(
              opacity: animation,
              child: child,
            );
          },
        ),
      );
    }
  }

  @override
  void dispose() {
    _controller?.removeListener(_videoListener);
    _controller?.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF121212), // ì–´ë‘ìš´ ë°°ê²½
      body: Center(
        child: _isVideoInitialized && _controller != null
            ? AspectRatio(
                aspectRatio: _controller!.value.aspectRatio,
                child: VideoPlayer(_controller!),
              )
            : _buildLoadingFallback(),
      ),
    );
  }

  Widget _buildLoadingFallback() {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        // ë¡œë”© ì¤‘ì´ê±°ë‚˜ ë¹„ë””ì˜¤ ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ UI
        Icon(
          Icons.currency_bitcoin,
          size: 64,
          color: Colors.orange.withValues(alpha: 0.8),
        ),
        const SizedBox(height: 16),
        Text(
          'NOONCHIT',
          style: TextStyle(
            fontSize: 24,
            fontWeight: FontWeight.bold,
            color: Colors.white.withValues(alpha: 0.9),
            letterSpacing: 2.0,
          ),
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: 32,
          height: 32,
          child: CircularProgressIndicator(
            strokeWidth: 3,
            valueColor: AlwaysStoppedAnimation<Color>(
              Colors.orange.withValues(alpha: 0.8),
            ),
          ),
        ),
      ],
    );
  }
}\n\n// ====== lib/presentation/pages/notification_page.dart ======\n
// lib/presentation/pages/notification_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// ì„ì‹œ ì•Œë¦¼ í˜ì´ì§€ (ì—ëŸ¬ í•´ê²°ìš©)
class NotificationPage extends ConsumerWidget {
  const NotificationPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ì•Œë¦¼'),
        centerTitle: true,
        elevation: 0,
      ),
      body: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.notifications_outlined,
              size: 80,
              color: Colors.orange,
            ),
            SizedBox(height: 24),
            Text(
              'ì•Œë¦¼ í˜ì´ì§€',
              style: TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
                color: Colors.orange,
              ),
            ),
            SizedBox(height: 12),
            Text(
              'ì„ì‹œ í˜ì´ì§€ì…ë‹ˆë‹¤',
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/volume_page.dart ======\n
\n\n// ====== lib/presentation/pages/surge_page.dart ======\n
\n\n// ====== lib/presentation/pages/settings_page.dart ======\n
// lib/presentation/pages/settings_page.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../domain/entities/app_settings.dart';
import '../../../shared/widgets/theme_mode_segment.dart';
import '../../../shared/widgets/slider_position_segment.dart';

/// ğŸ†• TopSheetì—ì„œ ì‚¬ìš©í•  ì„¤ì • ë‚´ìš©ë§Œ ë‹´ì€ ìœ„ì ¯
class SettingsPageContent extends ConsumerWidget {
  const SettingsPageContent({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(appSettingsProvider);
    final controller = ref.read(appSettingsProvider.notifier);

    return Container(
      constraints: const BoxConstraints(maxHeight: 400), // ìµœëŒ€ ë†’ì´ ì œí•œ
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // ğŸ¨ í…Œë§ˆ ì„¤ì •
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.palette, color: Colors.orange),
                title: const Text(
                  'í™”ë©´ ëª¨ë“œ',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                trailing: ThemeModeSegment(
                  value: settings.themeMode,
                  onChanged: controller.setThemeMode,
                ),
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸ“± í™”ë©´ í•­ìƒ ì¼œê¸°
            Card(
              elevation: 2,
              child: SwitchListTile(
                secondary: const Icon(Icons.screen_lock_rotation, color: Colors.orange),
                title: const Text(
                  'í™”ë©´ í•­ìƒ ì¼œê¸°',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  settings.keepScreenOn
                    ? 'í™”ë©´ì´ ìë™ìœ¼ë¡œ êº¼ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤'
                    : 'ì‹œìŠ¤í…œ ì„¤ì •ì— ë”°ë¼ í™”ë©´ì´ êº¼ì§‘ë‹ˆë‹¤'
                ),
                value: settings.keepScreenOn,
                onChanged: controller.setKeepScreenOn,
                activeColor: Colors.orange,
              ),
            ),
            
            const SizedBox(height: 12),
            
            // ğŸšï¸ ìŠ¬ë¼ì´ë” ìœ„ì¹˜
            Card(
              elevation: 2,
              child: ListTile(
                leading: const Icon(Icons.tune, color: Colors.orange),
                title: const Text(
                  'ìŠ¬ë¼ì´ë” ìœ„ì¹˜',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  'í•„í„° ìŠ¬ë¼ì´ë”ë¥¼ ${_getSliderPositionText(settings.sliderPosition)}ì— í‘œì‹œ'
                ),
                trailing: SliderPositionSegment(
                  value: settings.sliderPosition,
                  onChanged: controller.setSliderPosition,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ í…ìŠ¤íŠ¸
  String _getSliderPositionText(SliderPosition position) {
    return position.name == 'top' ? 'ìƒë‹¨' : 'í•˜ë‹¨';
  }
}

/// ğŸ—‘ï¸ ê¸°ì¡´ SettingsPageëŠ” í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ (ì‚¬ìš© ì•ˆ í•¨)
class SettingsPage extends ConsumerWidget {
  const SettingsPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ì„¤ì •'),
        centerTitle: true,
      ),
      body: const SettingsPageContent(),
    );
  }
}\n\n// ====== lib/presentation/widgets/momentary_tile.dart ======\n
\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';
import '../../core/di/app_providers.dart'; // DisplayMode import
import '../../shared/widgets/amount_display_widget.dart'; // ğŸ’° AmountDisplayWidget import

class TradeTile extends ConsumerWidget { // âœ… StatelessWidget â†’ ConsumerWidget ë³€ê²½
  // í¬ë§·í„°ë¥¼ staticìœ¼ë¡œ ìºì‹±í•´ ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±í•˜ì§€ ì•Šë„ë¡ ìµœì í™”
  static final _timeFormat = DateFormat('HH:mm:ss');
  static final _integerFormat = NumberFormat('#,###'); // ì •ìˆ˜ìš©
  static final _decimalFormat = NumberFormat('#,##0.######'); // ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
  static final _decimal3Format = NumberFormat('#,##0.###'); // ì†Œìˆ˜ì  3ìë¦¬
  static final _decimal2Format = NumberFormat('#,##0.##'); // ì†Œìˆ˜ì  2ìë¦¬
  static final _decimal1Format = NumberFormat('#,##0.#'); // ì†Œìˆ˜ì  1ìë¦¬
  
  final Trade trade;
  
  const TradeTile({Key? key, required this.trade}) : super(key: key);
  
  // ğŸ¯ ì¡°ê±´ë¶€ ê°€ê²© í¬ë§·íŒ…
  String _formatPrice(double price) {
    if (price <= 1.0) {
      return _decimalFormat.format(price); // 1 ì´í•˜: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else if (price < 10.0) {
      return _decimal3Format.format(price); // 1 ì´ˆê³¼ ~ 10 ë¯¸ë§Œ: ì†Œìˆ˜ì  3ìë¦¬
    } else if (price < 100.0) {
      return _decimal2Format.format(price); // 10 ì´ˆê³¼ ~ 100 ë¯¸ë§Œ: ì†Œìˆ˜ì  2ìë¦¬
    } else if (price < 1000.0) {
      return _decimal1Format.format(price); // 100 ì´ˆê³¼ ~ 1000 ë¯¸ë§Œ: ì†Œìˆ˜ì  1ìë¦¬
    } else {
      return _integerFormat.format(price); // 1000 ì´ìƒ: ì •ìˆ˜
    }
  }
  
  // ğŸ¯ ì¡°ê±´ë¶€ ê±°ë˜ëŸ‰ í¬ë§·íŒ…
  String _formatVolume(double volume) {
    if (volume < 1.0) {
      return _decimalFormat.format(volume); // 1ê°œ ë¯¸ë§Œ: ì†Œìˆ˜ì  ìµœëŒ€ 6ìë¦¬
    } else {
      return _integerFormat.format(volume); // 1ê°œ ì´ìƒ: ì •ìˆ˜ í‘œì‹œ
    }
  }

  // ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë¡œì§
  String _getDisplayName(WidgetRef ref) {
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    final marketInfoAsync = ref.watch(marketInfoProvider);
    
    // ê¸°ë³¸ í‹°ì»¤ (fallback)
    final ticker = trade.market.replaceFirst('KRW-', '');
    
    // marketInfoê°€ ë¡œë”© ì¤‘ì´ê±°ë‚˜ ì—ëŸ¬ì¸ ê²½ìš° í‹°ì»¤ ë°˜í™˜
    return marketInfoAsync.when(
      data: (marketInfoMap) {
        final marketInfo = marketInfoMap[trade.market];
        
        switch (displayMode) {
          case DisplayMode.ticker:
            return ticker;
          case DisplayMode.korean:
            return marketInfo?.koreanName ?? ticker;
          case DisplayMode.english:
            return marketInfo?.englishName ?? ticker;
        }
      },
      loading: () => ticker, // ë¡œë”© ì¤‘ì—ëŠ” í‹°ì»¤ í‘œì‹œ
      error: (_, __) => ticker, // ì—ëŸ¬ ì‹œì—ë„ í‹°ì»¤ í‘œì‹œ
    );
  }
  
  @override
  Widget build(BuildContext context, WidgetRef ref) { // âœ… WidgetRef íŒŒë¼ë¯¸í„° ì¶”ê°€
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7); // âœ… withAlpha â†’ withValues
    
    return Card(
      elevation: 2,
      margin: const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Row(
          children: [
            // ğŸ¯ ì‹œê°„ ë¶€ë¶„: flex 12 (1.2 ë¹„ìœ¨, 17.1%)
            Expanded(
              flex: 12,
              child: Text(
                _timeFormat.format(trade.timestamp),
                style: TextStyle(color: onSurface, fontSize: 11),
                // ì‹œê°„ì€ ê³ ì • í˜•ì‹ì´ë¯€ë¡œ overflow ë°©ì§€ ë¶ˆí•„ìš”
              ),
            ),
            
            // ğŸ”§ ì½”ì¸ëª… ë¶€ë¶„: flex 18 (1.8 ë¹„ìœ¨, 25.7%) - ë™ì  í‘œì‹œ ì ìš©
            Expanded(
              flex: 18,
              child: Text(
                _getDisplayName(ref), // âœ… ë™ì  ì½”ì¸ëª… í‘œì‹œ
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                  fontSize: 16,
                ),
                overflow: TextOverflow.ellipsis, // ê¸´ ì½”ì¸ëª… ë°©ì§€
                maxLines: 1,
              ),
            ),
            
            // ğŸ”§ ê°€ê²©/ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 20 (2.0 ë¹„ìœ¨, 28.6%)
            Expanded(
              flex: 20,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  Text(
                    '${_formatPrice(trade.price)}ì›', // ğŸ¯ ì¡°ê±´ë¶€ ê°€ê²© í¬ë§·
                    style: TextStyle(color: onSurface, fontSize: 14),
                    overflow: TextOverflow.ellipsis, // í° ê°€ê²© ë°©ì§€
                    maxLines: 1,
                  ),
                  const SizedBox(height: 2),
                  Text(
                    '${_formatVolume(trade.volume)} ê°œ', // ğŸ¯ ì¡°ê±´ë¶€ ê±°ë˜ëŸ‰ í¬ë§·
                    style: TextStyle(color: onSurface70, fontSize: 12),
                    overflow: TextOverflow.ellipsis, // í° ê±°ë˜ëŸ‰ ë°©ì§€
                    maxLines: 1,
                  ),
                ],
              ),
            ),
            
            // ğŸ’° ì´ì•¡ ë¶€ë¶„: flex 20 (2.0 ë¹„ìœ¨, 28.6%) - AmountDisplayWidget ì‚¬ìš©!
            Expanded(
              flex: 20,
              child: Align(
                alignment: Alignment.centerRight,
                child: AmountDisplayWidget(
                  totalAmount: trade.total,
                  isBuy: trade.isBuy,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            
            // ì•„ì´ì½˜ì€ ê³ ì • í¬ê¸°ì´ë¯€ë¡œ ë³€ê²½ ì—†ìŒ
            Icon(
              trade.isBuy ? Icons.arrow_upward : Icons.arrow_downward,
              color: trade.isBuy ? Colors.green : Colors.red,
              size: 16,
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/widgets/surge_tile.dart ======\n
\n\n// ====== lib/presentation/widgets/volume_tile.dart ======\n
