\n\n// ====== lib/core/di/trade_provider.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../services/hive_service.dart';          // 🎯 NEW
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider; // 🆕 WebSocket import
import '../../data/datasources/trade_cache_ds.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// 🆕 마켓 정보 클래스
class MarketInfo {
  final String market;      // KRW-BTC
  final String koreanName;  // 비트코인
  final String englishName; // Bitcoin

  const MarketInfo({
    required this.market,
    required this.koreanName,
    required this.englishName,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      market: json['market'] ?? '',
      koreanName: json['korean_name'] ?? '',
      englishName: json['english_name'] ?? '',
    );
  }
}

/// 0) REST API client
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient(
      apiKey: AppConfig.apiKey,
      apiSecret: AppConfig.apiSecret,
    ));

/// 🎯 HiveService Provider (main.dart에서 override)
final hiveServiceProvider = Provider<HiveService>((ref) {
  throw UnimplementedError('HiveService must be provided via main.dart override');
});

/// 🆕 마켓 정보 Provider (1시간 캐시 + market_warning 필터링)
final marketInfoProvider = FutureProvider<Map<String, MarketInfo>>((ref) async {
  final client = ref.read(apiClientProvider);
  
  try {
    final result = await client.request<List<dynamic>>(
      method: 'GET',
      path: '${AppConfig.upbitRestBase}/market/all',
      cacheDur: const Duration(hours: 1), // 1시간 캐시
    );
    
    return result.when(
      ok: (markets) {
        final Map<String, MarketInfo> marketMap = {};
        int filteredCount = 0;
        
        for (final market in markets) {
          if (market is Map<String, dynamic>) {
            // 🔒 market_warning 필터링 (업비트 백서 준수)
            final warning = market['market_warning'] as String?;
            if (warning == 'CAUTION') {
              filteredCount++;
              if (AppConfig.enableTradeLog) {
                log.d('Filtered CAUTION market: ${market['market']}');
              }
              continue; // CAUTION 종목은 건너뛰기
            }
            
            final info = MarketInfo.fromJson(market);
            marketMap[info.market] = info;
          }
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('마켓 정보 로드됨: ${marketMap.length}개 (CAUTION 필터링: $filteredCount개)');
        }
        return marketMap;
      },
      err: (error) {
        log.w('마켓 정보 로드 실패: $error');
        return <String, MarketInfo>{};
      },
    );
  } catch (e) {
    log.e('마켓 정보 로드 중 오류: $e');
    return <String, MarketInfo>{};
  }
});

/// 1) KRW market list (top 199 by volume + essentials) + market_warning 필터링
final marketsProvider = FutureProvider<List<String>>((ref) async {
  final client = ref.read(apiClientProvider);

  // fetch all markets (cache 5 minutes)
  final marketResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/market/all',
    cacheDur: const Duration(minutes: 5),
  );
  final allMarkets =
      marketResult.when(ok: (v) => v, err: (_) => <dynamic>[]);

  // 🔒 filter KRW markets + market_warning 필터링 (업비트 백서 준수)
  final krwMarkets = <String>[];
  int cautionCount = 0;
  
  for (final market in allMarkets.whereType<Map<String, dynamic>>()) {
    final marketCode = market['market'] as String?;
    if (marketCode != null && marketCode.startsWith('KRW-')) {
      // CAUTION 종목은 WebSocket 구독에서 제외
      final warning = market['market_warning'] as String?;
      if (warning == 'CAUTION') {
        cautionCount++;
        continue;
      }
      krwMarkets.add(marketCode);
    }
  }
  
  if (AppConfig.enableTradeLog && cautionCount > 0) {
    log.i('CAUTION 종목 $cautionCount개 제외됨 (WebSocket 구독 안전성)');
  }

  // pick top by 24h volume (or acc_trade_price when outside 9–10am)
  final now = DateTime.now();
  final isEarly = now.hour >= 9 && now.hour < 10;
  final key = isEarly ? 'acc_trade_price_24h' : 'acc_trade_price';

  // real-time ticker lookup (no cache)
  final tickerResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/ticker',
    query: {'markets': krwMarkets.join(',')},
    cacheDur: null,
  );
  final tickers = tickerResult
      .when(ok: (v) => v, err: (_) => <dynamic>[])  
      .whereType<Map<String, dynamic>>()
      .toList()
    ..sort((a, b) =>
        ((b[key] as num?) ?? 0).compareTo((a[key] as num?) ?? 0));

  // ─── WS 구독 종목 슬라이싱 로직 (essentials 우선 + 중복 제거 후 상위 199개) ───
  const essentials = ['KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL'];
  final sortedMarkets = tickers.map((e) => e['market'] as String).toList();
  final combined = [
    ...essentials.where((market) => krwMarkets.contains(market)), // 🔒 essentials도 CAUTION 체크
    ...sortedMarkets.where((m) => !essentials.contains(m)),
  ];
  return combined.take(199).toList();
});

final cacheDSProvider = Provider<TradeCacheDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return TradeCacheDataSource(hive.tradeBox);
});

final remoteDSProvider = Provider((ref) => TradeRemoteDataSource(
      ref.read(wsClientProvider), // 🔄 websocket_provider에서 import
      ref.read(signalBusProvider),
      useTestData: AppConfig.useTestDataInDev,
    ));

final repoProvider = Provider((ref) => TradeRepositoryImpl(
      ref.read(remoteDSProvider),
      ref.read(cacheDSProvider),
    ));

final usecaseProvider = Provider((ref) => TradeUsecase(ref.read(repoProvider)));

/// 3) Filter state
final tradeFilterIndexProvider = StateProvider<int>((_) => 0);
final tradeFilterThresholdProvider = StateProvider<double>((ref) =>
    AppConfig.tradeFilters.firstWhere(
      (f) => f >= 20000000,
      orElse: () => AppConfig.tradeFilters.last,
    ));

/// 4) Filtered trades stream
final tradeListProvider = StreamProvider.autoDispose<List<Trade>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // 현재 threshold 값과 markets를 읽어 스트림 구독
  final threshold = ref.watch(tradeFilterThresholdProvider);
  final markets = await ref.watch(marketsProvider.future);
  final repository = ref.read(repoProvider);

  // threshold 변경 시 Repository에도 업데이트
  ref.listen<double>(tradeFilterThresholdProvider, (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i(
          'Threshold changed: ${prev.toStringAsFixed(0)} → ${next.toStringAsFixed(0)}',
        );
      }
      repository.updateThreshold(next);
    }
  });

  // 실제 필터된 거래 스트림 방출
  yield* repository.watchFilteredTrades(threshold, markets);
});

/// 5) Aggregated trades stream
final aggregatedTradeProvider = StreamProvider.autoDispose<Trade>((ref) {
  // Prevent dispose on background
  ref.keepAlive();
  final repository = ref.read(repoProvider);
  return repository.watchAggregatedTrades();
});

/// 6) Helper to change threshold & index
final tradeThresholdController = Provider((ref) => TradeThresholdController(ref));

class TradeThresholdController {
  final Ref ref;
  TradeThresholdController(this.ref);

  void updateThreshold(double threshold, int index) {
    final options =
        AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    if (index < 0 || index >= options.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid threshold index: $index');
      return;
    }
    ref.read(tradeFilterThresholdProvider.notifier).state = threshold;
    ref.read(tradeFilterIndexProvider.notifier).state = index;
    AppConfig.updateFilters(options);
    if (AppConfig.enableTradeLog) {
      log.i(
        'Threshold updated: ${threshold.toStringAsFixed(0)} (index: $index)',
      );
    }
  }

  double get currentThreshold => ref.read(tradeFilterThresholdProvider);
  int get currentIndex => ref.read(tradeFilterIndexProvider);
  List<double> get availableThresholds =>
      AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
}\n\n// ====== lib/core/di/websocket_provider.dart ======\n
// lib/core/di/websocket_provider.dart

import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../network/websocket/trade_ws_client.dart';
import '../network/websocket/base_ws_client.dart'; // WsStatus enum
import '../utils/logger.dart';
import '../bridge/signal_bus.dart';

/// 🆕 WebSocket 상세 통계 클래스 (시간/연결/앱생명주기 중심)
class WebSocketStats {
  final DateTime? connectTime;
  final int reconnectCount;
  final int totalSessions;
  final Duration cumulativeConnectTime;
  final int connectionAttempts;
  final DateTime? lastStateChangeTime;
  
  const WebSocketStats({
    this.connectTime,
    this.reconnectCount = 0,
    this.totalSessions = 0,
    this.cumulativeConnectTime = Duration.zero,
    this.connectionAttempts = 0,
    this.lastStateChangeTime,
  });

  /// 연결 지속 시간 계산
  Duration? get uptime {
    if (connectTime == null) return null;
    return DateTime.now().difference(connectTime!);
  }

  /// 평균 연결 지속 시간
  Duration get averageSessionDuration {
    if (totalSessions == 0) return Duration.zero;
    return Duration(
      milliseconds: cumulativeConnectTime.inMilliseconds ~/ totalSessions,
    );
  }

  /// 연결 성공률 (%)
  double get connectionSuccessRate {
    if (connectionAttempts == 0) return 0.0;
    return (totalSessions / connectionAttempts) * 100;
  }
}

/// 🔄 SignalBus Provider (순환 참조 방지)
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});

/// 🆕 WebSocket 상태 관리
final wsStatusProvider = StateProvider<WsStatus>((ref) => WsStatus.disconnected);

/// 🆕 WebSocket 통계 관리 (개별 Provider들 - 시간/연결/앱생명주기)
final wsConnectTimeProvider = StateProvider<DateTime?>((ref) => null);
final wsReconnectCountProvider = StateProvider<int>((ref) => 0);
final wsTotalSessionsProvider = StateProvider<int>((ref) => 0);
final wsCumulativeConnectTimeProvider = StateProvider<Duration>((ref) => Duration.zero);
final wsConnectionAttemptsProvider = StateProvider<int>((ref) => 0);
final wsLastStateChangeTimeProvider = StateProvider<DateTime?>((ref) => null);

/// 🆕 통합 WebSocket 통계 Provider (개별 Provider들을 조합)
final wsStatsProvider = Provider<WebSocketStats>((ref) {
  final connectTime = ref.watch(wsConnectTimeProvider);
  final reconnectCount = ref.watch(wsReconnectCountProvider);
  final totalSessions = ref.watch(wsTotalSessionsProvider);
  final cumulativeConnectTime = ref.watch(wsCumulativeConnectTimeProvider);
  final connectionAttempts = ref.watch(wsConnectionAttemptsProvider);
  final lastStateChangeTime = ref.watch(wsLastStateChangeTimeProvider);

  return WebSocketStats(
    connectTime: connectTime,
    reconnectCount: reconnectCount,
    totalSessions: totalSessions,
    cumulativeConnectTime: cumulativeConnectTime,
    connectionAttempts: connectionAttempts,
    lastStateChangeTime: lastStateChangeTime,
  );
});

/// 🆕 WebSocket 클라이언트 (기본 - 기존 그대로)
final wsClientProvider = Provider<TradeWsClient>((ref) {
  return TradeWsClient(
    onStatusChange: (status) {
      final now = DateTime.now();
      ref.read(wsStatusProvider.notifier).state = status;
      ref.read(wsLastStateChangeTimeProvider.notifier).state = now;
      
      // 간단한 통계 업데이트 (시간/연결/앱생명주기)
      switch (status) {
        case WsStatus.connecting:
          // 연결 시도 카운트
          final attempts = ref.read(wsConnectionAttemptsProvider);
          ref.read(wsConnectionAttemptsProvider.notifier).state = attempts + 1;
          break;
          
        case WsStatus.connected:
          // 연결 성공
          ref.read(wsConnectTimeProvider.notifier).state = now;
          
          // 총 세션 수 증가
          final sessions = ref.read(wsTotalSessionsProvider);
          ref.read(wsTotalSessionsProvider.notifier).state = sessions + 1;
          break;
          
        case WsStatus.reconnecting:
          // 재연결 카운트
          final currentCount = ref.read(wsReconnectCountProvider);
          ref.read(wsReconnectCountProvider.notifier).state = currentCount + 1;
          break;
          
        case WsStatus.disconnected:
          // 연결 종료 시 누적 시간 업데이트
          final connectTime = ref.read(wsConnectTimeProvider);
          if (connectTime != null) {
            final sessionDuration = now.difference(connectTime);
            final cumulative = ref.read(wsCumulativeConnectTimeProvider);
            ref.read(wsCumulativeConnectTimeProvider.notifier).state = 
                cumulative + sessionDuration;
          }
          ref.read(wsConnectTimeProvider.notifier).state = null;
          break;
          
        default:
          break;
      }
      
      if (AppConfig.enableTradeLog) {
        log.i('WebSocket status changed: $status');
      }
    },
  );
});\n\n// ====== lib/core/di/app_providers.dart ======\n
// lib/core/di/app_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../bridge/signal_bus.dart';

/// ▶ App lifecycle (sliderPositionProvider 제거됨)
export '../utils/app_life_cycle_manager.dart'
    show appLifecycleManagerProvider;

/// ▶ Settings DI + state (settingsProvider → appSettingsProvider)
export 'settings_provider.dart'
    show
        sharedPreferencesProvider,
        settingsLocalDSProvider,
        settingsRepositoryProvider,
        settingsUsecaseProvider,
        appSettingsProvider; // 🔧 이름 변경!

/// ▶ Domain entities (DisplayMode 등 enum export)
export '../../domain/entities/app_settings.dart'
    show
        DisplayMode, // 🆕 DisplayMode enum export
        SliderPosition; // 기존 SliderPosition도 명시적 export

/// ▶ WebSocket DI & stats (🆕 새로 추가)
export 'websocket_provider.dart'
    show
        wsStatusProvider,
        wsClientProvider,
        wsStatsProvider,
        WebSocketStats;

/// ▶ Trade DI & streams
export 'trade_provider.dart';

/// ▶ Trade 화면 로직
export '../../presentation/controllers/trade_controller.dart'
    show tradeControllerProvider;

/// ▶ 🆕 Volume DI & streams
export 'volume_provider.dart'
    show
        volumeRepositoryProvider,
        volumeUsecaseProvider,
        volumeTimeFrameIndexProvider,
        volumeTimeFrameProvider,
        volumeDataProvider,
        rawVolumeDataProvider,
        volumeTimeFrameController;

/// ▶ 🆕 Volume 도메인 엔티티
export '../../domain/entities/volume.dart'
    show Volume;

/// ▶ 전역 SnackBar key
final scaffoldMessengerKeyProvider =
    Provider<GlobalKey<ScaffoldMessengerState>>((ref) {
  return GlobalKey<ScaffoldMessengerState>();
});

/// ▶ BottomTab 인덱스
final selectedTabProvider = StateProvider<int>((ref) => 0);

/// ▶ SignalBus 싱글턴
/// Riverpod이 dispose 시점에 자동으로 SignalBus.dispose() 호출
final signalBusProvider = Provider<SignalBus>((ref) {
  final bus = SignalBus();
  ref.onDispose(() => bus.dispose());
  return bus;
});\n\n// ====== lib/core/di/notification_provider.dart ======\n
// lib/core/di/notification_provider.dart
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import '../utils/logger.dart';
import 'app_providers.dart'; // scaffoldMessengerKeyProvider

/// 🔔 알림 타입 enum
enum NotificationType {
  trade,       // 체결 알림
  priceAlert,  // 가격 알림  
  volume,      // 거래량 알림
  surge,       // 급등락 알림
  system,      // 시스템 알림
}

/// 🔔 알림 상태 enum  
enum NotificationStatus {
  unread,      // 읽지 않음
  read,        // 읽음
  archived,    // 보관됨
}

/// 🔔 알림 데이터 모델 (임시)
class NotificationData {
  final String id;
  final String title;
  final String message;
  final NotificationType type;
  final NotificationStatus status;
  final DateTime createdAt;
  final Map<String, dynamic>? extra;

  const NotificationData({
    required this.id,
    required this.title,
    required this.message,
    required this.type,
    this.status = NotificationStatus.unread,
    required this.createdAt,
    this.extra,
  });

  NotificationData copyWith({
    NotificationStatus? status,
    Map<String, dynamic>? extra,
  }) {
    return NotificationData(
      id: id,
      title: title,
      message: message,
      type: type,
      status: status ?? this.status,
      createdAt: createdAt,
      extra: extra ?? this.extra,
    );
  }
}

/// 🔔 알림 목록 Provider
final notificationListProvider = StateProvider<List<NotificationData>>((ref) => []);

/// 🔔 읽지 않은 알림 개수
final unreadNotificationCountProvider = Provider<int>((ref) {
  final notifications = ref.watch(notificationListProvider);
  return notifications.where((n) => n.status == NotificationStatus.unread).length;
});

/// 🔔 알림 필터 Provider
final notificationFilterProvider = StateProvider<NotificationType?>((ref) => null);

/// 🔔 필터된 알림 목록
final filteredNotificationProvider = Provider<List<NotificationData>>((ref) {
  final notifications = ref.watch(notificationListProvider);
  final filter = ref.watch(notificationFilterProvider);
  
  if (filter == null) return notifications;
  return notifications.where((n) => n.type == filter).toList();
});

/// 🔔 알림 관리 서비스
final notificationServiceProvider = Provider((ref) => NotificationService(ref));

/// 알림 서비스 클래스
class NotificationService {
  final Ref ref;
  StreamSubscription<RemoteMessage>? _onMessageSub;
  StreamSubscription<RemoteMessage>? _onMessageOpenedSub;
  
  NotificationService(this.ref);

  /// 🆕 Firebase 리스너 설정 (AppRouter에서 이동됨)
  void setupFirebaseListeners(GlobalKey<NavigatorState> navigatorKey) {
    final messenger = ref.read(scaffoldMessengerKeyProvider).currentState;
    
    // 앱이 실행 중일 때 알림 수신
    _onMessageSub = FirebaseMessaging.onMessage.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        // 알림 Provider에 저장
        addNotification(
          title: n.title ?? '알림',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // SnackBar로도 표시
        if (messenger != null) {
          messenger
            ..hideCurrentSnackBar()
            ..showSnackBar(SnackBar(content: Text('${n.title}: ${n.body}')));
        }
      }
    });
    
    // 앱이 종료된 상태에서 알림 클릭해서 앱 시작
    FirebaseMessaging.instance.getInitialMessage().then((msg) {
      if (msg != null) {
        final n = msg.notification;
        if (n != null) {
          addNotification(
            title: n.title ?? '알림',
            message: n.body ?? '',
            type: _getNotificationType(msg.data),
            extra: msg.data,
          );
        }
        
        // TODO: 나중에 특정 알림 모달 자동 열기 기능 추가 가능
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    // 앱이 백그라운드에 있을 때 알림 클릭
    _onMessageOpenedSub = FirebaseMessaging.onMessageOpenedApp.listen((msg) {
      final n = msg.notification;
      if (n != null) {
        addNotification(
          title: n.title ?? '알림',
          message: n.body ?? '',
          type: _getNotificationType(msg.data),
          extra: msg.data,
        );
        
        // TODO: 나중에 특정 알림 모달 자동 열기 기능 추가 가능
        // NotificationModal.show(navigatorKey.currentContext!);
      }
    });
    
    log.i('🔔 Firebase 알림 리스너 설정 완료');
  }

  /// Firebase 메시지 데이터로부터 알림 타입 추론
  NotificationType _getNotificationType(Map<String, dynamic>? data) {
    if (data == null) return NotificationType.system;
    
    final type = data['type']?.toString().toLowerCase();
    switch (type) {
      case 'trade':
      case 'execution':
        return NotificationType.trade;
      case 'price':
      case 'price_alert':
        return NotificationType.priceAlert;
      case 'volume':
        return NotificationType.volume;
      case 'surge':
      case 'pump':
      case 'dump':
        return NotificationType.surge;
      default:
        return NotificationType.system;
    }
  }
  
  /// Firebase 리스너 정리
  void dispose() {
    _onMessageSub?.cancel();
    _onMessageOpenedSub?.cancel();
    log.i('🧹 Firebase 알림 리스너 정리됨');
  }
  
  /// 알림 추가
  void addNotification({
    required String title,
    required String message,
    required NotificationType type,
    Map<String, dynamic>? extra,
  }) {
    final notification = NotificationData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      message: message,
      type: type,
      createdAt: DateTime.now(),
      extra: extra,
    );
    
    final currentList = ref.read(notificationListProvider);
    ref.read(notificationListProvider.notifier).state = [
      notification,
      ...currentList,
    ];
    
    log.i('🔔 알림 추가: $title');
  }
  
  /// 알림 읽음 처리
  void markAsRead(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) {
      if (notification.id == notificationId) {
        return notification.copyWith(status: NotificationStatus.read);
      }
      return notification;
    }).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('👁️ 알림 읽음: $notificationId');
  }
  
  /// 알림 제거
  void removeNotification(String notificationId) {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.where((n) => n.id != notificationId).toList();
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('🗑️ 알림 제거: $notificationId');
  }
  
  /// 모든 알림 읽음 처리
  void markAllAsRead() {
    final currentList = ref.read(notificationListProvider);
    final updatedList = currentList.map((notification) => 
      notification.copyWith(status: NotificationStatus.read)
    ).toList();
    
    ref.read(notificationListProvider.notifier).state = updatedList;
    log.i('👁️ 모든 알림 읽음 처리');
  }
  
  /// 모든 알림 제거
  void clearAllNotifications() {
    ref.read(notificationListProvider.notifier).state = [];
    log.i('🧹 모든 알림 제거');
  }
  
  /// 필터 설정
  void setFilter(NotificationType? type) {
    ref.read(notificationFilterProvider.notifier).state = type;
    log.i('🔍 알림 필터: ${type?.name ?? "전체"}');
  }
  
  /// 읽지 않은 알림 개수
  int getUnreadCount() {
    return ref.read(unreadNotificationCountProvider);
  }
}\n\n// ====== lib/core/di/volume_provider.dart ======\n
// lib/core/di/volume_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../core/utils/logger.dart';
import '../config/app_config.dart';
import '../utils/app_life_cycle_manager.dart';
import '../../data/repositories/volume_repository_impl.dart';
import '../../domain/entities/volume.dart';
import '../../domain/repositories/volume_repository.dart';
import '../../domain/usecases/volume_usecase.dart';
import 'trade_provider.dart'; // TradeRemoteDataSource 재사용

/// 0) Volume Repository Implementation
final volumeRepositoryProvider = Provider<VolumeRepository>((ref) {
  final remoteDS = ref.read(remoteDSProvider); // 🔥 TradeRemoteDataSource 공유!
  final lifecycleManager = ref.read(appLifecycleManagerProvider);
  
  final repo = VolumeRepositoryImpl(remoteDS, lifecycleManager);
  ref.onDispose(() => repo.dispose());
  return repo;
});

/// 1) Volume UseCase
final volumeUsecaseProvider = Provider<VolumeUsecase>((ref) {
  final repository = ref.read(volumeRepositoryProvider);
  return VolumeUsecase(repository);
});

/// 2) Volume 시간대 상태 관리
final volumeTimeFrameIndexProvider = StateProvider<int>((ref) => 2); // 기본값: 15분 (index 2)
final volumeTimeFrameProvider = StateProvider<String>((ref) {
  final index = ref.watch(volumeTimeFrameIndexProvider);
  const timeFrames = AppConfig.timeFrames;
  if (index >= 0 && index < timeFrames.length) {
    return '${timeFrames[index]}m'; // "15m"
  }
  return '15m'; // 기본값
});

/// 3) 정렬된 볼륨 데이터 스트림 (메인)
final volumeDataProvider = StreamProvider.autoDispose<List<Volume>>((ref) async* {
  // Prevent immediate dispose on loss of listeners
  ref.keepAlive();

  // 현재 시간대와 마켓 정보
  final timeFrame = ref.watch(volumeTimeFrameProvider);
  final markets = await ref.watch(marketsProvider.future); // 트레이드와 같은 마켓 사용
  final usecase = ref.read(volumeUsecaseProvider);

  // 시간대 변경 시 로그
  ref.listen<String>(volumeTimeFrameProvider, (prev, next) {
    if (prev != null && prev != next) {
      if (AppConfig.enableTradeLog) {
        log.i('Volume timeFrame changed: $prev → $next');
      }
    }
  });

  // 실제 볼륨 데이터 스트림 방출
  yield* usecase.getVolumeRanking(timeFrame, markets).map((result) {
    return result.when(
      ok: (volumeList) => volumeList,
      err: (error) {
        if (AppConfig.enableTradeLog) {
          log.e('Volume data error: ${error.message}');
        }
        return <Volume>[];
      },
    );
  });
});

/// 4) 원시 볼륨 Map 스트림 (디버깅용)
final rawVolumeDataProvider = StreamProvider.autoDispose<Map<String, double>>((ref) async* {
  ref.keepAlive();

  final timeFrame = ref.watch(volumeTimeFrameProvider);
  final markets = await ref.watch(marketsProvider.future);
  final usecase = ref.read(volumeUsecaseProvider);

  yield* usecase.getRawVolumeData(timeFrame, markets).map((result) {
    return result.when(
      ok: (volumeMap) => volumeMap,
      err: (error) {
        if (AppConfig.enableTradeLog) {
          log.e('Raw volume data error: ${error.message}');
        }
        return <String, double>{};
      },
    );
  });
});

/// 5) 시간대 변경 컨트롤러
final volumeTimeFrameController = Provider((ref) => VolumeTimeFrameController(ref));

class VolumeTimeFrameController {
  final Ref ref;
  VolumeTimeFrameController(this.ref);

  /// 시간대 변경
  void updateTimeFrame(String timeFrame, int index) {
    const timeFrames = AppConfig.timeFrames;
    if (index < 0 || index >= timeFrames.length) {
      if (AppConfig.enableTradeLog) {
        log.w('Invalid volume timeFrame index: $index');
      }
      return;
    }
    
    ref.read(volumeTimeFrameProvider.notifier).state = timeFrame;
    ref.read(volumeTimeFrameIndexProvider.notifier).state = index;
    
    if (AppConfig.enableTradeLog) {
      log.i('Volume timeFrame updated: $timeFrame (index: $index)');
    }
  }

  /// 현재 시간대 정보
  String get currentTimeFrame => ref.read(volumeTimeFrameProvider);
  int get currentIndex => ref.read(volumeTimeFrameIndexProvider);
  
  /// 사용 가능한 시간대 옵션들
  List<String> get availableTimeFrames => 
      AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  /// 시간대 인덱스로부터 한글 이름 가져오기
  String getTimeFrameName(int index) {
    const timeFrames = AppConfig.timeFrames;
    if (index >= 0 && index < timeFrames.length) {
      final timeFrameMinutes = timeFrames[index];
      return AppConfig.timeFrameNames[timeFrameMinutes] ?? '$timeFrameMinutes분';
    }
    return '알 수 없음';
  }
  
  /// 시간대 문자열로부터 한글 이름 가져오기
  String getTimeFrameNameFromString(String timeFrame) {
    // "15m" → 15 → "15분"
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null) {
      return AppConfig.timeFrameNames[minutes] ?? '$minutes분';
    }
    return timeFrame;
  }
}\n\n// ====== lib/core/di/surge_provider.dart ======\n
\n\n// ====== lib/core/di/settings_provider.dart ======\n
// 1️⃣ lib/core/di/settings_provider.dart (수정)
// ==========================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../data/datasources/settings_local_ds.dart';
import '../../data/repositories/settings_repository_impl.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../../domain/usecases/settings_usecase.dart';
import '../utils/logger.dart';

/// 1) SharedPreferences 인스턴스 (main.dart에서 override)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'main.dart에서 SharedPreferences.getInstance() 후 overrides로 주입하세요.'
  );
});

/// 2) Local DataSource
final settingsLocalDSProvider = Provider<SettingsLocalDataSource>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return SettingsLocalDataSource(prefs);
});

/// 3) Repository
final settingsRepositoryProvider = Provider<SettingsRepository>((ref) {
  final ds = ref.watch(settingsLocalDSProvider);
  return SettingsRepositoryImpl(ds);
});

/// 4) UseCase
final settingsUsecaseProvider = Provider<SettingsUsecase>((ref) {
  final repo = ref.watch(settingsRepositoryProvider);
  return SettingsUsecase(repo);
});

/// 5) 🆕 통합 설정 Provider (이것만 사용!)
final appSettingsProvider = StateNotifierProvider<AppSettingsNotifier, AppSettings>((ref) {
  final usecase = ref.watch(settingsUsecaseProvider);
  return AppSettingsNotifier(usecase);
});

/// 🆕 통합 설정 관리 클래스
class AppSettingsNotifier extends StateNotifier<AppSettings> {
  final SettingsUsecase _usecase;

  AppSettingsNotifier(this._usecase) : super(const AppSettings()) {
    _loadSettings();
  }

  /// 초기 설정 로드
  Future<void> _loadSettings() async {
    try {
      final settings = await _usecase.getSettings();
      state = settings;
      
      // 초기 화면 켜기 상태 적용
      _applyKeepScreen(settings.keepScreenOn);
      
      log.i('⚙️ 설정 로드 완료: ${settings.toString()}');
    } catch (e, st) {
      log.e('설정 로드 실패', e, st);
    }
  }

  /// 테마 모드 변경
  Future<void> setThemeMode(ThemeMode mode) async {
    try {
      await _usecase.updateThemeMode(mode);
      state = state.copyWith(themeMode: mode);
      log.i('🎨 테마 모드 변경: ${mode.name}');
    } catch (e, st) {
      log.e('테마 모드 변경 실패', e, st);
    }
  }

  /// 화면 항상 켜기 설정
  Future<void> setKeepScreenOn(bool keep) async {
    try {
      await _usecase.updateKeepScreenOn(keep);
      state = state.copyWith(keepScreenOn: keep);
      _applyKeepScreen(keep);
      log.i('📱 화면 항상 켜기: $keep');
    } catch (e, st) {
      log.e('화면 켜기 설정 실패', e, st);
    }
  }

  /// 슬라이더 위치 변경
  Future<void> setSliderPosition(SliderPosition position) async {
    try {
      await _usecase.updateSliderPosition(position);
      state = state.copyWith(sliderPosition: position);
      log.i('🎚️ 슬라이더 위치: ${position.name}');
    } catch (e, st) {
      log.e('슬라이더 위치 변경 실패', e, st);
    }
  }

  /// 🆕 코인명 표시 방식 변경
  Future<void> setDisplayMode(DisplayMode mode) async {
    try {
      await _usecase.updateDisplayMode(mode);
      state = state.copyWith(displayMode: mode);
      log.i('💰 코인명 표시 방식 변경: ${mode.name}');
    } catch (e, st) {
      log.e('코인명 표시 방식 변경 실패', e, st);
    }
  }

  /// 💰 금액 표시 방식 변경
  Future<void> setAmountDisplayMode(AmountDisplayMode mode) async {
    try {
      await _usecase.updateAmountDisplayMode(mode);
      state = state.copyWith(amountDisplayMode: mode);
      log.i('💵 금액 표시 방식 변경: ${mode.name}');
    } catch (e, st) {
      log.e('금액 표시 방식 변경 실패', e, st);
    }
  }

  /// 화면 켜기 실제 적용
  void _applyKeepScreen(bool keep) {
    if (keep) {
      WakelockPlus.enable();
    } else {
      WakelockPlus.disable();
    }
  }

  /// 설정 새로고침
  Future<void> refresh() async {
    await _loadSettings();
  }
}\n\n// ====== lib/core/di/momentary_provider.dart ======\n
\n\n// ====== lib/core/config/app_config.dart ======\n
// lib/core/config/app_config.dart

import 'dart:collection';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:logger/logger.dart';
import '../utils/logger.dart';

/// Application-wide configuration and constants,
/// optimized per Upbit REST & WebSocket specifications.
class AppConfig {
  AppConfig._();

  /// Call once at startup to initialize dynamic config (env variables)
  static Future<void> init({String? envPath}) async {
    // Load .env (optional custom path) + validate
    try {
      if (envPath != null && envPath.isNotEmpty) {
        await dotenv.load(fileName: envPath);
      } else {
        await dotenv.load();
      }
      log.i('[AppConfig] .env loaded');
      _loadEnv();
    } catch (e, st) {
      log.e('[AppConfig] ⚠️ Failed to load required env vars', e, st);
      throw Exception('[AppConfig] ⚠️ Failed to load required env vars: $e');
    }

    log.i('[AppConfig] initialized (debug=$isDebugMode)');
  }

  static void _loadEnv() {
    const requiredKeys = ['UPBIT_API_KEY', 'UPBIT_API_SECRET'];
    for (final key in requiredKeys) {
      final value = dotenv.env[key];
      if (value == null || value.isEmpty) {
        throw Exception('[AppConfig] Missing required env var: $key');
      }
    }

    _upbitRestBase = dotenv.env['UPBIT_REST_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_REST_URL']!
        : _upbitRestBase;
    _upbitWsUrl = dotenv.env['UPBIT_WS_URL']?.isNotEmpty == true
        ? dotenv.env['UPBIT_WS_URL']!
        : _upbitWsUrl;

    _apiKey = dotenv.env['UPBIT_API_KEY']!;
    _apiSecret = dotenv.env['UPBIT_API_SECRET']!;
  }

  // ──────────────── 🆕 통일된 Bool 해석 유틸리티 ────────────────
  /// 환경변수에서 boolean 값을 안전하고 일관되게 파싱
  /// 지원하는 true 값: 'true', '1', 'yes', 'on'
  /// 지원하는 false 값: 'false', '0', 'no', 'off', null, 빈 문자열
  static bool _getBool(String key, {bool fallback = false}) {
    final value = dotenv.env[key]?.toLowerCase().trim();
    if (value == null || value.isEmpty) return fallback;
    
    // true 값들
    if (value == 'true' || value == '1' || value == 'yes' || value == 'on') {
      return true;
    }
    
    // false 값들
    if (value == 'false' || value == '0' || value == 'no' || value == 'off') {
      return false;
    }
    
    // 알 수 없는 값이면 fallback 사용
    return fallback;
  }

  // ─────────────────── API Credentials ───────────────────
  static String _apiKey = '';
  static String _apiSecret = '';
  static String get apiKey => _apiKey;
  static String get apiSecret => _apiSecret;

  // ──────────────── Environment Flags ────────────────
  /// `true` when not in Dart VM product mode.
  static const bool isDebugMode = !bool.fromEnvironment('dart.vm.product');

  // ──────────────── Logging Configuration ────────────────
  /// 로그 레벨 설정 (개발 중 조절 가능)
  static Level get logLevel {
    if (!isDebugMode) return Level.warning;
    final envLevel = dotenv.env['LOG_LEVEL']?.toLowerCase();
    switch (envLevel) {
      case 'verbose':
        return Level.verbose;
      case 'debug':
        return Level.debug;
      case 'info':
        return Level.info;
      case 'warning':
        return Level.warning;
      case 'error':
        return Level.error;
      default:
        return Level.debug;
    }
  }

  /// 🔧 특정 모듈 로그 on/off (통일된 방식 적용)
  static bool get enableSignalBusLog =>
      _getBool('ENABLE_SIGNAL_BUS_LOG', fallback: true);
  static bool get enableWebSocketLog =>
      _getBool('ENABLE_WEBSOCKET_LOG', fallback: true);
  static bool get enableTradeLog =>
      _getBool('ENABLE_TRADE_LOG', fallback: true);
  static bool get enableAdaptiveBackoffLog =>
      _getBool('ENABLE_ADAPTIVE_BACKOFF_LOG', fallback: true);

  // ──────────────── REST Configuration (업비트 2025 스펙) ────────────────
  static String _upbitRestBase = 'https://api.upbit.com/v1';
  static String get upbitRestBase => _upbitRestBase;
  
  /// 🆕 업비트 백서 2025 기준 레이트리밋 (그룹별)
  /// 공개 API: 초당 30회 / 사적 API: 초당 8회
  static const Map<String, int> rateLimitByGroup = {
    'market': 30,      // 공개 API: /market/all, /ticker 등
    'candles': 30,     // 공개 API: /candles 등  
    'trades': 30,      // 공개 API: /trades 등
    'orderbook': 30,   // 공개 API: /orderbook 등
    'orders': 8,       // 사적 API: 주문 관련
    'accounts': 8,     // 사적 API: 계정 관련
    'withdraws': 8,    // 사적 API: 출금 관련
    'deposits': 8,     // 사적 API: 입금 관련
    'default': 8,      // 기본값: 사적 API 기준
  };
  
  /// 🆕 그룹별 레이트리밋 조회
  static int getRateLimitForGroup(String group) {
    return rateLimitByGroup[group] ?? rateLimitByGroup['default']!;
  }
  
  /// 🆕 경로 기반 그룹 자동 판별
  static String getGroupFromPath(String path) {
    final normalizedPath = path.toLowerCase();
    
    // 공개 API 그룹들
    if (normalizedPath.contains('/market/')) return 'market';
    if (normalizedPath.contains('/ticker')) return 'market';
    if (normalizedPath.contains('/candles/')) return 'candles';
    if (normalizedPath.contains('/trades')) return 'trades';  
    if (normalizedPath.contains('/orderbook')) return 'orderbook';
    
    // 사적 API 그룹들
    if (normalizedPath.contains('/orders')) return 'orders';
    if (normalizedPath.contains('/accounts')) return 'accounts';
    if (normalizedPath.contains('/withdraws')) return 'withdraws';
    if (normalizedPath.contains('/deposits')) return 'deposits';
    
    // 기본값 (사적 API)
    return 'default';
  }
  
  /// 레거시 호환용 (기존 코드 호환성)
  @Deprecated('Use rateLimitByGroup instead')
  static const int restRateLimitCount = 8; // 사적 API 기준으로 보수적 설정
  static const Duration restRateLimitPeriod = Duration(seconds: 1);

  // ──────────────── WebSocket Configuration ────────────────
  static String _upbitWsUrl = 'wss://api.upbit.com/websocket/v1';
  static String get upbitWsUrl => _upbitWsUrl;
  static const int wsMaxSubscriptionCount = 200;

  // Upbit 권장 타이밍으로 변경 (30s Ping / 60s Pong):
  static const Duration wsPingInterval = Duration(seconds: 30);
  static const Duration wsPongTimeout = Duration(seconds: 60);

  static const int wsMaxRetryCount = 5;
  static const Duration wsInitialBackoff = Duration(seconds: 1);
  static const Duration wsMaxBackoff = Duration(seconds: 30);

  // ──────────────── Aggregation ────────────────
  static const int mergeWindowMs = 1000;
  static const Duration globalResetInterval = Duration(seconds: 30);

  // ──────────────── Dev/Test Flags ────────────────
  static bool useTestDataInDev = false;

  // ──────────────── Trade Filters ────────────────
  static final List<double> _filters = [
    2e6, 5e6, 1e7, 2e7, 5e7,
    1e8, 2e8, 3e8, 4e8, 5e8,
    1e9,
  ];
  static UnmodifiableListView<double> get tradeFilters =>
      UnmodifiableListView(_filters);

  /// Human-readable labels always in sync with `_filters`
  static Map<double, String> get filterNames => Map.unmodifiable({
        for (final f in _filters) f: _formatFilterLabel(f),
      });

  /// Update the trade filters at runtime (ensures positive & sorted)
  static void updateFilters(List<double> newFilters) {
    _filters
      ..clear()
      ..addAll(newFilters.where((f) => f > 0))
      ..sort();
    log.i('[AppConfig] filters updated → $_filters');
  }

  static String _formatFilterLabel(double f) {
    if (f >= 1e8 && f % 1e8 == 0) return '${(f / 1e8).toInt()}억';
    if (f >= 1e7 && f % 1e7 == 0) return '${(f / 1e7).toInt()}천만';
    if (f >= 1e6 && f % 1e6 == 0) return '${(f / 1e6).toInt()}백만';
    return f.toStringAsFixed(0);
  }

  // ──────────────── Candle Timeframes ────────────────
  static const List<int> timeFrames = [
    1, 5, 15, 30, 60, 120, 240, 480, 720, 1440
  ];
  static final Map<int, String> timeFrameNames = Map.unmodifiable({
    1: '1분',
    5: '5분',
    15: '15분',
    30: '30분',
    60: '1시간',
    120: '2시간',
    240: '4시간',
    480: '8시간',
    720: '12시간',
    1440: '1일',
  });

  // ──────────────── Surge Detection ────────────────
  static const double surgeThresholdPercent = 1.1;
  static const Duration surgeWindowDuration = Duration(minutes: 1);
}\n\n// ====== lib/core/bridge/signal_bus.dart ======\n
import 'dart:async';

import '../utils/logger.dart';           // log.d, log.i, log.w, log.e
import '../event/app_event.dart';        // Json typedef

/// Types of signals carried by the bus.
enum SignalEventType { trade, orderBook, notification }

/// Supported exchange platforms.
enum ExchangePlatform { upbit, binance, bybit, bithumb }

/// Global singleton event bus.
/// Dispatches all AppEvent payloads by type & platform.
///
/// ⚠️ Remember to call `SignalBus().dispose()` on app shutdown or via
/// Riverpod's `ref.onDispose` to clean up streams.
class SignalBus {
  SignalBus._();
  static final SignalBus _instance = SignalBus._();
  factory SignalBus() => _instance;

  final StreamController<Json> _globalController = StreamController<Json>.broadcast();
  final Map<SignalEventType, StreamController<Json>> _typeControllers = {};
  final Map<String, StreamController<Json>> _platformControllers = {};
  final StreamController<String> _errorController = StreamController<String>.broadcast();

  /// All events as raw JSON maps.
  Stream<Json> get events => _globalController.stream;

  /// Events of a specific type.
  Stream<Json> eventsOfType(SignalEventType type) =>
      _typeControllers.putIfAbsent(type, () {
        final ctrl = StreamController<Json>.broadcast();
        log.d('SignalBus: Created type controller for $type');
        return ctrl;
      }).stream;

  /// 🆕 타입 안전한 이벤트 스트림 (제네릭)
  Stream<T> eventsOf<T>(SignalEventType type, T Function(Json) converter) =>
      eventsOfType(type).map(converter);

  /// Events of a specific type and platform, cached for efficiency.
  Stream<Json> eventsOfPlatform(SignalEventType type, ExchangePlatform platform) {
    final key = '${type.name}_${platform.name}';
    return _platformControllers.putIfAbsent(key, () {
      final ctrl = StreamController<Json>.broadcast();
      eventsOfType(type)
          .where((m) => (m['platform'] as String? ?? '') == platform.name)
          .listen(
            ctrl.add,
            onError: ctrl.addError,
            onDone: () {
              ctrl.close();
              _platformControllers.remove(key);
              log.d('SignalBus: Closed platform controller for $key');
            },
          );
      log.d('SignalBus: Created platform controller for $key');
      return ctrl;
    }).stream;
  }

  /// 🆕 타입 안전한 플랫폼별 이벤트 스트림
  Stream<T> eventsOfPlatformTyped<T>(
    SignalEventType type,
    ExchangePlatform platform,
    T Function(Json) converter,
  ) => eventsOfPlatform(type, platform).map(converter);

  /// Errors from bus internals.
  Stream<String> get errors => _errorController.stream;

  // ───────────────────────────────────────────────────────────────────────
  // Emitters for raw payloads
  // ───────────────────────────────────────────────────────────────────────

  void fireTrade(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, data, platform);

  void fireOrderBook(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, data, platform);

  void fireNotification(Json data, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, data, platform);

  // ───────────────────────────────────────────────────────────────────────
  // Emitters for AppEvent
  // ───────────────────────────────────────────────────────────────────────

  void fireTradeEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.trade, event.toJson(), platform);

  void fireOrderBookEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.orderBook, event.toJson(), platform);

  void fireNotificationEvent(AppEvent event, {ExchangePlatform platform = ExchangePlatform.upbit}) =>
      _fire(SignalEventType.notification, event.toJson(), platform);

  // ───────────────────────────────────────────────────────────────────────
  // Internal dispatch logic
  // ───────────────────────────────────────────────────────────────────────

  void _fire(SignalEventType type, Json data, ExchangePlatform platform) {
    try {
      final enriched = <String, dynamic>{...data, 'platform': platform.name};

      // Broadcast to global subscribers
      if (!_globalController.isClosed) {
        _globalController.add(enriched);
      } else {
        log.w('SignalBus: Global controller closed, skipping event $type');
      }

      // Type-specific subscribers
      final typeCtrl = _typeControllers[type];
      if (typeCtrl != null && !typeCtrl.isClosed) {
        typeCtrl.add(enriched);
      } else if (typeCtrl != null) {
        log.w('SignalBus: Type controller for $type closed, removing');
        _typeControllers.remove(type);
      }

      // Debug preview (limited to 100 chars)
      final msg = enriched.toString();
      if (msg.length <= 100) {
        log.d('SignalBus: $type @${platform.name} → $msg');
      } else {
        log.d('SignalBus: $type @${platform.name} → ${msg.substring(0, 100)}…');
      }
    } catch (e, st) {
      final errMsg = 'SignalBus error: $e';
      log.e(errMsg, e, st);
      if (!_errorController.isClosed) {
        _errorController.add(errMsg);
      } else {
        log.w('SignalBus: Error controller closed, error not dispatched: $errMsg');
      }
    }
  }

  /// Log current memory status for debugging.
  void logMemoryStatus() {
    log.d('SignalBus Memory Status:');
    log.d('  - Type controllers: ${_typeControllers.length}');
    log.d('  - Platform controllers: ${_platformControllers.length}');
    log.d('  - Global controller active: ${_globalController.hasListener}');
    log.d('  - Error controller active: ${_errorController.hasListener}');
  }

  /// Close all controllers to free resources and log cleanup.
  void dispose() {
    // Close type-specific controllers
    for (final entry in _typeControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed type controller for ${entry.key}');
      }
    }
    _typeControllers.clear();

    // Close platform-specific controllers
    for (final entry in _platformControllers.entries) {
      final ctrl = entry.value;
      if (!ctrl.isClosed) {
        ctrl.close();
        log.d('SignalBus: Closed platform controller for ${entry.key}');
      }
    }
    _platformControllers.clear();

    // Close global and error controllers
    if (!_globalController.isClosed) {
      _globalController.close();
      log.d('SignalBus: Closed global controller');
    }
    if (!_errorController.isClosed) {
      _errorController.close();
      log.d('SignalBus: Closed error controller');
    }

    log.i('SignalBus: fully disposed');
  }
}\n\n// ====== lib/core/network/websocket/ticker_ws_client.dart ======\n
// lib/core/network/websocket/ticker_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// “현재가” 스트림: List<Map<String, dynamic>>
class TickerWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TickerWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'ticker-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'ticker',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/candle_ws_client.dart ======\n
// lib/core/network/websocket/candle_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// “캔들” 스트림: List<Map<String, dynamic>>
/// [timeFrame]: e.g. "1m", "5m", "15m", ...
class CandleWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  CandleWsClient({
    required String timeFrame,
    void Function(WsStatus)? onStatusChange,
  }) : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'candle-$timeFrame-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'candles_$timeFrame',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// “체결” 스트림: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/websocket/base_ws_client.dart ======\n
// lib/core/network/websocket/base_ws_client.dart

import 'dart:async';
import 'dart:convert';

import 'package:web_socket_channel/web_socket_channel.dart';

import '../../config/app_config.dart';
import '../../error/app_exception.dart';
import '../adaptive_backoff.dart';               // AdaptiveBackoff 연동
import '../ws_rate_limiter_interceptor.dart';
import '../../utils/logger.dart';                // ← logger import

typedef DecodeFn<T> = T Function(dynamic json);
typedef EncodeFn = String Function(List<String> symbols);

/// WebSocket connection status notifications.
enum WsStatus {
  connecting,
  connected,
  failed,
  disconnected,
  error,
  reconnecting,
  pongTimeout,
  maxRetryExceeded,
}

/// Common WebSocket client: connect, subscribe, reconnect, emit
class BaseWsClient<T> {
  /// Helper to decode a JSON list (or single object) into a List<Map<String, dynamic>>.
  static List<Map<String, dynamic>> decodeJsonList(dynamic raw) {
    final jsonObj = raw is String ? jsonDecode(raw) : raw;
    final list = jsonObj is List ? jsonObj : [jsonObj];
    return list
        .cast<Map<String, dynamic>>()
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }

  final String url;
  final DecodeFn<T> decode;
  final EncodeFn encodeSubscribe;
  final void Function(WsStatus)? onStatusChange;
  final WsRateLimiter _rateLimiter;
  final AdaptiveBackoffCalculator _backoffCalculator =
      AdaptiveBackoffCalculator();
  final Set<StreamSubscription> _activeSubscriptions = {};
  Timer? _memoryCleanupTimer;

  WebSocketChannel? _channel;
  final _controller = StreamController<T>.broadcast();
  List<String> _symbols = [];
  Timer? _pingTimer;
  Timer? _pongTimer;
  bool _disposed = false;
  bool _reconnecting = false;
  int _retryCount = 0;

  BaseWsClient({
    required this.url,
    required this.decode,
    required this.encodeSubscribe,
    this.onStatusChange,
    WsRateLimiter? rateLimiter,
  }) : _rateLimiter = rateLimiter ?? WsRateLimiter() {
    _startMemoryCleanup();
  }

  /// Start periodic cleanup of inactive subscriptions.
  void _startMemoryCleanup() {
    _memoryCleanupTimer =
        Timer.periodic(const Duration(seconds: 30), (_) {
      _cleanupInactiveSubscriptions();
    });
  }

  /// Clean up paused subscriptions to prevent memory leaks.
  void _cleanupInactiveSubscriptions() {
    final toRemove =
        _activeSubscriptions.where((sub) => sub.isPaused).toList();
    for (final sub in toRemove) {
      sub.cancel();
      _activeSubscriptions.remove(sub);
    }
    if (toRemove.isNotEmpty) {
      log.d('WSClient: Cleaned up ${toRemove.length} inactive subscriptions');
    }
  }

  /// 🔥 재연결 시 기존 구독들 안전하게 정리 (메모리 누수 방지)
  void _cleanupActiveSubscriptions() {
    if (_activeSubscriptions.isNotEmpty) {
      log.d('🧹 기존 구독 ${_activeSubscriptions.length}개 정리 중...');
      
      for (final subscription in _activeSubscriptions) {
        try {
          subscription.cancel();
        } catch (e) {
          log.w('⚠️ 구독 취소 중 에러: $e');
        }
      }
      
      _activeSubscriptions.clear();
      log.d('✅ 구독 정리 완료');
    }
  }

  /// Exposed stream of decoded messages.
  Stream<T> get stream => _controller.stream;

  /// Connect or reconnect with a new set of symbols.
  Future<void> connect(List<String> symbols) async {
    _notify(WsStatus.connecting);
    if (_disposed) return;
    _symbols = List.from(symbols);
    
    // 🔥 재연결 시 기존 구독들 정리 (메모리 누수 방지)
    _cleanupActiveSubscriptions();
    
    await _channel?.sink.close();

    try {
      if (_symbols.length > AppConfig.wsMaxSubscriptionCount) {
        throw const WebSocketException('Subscribe limit exceeded');
      }
      _channel = WebSocketChannel.connect(Uri.parse(url));
      _setupPing();
      _send(encodeSubscribe(_symbols));

      final subscription = _channel!.stream.listen(
        _handleData,
        onDone: _handleDone,
        onError: _handleError,
        cancelOnError: true,
      );
      _activeSubscriptions.add(subscription);

      _retryCount = 0;
      _backoffCalculator.recordSuccess();
      _notify(WsStatus.connected);
      log.i('WS connected to $url (subscriptions: ${_symbols.length})');
    } catch (e, st) {
      log.w('WS connect failed: $e', e, st);
      _backoffCalculator.recordFailure();
      _notify(WsStatus.failed);
      _scheduleReconnect();
    }
  }

  void _handleData(dynamic raw) {
    _pongTimer?.cancel();
    try {
      final text = raw is List<int> ? utf8.decode(raw) : raw.toString();
      final jsonObj = jsonDecode(text);
      final data = decode(jsonObj);
      _controller.add(data);
    } catch (e, st) {
      log.e('WS processing error', e, st);
    }
  }

  void _handleDone() {
    log.i('WS closed by server');
    _notify(WsStatus.disconnected);
    _scheduleReconnect();
  }

  void _handleError(dynamic e) {
    log.e('WS error', e);
    _backoffCalculator.recordFailure();
    _notify(WsStatus.error);
    _scheduleReconnect();
  }

  void _send(String msg) => _rateLimiter.enqueue(() {
        try {
          _channel?.sink.add(msg);
          log.d('WS ▶ $msg');
        } catch (e, st) {
          log.e('WS send error', e, st);
        }
      });

  void _setupPing() {
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _pingTimer =
        Timer.periodic(AppConfig.wsPingInterval, (_) {
      _send(jsonEncode({'type': 'ping'}));
      _pongTimer = Timer(AppConfig.wsPongTimeout, () {
        log.w('Pong timeout, reconnecting');
        _notify(WsStatus.pongTimeout);
        _scheduleReconnect();
      });
    });
    log.d('WS ping/pong timers set');
  }

  /// Schedule reconnection with adaptive backoff.
  void _scheduleReconnect() {
    if (_disposed || _reconnecting) return;
    _reconnecting = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();

    _backoffCalculator
        .calculateBackoff(
          _retryCount,
          AppConfig.wsInitialBackoff,
          AppConfig.wsMaxBackoff,
        )
        .then((delay) {
      if (_disposed) return;
      Future.delayed(delay, () {
        if (_disposed) return;
        if (_retryCount < AppConfig.wsMaxRetryCount) {
          _retryCount++;
          log.i(
            'Reconnect attempt #$_retryCount after ${delay.inMilliseconds}ms',
          );
          _notify(WsStatus.reconnecting);
          connect(_symbols).whenComplete(() => _reconnecting = false);
        } else {
          log.w('Max WS retries exceeded');
          _notify(WsStatus.maxRetryExceeded);
          _retryCount = 0;
          _reconnecting = false;
        }
      });
    });
  }

  void _notify(WsStatus status) => onStatusChange?.call(status);

  /// Dispose resources: timers, subscriptions, channel, controller, and backoff state.
  Future<void> dispose() async {
    _disposed = true;
    _pingTimer?.cancel();
    _pongTimer?.cancel();
    _memoryCleanupTimer?.cancel();

    // 🔥 dispose 시에도 안전하게 정리
    _cleanupActiveSubscriptions();

    _rateLimiter.dispose();
    await _channel?.sink.close();
    await _controller.close();
    _backoffCalculator.recordSuccess(); // reset
    log.i('WSClient disposed');
  }
}\n\n// ====== lib/core/network/websocket/orderbook_ws_client.dart ======\n
// lib/core/network/websocket/orderbook_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// “호가” 스트림: List<Map<String, dynamic>>
class OrderbookWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  OrderbookWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket':
                    'orderbook-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'orderbook',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/core/network/auth_interceptor.dart ======\n
// lib/core/network/auth_interceptor.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// Upbit REST API 호출 시 JWT 방식의 인증 헤더를 붙여줍니다.
/// - payload에 access_key, nonce, (query_hash, query_hash_alg)을 포함해야 합니다.
/// - 알고리즘: HS256
class AuthInterceptor extends Interceptor {
  final String apiKey;
  final String apiSecret;

  AuthInterceptor({required this.apiKey, required this.apiSecret});

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    try {
      final nonce = DateTime.now().millisecondsSinceEpoch.toString();
      final payload = <String, dynamic>{
        'access_key': apiKey,
        'nonce': nonce,
      };

      if (options.queryParameters.isNotEmpty || _hasRequestBody(options)) {
        final raw = options.queryParameters.isNotEmpty
            ? Uri(queryParameters: options.queryParameters).query
            : jsonEncode(options.data);
        payload['query_hash'] = sha512.convert(utf8.encode(raw)).toString();
        payload['query_hash_alg'] = 'SHA512';
      }

      // JWT Header and Payload
      const headerMap = {'alg': 'HS256', 'typ': 'JWT'};
      final headerJson = jsonEncode(headerMap);
      final payloadJson = jsonEncode(payload);
      final headerSeg = _base64UrlEncode(headerJson);
      final payloadSeg = _base64UrlEncode(payloadJson);

      // Signature
      final sigBytes = Hmac(sha256, utf8.encode(apiSecret))
          .convert(utf8.encode('$headerSeg.$payloadSeg'))
          .bytes;
      final sigSeg = base64Url.encode(sigBytes).replaceAll('=', '');

      options.headers['Authorization'] =
          'Bearer $headerSeg.$payloadSeg.$sigSeg';
    } catch (e, st) {
      log.e('AuthInterceptor error', e, st);
      return handler.reject(
        DioException(requestOptions: options, error: e),
      );
    }

    handler.next(options);
  }

  bool _hasRequestBody(RequestOptions options) {
    final data = options.data;
    if (data == null) return false;
    if (data is String) return data.isNotEmpty;
    if (data is Iterable || data is Map) return data.isNotEmpty;
    if (data is FormData) return data.fields.isNotEmpty || data.files.isNotEmpty;
    return true;
  }

  String _base64UrlEncode(String input) =>
      base64Url.encode(utf8.encode(input)).replaceAll('=', '');
}
\n\n// ====== lib/core/network/adaptive_backoff.dart ======\n
// lib/core/network/adaptive_backoff.dart

import 'dart:math' as math;
import 'package:connectivity_plus/connectivity_plus.dart';
import '../utils/logger.dart';

class AdaptiveBackoffCalculator {
  final Connectivity _connectivity = Connectivity();
  int _consecutiveFailures = 0;
  DateTime? _lastFailureTime;
  
  // 네트워크별 기본 지터 계수 (connectivity_plus 연동)
  static const Map<ConnectivityResult, double> _networkMultipliers = {
    ConnectivityResult.wifi: 0.8,      // WiFi는 빠른 재연결
    ConnectivityResult.mobile: 1.2,    // 모바일은 보수적
    ConnectivityResult.ethernet: 0.6,  // 유선은 가장 빠름
    ConnectivityResult.none: 2.0,      // 연결 없음은 매우 보수적
  };

  Future<Duration> calculateBackoff(int attempt, Duration baseDelay, Duration maxDelay) async {
    final connectivityResult = await _connectivity.checkConnectivity();
    final networkMultiplier = _networkMultipliers[connectivityResult] ?? 1.0; // 기본값
    
    final failurePenalty = _calculateFailurePenalty();
    
    final exponentialMs = baseDelay.inMilliseconds * (1 << attempt);
    final cappedMs = math.min(exponentialMs, maxDelay.inMilliseconds);
    
    // 지터 범위 20%로 빠른 재연결 보장
    final jitterRange = cappedMs * 0.2;
    final random = math.Random();
    final adaptiveJitter = random.nextDouble() * jitterRange * networkMultiplier * failurePenalty;
    
    final finalMs = math.max(0, cappedMs + adaptiveJitter.round());
    
    log.d('AdaptiveBackoff: attempt=$attempt, network=$connectivityResult, '
          'base=${cappedMs}ms, jitter=${adaptiveJitter.round()}ms, final=${finalMs}ms');
    
    return Duration(milliseconds: finalMs);
  }

  double _calculateFailurePenalty() {
    if (_lastFailureTime == null) return 1.0;
    
    final timeSinceLastFailure = DateTime.now().difference(_lastFailureTime!);
    if (timeSinceLastFailure > const Duration(minutes: 5)) {
      _consecutiveFailures = 0;
      return 1.0;
    }
    
    // 페널티 상한 1.5배로 조정 (그록의 수정사항 유지)
    return math.min(1.5, 1.0 + (_consecutiveFailures * 0.2));
  }

  void recordFailure() {
    _consecutiveFailures++;
    _lastFailureTime = DateTime.now();
  }

  void recordSuccess() {
    _consecutiveFailures = 0;
    _lastFailureTime = null;
  }
}\n\n// ====== lib/core/network/retry_interceptor.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 429 혹은 5xx 에러에 대해 지수 백오프 + 지터 방식으로 재시도합니다.
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialBackoff;
  final Duration maxBackoff;
  final double jitterFactor;

  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialBackoff = const Duration(milliseconds: 500),
    this.maxBackoff = const Duration(seconds: 5),
    this.jitterFactor = 0.2,
  });

  @override
  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {
    final options = err.requestOptions;
    final retryCount = (options.extra['retry_count'] as int?) ?? 0;
    final status = err.response?.statusCode;

    if (_shouldRetry(err) && retryCount < maxRetries) {
      final next = retryCount + 1;
      options.extra['retry_count'] = next;

      // 429 응답일 경우 서버가 제공하는 헤더 우선 사용
      Duration delay;
      if (status == 429) {
        final retryAfter = err.response?.headers.value('Retry-After');
        if (retryAfter != null) {
          final secs = int.tryParse(retryAfter) ?? 0;
          delay = Duration(seconds: secs);
          log.i('Retry #$next after Retry-After header: ${delay.inSeconds}s');
        } else {
          final remaining = err.response?.headers.value('Remaining-Req');
          if (remaining != null) {
            log.d('Remaining-Req header: $remaining');
          }
          delay = _computeBackoff(next);
        }
      } else {
        // 5xx 에러는 기본 백오프 사용
        delay = _computeBackoff(next);
      }

      log.i('Retry #$next for [${options.method} ${options.path}] in ${delay.inMilliseconds}ms');
      await Future.delayed(delay);

      try {
        final response = await dio.fetch(options);
        return handler.resolve(response);
      } on DioException catch (e) {
        return handler.next(e);
      }
    }

    handler.next(err);
  }

  bool _shouldRetry(DioException err) {
    final status = err.response?.statusCode;
    return err.type == DioExceptionType.badResponse &&
        (status == 429 || (status != null && status >= 500 && status < 600));
  }

  Duration _computeBackoff(int attempt) {
    final expMs = initialBackoff.inMilliseconds * (1 << (attempt - 1));
    final cap = min(expMs, maxBackoff.inMilliseconds);
    final jitter = ((Random().nextDouble() * 2 - 1) * jitterFactor * cap).round();
    final finalMs = max(0, cap + jitter);
    return Duration(milliseconds: finalMs);
  }
}
\n\n// ====== lib/core/network/ws_rate_limiter_interceptor.dart ======\n
// lib/core/network/ws_rate_limiter_interceptor.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import '../utils/logger.dart';

/// Upbit WebSocket 구독 메시지 발행 간 최소 간격 보장 유틸
class WsRateLimiter {
  final Duration minInterval;
  final Queue<VoidCallback> _queue = Queue<VoidCallback>();
  bool _isFlushing = false;
  DateTime _lastSent = DateTime.fromMillisecondsSinceEpoch(0);

  WsRateLimiter({this.minInterval = const Duration(milliseconds: 500)});

  /// 메시지를 큐에 추가하고 즉시 전송 시도
  void enqueue(VoidCallback send) {
    _queue.add(send);
    _flushNext();
  }

  void _flushNext() {
    if (_isFlushing || _queue.isEmpty) return;
    _isFlushing = true;

    final now = DateTime.now();
    final elapsed = now.difference(_lastSent);
    final delay = elapsed >= minInterval ? Duration.zero : minInterval - elapsed;

    Timer(delay, () {
      final send = _queue.removeFirst();
      try {
        send();
        _lastSent = DateTime.now();
        log.d('WsRateLimiter sent, next after \${minInterval.inMilliseconds}ms');
      } catch (e, st) {
        log.e('WsRateLimiter send error', e, st);
      } finally {
        _isFlushing = false;
        if (_queue.isNotEmpty) _flushNext();
      }
    });
  }

  /// 큐를 비우고 사용 중지
  void dispose() {
    _queue.clear();
  }
}
\n\n// ====== lib/core/network/api_client.dart ======\n
// lib/core/network/api_client.dart

import 'dart:async';
import 'dart:collection';
import 'package:dio/dio.dart';
import '../config/app_config.dart';
import '../error/app_exception.dart';
import '../extensions/result.dart';
import '../utils/logger.dart';
import 'auth_interceptor.dart';
import 'retry_interceptor.dart';
import 'logging_interceptor.dart';

typedef Json = Map<String, dynamic>;

/// 🆕 업비트 백서 2025 기준 동적 레이트리밋 관리자
/// Remaining-Req 헤더를 파싱하여 그룹별 실시간 슬롯 계산
class _UpbitDynamicRateLimiter {
  final Map<String, _GroupRateLimiter> _groupLimiters = {};
  final Duration _defaultPeriod = const Duration(seconds: 1);
  
  /// 응답 헤더에서 레이트리밋 정보 업데이트
  /// 형식: "Remaining-Req: group=market; min=900; sec=29"
  void updateFromHeaders(Map<String, List<String>> headers) {
    try {
      final remainingReq = headers['remaining-req']?.first ?? 
                          headers['Remaining-Req']?.first;
      if (remainingReq == null) return;
      
      // 헤더 파싱: group=market; min=900; sec=29
      final parsedInfo = _parseRemainingReqHeader(remainingReq);
      if (parsedInfo != null) {
        _updateGroupLimiter(
          parsedInfo.group, 
          parsedInfo.remaining, 
          Duration(seconds: parsedInfo.windowSec)
        );
        
        if (AppConfig.enableTradeLog) {
          log.i('Rate limit updated: ${parsedInfo.group}=${parsedInfo.remaining} req in ${parsedInfo.windowSec}s');
        }
      }
      
      // Req-Group 헤더도 확인 (그룹 정보만)
      final reqGroup = headers['req-group']?.first ?? 
                      headers['Req-Group']?.first;
      if (reqGroup != null && _groupLimiters[reqGroup] == null) {
        _initializeGroupLimiter(reqGroup);
      }
      
    } catch (e, st) {
      log.w('Failed to parse rate limit headers: $e', e, st);
    }
  }
  
  /// Remaining-Req 헤더 파싱
  _RemainingReqInfo? _parseRemainingReqHeader(String header) {
    try {
      final parts = header.split(';').map((p) => p.trim()).toList();
      String? group;
      int? remaining;
      int? windowSec;
      
      for (final part in parts) {
        final kv = part.split('=');
        if (kv.length != 2) continue;
        
        final key = kv[0].trim().toLowerCase();
        final value = kv[1].trim();
        
        switch (key) {
          case 'group':
            group = value;
            break;
          case 'min':
          case 'remaining':
            remaining = int.tryParse(value);
            break;
          case 'sec':
          case 'window':
            windowSec = int.tryParse(value);
            break;
        }
      }
      
      if (group != null && remaining != null && windowSec != null) {
        return _RemainingReqInfo(group, remaining, windowSec);
      }
    } catch (e) {
      log.w('Failed to parse Remaining-Req header: $header, error: $e');
    }
    return null;
  }
  
  /// 그룹별 레이트리밋 초기화
  void _initializeGroupLimiter(String group) {
    final maxRequests = AppConfig.getRateLimitForGroup(group);
    _groupLimiters[group] = _GroupRateLimiter(
      group: group,
      maxRequests: maxRequests,
      period: _defaultPeriod,
    );
    
    if (AppConfig.enableTradeLog) {
      log.d('Initialized rate limiter for group: $group ($maxRequests rps)');
    }
  }
  
  /// 그룹별 레이트리밋 업데이트 (서버 응답 기반)
  void _updateGroupLimiter(String group, int remaining, Duration window) {
    var limiter = _groupLimiters[group];
    if (limiter == null) {
      _initializeGroupLimiter(group);
      limiter = _groupLimiters[group]!;
    }
    
    // 서버에서 받은 정보로 동적 업데이트
    limiter.updateFromServer(remaining, window);
  }
  
  /// 특정 그룹의 throttle 실행
  Future<void> throttle(String group, String path) async {
    // 그룹 리밋이 없으면 초기화
    if (!_groupLimiters.containsKey(group)) {
      _initializeGroupLimiter(group);
    }
    
    final limiter = _groupLimiters[group]!;
    await limiter.throttle(path);
  }
  
  /// 디버그 정보 제공
  Map<String, dynamic> getDebugInfo() {
    return {
      'activeGroups': _groupLimiters.keys.toList(),
      'groupStats': {
        for (final entry in _groupLimiters.entries)
          entry.key: entry.value.getStats(),
      },
      'timestamp': DateTime.now().toIso8601String(),
    };
  }
  
  /// 리소스 정리
  void dispose() {
    for (final limiter in _groupLimiters.values) {
      limiter.dispose();
    }
    _groupLimiters.clear();
  }
}

/// 헤더 파싱 결과 정보
class _RemainingReqInfo {
  final String group;
  final int remaining;
  final int windowSec;
  
  _RemainingReqInfo(this.group, this.remaining, this.windowSec);
}

/// 개별 그룹의 레이트리밋 관리자
class _GroupRateLimiter {
  final String group;
  int _maxRequests;
  final Duration _period;
  final Queue<DateTime> _timestamps = Queue<DateTime>();
  
  // 서버 기반 동적 정보
  int? _serverRemaining;
  DateTime? _serverUpdateTime;
  Duration? _serverWindow;
  
  _GroupRateLimiter({
    required this.group,
    required int maxRequests,
    required Duration period,
  }) : _maxRequests = maxRequests, _period = period;
  
  /// 서버 응답 기반 업데이트
  void updateFromServer(int remaining, Duration window) {
    _serverRemaining = remaining;
    _serverUpdateTime = DateTime.now();
    _serverWindow = window;
    
    // 서버 정보가 더 제한적이면 클라이언트 제한도 조정
    if (remaining < _maxRequests) {
      final adjustedMax = (remaining * 0.9).floor(); // 10% 여유
      if (adjustedMax > 0 && adjustedMax < _maxRequests) {
        log.i('Adjusting rate limit for $group: $_maxRequests → $adjustedMax (server: $remaining)');
        _maxRequests = adjustedMax;
      }
    }
  }
  
  /// throttle 실행
  Future<void> throttle(String path) async {
    final now = DateTime.now();
    
    // 서버 정보 기반 추가 체크
    if (_shouldWaitForServerLimit(now)) {
      final waitTime = _calculateServerWaitTime(now);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for server rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
      }
    }
    
    // 클라이언트 사이드 레이트리밋
    _cleanOldTimestamps(now);
    
    if (_timestamps.length >= _maxRequests) {
      final oldestTime = _timestamps.first;
      final waitTime = _period - now.difference(oldestTime);
      if (waitTime > Duration.zero) {
        if (AppConfig.enableTradeLog) {
          log.d('Waiting ${waitTime.inMilliseconds}ms for client rate limit (group: $group)');
        }
        await Future.delayed(waitTime);
        _cleanOldTimestamps(DateTime.now());
      }
    }
    
    _timestamps.addLast(DateTime.now());
  }
  
  /// 서버 제한 대기 필요 여부
  bool _shouldWaitForServerLimit(DateTime now) {
    if (_serverRemaining == null || _serverUpdateTime == null || _serverWindow == null) {
      return false;
    }
    
    // 서버 정보가 5분 이상 오래됐으면 무시
    if (now.difference(_serverUpdateTime!).inMinutes > 5) {
      return false;
    }
    
    return _serverRemaining! <= 5; // 서버 잔여 요청이 5개 이하
  }
  
  /// 서버 기반 대기 시간 계산
  Duration _calculateServerWaitTime(DateTime now) {
    if (_serverUpdateTime == null || _serverWindow == null) {
      return Duration.zero;
    }
    
    final elapsed = now.difference(_serverUpdateTime!);
    final remaining = _serverWindow! - elapsed;
    
    return remaining > Duration.zero ? remaining : Duration.zero;
  }
  
  /// 오래된 타임스탬프 정리
  void _cleanOldTimestamps(DateTime now) {
    while (_timestamps.isNotEmpty && 
           now.difference(_timestamps.first) > _period) {
      _timestamps.removeFirst();
    }
  }
  
  /// 통계 정보
  Map<String, dynamic> getStats() {
    return {
      'group': group,
      'maxRequests': _maxRequests,
      'period': _period.inSeconds,
      'currentRequests': _timestamps.length,
      'serverRemaining': _serverRemaining,
      'serverLastUpdate': _serverUpdateTime?.toIso8601String(),
      'availableSlots': _maxRequests - _timestamps.length,
    };
  }
  
  void dispose() {
    _timestamps.clear();
  }
}

/// In-memory cache entry with timestamp.
class _MemCacheEntry<T> {
  final T data;
  final DateTime ts;
  _MemCacheEntry(this.data) : ts = DateTime.now();

  bool fresh(Duration dur) => DateTime.now().difference(ts) < dur;
}

/// Simple LRU cache based on insertion order, with a maxEntries limit.
class _MemCache {
  final int maxEntries;
  final Map<String, _MemCacheEntry<dynamic>> _box;

  _MemCache({this.maxEntries = 100}) : _box = <String, _MemCacheEntry<dynamic>>{};

  T? get<T>(String key, Duration dur) {
    final entry = _box[key];
    if (entry == null || !entry.fresh(dur)) return null;
    return entry.data as T;
  }

  void put<T>(String key, T data) {
    if (_box.length >= maxEntries) {
      final oldestKey = _box.keys.first;
      _box.remove(oldestKey);
    }
    _box[key] = _MemCacheEntry<T>(data);
  }

  void invalidate(String key) => _box.remove(key);

  void clear() => _box.clear();
}

/// Converts a query map into a stable, sorted query string.
/// Silently skips values that cannot be represented.
String _stableQueryString(Json? query) {
  if (query == null || query.isEmpty) return '';
  try {
    final entries = query.entries
      .where((e) => e.value != null)
      .toList()
      ..sort((a, b) => a.key.compareTo(b.key));
    final params = <String, String>{};
    for (final e in entries) {
      final v = e.value;
      if (v is List) {
        params[e.key] = v.join(',');
      } else {
        params[e.key] = v.toString();
      }
    }
    return Uri(queryParameters: params).query;
  } catch (e, st) {
    log.e('StableQueryString failed', e, st);
    return '';
  }
}

/// 🆕 응답 헤더에서 레이트리밋 정보를 파싱하는 인터셉터
class _RateLimitResponseInterceptor extends Interceptor {
  final _UpbitDynamicRateLimiter rateLimiter;
  
  _RateLimitResponseInterceptor(this.rateLimiter);
  
  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // 업비트 응답 헤더에서 레이트리밋 정보 업데이트
    rateLimiter.updateFromHeaders(response.headers.map);
    handler.next(response);
  }
}

/// 🔥 완전히 재구현된 ApiClient - 업비트 백서 100% 준수
/// - 그룹별 동적 레이트리밋 (공개 30rps / 사적 8rps)
/// - Remaining-Req 헤더 실시간 파싱
/// - 서버 응답 기반 동적 슬롯 조정
class ApiClient {
  final Dio _dio;
  final _MemCache _cache;
  final _UpbitDynamicRateLimiter _rateLimiter;

  /// [apiKey], [apiSecret] 는 Upbit Open API 자격증명
  ApiClient({
    Dio? dio,
    required String apiKey,
    required String apiSecret,
    int cacheSize = 100,
  })  : _dio = dio ?? Dio(),
        _cache = _MemCache(maxEntries: cacheSize),
        _rateLimiter = _UpbitDynamicRateLimiter() {
    _dio.interceptors.addAll([
      AuthInterceptor(apiKey: apiKey, apiSecret: apiSecret),
      RetryInterceptor(dio: _dio),
      LoggingInterceptor(),
      _RateLimitResponseInterceptor(_rateLimiter), // 🆕 동적 레이트리밋 인터셉터
    ]);
  }

  /// [method]: GET, POST 등
  /// [path]: 전체 URL 또는 baseUrl 이후 경로
  /// [query]: URL 쿼리 파라미터
  /// [body]: JSON 바디
  /// [cacheDur]: null이 아닐 때 캐시 사용 (기간 지정)
  /// [rateLimitGroup]: 수동 그룹 지정 (선택적)
  Future<Result<R, NetworkException>> request<R>({
    required String method,
    required String path,
    Json? query,
    Json? body,
    Duration? cacheDur,
    String? rateLimitGroup,
  }) async {
    // 🔥 업비트 백서 기준 그룹별 동적 레이트리밋 적용
    final group = rateLimitGroup ?? AppConfig.getGroupFromPath(path);
    await _rateLimiter.throttle(group, path);

    String? cacheKey;
    if (cacheDur != null) {
      final qstr = _stableQueryString(query);
      cacheKey = '$method|$path|$qstr';
      final cached = _cache.get<R>(cacheKey, cacheDur);
      if (cached != null) {
        return Ok(cached);
      }
    }

    try {
      final response = await _dio.request<R>(
        path,
        queryParameters: query,
        data: body,
        options: Options(method: method),
      );

      final data = response.data;
      if (cacheKey != null && data != null) {
        _cache.put<R>(cacheKey, data as R);
      }

      return Ok(data as R);
    } on DioException catch (dioErr) {
      return Err(NetworkException.fromDio(dioErr));
    } catch (e, st) {
      log.e('ApiClient unexpected error', e, st);
      final ex = e is Exception ? e : Exception(e.toString());
      return Err(NetworkException(e.toString(), originalException: ex));
    }
  }
  
  /// 🆕 레이트리밋 디버그 정보 조회
  Map<String, dynamic> getRateLimitDebugInfo() {
    return _rateLimiter.getDebugInfo();
  }
  
  /// 🆕 리소스 정리
  void dispose() {
    _rateLimiter.dispose();
    _cache.clear();
  }
}\n\n// ====== lib/core/network/logging_interceptor.dart ======\n
// lib/core/network/logging_interceptor.dart

import 'dart:convert';
import 'package:dio/dio.dart';
import '../utils/logger.dart';

/// 모든 REST 요청과 응답, 오류를 로깅합니다.
/// 🔒 보안: access_key, signature 등 민감 정보 자동 마스킹
class LoggingInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // 🔒 URL 보안 마스킹
    final secureUri = _sanitizeUri(options.uri);
    log.i('--> ${options.method} $secureUri');
    
    // 🔒 헤더 보안 마스킹 (Authorization 헤더)
    if (options.headers.containsKey('Authorization')) {
      log.d('Headers: Authorization: Bearer ***[MASKED]***');
    }
    
    if (options.data != null && options.data is! String) {
      try {
        final sanitizedData = _sanitizeRequestData(options.data);
        log.d('Request Data:\n${const JsonEncoder.withIndent('  ').convert(sanitizedData)}');
      } catch (e, st) {
        log.d('Request Data serialization failed', e, st);
      }
    }
    handler.next(options);
  }

  @override
  void onResponse(Response response, ResponseInterceptorHandler handler) {
    // 🔒 URL 보안 마스킹
    final secureUri = _sanitizeUri(response.requestOptions.uri);
    log.i('<-- ${response.statusCode} $secureUri');
    
    final text = response.data is String
        ? response.data as String
        : response.data.toString();
    if (text.isNotEmpty) {
      log.d(text.length > 500 ? '${text.substring(0, 500)}...' : text);
    }
    handler.next(response);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) {
    // 🔒 URL 보안 마스킹
    final secureUri = _sanitizeUri(err.requestOptions.uri);
    log.e('<-- Error ${err.response?.statusCode} $secureUri', err, err.stackTrace);
    handler.next(err);
  }

  /// 🔒 URI에서 민감 정보 마스킹
  String _sanitizeUri(Uri uri) {
    final uriString = uri.toString();
    return uriString
        .replaceAll(RegExp(r'access_key=[^&?#]+'), 'access_key=***')
        .replaceAll(RegExp(r'signature=[^&?#]+'), 'signature=***')
        .replaceAll(RegExp(r'nonce=[^&?#]+'), 'nonce=***')
        .replaceAll(RegExp(r'api_key=[^&?#]+'), 'api_key=***')
        .replaceAll(RegExp(r'secret=[^&?#]+'), 'secret=***');
  }

  /// 🔒 요청 데이터에서 민감 정보 마스킹
  dynamic _sanitizeRequestData(dynamic data) {
    if (data is Map<String, dynamic>) {
      final sanitized = <String, dynamic>{};
      for (final entry in data.entries) {
        final key = entry.key.toLowerCase();
        if (_isSensitiveKey(key)) {
          sanitized[entry.key] = '***[MASKED]***';
        } else {
          sanitized[entry.key] = _sanitizeRequestData(entry.value);
        }
      }
      return sanitized;
    } else if (data is List) {
      return data.map((item) => _sanitizeRequestData(item)).toList();
    }
    return data;
  }

  /// 🔒 민감한 키 판별
  bool _isSensitiveKey(String key) {
    const sensitiveKeys = {
      'access_key', 'accesskey', 'api_key', 'apikey',
      'secret', 'signature', 'nonce', 'password', 
      'token', 'auth', 'authorization'
    };
    return sensitiveKeys.contains(key);
  }
}\n\n// ====== lib/core/navigation/app_router.dart ======\n
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:firebase_messaging/firebase_messaging.dart';

import '../config/app_config.dart';
import '../di/app_providers.dart';
import '../../shared/widgets/notification_service.dart';
import '../../presentation/pages/main_page.dart'; // 🆕 MainPage 사용

/// 🗑️ 개별 라우트 enum 제거 (이제 MainPage에서 관리)
// enum AppRoute는 더 이상 필요 없음

class AppRouter {
  final WidgetRef ref;
  final GlobalKey<NavigatorState> navigatorKey;
  late final GoRouter router;

  AppRouter(this.ref, this.navigatorKey) {
    router = GoRouter(
      navigatorKey: navigatorKey,
      initialLocation: '/', // 메인 페이지로 시작
      debugLogDiagnostics: AppConfig.isDebugMode,
      routes: [
        // 🆕 단일 메인 라우트 (PageView 기반)
        GoRoute(
          path: '/',
          name: 'main',
          builder: (context, state) => const MainPage(),
        ),
        
        // 🔧 필요시 추가 라우트들 (설정, 상세 페이지 등)
        // GoRoute(
        //   path: '/detail/:id',
        //   name: 'detail',
        //   builder: (context, state) => DetailPage(id: state.params['id']!),
        // ),
      ],
    );
  }

  /// 🔧 Firebase 리스너 설정 (NotificationService에 위임)
  void setupFCMListeners() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.setupFirebaseListeners(navigatorKey);
  }

  /// 🔧 리소스 정리 (NotificationService에 위임)
  void dispose() {
    final notificationService = ref.read(notificationServiceProvider);
    notificationService.dispose();
  }
}\n\n// ====== lib/core/utils/date_time.dart ======\n
import 'package:intl/intl.dart';

/// DateTime extension utilities for formatting and comparison.
extension DateTimeX on DateTime {
  /// `2024-05-17 22:05:01` → `22:05:01`
  String hhmmss() => DateFormat('HH:mm:ss').format(this);

  /// `2024-05-17` 형식의 날짜 문자열 반환
  String yyyyMMdd() => DateFormat('yyyy-MM-dd').format(this);

  /// `22:05` 형식의 시간 문자열 반환
  String hhmm() => DateFormat('HH:mm').format(this);

  /// `2024-05-17 22:05` 형식의 날짜+시간 문자열 반환
  String yyyyMMddhhmm() => DateFormat('yyyy-MM-dd HH:mm').format(this);

  /// 현재 시간과의 차이를 사람이 읽기 쉬운 형태로 표시
  /// 예: '방금 전', '3분 전', '2시간 전', '어제', '3일 전', '2주 전', '5개월 전', '1년 전'
  String timeAgo() {
    final now = DateTime.now();
    final diff = now.difference(this);

    if (diff.inSeconds < 60) return '방금 전';
    if (diff.inMinutes < 60) return '${diff.inMinutes}분 전';
    if (diff.inHours < 24) return '${diff.inHours}시간 전';
    if (diff.inDays < 2) return '어제';
    if (diff.inDays < 7) return '${diff.inDays}일 전';
    if (diff.inDays < 30) return '${(diff.inDays / 7).floor()}주 전';
    if (diff.inDays < 365) return '${(diff.inDays / 30).floor()}개월 전';
    return '${(diff.inDays / 365).floor()}년 전';
  }

  /// UTC 밀리초(ms)를 로컬 DateTime으로 변환
  static DateTime fromEpochMs(int ms) =>
      DateTime.fromMillisecondsSinceEpoch(ms, isUtc: true).toLocal();

  /// ISO 8601 문자열을 로컬 DateTime으로 파싱
  static DateTime parseIso8601(String iso) =>
      DateTime.parse(iso).toLocal();

  /// 동일한 날짜인지 확인
  bool isSameDay(DateTime other) =>
      year == other.year && month == other.month && day == other.day;

  /// 오늘인지 확인
  bool get isToday => isSameDay(DateTime.now());

  /// 어제인지 확인
  bool get isYesterday =>
      isSameDay(DateTime.now().subtract(const Duration(days: 1)));
}
\n\n// ====== lib/core/utils/logger.dart ======\n
import 'package:logger/logger.dart';
import '../config/app_config.dart';

/// 글로벌 Logger 인스턴스
/// - 개발 모드: AppConfig.logLevel에 따라 동적 조절
/// - 프로덕션모드: warning 이상 자동
final Logger log = Logger(
  printer: PrettyPrinter(
    methodCount: 0,      // 스택 트레이스 라인 수
    errorMethodCount: 5, // 오류 시 표시할 스택 트레이스 라인 수
    lineLength: 120,     // 로그 한 줄 최대 길이
    colors: true,        // 컬러 출력 (터미널)
    printTime: true,     // 타임스탬프 포함
  ),
  level: AppConfig.logLevel, // 🔥 환경변수로 동적 조절 가능
);\n\n// ====== lib/core/utils/app_life_cycle_manager.dart ======\n
// lib/core/utils/app_life_cycle_manager.dart
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../utils/logger.dart';

/// 앱 라이프사이클과 주기적인 작업을 관리합니다.
/// 🎯 Hive Box는 백그라운드에서도 유지 (닫지 않음)
/// 🆕 외부 접근을 위한 풀 기능 API 제공
class AppLifecycleManager extends WidgetsBindingObserver {
  final Ref ref;
  Timer? _globalTimer;
  
  // 🆕 외부 접근을 위한 상태 관리
  DateTime? _appStartTime;
  DateTime? _lastResumeTime;
  DateTime? _lastPauseTime;
  int _resumeCount = 0;
  int _pauseCount = 0;
  Duration _totalForegroundTime = Duration.zero;
  Duration _totalBackgroundTime = Duration.zero;
  AppLifecycleState _currentState = AppLifecycleState.resumed;
  
  // 🆕 라이프사이클 리스너들
  final List<void Function(AppLifecycleState)> _lifecycleListeners = [];
  
  // 🆕 성능 통계
  final Map<String, dynamic> _performanceStats = {};

  AppLifecycleManager(this.ref) {
    _appStartTime = DateTime.now();
    _lastResumeTime = _appStartTime;
    WidgetsBinding.instance.addObserver(this);
    _startGlobalTimer();
    log.i('🎬 AppLifecycleManager 초기화 완료');
  }

  // ══════════════════════════════════════════════════════════
  // 🆕 외부 접근 API들
  // ══════════════════════════════════════════════════════════

  /// 🆕 현재 앱 상태 조회
  AppLifecycleState get currentState => _currentState;

  /// 🆕 앱 시작 시간
  DateTime? get appStartTime => _appStartTime;

  /// 🆕 앱 가동 시간 (업타임)
  Duration get uptime {
    if (_appStartTime == null) return Duration.zero;
    return DateTime.now().difference(_appStartTime!);
  }

  /// 🆕 포그라운드 총 시간
  Duration get totalForegroundTime {
    var total = _totalForegroundTime;
    if (_currentState == AppLifecycleState.resumed && _lastResumeTime != null) {
      total += DateTime.now().difference(_lastResumeTime!);
    }
    return total;
  }

  /// 🆕 백그라운드 총 시간
  Duration get totalBackgroundTime {
    var total = _totalBackgroundTime;
    if (_currentState == AppLifecycleState.paused && _lastPauseTime != null) {
      total += DateTime.now().difference(_lastPauseTime!);
    }
    return total;
  }

  /// 🆕 이벤트 카운터들
  int get resumeCount => _resumeCount;
  int get pauseCount => _pauseCount;

  /// 🆕 마지막 상태 변경 시간
  DateTime? get lastStateChangeTime {
    switch (_currentState) {
      case AppLifecycleState.resumed:
        return _lastResumeTime;
      case AppLifecycleState.paused:
        return _lastPauseTime;
      default:
        return null;
    }
  }

  /// 🆕 라이프사이클 리스너 추가
  void addLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.add(listener);
    log.d('🎧 라이프사이클 리스너 추가됨 (총 ${_lifecycleListeners.length}개)');
  }

  /// 🆕 라이프사이클 리스너 제거
  void removeLifecycleListener(void Function(AppLifecycleState) listener) {
    _lifecycleListeners.remove(listener);
    log.d('🎧 라이프사이클 리스너 제거됨 (총 ${_lifecycleListeners.length}개)');
  }

  /// 🆕 수동 새로고침/정리 작업 강제 실행
  void forceRefresh() {
    log.i('🔄 수동 새로고침 실행');
    _performPeriodicTasks();
  }

  /// 🆕 메모리 정리 강제 실행
  void forceCleanup() {
    log.i('🧹 수동 메모리 정리 실행');
    _performMemoryCleanup();
  }

  /// 🆕 성능 통계 업데이트
  void updatePerformanceStats(String key, dynamic value) {
    _performanceStats[key] = value;
    _performanceStats['lastUpdated'] = DateTime.now().toIso8601String();
  }

  /// 🆕 메모리 상태 조회
  Map<String, dynamic> getMemoryStats() {
    return {
      'uptime': uptime.toString(),
      'foregroundTime': totalForegroundTime.toString(),
      'backgroundTime': totalBackgroundTime.toString(),
      'resumeCount': resumeCount,
      'pauseCount': pauseCount,
      'currentState': _currentState.name,
      'lastStateChange': lastStateChangeTime?.toIso8601String(),
      'platformMemoryUsage': _getPlatformMemoryInfo(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// 🆕 성능 통계 조회
  Map<String, dynamic> getPerformanceStats() {
    return Map.from(_performanceStats)
      ..addAll({
        'uptime': uptime.inSeconds,
        'foregroundTimeSeconds': totalForegroundTime.inSeconds,
        'backgroundTimeSeconds': totalBackgroundTime.inSeconds,
        'resumeCount': resumeCount,
        'pauseCount': pauseCount,
        'currentState': _currentState.name,
      });
  }

  /// 🆕 전체 시스템 상태 조회 (디버깅용)
  Map<String, dynamic> getSystemStatus() {
    return {
      'app': getMemoryStats(),
      'performance': getPerformanceStats(),
      'platform': {
        'os': Platform.operatingSystem,
        'version': Platform.operatingSystemVersion,
        'locale': Platform.localeName,
      },
      'listeners': {
        'lifecycleListeners': _lifecycleListeners.length,
      },
      'timers': {
        'globalTimerActive': _globalTimer?.isActive ?? false,
      },
    };
  }

  // ══════════════════════════════════════════════════════════
  // 기존 내부 로직들
  // ══════════════════════════════════════════════════════════

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    final previousState = _currentState;
    _currentState = state;
    
    _updateStateTimes(previousState, state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        log.i('➡️ 앱이 포그라운드로 돌아왔습니다.');
        _resumeCount++;
        _lastResumeTime = DateTime.now();
        _startGlobalTimer();
        _onAppResumed();
        break;
        
      case AppLifecycleState.paused:
        log.i('⏸️ 앱이 백그라운드로 이동했습니다.');
        _pauseCount++;
        _lastPauseTime = DateTime.now();
        _stopGlobalTimer();
        _onAppPaused();
        break;
        
      case AppLifecycleState.detached:
        log.i('🔚 앱이 종료되었습니다.');
        _onAppDetached();
        break;
        
      case AppLifecycleState.inactive:
        log.d('😴 앱이 비활성 상태입니다.');
        break;
        
      case AppLifecycleState.hidden:
        log.d('🫥 앱이 숨김 상태입니다.');
        break;
    }
    
    // 🆕 외부 리스너들에게 알림
    _notifyLifecycleListeners(state);
  }

  /// 🆕 상태 전환 시간 업데이트
  void _updateStateTimes(AppLifecycleState from, AppLifecycleState to) {
    final now = DateTime.now();
    
    if (from == AppLifecycleState.resumed && _lastResumeTime != null) {
      _totalForegroundTime += now.difference(_lastResumeTime!);
    } else if (from == AppLifecycleState.paused && _lastPauseTime != null) {
      _totalBackgroundTime += now.difference(_lastPauseTime!);
    }
  }

  /// 🆕 라이프사이클 리스너들에게 알림
  void _notifyLifecycleListeners(AppLifecycleState state) {
    for (final listener in _lifecycleListeners) {
      try {
        listener(state);
      } catch (e, st) {
        log.e('라이프사이클 리스너 실행 중 오류', e, st);
      }
    }
  }

  /// 전역 타이머 시작
  void _startGlobalTimer() {
    if (_globalTimer == null || !_globalTimer!.isActive) {
      _globalTimer = Timer.periodic(const Duration(seconds: 30), (_) {
        _performPeriodicTasks();
      });
      log.i('⏰ 전역 타이머 시작: 30초 간격');
    }
  }

  /// 전역 타이머 중지
  void _stopGlobalTimer() {
    _globalTimer?.cancel();
    _globalTimer = null;
    log.d('⏹️ 전역 타이머 중지');
  }

  /// 주기적 작업 실행
  void _performPeriodicTasks() {
    log.d('🔄 전역 타이머: 주기적 작업 실행');
    
    // 여기에 주기적으로 실행할 작업들 추가
    // 예: 메모리 정리, 상태 체크, 백그라운드 동기화 등
    
    // 예시: 메모리 사용량 체크 (디버그 모드에서만)
    _checkMemoryUsage();
    
    // 🆕 성능 통계 업데이트
    updatePerformanceStats('lastPeriodicTaskRun', DateTime.now().toIso8601String());
  }

  /// 앱이 포그라운드로 돌아왔을 때
  void _onAppResumed() {
    log.i('📦 Hive Box 유지 - 백그라운드에서도 데이터 보존됨');
    
    // 포그라운드 복귀 시 필요한 작업들
    // 예: 연결 상태 확인, 데이터 새로고침 등
  }

  /// 앱이 백그라운드로 이동했을 때
  void _onAppPaused() {
    log.i('💾 백그라운드 진입 - 중요 데이터 보존 중');
    
    // 백그라운드 진입 시 필요한 작업들
    // 예: 임시 데이터 저장, 연결 정리 등
  }

  /// 앱이 완전히 종료될 때
  void _onAppDetached() {
    log.i('🧹 앱 종료 - 최종 정리 작업 수행');
    dispose();
  }

  /// 메모리 사용량 체크 (디버그용)
  void _checkMemoryUsage() {
    // 실제 구현은 플랫폼별로 다를 수 있음
    log.d('🧠 메모리 상태 체크 (개발 중)');
    
    // 🆕 플랫폼별 메모리 정보 수집
    final memInfo = _getPlatformMemoryInfo();
    updatePerformanceStats('memoryInfo', memInfo);
  }

  /// 🆕 메모리 정리 실행
  void _performMemoryCleanup() {
    // 실제 메모리 정리 로직
    log.i('🧹 메모리 정리 실행');
    
    // 예시: 가비지 컬렉션 강제 실행 (Dart에서는 제한적)
    // System.gc() 같은 것은 없지만, 불필요한 참조 정리 등을 할 수 있음
  }

  /// 🆕 플랫폼별 메모리 정보 수집
  Map<String, dynamic> _getPlatformMemoryInfo() {
    try {
      return {
        'platform': Platform.operatingSystem,
        'availableProcessors': Platform.numberOfProcessors,
        'timestamp': DateTime.now().toIso8601String(),
        // 실제 메모리 정보는 플랫폼 채널을 통해 구현 가능
        'note': 'Platform memory info implementation needed'
      };
    } catch (e) {
      return {'error': e.toString()};
    }
  }

  /// 정리 작업
  void dispose() {
    _stopGlobalTimer();
    WidgetsBinding.instance.removeObserver(this);
    _lifecycleListeners.clear();
    log.i('🧹 AppLifecycleManager 정리 완료');
  }
}

/// AppLifecycleManager 프로바이더
final appLifecycleManagerProvider = Provider<AppLifecycleManager>((ref) {
  final manager = AppLifecycleManager(ref);
  ref.onDispose(() => manager.dispose());
  return manager;
});\n\n// ====== lib/core/extensions/result.dart ======\n
import 'package:meta/meta.dart';
import '../error/app_exception.dart';

/// Either 스타일의 결과 타입.
///
/// - `Ok<T, E>`: 성공 시 데이터를 담습니다.
/// - `Err<T, E>`: 실패 시 예외를 담습니다.
@immutable
sealed class Result<T, E extends AppException> {
  const Result();

  /// 성공/실패에 따라 분기 처리합니다.
  R when<R>({
    required R Function(T value) ok,
    required R Function(E error) err,
  }) {
    if (this is Ok<T, E>) {
      return ok((this as Ok<T, E>).value);
    } else {
      return err((this as Err<T, E>).error);
    }
  }

  /// 성공 여부
  bool get isOk => this is Ok<T, E>;

  /// 실패 여부
  bool get isErr => this is Err<T, E>;

  /// 성공 값 (없으면 null)
  T? get valueOrNull => isOk ? (this as Ok<T, E>).value : null;

  /// 실패 예외 (없으면 null)
  E? get errorOrNull => isErr ? (this as Err<T, E>).error : null;

  /// 성공 값을 매핑합니다.
  Result<U, E> map<U>(U Function(T value) f) {
    if (this is Ok<T, E>) {
      return Ok<U, E>(f((this as Ok<T, E>).value));
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  /// 실패 예외를 다른 타입으로 매핑합니다.
  /// 성공 시에도 새로운 에러 타입 F 를 사용하도록 합니다.
  Result<T, F> mapErr<F extends AppException>(F Function(E error) f) {
    if (this is Err<T, E>) {
      final err = (this as Err<T, E>).error;
      return Err<T, F>(f(err));
    }
    return Ok<T, F>((this as Ok<T, E>).value);
  }

  /// 성공 시 비동기 후속 작업을 수행합니다.
  Future<Result<U, E>> thenAsync<U>(Future<U> Function(T value) f) async {
    if (this is Ok<T, E>) {
      final T value = (this as Ok<T, E>).value;
      try {
        final u = await f(value);
        return Ok<U, E>(u);
      } on AppException catch (e) {
        final E errVal = e is E ? e : AppException(e.message) as E;
        return Err<U, E>(errVal);
      } catch (e) {
        final E errVal = AppException(e.toString()) as E;
        return Err<U, E>(errVal);
      }
    } else {
      return Err<U, E>((this as Err<T, E>).error);
    }
  }

  @override
  String toString() {
    if (this is Ok<T, E>) {
      return 'Ok(${(this as Ok<T, E>).value})';
    } else {
      return 'Err(${(this as Err<T, E>).error})';
    }
  }
}

/// 성공 결과를 담습니다.
class Ok<T, E extends AppException> extends Result<T, E> {
  final T value;
  const Ok(this.value);
}

/// 실패 결과를 담습니다.
class Err<T, E extends AppException> extends Result<T, E> {
  final E error;
  const Err(this.error);
}
\n\n// ====== lib/core/error/app_exception.dart ======\n
// lib/core/error/app_exception.dart

import 'package:dio/dio.dart';

/// 최상위 앱 예외
/// - 모든 커스텀 예외는 이 클래스를 상속해주세요.
class AppException implements Exception {
  /// 사용자에게 노출할 메시지
  final String message;

  /// 내부 로깅 또는 식별용 코드 (nullable)
  final String? code;

  /// HTTP 상태 코드 등 추가 상태 정보
  final int? statusCode;

  /// 원본 예외(있는 경우)
  final Exception? originalException;

  const AppException(
    this.message, {
    this.code,
    this.statusCode,
    this.originalException,
  });

  @override
  String toString() {
    final parts = <String>[];
    if (code != null) parts.add('code: $code');
    if (statusCode != null) parts.add('status: $statusCode');
    parts.add('message: $message');
    return 'AppException(${parts.join(', ')})';
  }
}

/// REST/HTTP 호출 중 발생한 예외
class NetworkException extends AppException {
  const NetworkException(
    String message, {
    String? code,
    int? statusCode,
    Exception? originalException,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
          originalException: originalException,
        );

  /// DioException → NetworkException 변환 헬퍼
  factory NetworkException.fromDio(DioException dioError) {
    final msg = dioError.message ?? dioError.toString();
    return NetworkException(
      msg,
      code: dioError.response?.statusMessage,
      statusCode: dioError.response?.statusCode,
      originalException: dioError,
    );
  }
}

/// WebSocket 연결/통신 중 발생한 예외
class WebSocketException extends AppException {
  /// WS 서버가 보낸 이유 문자열 (nullable)
  final String? reason;

  const WebSocketException(
    String message, {
    this.reason,
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );

  @override
  String toString() {
    final parts = <String>[];
    if (reason != null) parts.add('reason: $reason');
    parts.add('message: $message');
    return 'WebSocketException(${parts.join(', ')})';
  }
}

/// 서버로부터 Rate Limit(HTTP 429 등) 응답을 받았을 때
class RateLimitException extends AppException {
  /// 재시도까지 대기해야 할 시간
  final Duration retryAfter;

  const RateLimitException(
    String message, {
    required this.retryAfter,
    String? code,
    int? statusCode,
  }) : super(
          message,
          code: code,
          statusCode: statusCode,
        );

  @override
  String toString() =>
      'RateLimitException(retryAfter: ${retryAfter.inSeconds}s, message: $message)';
}

/// JSON 파싱 또는 데이터 변환 중 발생한 예외
class DataParsingException extends AppException {
  const DataParsingException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// 인메모리 캐시에서 키를 찾지 못했을 때
class CacheMissException extends AppException {
  const CacheMissException([String message = 'Cache miss'])
      : super(message);
}

// ──────────────────────────────────────────────────────────────────────────
// 도메인 특화 예외
// ──────────────────────────────────────────────────────────────────────────

/// 체결(Trade) 데이터 유효성 검사 오류
class TradeException extends AppException {
  const TradeException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// 호가(Order Book) 데이터 오류
class OrderBookException extends AppException {
  const OrderBookException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// 캔들(Candle) 데이터 파싱 오류
class CandleException extends DataParsingException {
  const CandleException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}

/// 현재가(Ticker) 데이터 파싱 오류
class TickerException extends DataParsingException {
  const TickerException(
    String message, {
    Exception? originalException,
  }) : super(
          message,
          originalException: originalException,
        );
}
\n\n// ====== lib/core/event/app_event.dart ======\n
// lib/core/event/app_event.dart

import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';

typedef Json = Map<String, dynamic>;

/// 애플리케이션 전역 이벤트의 베이스 클래스
/// - id     : UUID v4
/// - ts     : UTC 밀리초 타임스탬프
/// - payload: 자유 형태 JSON
class AppEvent extends Equatable {
  /// 고유 ID (UUID v4)
  final String id;

  /// UTC 밀리초 타임스탬프
  final int ts;

  /// 페이로드 데이터 (불변)
  final Json payload;

  const AppEvent({
    required this.id,
    required this.ts,
    required this.payload,
  });

  /// 현재 시각을 기준으로 id·ts를 자동 생성합니다.
  factory AppEvent.now(Json payload) {
    final nowUtcMs = DateTime.now().toUtc().millisecondsSinceEpoch;
    return AppEvent(
      id: const Uuid().v4(),
      ts: nowUtcMs,
      payload: Map<String, dynamic>.of(payload), // 방어적 복사
    );
  }

  /// UTC ms → 로컬 DateTime
  DateTime get timestamp =>
      DateTime.fromMillisecondsSinceEpoch(ts, isUtc: true).toLocal();

  /// JSON 직렬화 (payload도 복사하여 노출)
  Json toJson() => {
        'id': id,
        'ts': ts,
        'payload': Map<String, dynamic>.of(payload),
      };

  /// JSON 역직렬화
  factory AppEvent.fromJson(Json json) {
    return AppEvent(
      id: json['id'] as String,
      ts: json['ts'] as int,
      payload: Map<String, dynamic>.of(json['payload'] as Json),
    );
  }

  /// 복사본 생성 (immutable 유지)
  AppEvent copyWith({
    String? id,
    int? ts,
    Json? payload,
  }) =>
      AppEvent(
        id: id ?? this.id,
        ts: ts ?? this.ts,
        payload: payload != null ? Map<String, dynamic>.of(payload) : this.payload,
      );

  @override
  List<Object?> get props => [id, ts, payload];
}
\n\n// ====== lib/core/services/hive_service.dart ======\n
// lib/core/services/hive_service.dart

import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../utils/logger.dart';
import '../../data/models/trade_dto.dart';

/// 🎯 Hive 전역 관리 서비스 (싱글톤)
/// - 앱 시작 시 한 번만 초기화
/// - 모든 TypeAdapter 등록 및 Box 관리
/// - 백그라운드에서도 Box 유지 (닫지 않음)
/// - AppConfig에 의존하지 않는 완전 독립 서비스
class HiveService {
  // 싱글톤 패턴
  HiveService._();
  static final HiveService _instance = HiveService._();
  factory HiveService() => _instance;

  // 🏷️ Box 이름 상수 (HiveService 자체 관리)
  static const String _tradeBoxName = 'trades';

  // Box 인스턴스 캐싱
  late final Box<TradeDto> _tradeBox;
  
  // 초기화 상태 관리
  bool _initialized = false;
  Future<void>? _initFuture;

  /// 🎯 Trade Box getter (이미 열려있다는 전제)
  Box<TradeDto> get tradeBox {
    if (!_initialized) {
      throw StateError(
        'HiveService has not been initialized. Call HiveService.init() before using tradeBox.'
      );
    }
    return _tradeBox;
  }

  /// 🚀 Hive 초기화 (앱 시작 시 단 한 번만 호출)
  Future<void> init() async {
    if (_initialized) {
      log.i('[HiveService] already initialized, skipping');
      return;
    }

    // 동시 호출 방어 - race condition 완전 차단
    if (_initFuture != null) {
      log.d('[HiveService] init already in progress, waiting...');
      return _initFuture;
    }

    _initFuture = _doInit();
    await _initFuture;
  }

  /// 🔧 실제 초기화 로직
  Future<void> _doInit() async {
    try {
      // 1. Hive 플랫폼 초기화
      await Hive.initFlutter();
      log.i('[HiveService] Hive.initFlutter() completed');

      // 2. TypeAdapter 등록 (중복 방지)
      _registerAdapters();

      // 3. Trade Box 열기 및 캐싱
      _tradeBox = await Hive.openBox<TradeDto>(_tradeBoxName);
      log.i('[HiveService] "$_tradeBoxName" box opened and cached');

      _initialized = true;
      log.i('[HiveService] ✅ initialized successfully');
      
    } catch (e, st) {
      log.e('[HiveService] ❌ init failed', e, st);
      _initialized = false;
      rethrow; // 초기화 실패 시 상위에서 처리할 수 있도록
    } finally {
      // 초기화 완료 후 Future 해제 (재시도 가능하도록)
      _initFuture = null;
    }
  }

  /// 📋 모든 TypeAdapter 등록 (중복 방지)
  void _registerAdapters() {
    final adapter = TradeDtoAdapter();
    if (!Hive.isAdapterRegistered(adapter.typeId)) {
      Hive.registerAdapter(adapter);
      log.i('[HiveService] TradeDtoAdapter registered (typeId: ${adapter.typeId})');
    } else {
      log.d('[HiveService] TradeDtoAdapter already registered');
    }
    
    // 📝 향후 다른 어댑터 추가 시 여기에 추가
    // if (!Hive.isAdapterRegistered(AnotherDtoAdapter().typeId)) {
    //   Hive.registerAdapter(AnotherDtoAdapter());
    //   log.i('[HiveService] AnotherDtoAdapter registered');
    // }
  }

  /// 🧹 리소스 정리 (디버그 모드에서만 실행)
  /// 일반적으로 모바일 앱에서는 OS가 자동 정리하므로 호출 불필요
  Future<void> dispose() async {
    if (!kDebugMode) {
      log.d('[HiveService] dispose skipped in production mode');
      return;
    }
    
    if (!_initialized) {
      log.d('[HiveService] not initialized, skip dispose');
      return;
    }

    try {
      if (_tradeBox.isOpen) {
        await _tradeBox.close();
        log.i('[HiveService] "$_tradeBoxName" box closed');
      }

      await Hive.close();
      log.i('[HiveService] 🧹 all Hive resources disposed');
      
    } catch (e, st) {
      log.e('[HiveService] dispose failed', e, st);
    } finally {
      _initialized = false;
    }
  }

  /// 🔍 디버깅용: 현재 상태 정보
  Map<String, Object> get debugInfo => {
    'initialized': _initialized,
    'boxName': _tradeBoxName,
    'boxOpen': _initialized ? _tradeBox.isOpen : false,
    'boxLength': _initialized ? _tradeBox.length : 0,
    'initInProgress': _initFuture != null,
  };

  /// 🔍 디버깅용: 상태 로깅
  void logStatus() {
    log.d('[HiveService] Status: $debugInfo');
  }

  /// 🔍 디버깅용: Box 상세 정보 (개발 시 유용)
  void logBoxDetails() {
    if (!_initialized) {
      log.w('[HiveService] Cannot log box details - not initialized');
      return;
    }
    
    log.d('[HiveService] Box Details:');
    log.d('  - Name: $_tradeBoxName');
    log.d('  - Length: ${_tradeBox.length}');
    log.d('  - Keys sample: ${_tradeBox.keys.take(5).toList()}');
    log.d('  - Is open: ${_tradeBox.isOpen}');
  }
}