\n\n// ====== lib/core/di/trade_provider.dart ======\n
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../config/app_config.dart';
import '../services/hive_service.dart';
import '../network/api_client.dart';
import '../utils/logger.dart';
import 'app_providers.dart' show signalBusProvider;
import 'websocket_provider.dart' show wsClientProvider;
import '../../data/datasources/trade_cache_ds.dart';
import '../../data/datasources/trade_remote_ds.dart';
import '../../data/repositories/trade_repository_impl.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';
import '../../data/processors/trade_aggregator.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ ë°ì´í„° í´ë˜ìŠ¤ ì •ì˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë§ˆì¼“ ì •ë³´ í´ë˜ìŠ¤
class MarketInfo {
  final String market;
  final String koreanName;
  final String englishName;

  const MarketInfo({
    required this.market,
    required this.koreanName,
    required this.englishName,
  });

  factory MarketInfo.fromJson(Map<String, dynamic> json) {
    return MarketInfo(
      market: json['market'] ?? '',
      koreanName: json['korean_name'] ?? '',
      englishName: json['english_name'] ?? '',
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ—ï¸ Infrastructure Layer (ìƒëª…ì£¼ê¸°: ì•± ì „ì²´)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// REST API client
final apiClientProvider = Provider<ApiClient>((ref) => ApiClient(
      apiKey: AppConfig.apiKey,
      apiSecret: AppConfig.apiSecret,
    ));

/// HiveService (main.dartì—ì„œ override)
final hiveServiceProvider = Provider<HiveService>((ref) {
  throw UnimplementedError('HiveService must be provided via main.dart override');
});

/// Data Sources
final cacheDSProvider = Provider<TradeCacheDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return TradeCacheDataSource(hive.tradeBox);
});

final remoteDSProvider = Provider((ref) => TradeRemoteDataSource(
      ref.read(wsClientProvider),
      ref.read(signalBusProvider),
      useTestData: AppConfig.useTestDataInDev,
    ));

/// Repository
final repoProvider = Provider((ref) => TradeRepositoryImpl(
      ref.read(remoteDSProvider),
      ref.read(cacheDSProvider),
    ));

/// UseCase (ìˆœìˆ˜ ê³„ì‚°ë§Œ)
final usecaseProvider = Provider((ref) => TradeUsecase(ref.read(repoProvider)));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š Market Data Layer (ìƒëª…ì£¼ê¸°: ì•± ì „ì²´)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ë§ˆì¼“ ì •ë³´ (1ì‹œê°„ ìºì‹œ)
final marketInfoProvider = FutureProvider<Map<String, MarketInfo>>((ref) async {
  final client = ref.read(apiClientProvider);
  
  try {
    final result = await client.request<List<dynamic>>(
      method: 'GET',
      path: '${AppConfig.upbitRestBase}/market/all',
      cacheDur: const Duration(hours: 1),
    );
    
    return result.when(
      ok: (markets) {
        final Map<String, MarketInfo> marketMap = {};
        int filteredCount = 0;
        
        for (final market in markets) {
          if (market is Map<String, dynamic>) {
            final warning = market['market_warning'] as String?;
            if (warning == 'CAUTION') {
              filteredCount++;
              continue;
            }
            
            final info = MarketInfo.fromJson(market);
            marketMap[info.market] = info;
          }
        }
        
        if (AppConfig.enableTradeLog) {
          log.i('ë§ˆì¼“ ì •ë³´ ë¡œë“œë¨: ${marketMap.length}ê°œ (CAUTION í•„í„°ë§: $filteredCountê°œ)');
        }
        return marketMap;
      },
      err: (error) {
        log.w('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì‹¤íŒ¨: $error');
        return <String, MarketInfo>{};
      },
    );
  } catch (e) {
    log.e('ë§ˆì¼“ ì •ë³´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: $e');
    return <String, MarketInfo>{};
  }
});

/// KRW ë§ˆì¼“ ëª©ë¡ (top 199 + essentials)
final marketsProvider = FutureProvider<List<String>>((ref) async {
  final client = ref.read(apiClientProvider);

  final marketResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/market/all',
    cacheDur: const Duration(minutes: 5),
  );
  final allMarkets = marketResult.when(ok: (v) => v, err: (_) => <dynamic>[]);

  final krwMarkets = <String>[];
  int cautionCount = 0;
  
  for (final market in allMarkets.whereType<Map<String, dynamic>>()) {
    final marketCode = market['market'] as String?;
    if (marketCode != null && marketCode.startsWith('KRW-')) {
      final warning = market['market_warning'] as String?;
      if (warning == 'CAUTION') {
        cautionCount++;
        continue;
      }
      krwMarkets.add(marketCode);
    }
  }

  final now = DateTime.now();
  final isEarly = now.hour >= 9 && now.hour < 10;
  final key = isEarly ? 'acc_trade_price_24h' : 'acc_trade_price';

  final tickerResult = await client.request<List<dynamic>>(
    method: 'GET',
    path: '${AppConfig.upbitRestBase}/ticker',
    query: {'markets': krwMarkets.join(',')},
    cacheDur: null,
  );
  final tickers = tickerResult
      .when(ok: (v) => v, err: (_) => <dynamic>[])  
      .whereType<Map<String, dynamic>>()
      .toList()
    ..sort((a, b) =>
        ((b[key] as num?) ?? 0).compareTo((a[key] as num?) ?? 0));

  const essentials = ['KRW-BTC', 'KRW-ETH', 'KRW-XRP', 'KRW-SOL'];
  final sortedMarkets = tickers.map((e) => e['market'] as String).toList();
  final combined = [
    ...essentials.where((market) => krwMarkets.contains(market)),
    ...sortedMarkets.where((m) => !essentials.contains(m)),
  ];
  return combined.take(199).toList();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ Settings Layer (ìƒëª…ì£¼ê¸°: ì‚¬ìš©ì ì„¸ì…˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// í•„í„° ì¸ë±ìŠ¤
final tradeFilterIndexProvider = StateProvider<int>((_) => 0);

/// í•„í„° ì„ê³„ê°’
final tradeFilterThresholdProvider = StateProvider<double>((ref) =>
    AppConfig.tradeFilters.firstWhere(
      (f) => f >= 20000000,
      orElse: () => AppConfig.tradeFilters.last,
    ));

/// êµ¬ê°„/ëˆ„ì  ëª¨ë“œ
final tradeRangeModeProvider = StateProvider<bool>((ref) => false);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ State Management Layer (ìƒëª…ì£¼ê¸°: ë©”ì¸ Providerì™€ ì—°ë™)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// íŠ¸ë ˆì´ë“œ í•„í„° ìºì‹œ (ìƒëª…ì£¼ê¸°: keepAlive Providerì™€ ì—°ë™)
final tradeFilterCacheProvider = StateNotifierProvider<TradeFilterNotifier, Map<double, List<Trade>>>((ref) {
  return TradeFilterNotifier();
});

class TradeFilterNotifier extends StateNotifier<Map<double, List<Trade>>> {
  static const int _maxTrades = 200;

  TradeFilterNotifier() : super({}) {
    for (final filter in AppConfig.tradeFilters) {
      state = {...state, filter: <Trade>[]};
    }
    log.d('ğŸ—ï¸ TradeFilterNotifier created');
  }

  void addTrade(Trade trade) {
    final total = trade.total;
    final newState = Map<double, List<Trade>>.from(state);

    for (final filter in AppConfig.tradeFilters) {
      if (total >= filter) {
        final list = List<Trade>.from(newState[filter] ?? <Trade>[]);
        list.insert(0, trade);

        if (list.length > _maxTrades) {
          list.removeLast();
        }

        newState[filter] = list;
      }
    }

    state = newState;
    log.d('ğŸ“Š Trade added: ${trade.market} - ${total.toStringAsFixed(0)}ì›');
  }

  void clearAll() {
    final newState = <double, List<Trade>>{};
    for (final filter in AppConfig.tradeFilters) {
      newState[filter] = <Trade>[];
    }
    state = newState;
    log.d('ğŸ§¹ All trades cleared');
  }

  @override
  void dispose() {
    log.d('ğŸ§¹ TradeFilterNotifier disposed');
    super.dispose();
  }
}

/// ì¤‘ë³µ ID ê´€ë¦¬ (ìƒëª…ì£¼ê¸°: keepAlive Providerì™€ ì—°ë™)
final tradeSeenIdsProvider = StateNotifierProvider<TradeSeenIdsNotifier, Set<String>>((ref) {
  return TradeSeenIdsNotifier();
});

class TradeSeenIdsNotifier extends StateNotifier<Set<String>> {
  static const int _maxCacheSize = 1000;

  TradeSeenIdsNotifier() : super(<String>{}) {
    log.d('ğŸ—ï¸ TradeSeenIdsNotifier created');
  }

  bool addId(String id) {
    if (state.contains(id)) return false;

    final newState = Set<String>.from(state);
    newState.add(id);

    if (newState.length > _maxCacheSize) {
      final removeCount = (newState.length / 4).ceil();
      final toRemove = newState.take(removeCount).toList();
      newState.removeAll(toRemove);
    }

    state = newState;
    return true;
  }

  void clear() {
    state = <String>{};
    log.d('ğŸ§¹ Seen IDs cleared');
  }

  @override
  void dispose() {
    log.d('ğŸ§¹ TradeSeenIdsNotifier disposed');
    super.dispose();
  }
}

/// ì§‘ê³„ê¸° (ìƒëª…ì£¼ê¸°: ì²˜ë¦¬ Providerì™€ ì—°ë™)
final tradeAggregatorProvider = Provider<TradeAggregator>((ref) {
  log.d('ğŸ—ï¸ TradeAggregator created');
  return TradeAggregator();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ Processing Layer (ìƒëª…ì£¼ê¸°: ë©”ì¸ Providerê°€ ê´€ë¦¬)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì£¼ê¸°ì  ë¦¬ì…‹ íƒ€ì´ë¨¸
final tradeProcessingTimerProvider = StreamProvider((ref) {
  log.d('â° Processing timer started');
  return Stream.periodic(AppConfig.globalResetInterval, (i) => i);
});

/// ì›ì‹œ íŠ¸ë ˆì´ë“œ ì²˜ë¦¬ ìŠ¤íŠ¸ë¦¼ (keepAlive Providerì—ì„œ ì§ì ‘ ê´€ë¦¬)
final rawTradeProcessingProvider = StreamProvider<Trade>((ref) async* {
  log.i('ğŸš€ Raw trade processing started');
  
  final markets = await ref.watch(marketsProvider.future);
  final repo = ref.read(repoProvider);
  final aggregator = ref.read(tradeAggregatorProvider);
  final seenIdsNotifier = ref.read(tradeSeenIdsProvider.notifier);
  final filterCacheNotifier = ref.read(tradeFilterCacheProvider.notifier);

  log.i('ğŸ“¡ Markets loaded: ${markets.length}');

  // ì£¼ê¸°ì  ë¦¬ì…‹ êµ¬ë…
  ref.listen(tradeProcessingTimerProvider, (previous, next) {
    next.whenData((value) {
      log.d('â° Periodic reset triggered');
      aggregator.flushTrades(onTradeProcessed: (processedTrade) {
        final trade = Trade(
          market: processedTrade['market'] as String,
          price: processedTrade['price'] as double,
          volume: processedTrade['volume'] as double,
          side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: processedTrade['timestamp'] as int,
          sequentialId: processedTrade['sequential_id'] as String,
        );
        filterCacheNotifier.addTrade(trade);
      });
    });
  });

  // Repository ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
  yield* repo.watchTrades(markets).where((trade) {
    final key = '${trade.market}/${trade.sequentialId}';
    if (!seenIdsNotifier.addId(key)) return false;

    log.d('ğŸ” Processing trade: ${trade.market} - ${trade.total.toStringAsFixed(0)}ì›');

    aggregator.processTrade(
      {
        'market': trade.market,
        'price': trade.price,
        'volume': trade.volume,
        'timestamp': trade.timestampMs,
        'isBuy': trade.isBuy,
        'sequential_id': trade.sequentialId,
      },
      onTradeProcessed: (processedTrade) {
        final aggregatedTrade = Trade(
          market: processedTrade['market'] as String,
          price: processedTrade['price'] as double,
          volume: processedTrade['volume'] as double,
          side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
          changePrice: 0.0,
          changeState: 'EVEN',
          timestampMs: processedTrade['timestamp'] as int,
          sequentialId: processedTrade['sequential_id'] as String,
        );
        filterCacheNotifier.addTrade(aggregatedTrade);
        log.d('âœ… Trade aggregated and cached');
      },
    );

    return true;
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”µ Public API Layer (ìƒëª…ì£¼ê¸°: keepAliveë¡œ ì˜êµ¬ ìœ ì§€)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ Provider
final tradeListProvider = StreamProvider<List<Trade>>((ref) {
  ref.keepAlive(); // í•µì‹¬: ì˜êµ¬ ìœ ì§€
  log.i('ğŸš€ TradeListProvider initialized (keepAlive)');

  final controller = StreamController<List<Trade>>.broadcast();
  
  void updateTrades() {
    final threshold = ref.read(tradeFilterThresholdProvider);
    final isRangeMode = ref.read(tradeRangeModeProvider);
    final usecase = ref.read(usecaseProvider);
    final filterCache = ref.read(tradeFilterCacheProvider);
    
    log.d('ğŸ” updateTrades() - threshold: ${threshold.toStringAsFixed(0)}, rangeMode: $isRangeMode');
    log.d('ğŸ“¦ filterCache sizes: ${filterCache.map((k, v) => MapEntry(k.toStringAsFixed(0), v.length))}');
    
    final filteredTrades = usecase.calculateFilteredTrades(
      filterCache,
      threshold,
      isRangeMode,
    );
    
    log.i('âœ… Filtered trades: ${filteredTrades.length}');
    if (filteredTrades.isNotEmpty) {
      log.d('ğŸ“‹ First trade: ${filteredTrades.first.market} - ${filteredTrades.first.total.toStringAsFixed(0)}ì›');
    }
    
    if (!controller.isClosed) {
      controller.add(filteredTrades);
      log.d('ğŸ“¤ Trades sent to stream');
    }
  }

  // ì›ì‹œ ì²˜ë¦¬ ìŠ¤íŠ¸ë¦¼ í™œì„±í™” (ë¶€ìˆ˜ íš¨ê³¼)
  ref.listen(rawTradeProcessingProvider, (previous, next) {
    next.when(
      data: (trade) => log.d('ğŸ”¥ Raw trade received: ${trade.market}'),
      loading: () => log.d('â³ Raw trade loading...'),
      error: (error, stack) => log.e('ğŸ’¥ Raw trade error: $error'),
    );
  });

  // ìƒíƒœ ë³€í™” ê°ì§€
  ref.listen(tradeFilterCacheProvider, (previous, next) {
    log.d('ğŸ“ˆ Filter cache updated');
    updateTrades();
  });

  ref.listen<double>(tradeFilterThresholdProvider, (prev, next) {
    if (prev != null && prev != next) {
      log.i('ğŸ¯ Threshold: ${prev.toStringAsFixed(0)} â†’ ${next.toStringAsFixed(0)}');
      updateTrades();
    }
  });

  ref.listen<bool>(tradeRangeModeProvider, (prev, next) {
    if (prev != null && prev != next) {
      log.i('ğŸ”„ Range mode: ${prev ? "êµ¬ê°„" : "ëˆ„ì "} â†’ ${next ? "êµ¬ê°„" : "ëˆ„ì "}');
      updateTrades();
    }
  });

  // ì´ˆê¸° ë°ì´í„°
  updateTrades();

  // ì •ë¦¬
  ref.onDispose(() {
    log.i('ğŸ§¹ TradeListProvider disposed');
    controller.close();
  });

  return controller.stream;
});

/// ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ Provider  
final aggregatedTradeProvider = StreamProvider<Trade>((ref) {
  ref.keepAlive(); // í•µì‹¬: ì˜êµ¬ ìœ ì§€
  log.i('ğŸš€ AggregatedTradeProvider initialized (keepAlive)');

  // ì›ì‹œ ì²˜ë¦¬ ìŠ¤íŠ¸ë¦¼ì„ ì§ì ‘ ì „ë‹¬
  return ref.watch(rawTradeProcessingProvider.future).asStream().expand((trade) => [trade]);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›ï¸ Controller Helper
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

final tradeThresholdController = Provider((ref) => TradeThresholdController(ref));

class TradeThresholdController {
  final Ref ref;
  TradeThresholdController(this.ref);

  void updateThreshold(double threshold, int index) {
    final options = AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
    if (index < 0 || index >= options.length) {
      if (AppConfig.enableTradeLog) log.w('Invalid threshold index: $index');
      return;
    }
    ref.read(tradeFilterThresholdProvider.notifier).state = threshold;
    ref.read(tradeFilterIndexProvider.notifier).state = index;
    AppConfig.updateFilters(options);
    if (AppConfig.enableTradeLog) {
      log.i('Threshold updated: ${threshold.toStringAsFixed(0)} (index: $index)');
    }
  }

  double get currentThreshold => ref.read(tradeFilterThresholdProvider);
  int get currentIndex => ref.read(tradeFilterIndexProvider);
  List<double> get availableThresholds =>
      AppConfig.tradeFilters.where((f) => f >= 20000000).toList();
}\n\n// ====== lib/core/config/trade_config.dart ======\n
\n\n// ====== lib/core/network/websocket/trade_ws_client.dart ======\n
// lib/core/network/websocket/trade_ws_client.dart

import 'dart:convert';
import '../../config/app_config.dart';
import 'base_ws_client.dart';

/// â€œì²´ê²°â€ ìŠ¤íŠ¸ë¦¼: List<Map<String, dynamic>>
class TradeWsClient extends BaseWsClient<List<Map<String, dynamic>>> {
  TradeWsClient({void Function(WsStatus)? onStatusChange})
      : super(
          url: AppConfig.upbitWsUrl,
          onStatusChange: onStatusChange,
          decode: BaseWsClient.decodeJsonList,
          encodeSubscribe: (markets) {
            final codes = markets.take(AppConfig.wsMaxSubscriptionCount).toList();
            return jsonEncode([
              {
                'ticket': 'trade-${DateTime.now().millisecondsSinceEpoch}'
              },
              {
                'type': 'trade',
                'codes': codes,
              },
              {'format': 'DEFAULT'},
            ]);
          },
        );
}
\n\n// ====== lib/data/datasources/trade_cache_ds.dart ======\n
// lib/data/datasources/trade_cache_ds.dart
import 'package:hive/hive.dart';
import 'dart:async';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';
import '../../core/error/app_exception.dart';

/// Hive ê¸°ë°˜ ë°°ì¹˜ ì •ë¦¬ ì‹œìŠ¤í…œì„ ì ìš©í•œ ê±°ë˜ ìºì‹œ ë°ì´í„°ì†ŒìŠ¤
/// 
/// ğŸ”§ ê°œì„ ì‚¬í•­:
/// - ë°°ì¹˜ ê¸°ë°˜ ìºì‹œ ì •ë¦¬ë¡œ ì„±ëŠ¥ ìµœì í™”
/// - ì„ê³„ì  ë„ë‹¬ ì‹œì—ë§Œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
/// - ê¸°ì¡´ API í˜¸í™˜ì„± ìœ ì§€
/// - ì •ë¦¬ ì‘ì—… ì¤‘ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
class TradeCacheDataSource {
  // ğŸ“Š ìºì‹œ ì„¤ì •
  static const int _maxCacheSize = 1000;           // ëª©í‘œ ìºì‹œ ì‚¬ì´ì¦ˆ
  static const int _cleanupThreshold = 1200;       // ì •ë¦¬ ì‹œì‘ ì„ê³„ì  (20% ë²„í¼)
  static const int _cleanupBatchSize = 300;        // í•œ ë²ˆì— ì •ë¦¬í•  ê°œìˆ˜
  
  /// ğŸ¯ ì£¼ì…ë°›ì€ Box (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  final Box<TradeDto> _box;
  
  /// ğŸ”’ ì •ë¦¬ ì‘ì—… ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
  bool _isCleaningUp = false;
  
  /// ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ìš© (ì„ íƒì )
  int _totalCacheOps = 0;
  int _cleanupCount = 0;
  
  /// ìƒì„±ì: ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ìŒ
  TradeCacheDataSource(this._box);
  
  /// ğŸš€ Tradeë¥¼ DTOë¡œ ë³€í™˜í•´ ì €ì¥ (ë°°ì¹˜ ì •ë¦¬ ì ìš©)
  /// 
  /// ê¸°ì¡´ APIì™€ 100% í˜¸í™˜ì„± ìœ ì§€
  /// Throws: [CacheException] if storage operation fails
  Future<void> cacheTrade(Trade trade) async {
    try {
      // 1. ë°ì´í„° ì €ì¥ (ê¸°ì¡´ê³¼ ë™ì¼)
      final dto = TradeDto(
        market: trade.market,
        price: trade.price,
        volume: trade.volume,
        side: trade.side,
        changePrice: trade.changePrice,
        changeState: trade.changeState,
        timestampMs: trade.timestampMs,
        sequentialId: trade.sequentialId,
      );
      
      await _box.put(trade.sequentialId, dto);
      _totalCacheOps++;
      
      // 2. ë°°ì¹˜ ì •ë¦¬ í™•ì¸ (ì„ê³„ì  ë„ë‹¬ ì‹œì—ë§Œ)
      if (_shouldTriggerCleanup()) {
        // ë¹„ë™ê¸°ë¡œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰ (ë¸”ë¡œí‚¹ ë°©ì§€)
        unawaited(_performBatchCleanup());
      }
    } catch (e) {
      log.e('Failed to cache trade', e);
      throw AppException(
        'Failed to cache trade for market ${trade.market}',
        originalException: e is Exception ? e : Exception(e.toString()),
      );
    }
  }
  
  /// ğŸ§¹ ë°°ì¹˜ ì •ë¦¬ íŠ¸ë¦¬ê±° ì¡°ê±´ í™•ì¸
  bool _shouldTriggerCleanup() {
    return _box.length > _cleanupThreshold && !_isCleaningUp;
  }
  
  /// ğŸ”„ ë°°ì¹˜ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
  Future<void> _performBatchCleanup() async {
    if (_isCleaningUp) return; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    
    _isCleaningUp = true;
    
    try {
      // í˜„ì¬ ìƒíƒœ ì¬í™•ì¸ (ë™ì‹œì„± ì´ìŠˆ ë°©ì§€)
      if (_box.length <= _maxCacheSize) {
        return;
      }
      
      // ì œê±°í•  ê°œìˆ˜ ê³„ì‚°
      final currentSize = _box.length;
      final targetRemoveCount = currentSize - _maxCacheSize;
      final actualRemoveCount = targetRemoveCount.clamp(0, _cleanupBatchSize);
      
      if (actualRemoveCount > 0) {
        // ì˜¤ë˜ëœ í‚¤ë¶€í„° ì œê±° (FIFO ë°©ì‹)
        final keysToRemove = _box.keys
            .take(actualRemoveCount)
            .toList();
        
        await _box.deleteAll(keysToRemove);
        
        _cleanupCount++;
        
        log.d('ğŸ§¹ Cache cleanup: ${keysToRemove.length} items removed, '
              'size: $currentSize â†’ ${_box.length}');
      }
    } catch (e) {
      log.e('Cache cleanup failed', e);
    } finally {
      _isCleaningUp = false;
    }
  }
  
  /// ğŸ“‹ ìºì‹œëœ Trade ì „ë¶€ ë°˜í™˜ (ê¸°ì¡´ API ìœ ì§€)
  List<Trade> getCachedTrades() {
    try {
      return _box.values.map((dto) => dto.toEntity()).toList();
    } catch (e) {
      log.w('Failed to get cached trades', e);
      return [];
    }
  }
  
  /// ğŸ”„ ìµœê·¼ Nê°œ Trade ë°˜í™˜ (ìƒˆë¡œìš´ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ)
  List<Trade> getRecentTrades([int? limit]) {
    try {
      final allTrades = getCachedTrades();
      
      if (limit == null || limit >= allTrades.length) {
        return allTrades;
      }
      
      // timestampMs ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ í›„ ìµœì‹  Nê°œ ë°˜í™˜
      allTrades.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
      return allTrades.take(limit).toList();
    } catch (e) {
      log.w('Failed to get recent trades', e);
      return [];
    }
  }
  
  /// ğŸ—‘ï¸ ìºì‹œ í´ë¦¬ì–´ (ê¸°ì¡´ API ìœ ì§€)
  Future<void> clearCache() async {
    try {
      await _box.clear();
      _totalCacheOps = 0;
      _cleanupCount = 0;
      log.i('Cache cleared completely');
    } catch (e) {
      log.e('Failed to clear cache', e);
      throw AppException(
        'Failed to clear cache', 
        originalException: e is Exception ? e : Exception(e.toString())
      );
    }
  }
  
  /// ğŸ”§ ìˆ˜ë™ ì •ë¦¬ íŠ¸ë¦¬ê±° (í•„ìš”ì‹œ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥)
  Future<void> forceCleanup() async {
    if (!_isCleaningUp) {
      await _performBatchCleanup();
    }
  }
  
  /// ğŸ“Š ìºì‹œ ìƒíƒœ ì •ë³´ ë°˜í™˜ (ë””ë²„ê¹…/ëª¨ë‹ˆí„°ë§ìš©)
  Map<String, dynamic> getCacheStats() {
    return {
      'currentSize': _box.length,
      'maxSize': _maxCacheSize,
      'threshold': _cleanupThreshold,
      'totalOperations': _totalCacheOps,
      'cleanupCount': _cleanupCount,
      'isCleaningUp': _isCleaningUp,
      'utilizationPercent': (_box.length / _maxCacheSize * 100).toInt(),
    };
  }
  
  /// ğŸ›ï¸ ëŸ°íƒ€ì„ ì„¤ì • ì¡°ì • (ê³ ê¸‰ ì‚¬ìš©ììš©)
  void adjustCacheSettings({
    int? maxSize,
    int? threshold,
    int? batchSize,
  }) {
    // Note: static const ê°’ë“¤ì€ ëŸ°íƒ€ì„ì— ë³€ê²½ ë¶ˆê°€í•˜ë¯€ë¡œ
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë³€ê²½ í•„ìš”
    log.d('Runtime cache adjustment requested - implement if needed');
  }
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// ğŸ”„ ë¦¬íŒ©í† ë§: ë‹¨ìˆœí•˜ê³  ê¹”ë”í•œ Trade ë°ì´í„° ì†ŒìŠ¤
/// - BaseWsClientë¥¼ ë¯¿ê³  ë§¡ê¹€
/// - ê°€ì§œ ë°ì´í„° fallback ì œê±°  
/// - ë³µì¡í•œ êµ¬ë…ì ê´€ë¦¬ ë¡œì§ ì œê±°
/// - ìˆœìˆ˜í•˜ê²Œ "ë°ì´í„° ë³€í™˜ + ë¸Œë¡œë“œìºìŠ¤íŒ…"ë§Œ ë‹´ë‹¹
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  // ğŸ¯ í•µì‹¬: ë‹¨ìˆœí•œ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _currentStream;
  List<String> _currentMarkets = [];
  bool _disposed = false;

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData;

  /// ğŸ¯ í•µì‹¬ ë©”ì†Œë“œ: ë§ˆì¼“ì´ ë°”ë€” ë•Œë§Œ ìƒˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
  Stream<Trade> watch(List<String> markets) {
    if (_disposed) {
      throw StateError('TradeRemoteDataSource has been disposed');
    }

    if (_useTestData) {
      return _testStream();
    }

    // ë§ˆì¼“ì´ ë°”ë€Œë©´ ìƒˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    if (!_marketsEqual(_currentMarkets, markets)) {
      debugPrint('TradeRemoteDataSource: Creating new stream for ${markets.length} markets');
      _currentMarkets = List.from(markets);
      _currentStream = _createTradeStream(markets);
    }

    return _currentStream!;
  }

  /// ğŸ”¥ ê³ ê¸‰: ìˆœìˆ˜ì„±ê³¼ ë¶€ìˆ˜íš¨ê³¼ ë¶„ë¦¬
  Stream<Trade> _createTradeStream(List<String> markets) {
    // WebSocket ì—°ê²° ì‹œì‘ (ë¹„ë™ê¸°)
    _ws.connect(markets);
    
    // BaseWsClientì˜ ìŠ¤íŠ¸ë¦¼ ì‚¬ìš©
    return _ws.stream
        .expand((batch) => batch)              // List<Map> â†’ Map
        .map(_parseToTradeDto)                 // Map â†’ TradeDto? (ìˆœìˆ˜ í•¨ìˆ˜)
        .where((dto) => dto != null)           // null í•„í„°ë§
        .cast<TradeDto>()                      // TradeDto? â†’ TradeDto
        .transform(_sideEffectTransformer())   // ë¶€ìˆ˜ íš¨ê³¼ ì²˜ë¦¬ (ì´ë²¤íŠ¸ ë°œì†¡)
        .map((dto) => dto.toEntity())          // TradeDto â†’ Trade (ìˆœìˆ˜ í•¨ìˆ˜)
        .asBroadcastStream();                  // ì—¬ëŸ¬ Repository êµ¬ë… ê°€ëŠ¥
  }

  /// ğŸ¯ ìˆœìˆ˜ í•¨ìˆ˜: íŒŒì‹±ë§Œ ë‹´ë‹¹ (ë¶€ìˆ˜ íš¨ê³¼ ì—†ìŒ)
  TradeDto? _parseToTradeDto(Map<String, dynamic> json) {
    try {
      return TradeDto.tryParse(json);
    } catch (e) {
      debugPrint('TradeRemoteDataSource: Parse error - $e');
      return null;
    }
  }

  /// ğŸ¯ ë¶€ìˆ˜ íš¨ê³¼ ì „ìš© Transformer: ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œ í†µê³¼ì‹œí‚¤ë˜ ì´ë²¤íŠ¸ ë°œì†¡
  StreamTransformer<TradeDto, TradeDto> _sideEffectTransformer() {
    return StreamTransformer.fromHandlers(
      handleData: (TradeDto dto, EventSink<TradeDto> sink) {
        // ğŸ¯ ë¶€ìˆ˜ íš¨ê³¼: SignalBus ì´ë²¤íŠ¸ ë°œì†¡
        _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
        
        // ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬
        sink.add(dto);
      },
      handleError: (error, stackTrace, EventSink<TradeDto> sink) {
        debugPrint('TradeRemoteDataSource: Stream error - $error');
        // ì—ëŸ¬ë„ ê·¸ëŒ€ë¡œ ì „íŒŒ
        sink.addError(error, stackTrace);
      },
    );
  }

  /// ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ (ìˆœì„œ ë¬´ê´€)
  bool _marketsEqual(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    final setA = Set<String>.from(a);
    final setB = Set<String>.from(b);
    return setA.containsAll(setB) && setB.containsAll(setA);
  }

  /// ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ìš© ìŠ¤íŠ¸ë¦¼ (ê°œë°œ/ë””ë²„ê·¸ìš©)
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'KRW-BTC', 'KRW-ETH', 'KRW-XRP',
      'KRW-DOGE', 'KRW-SOL', 'KRW-ADA',
    ];

    while (!_disposed) {
      await Future.delayed(const Duration(milliseconds: 500));
      if (_disposed) break;

      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final dto = TradeDto(
        market: symbols[rnd.nextInt(symbols.length)],
        price: (rnd.nextDouble() * 1000000 + 10000).roundToDouble(),
        volume: rnd.nextDouble() * 10,
        side: rnd.nextBool() ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: nowMs,
        sequentialId: 'test-$nowMs-${rnd.nextInt(1000)}',
      );
      
      yield dto.toEntity();
      _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
    }
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    if (_disposed) return;
    
    _disposed = true;
    _currentStream = null;
    _currentMarkets.clear();
    
    debugPrint('TradeRemoteDataSource: disposed');
    // BaseWsClientëŠ” TradeWsClientì—ì„œ ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ dispose ì•ˆí•¨
  }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_cache_ds.dart';
import '../datasources/trade_remote_ds.dart';

/// ğŸ”¥ TradeRepository - ìˆœìˆ˜í•œ ë°ì´í„° ê³„ì¸µë§Œ ë‹´ë‹¹ (Volume íŒ¨í„´)
/// - DataSourceì™€ 1:1 ë§¤í•‘
/// - Cache ì €ì¥
/// - ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì œê³µ
/// - ëª¨ë“  ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ TradeUsecaseì—ì„œ ì²˜ë¦¬
class TradeRepositoryImpl implements TradeRepository {
  final TradeRemoteDataSource _remote;
  final TradeCacheDataSource _cache;

  // ğŸ¯ í•µì‹¬: ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _masterStream;
  List<String> _currentMarkets = [];
  bool _disposed = false;

  TradeRepositoryImpl(this._remote, this._cache);

  /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì œê³µ (TradeUsecaseê°€ êµ¬ë…)
  @override
  Stream<Trade> watchTrades(List<String> markets) {
    if (_disposed) {
      throw StateError('TradeRepository has been disposed');
    }

    debugPrint('TradeRepository: watchTrades() - ${markets.length} markets');

    // ë§ˆì¼“ì´ ë°”ë€Œë©´ ìƒˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    if (!_marketsEqual(_currentMarkets, markets)) {
      debugPrint('TradeRepository: Creating new master stream for ${markets.length} markets');
      _currentMarkets = List.from(markets);
      
      _masterStream = _remote.watch(markets)
          .asyncMap((trade) async {
            // ğŸ¯ Cacheì— ì €ì¥ (ë‹¨ìˆœí•œ ë¶€ìˆ˜ íš¨ê³¼)
            try {
              await _cache.cacheTrade(trade);
            } catch (e) {
              debugPrint('Cache error (ignored): $e');
            }
            return trade;
          })
          .asBroadcastStream();
    }

    return _masterStream!;
  }

  /// âœ… Volumeì²˜ëŸ¼ ë¹ˆ êµ¬í˜„ (TradeUsecaseì—ì„œ ì²˜ë¦¬)
  @override
  Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
    if (_disposed) {
      return const Stream.empty();
    }
    
    debugPrint('TradeRepository: watchFilteredTrades() - $threshold, ${markets.length} markets');
    return _remote.watch(markets)
        .map((trade) => <Trade>[])  // ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜ (ì‹¤ì œ ë¡œì§ì€ Usecaseì—)
        .asBroadcastStream();
  }

  /// âœ… Volumeì²˜ëŸ¼ ë¹ˆ êµ¬í˜„ (TradeUsecaseì—ì„œ ì²˜ë¦¬)
  @override
  Stream<Trade> watchAggregatedTrades() {
    return const Stream.empty();
  }

  /// âœ… Volumeì²˜ëŸ¼ ë¹ˆ êµ¬í˜„ (TradeUsecaseì—ì„œ ì²˜ë¦¬)
  @override
  void updateThreshold(double threshold) {
    // TradeUsecaseì—ì„œ ì²˜ë¦¬
  }

  /// âœ… Volumeì²˜ëŸ¼ ë¹ˆ êµ¬í˜„ (TradeUsecaseì—ì„œ ì²˜ë¦¬)
  @override
  void updateRangeMode(bool isRangeMode) {
    // TradeUsecaseì—ì„œ ì²˜ë¦¬
  }

  /// ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ (ìˆœì„œ ë¬´ê´€)
  bool _marketsEqual(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    final setA = Set<String>.from(a);
    final setB = Set<String>.from(b);
    return setA.containsAll(setB) && setB.containsAll(setA);
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  Future<void> dispose() async {
    if (_disposed) return;
    
    debugPrint('TradeRepository: dispose() called');
    _disposed = true;
    
    // ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
    _masterStream = null;
    _currentMarkets.clear();
    
    // DataSource ì •ë¦¬
    await _remote.dispose();
    
    debugPrint('TradeRepository: dispose completed');
  }
}\n\n// ====== lib/data/models/trade_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trade_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TradeDtoAdapter extends TypeAdapter<TradeDto> {
  @override
  final int typeId = 0;

  @override
  TradeDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TradeDto(
      market: fields[0] as String,
      price: fields[1] as double,
      volume: fields[2] as double,
      side: fields[3] as String,
      changePrice: fields[4] as double,
      changeState: fields[5] as String,
      timestampMs: fields[6] as int,
      sequentialId: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TradeDto obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.market)
      ..writeByte(1)
      ..write(obj.price)
      ..writeByte(2)
      ..write(obj.volume)
      ..writeByte(3)
      ..write(obj.side)
      ..writeByte(4)
      ..write(obj.changePrice)
      ..writeByte(5)
      ..write(obj.changeState)
      ..writeByte(6)
      ..write(obj.timestampMs)
      ..writeByte(7)
      ..write(obj.sequentialId);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TradeDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/trade_dto.dart ======\n
// lib/data/models/trade_dto.dart

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

part 'trade_dto.g.dart';

@HiveType(typeId: 0)
class TradeDto {
  @HiveField(0)
  final String market;

  @HiveField(1)
  final double price;

  @HiveField(2)
  final double volume;

  @HiveField(3)
  final String side;

  @HiveField(4)
  final double changePrice;

  @HiveField(5)
  final String changeState;

  @HiveField(6)
  final int timestampMs;

  @HiveField(7)
  final String sequentialId;

  TradeDto({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  Trade toEntity() => Trade(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestampMs,
        sequentialId: sequentialId,
      );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜ (camelCase í‚¤ ì‚¬ìš©ìœ¼ë¡œ ì‹œìŠ¤í…œ í†µì¼)
  Map<String, dynamic> toMap() => {
        'market': market,
        'price': price,
        'volume': volume,
        'side': side,
        'changePrice': changePrice,
        'changeState': changeState,
        'timestampMs': timestampMs,
        'sequentialId': sequentialId,
      };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (ì—¬ëŸ¬ í‚¤ ë„¤ì´ë° ì§€ì›)
  static TradeDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      log.d('TradeDto.tryParse: ${m.toString().substring(0, m.toString().length.clamp(0, 100))}');

      String parseString(dynamic v, [String fallback = '']) =>
          v != null ? v.toString() : fallback;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch
                              : DateTime.now().millisecondsSinceEpoch;
      }

      final market = parseString(m['market'] ?? m['symbol'] ?? m['code'], 'UNKNOWN');
      final price = parseDouble(m['price'] ?? m['trade_price']);
      final volume = parseDouble(m['volume'] ?? m['trade_volume']);
      final side = parseString(m['side'] ?? m['ask_bid'], 'UNKNOWN');

      final changePrice = parseDouble(m['changePrice'] ?? m['change_price']);
      final changeState = parseString(m['changeState'] ?? m['change_state'], 'EVEN');
      final timestamp = parseInt(m['timestampMs'] ?? m['timestamp_ms'] ?? m['timestamp']);
      final sequentialId = parseString(
        m['sequentialId'] ?? m['sequential_id'] ?? m['sid'], 
        timestamp.toString(),
      );

      return TradeDto(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestamp,
        sequentialId: sequentialId,
      );
    } catch (e) {
      log.w('TradeDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TradeDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TradeDto(
        market: 'ERROR',
        price: 0.0,
        volume: 0.0,
        side: 'UNKNOWN',
        changePrice: 0.0,
        changeState: 'UNKNOWN',
        timestampMs: DateTime.now().millisecondsSinceEpoch,
        sequentialId: 'ERROR',
      );
}
\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/features/trade/data/utils/trade_aggregator.dart
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ì™€ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Map<String, dynamic>> _lastTrades = {};
  final int mergeWindow = AppConfig.mergeWindowMs;

  /// ê±°ë˜ ì²˜ë¦¬ ë° ë³‘í•© ë¡œì§
  void processTrade(
    Map<String, dynamic> trade, {
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      // ì•ˆì „í•œ null ì²´í¬ì™€ íƒ€ì… ìºìŠ¤íŒ…
      final market = trade['market'] as String? ?? '';
      final price = trade['price'] as double? ?? 0.0;
      final volume = trade['volume'] as double? ?? 0.0;
      final timestamp = trade['timestamp'] as int? ?? 0;
      final isBuy = trade['isBuy'] as bool? ?? true;
      final sequentialId = trade['sequential_id'] as String? ?? '';

      // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (market.isEmpty || price <= 0 || volume <= 0 || timestamp <= 0) {
        if (kDebugMode) {
          debugPrint('TradeAggregator: Invalid trade data, skipping: market=$market, price=$price, volume=$volume, timestamp=$timestamp');
        }
        return;
      }

      final total = price * volume;

      if (_lastTrades.containsKey(market)) {
        final lastTrade = _lastTrades[market]!;
        final lastTs = lastTrade['timestamp'] as int;

        // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê±°ë˜ë©´ ë³‘í•©
        if (timestamp - lastTs <= mergeWindow) {
          final lastTotal = lastTrade['total'] as double;
          final lastVolume = lastTrade['volume'] as double;
          final newTotal = lastTotal + total;
          final newVolume = lastVolume + volume;

          // ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°
          final avgPrice = newTotal / newVolume;

          // ë³‘í•©ëœ ê±°ë˜ ì •ë³´ ì—…ë°ì´íŠ¸
          lastTrade['price'] = avgPrice;
          lastTrade['volume'] = newVolume;
          lastTrade['total'] = newTotal;
          lastTrade['timestamp'] = timestamp; // ìµœì‹  ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          lastTrade['sequential_id'] = sequentialId;
          lastTrade['isBuy'] = isBuy; // ìµœì‹  ê±°ë˜ì˜ ë°©í–¥ ì‚¬ìš©

          if (kDebugMode) {
            debugPrint(
              'Merged trade: $market, total: ${newTotal.toStringAsFixed(0)}, avg_price: ${avgPrice.toStringAsFixed(2)}',
            );
          }
        } else {
          // ì‹œê°„ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚˜ë©´ ì´ì „ ê±°ë˜ ì²˜ë¦¬í•˜ê³  ìƒˆ ê±°ë˜ë¡œ êµì²´
          onTradeProcessed(Map<String, dynamic>.from(lastTrade));
          _lastTrades[market] = {
            'market': market,
            'price': price,
            'volume': volume,
            'total': total,
            'timestamp': timestamp,
            'isBuy': isBuy,
            'sequential_id': sequentialId,
          };
        }
      } else {
        // ìƒˆë¡œìš´ ë§ˆì¼“ì˜ ì²« ê±°ë˜
        final newTrade = {
          'market': market,
          'price': price,
          'volume': volume,
          'total': total,
          'timestamp': timestamp,
          'isBuy': isBuy,
          'sequential_id': sequentialId,
        };
        _lastTrades[market] = newTrade;
        // ğŸ”¥ ì¤‘ìš”: ì²« ê±°ë˜ë„ ë°”ë¡œ ì²˜ë¦¬í•˜ì—¬ UIì— ë°˜ì˜
        onTradeProcessed(Map<String, dynamic>.from(newTrade));
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator processTrade error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í”ŒëŸ¬ì‹œ
  void flushTrades({
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      final tradesCount = _lastTrades.length;
      for (final trade in _lastTrades.values) {
        onTradeProcessed(Map<String, dynamic>.from(trade));
      }
      _lastTrades.clear();
      
      if (kDebugMode) {
        debugPrint('TradeAggregator: $tradesCount trades flushed');
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator flushTrades error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê¹…ìš©)
  Map<String, dynamic>? getPendingTrade(String market) {
    return _lastTrades[market] != null
        ? Map<String, dynamic>.from(_lastTrades[market]!)
        : null;
  }

  /// í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _lastTrades.length;

  /// ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _lastTrades.clear();
  }
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart
import '../entities/trade.dart';

/// Provides streams of trade data and handles resource cleanup.
abstract class TradeRepository {
 /// Streams raw [Trade] events for the given list of market codes.
 Stream<Trade> watchTrades(List<String> markets);
 
 /// Streams lists of [Trade] filtered by a minimum total trade value.
 /// => markets íŒŒë¼ë¯¸í„° ì¶”ê°€
 Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);
 
 /// Streams aggregated [Trade] events over a merge window.
 Stream<Trade> watchAggregatedTrades();
 
 /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
 void updateThreshold(double threshold);
 
 /// ğŸ†• ìƒˆë¡œ ì¶”ê°€: êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì—…ë°ì´íŠ¸
 void updateRangeMode(bool isRangeMode);
 
 /// Releases any held resources (e.g., WebSocket connections, Hive boxes).
 Future<void> dispose();
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import '../../core/config/app_config.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// ğŸ”¥ TradeUsecase - ìˆœìˆ˜ ê³„ì‚° í•¨ìˆ˜ë“¤ë§Œ ë‹´ë‹¹ (ë¦¬íŒ©í† ë§ë¨)
/// - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
/// - ë°ì´í„° ë³€í™˜ ë° í•„í„°ë§ ê³„ì‚°
/// - ìƒíƒœ ê´€ë¦¬ëŠ” ëª¨ë‘ Providerë¡œ ì´ì „ë¨
class TradeUsecase {
  final TradeRepository _repository;

  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int maxTrades = 200;
  static const int maxCacheSize = 1000;

  TradeUsecase(this._repository);

  /// ğŸ¯ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ê³„ì‚° (ìˆœìˆ˜ í•¨ìˆ˜)
  /// Providerì—ì„œ í˜¸ì¶œ: usecase.calculateFilteredTrades(cache, threshold, false)
  List<Trade> calculateFilteredTrades(
    Map<double, List<Trade>> filterCache,
    double threshold,
    bool isRangeMode,
  ) {
    if (!isValidThreshold(threshold)) {
      return <Trade>[];
    }

    final merged = <Trade>[];
    final seen = <String>{};

    if (isRangeMode) {
      // êµ¬ê°„ ëª¨ë“œ: threshold ~ nextThreshold ì‚¬ì´ì˜ ê±°ë˜ë§Œ
      final nextThreshold = getNextThreshold(threshold);
      for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
        final trades = filterCache[filter] ?? <Trade>[];
        for (final trade in trades) {
          final id = '${trade.sequentialId}-${trade.timestampMs}';
          final total = trade.total;
          if (total >= threshold && total < nextThreshold && seen.add(id)) {
            merged.add(trade);
          }
        }
      }
    } else {
      // ëˆ„ì  ëª¨ë“œ: threshold ì´ìƒì˜ ëª¨ë“  ê±°ë˜
      for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
        final trades = filterCache[filter] ?? <Trade>[];
        for (final trade in trades) {
          final id = '${trade.sequentialId}-${trade.timestampMs}';
          if (trade.total >= threshold && seen.add(id)) {
            merged.add(trade);
          }
        }
      }
    }

    // ì‹œê°„ ì—­ìˆœ ì •ë ¬ í›„ ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    merged.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return merged.take(maxTrades).toList();
  }

  /// ğŸ¯ ì„ê³„ê°’ ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isValidThreshold(double threshold) {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ì„ê³„ê°’ì€ 1ë§Œì› ì´ìƒ 100ì–µì› ì´í•˜
    const minThreshold = 10000.0; // 1ë§Œì›
    const maxThreshold = 10000000000.0; // 100ì–µì›
    return threshold >= minThreshold && threshold <= maxThreshold;
  }

  /// ğŸ¯ ë‹¤ìŒ ì„ê³„ê°’ ì°¾ê¸° (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  double getNextThreshold(double currentThreshold) {
    final sortedFilters = AppConfig.tradeFilters.toList()..sort();
    
    // í˜„ì¬ ì„ê³„ê°’ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” í•„í„° ì°¾ê¸°
    for (int i = 0; i < sortedFilters.length; i++) {
      if (sortedFilters[i] == currentThreshold) {
        return i + 1 < sortedFilters.length 
            ? sortedFilters[i + 1] 
            : double.infinity;
      }
    }
    
    // ì •í™•íˆ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ìŒìœ¼ë¡œ í° í•„í„° ì°¾ê¸°
    for (final filter in sortedFilters) {
      if (filter > currentThreshold) {
        return filter;
      }
    }
    
    return double.infinity;
  }

  /// ğŸ¯ êµ¬ê°„ ëª¨ë“œì—ì„œ ê±°ë˜ê°€ ë²”ìœ„ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isInRange(Trade trade, double minThreshold, double maxThreshold) {
    final total = trade.total;
    return total >= minThreshold && total < maxThreshold;
  }

  /// ğŸ¯ ê±°ë˜ ëª©ë¡ì„ ì‹œê°„ ì—­ìˆœìœ¼ë¡œ ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Trade> sortTradesByTimeDesc(List<Trade> trades) {
    final sorted = List<Trade>.from(trades);
    sorted.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return sorted;
  }

  /// ğŸ¯ ê±°ë˜ ëª©ë¡ í¬ê¸° ì œí•œ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Trade> limitTradeCount(List<Trade> trades, [int? maxCount]) {
    final limit = maxCount ?? maxTrades;
    return trades.length > limit ? trades.take(limit).toList() : trades;
  }

  /// ğŸ¯ ìœ íš¨í•œ ê±°ë˜ì¸ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isValidTrade(Trade trade) {
    return trade.market.isNotEmpty &&
           trade.price > 0 &&
           trade.volume > 0 &&
           trade.timestampMs > 0 &&
           trade.sequentialId.isNotEmpty;
  }

  /// ğŸ¯ ê±°ë˜ ì´ì•¡ ê³„ì‚° (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  double calculateTradeTotal(double price, double volume) {
    return price * volume;
  }

  /// ğŸ¯ ê±°ë˜ ì‹œì¥ì´ KRW ë§ˆì¼“ì¸ì§€ í™•ì¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™)
  bool isKrwMarket(String market) {
    return market.startsWith('KRW-');
  }

  /// ğŸ¯ ë””ë²„ê·¸ ë¡œê·¸ìš© ì„ê³„ê°’ í¬ë§·íŒ… (ìœ í‹¸ë¦¬í‹°)
  String formatThreshold(double threshold) {
    return threshold.toStringAsFixed(0);
  }

  /// ğŸ¯ ëª¨ë“œ ì´ë¦„ ê°€ì ¸ì˜¤ê¸° (ìœ í‹¸ë¦¬í‹°)
  String getModeName(bool isRangeMode) {
    return isRangeMode ? "êµ¬ê°„" : "ëˆ„ì ";
  }
}\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨
class Trade extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;

  /// ì²´ê²° ë‹¨ê°€
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰
  final double volume;

  /// 'BID' ë˜ëŠ” 'ASK'
  final String side;

  /// ê°€ê²© ë³€ë™ëŸ‰
  final double changePrice;

  /// ë³€ë™ ìƒíƒœ ('RISE'/'FALL'/'EVEN')
  final String changeState;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int timestampMs;

  /// ì¤‘ë³µ ì œê±°ìš© ê³ ìœ  ID
  final String sequentialId;

  const Trade({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  @override
  List<Object?> get props => [
        market,
        price,
        volume,
        side,
        changePrice,
        changeState,
        timestampMs,
        sequentialId,
      ];

  /// ì´ ì²´ê²° ê¸ˆì•¡
  double get total => price * volume;

  /// ë§¤ìˆ˜ ì—¬ë¶€
  bool get isBuy => side == 'BID';

  /// DateTime ë³€í™˜
  DateTime get timestamp => DateTime.fromMillisecondsSinceEpoch(timestampMs);
}
\n\n// ====== lib/presentation/controllers/trade_controller.dart ======\n
// lib/presentation/controllers/trade_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/trade_provider.dart';
import '../../domain/entities/trade.dart';
import '../../domain/usecases/trade_usecase.dart';

/// ğŸ¯ ê¹”ë”í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ TradeController (Volume/Surge íŒ¨í„´ + ê¸°ì¡´ Provider í˜¸í™˜)
class TradeController extends StateNotifier<TradeControllerState> {
  final Ref _ref;
  final TradeUsecase _usecase;
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  TradeController(this._usecase, this._ref) : super(const TradeControllerState()) {
    // âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
    _initializeDataSubscription();
  }

  /// âœ… ë°ì´í„° êµ¬ë… ì´ˆê¸°í™” (ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©)
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      tradeListProvider,  // âœ… ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©
      (previous, next) {
        next.when(
          data: (trades) => _processTradeData(trades),
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
  void _processTradeData(List<Trade> trades) {
    // 1. ë°ì´í„° ì •ë ¬
    final sortedTrades = _applySorting(trades);
    
    // 2. ìƒíƒœ ì—…ë°ì´íŠ¸ (TradeëŠ” HOT/Blink ì—†ìœ¼ë¯€ë¡œ ë‹¨ìˆœ)
    state = state.copyWith(
      trades: sortedTrades,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… ë°ì´í„° ì •ë ¬ (ìˆœìˆ˜ í•¨ìˆ˜)
  List<Trade> _applySorting(List<Trade> tradeData) {
    final sorted = [...tradeData];
    // ìµœì‹  ìˆœìœ¼ë¡œ ì •ë ¬
    sorted.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
    return sorted;
  }

  /// âœ… ì„ê³„ê°’ ì„¤ì • - Providerë¡œ ìœ„ì„
  void setThreshold(double threshold, int index) {
    // âœ… Providerë¡œ ìœ„ì„ (UseCase ì§ì ‘ í˜¸ì¶œ ì œê±°)
    _ref.read(tradeThresholdController).updateThreshold(threshold, index);
    
    // âœ… UI ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      threshold: threshold,
      selectedIndex: index,
    );
  }

  /// âœ… êµ¬ê°„/ëˆ„ì  ëª¨ë“œ í† ê¸€ - Providerë¡œ ìœ„ì„
  void toggleRangeMode() {
    final newMode = !state.isRangeMode;
    
    // âœ… Providerë¡œ ìœ„ì„ (UseCase ì§ì ‘ í˜¸ì¶œ ì œê±°)
    _ref.read(tradeRangeModeProvider.notifier).state = newMode;
    
    // âœ… UI ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(isRangeMode: newMode);
  }

  /// âœ… í˜„ì¬ ì„¤ì •ì— ë”°ë¥¸ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„±
  String getThresholdDisplayText() {
    final threshold = state.threshold;
    final thresholds = availableThresholds;
    final currentIndex = thresholds.indexOf(threshold);
    
    if (state.isRangeMode) {
      // êµ¬ê°„ ëª¨ë“œ
      if (currentIndex >= 0 && currentIndex < thresholds.length - 1) {
        final nextThreshold = thresholds[currentIndex + 1];
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        final nextLabel = AppConfig.filterNames[nextThreshold] ?? nextThreshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabel ~ $nextLabelì›';
      } else {
        final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
        return 'ê¸ˆì•¡ ë ˆì¸ì§€: $currentLabelì› ì´ìƒ';
      }
    } else {
      // ëˆ„ì  ëª¨ë“œ
      final currentLabel = AppConfig.filterNames[threshold] ?? threshold.toStringAsFixed(0);
      return 'ìµœì†Œ ê±°ë˜ê¸ˆì•¡: $currentLabelì›';
    }
  }

  /// âœ… í† ê¸€ ë²„íŠ¼ í…ìŠ¤íŠ¸
  String get toggleButtonText => state.isRangeMode ? 'êµ¬ê°„' : 'ëˆ„ì ';

  /// âœ… ì‚¬ìš© ê°€ëŠ¥í•œ ì„ê³„ê°’ ì˜µì…˜ë“¤
  List<double> get availableThresholds =>
    AppConfig.tradeFilters.where((f) => f >= 20000000).toList();

  /// âœ… ê±°ë˜ ëª©ë¡ ì¶”ê°€ í•„í„° (ì‹œì¥ëª…)
  List<Trade> filterByMarket(String? marketFilter) {
    if (marketFilter == null || marketFilter.isEmpty) {
      return state.trades;
    }
    final upper = marketFilter.toUpperCase();
    return state.trades.where((t) => t.market.contains(upper)).toList();
  }

  /// âœ… ê±°ë˜ ëª©ë¡ ì •ë ¬
  void sortTrades(String field, bool ascending) {
    final list = [...state.trades];
    list.sort((a, b) {
      dynamic aValue;
      dynamic bValue;
      switch (field) {
        case 'market':
          aValue = a.market;
          bValue = b.market;
          break;
        case 'price':
          aValue = a.price;
          bValue = b.price;
          break;
        case 'volume':
          aValue = a.volume;
          bValue = b.volume;
          break;
        case 'total':
          aValue = a.total;
          bValue = b.total;
          break;
        case 'timestamp':
          aValue = a.timestampMs;
          bValue = b.timestampMs;
          break;
        default:
          aValue = a.timestampMs;
          bValue = b.timestampMs;
      }
      final cmp = aValue is Comparable && bValue is Comparable
          ? aValue.compareTo(bValue)
          : 0;
      return ascending ? cmp : -cmp;
    });
    state = state.copyWith(trades: list);
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (Volume/Surge ìŠ¤íƒ€ì¼ë¡œ ë‹¨ìˆœí™”)
class TradeControllerState {
  final List<Trade> trades;           // í‘œì‹œìš© ê±°ë˜ ë°ì´í„°
  final bool isLoading;              // ë¡œë”© ìƒíƒœ
  final double threshold;            // í˜„ì¬ ì„ê³„ê°’
  final int selectedIndex;           // ìŠ¬ë¼ì´ë” ì¸ë±ìŠ¤
  final bool isRangeMode;           // êµ¬ê°„/ëˆ„ì  ëª¨ë“œ
  final String? errorMessage;        // ì—ëŸ¬ ë©”ì‹œì§€

  const TradeControllerState({
    this.trades = const [],
    this.isLoading = false,
    this.threshold = 20000000.0,
    this.selectedIndex = 0,
    this.isRangeMode = false,          // ê¸°ë³¸ê°’: ëˆ„ì  ëª¨ë“œ
    this.errorMessage,
  });

  TradeControllerState copyWith({
    List<Trade>? trades,
    bool? isLoading,
    double? threshold,
    int? selectedIndex,
    bool? isRangeMode,
    String? errorMessage,
  }) {
    return TradeControllerState(
      trades: trades ?? this.trades,
      isLoading: isLoading ?? this.isLoading,
      threshold: threshold ?? this.threshold,
      selectedIndex: selectedIndex ?? this.selectedIndex,
      isRangeMode: isRangeMode ?? this.isRangeMode,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// âœ… Provider ì„ ì–¸ (UIì—ì„œ TradeController ì‚¬ìš©í•˜ê¸° ìœ„í•´ í•„ìˆ˜)
final tradeControllerProvider = StateNotifierProvider<TradeController, TradeControllerState>(
  (ref) {
    final usecase = ref.read(usecaseProvider);  // âœ… ê¸°ì¡´ Provider ì´ë¦„ ì‚¬ìš©
    return TradeController(usecase, ref);
  },
);\n\n// ====== lib/presentation/pages/trade_page.dart ======\n
// lib/presentation/pages/trade_page.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/trade_controller.dart';
import '../widgets/trade_tile.dart';

class TradePage extends ConsumerWidget {
  final ScrollController scrollController;

  const TradePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ) - Volume/Surge íŒ¨í„´
    final state = ref.watch(tradeControllerProvider);
    final controller = ref.read(tradeControllerProvider.notifier);
    
    // âœ… ì„ê³„ê°’ ê´€ë ¨
    final thresholds = controller.availableThresholds;
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    final displayMode = ref.watch(appSettingsProvider).displayMode;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
    final sliderWidget = CommonSliderWidget(
      leftText: controller.getThresholdDisplayText(),
      sliderValue: state.selectedIndex.toDouble(),
      sliderMin: 0.0,
      sliderMax: (thresholds.length - 1).toDouble(),
      sliderDivisions: thresholds.length - 1,
      sliderLabel: AppConfig.filterNames[thresholds[state.selectedIndex]] ?? 
                   thresholds[state.selectedIndex].toStringAsFixed(0),
      onSliderChanged: (value) {
        final index = value.round();
        final threshold = thresholds[index];
        controller.setThreshold(threshold, index);  // âœ… Controller ë©”ì„œë“œ í˜¸ì¶œ (Volume/Surge íŒ¨í„´)
      },
      rightWidget: CommonToggleButton(  // âœ… rightWidgetìœ¼ë¡œ ë³µêµ¬ (ìš°ì¸¡ ìœ„ì¹˜)
        text: controller.toggleButtonText,
        isActive: !state.isRangeMode, // ëˆ„ì ì¼ ë•Œ active
        onTap: () => controller.toggleRangeMode(),  // âœ… Controller ë©”ì„œë“œ í˜¸ì¶œ
        // âœ… Sectorì™€ ë™ì¼í•œ ê¸°ë³¸ í¬ê¸° (fontSize, padding ì œê±°)
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildTradeList(state, controller, thresholds, context, displayMode)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜) - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
  Widget _buildTradeList(
    TradeControllerState state,
    TradeController controller,
    List<double> thresholds,
    BuildContext context,
    DisplayMode displayMode,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ì²´ê²° ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.trades.isEmpty) {
      return Center(
        child: Text(
          'í¬ì°©ëœ ì²´ê²°ì´ ì—†ìŠµë‹ˆë‹¤.\n(ì„ê³„ê°’: ${AppConfig.filterNames[thresholds[state.selectedIndex]] ?? thresholds[state.selectedIndex].toStringAsFixed(0)})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ê±°ë˜ ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì‚¬ìš©) - Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.trades.length,
      addAutomaticKeepAlives: true,   // ğŸ”¥ ë©”ëª¨ë¦¬ ìµœì í™”
      addRepaintBoundaries: true,     // ğŸ”¥ ë¦¬í˜ì¸íŠ¸ ìµœì í™”
      itemBuilder: (_, i) {
        final trade = state.trades[i];
        
        return TradeTile(
          trade: trade,
          displayMode: displayMode,
        );
      },
    );
  }
}\n\n// ====== lib/presentation/widgets/trade_tile.dart ======\n
// lib/presentation/widgets/trade_tile.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import '../../domain/entities/trade.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/amount_display_widget.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/amount_formatter.dart';

class TradeTile extends ConsumerWidget {
  // ğŸ•’ ì‹œê°„ í¬ë§·í„°ë§Œ ìœ ì§€ (ê³ ìœ  ê¸°ëŠ¥)
  static final _timeFormat = DateFormat('HH:mm:ss');
  
  final Trade trade;
  final DisplayMode displayMode;  // âœ… ìƒìœ„ì—ì„œ ë°›ì•„ì˜´ (Volume/Surge íŒ¨í„´)

  const TradeTile({
    Key? key,
    required this.trade,
    required this.displayMode,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final onSurface70 = onSurface.withValues(alpha: 0.7);
    
    // âœ… ìµœì í™”ëœ ì½”ì¸ëª… í‘œì‹œ (TileCommon ì‚¬ìš©)
    final displayName = TileCommon.getDisplayNameOptimized(
      ref,
      trade.market,
      displayMode, // ìƒìœ„ì—ì„œ ë°›ì€ DisplayMode ì‚¬ìš©
    );
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ì‚¬ìš© (Volume/Surgeì™€ ë™ì¼í•œ íŒ¨í„´)
    return TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ•’ ì‹œê°„ ë¶€ë¶„: flex 12
          FlexChild.expanded(
            Text(
              _timeFormat.format(trade.timestamp),
              style: TextStyle(color: onSurface, fontSize: 11),
            ),
            flex: 12,
          ),
          
          // ğŸª™ ì½”ì¸ëª… ë¶€ë¶„: flex 18 - ìµœì í™”ëœ ë²„ì „ ì‚¬ìš©
          FlexChild.expanded(
            Text(
              displayName, // âœ… ìµœì í™”ëœ ë°©ì‹
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: theme.colorScheme.primary,
                fontSize: 16,
              ),
              overflow: TextOverflow.ellipsis,
              maxLines: 1,
            ),
            flex: 18,
          ),
          
          // ğŸ’µ ê°€ê²©/ê±°ë˜ëŸ‰ ë¶€ë¶„: flex 20
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  '${AmountFormatter.formatPrice(trade.price)}ì›', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface, fontSize: 14),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatTradeVolume(trade.volume)}ê°œ', // âœ… ê³µí†µ í¬ë§·í„°
                  style: TextStyle(color: onSurface70, fontSize: 12),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 20,
          ),
          
          // ğŸ’° ì´ì•¡ ë¶€ë¶„: flex 20 - AmountDisplayWidget ì‚¬ìš©
          FlexChild.expanded(
            Align(
              alignment: Alignment.centerRight,
              child: AmountDisplayWidget(
                totalAmount: trade.total,
                isBuy: trade.isBuy,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
            flex: 20,
          ),
          
          // ğŸ“ˆ ë°©í–¥ ì•„ì´ì½˜: ê³ ì • í¬ê¸°
          FlexChild.fixed(
            Icon(
              trade.isBuy ? Icons.arrow_upward : Icons.arrow_downward,
              color: trade.isBuy ? Colors.green : Colors.red,
              size: 16,
            ),
          ),
        ],
      ),
    );
  }
}