\n\n// ====== lib/data/datasources/trade_cache_ds.dart ======\n
// lib/data/datasources/trade_cache_ds.dart
import 'package:hive/hive.dart';
import 'dart:async';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';
import '../../core/error/app_exception.dart';

/// Hive ê¸°ë°˜ ë°°ì¹˜ ì •ë¦¬ ì‹œìŠ¤í…œì„ ì ìš©í•œ ê±°ë˜ ìºì‹œ ë°ì´í„°ì†ŒìŠ¤
/// 
/// ğŸ”§ ê°œì„ ì‚¬í•­:
/// - ë°°ì¹˜ ê¸°ë°˜ ìºì‹œ ì •ë¦¬ë¡œ ì„±ëŠ¥ ìµœì í™”
/// - ì„ê³„ì  ë„ë‹¬ ì‹œì—ë§Œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
/// - ê¸°ì¡´ API í˜¸í™˜ì„± ìœ ì§€
/// - ì •ë¦¬ ì‘ì—… ì¤‘ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
class TradeCacheDataSource {
  // ğŸ“Š ìºì‹œ ì„¤ì •
  static const int _maxCacheSize = 1000;           // ëª©í‘œ ìºì‹œ ì‚¬ì´ì¦ˆ
  static const int _cleanupThreshold = 1200;       // ì •ë¦¬ ì‹œì‘ ì„ê³„ì  (20% ë²„í¼)
  static const int _cleanupBatchSize = 300;        // í•œ ë²ˆì— ì •ë¦¬í•  ê°œìˆ˜
  
  /// ğŸ¯ ì£¼ì…ë°›ì€ Box (ì´ë¯¸ ì—´ë ¤ìˆë‹¤ëŠ” ì „ì œ)
  final Box<TradeDto> _box;
  
  /// ğŸ”’ ì •ë¦¬ ì‘ì—… ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í”Œë˜ê·¸
  bool _isCleaningUp = false;
  
  /// ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ìš© (ì„ íƒì )
  int _totalCacheOps = 0;
  int _cleanupCount = 0;
  
  /// ìƒì„±ì: ì´ë¯¸ ì—´ë¦° Boxë¥¼ ì£¼ì…ë°›ìŒ
  TradeCacheDataSource(this._box);
  
  /// ğŸš€ Tradeë¥¼ DTOë¡œ ë³€í™˜í•´ ì €ì¥ (ë°°ì¹˜ ì •ë¦¬ ì ìš©)
  /// 
  /// ê¸°ì¡´ APIì™€ 100% í˜¸í™˜ì„± ìœ ì§€
  /// Throws: [CacheException] if storage operation fails
  Future<void> cacheTrade(Trade trade) async {
    try {
      // 1. ë°ì´í„° ì €ì¥ (ê¸°ì¡´ê³¼ ë™ì¼)
      final dto = TradeDto(
        market: trade.market,
        price: trade.price,
        volume: trade.volume,
        side: trade.side,
        changePrice: trade.changePrice,
        changeState: trade.changeState,
        timestampMs: trade.timestampMs,
        sequentialId: trade.sequentialId,
      );
      
      await _box.put(trade.sequentialId, dto);
      _totalCacheOps++;
      
      // 2. ë°°ì¹˜ ì •ë¦¬ í™•ì¸ (ì„ê³„ì  ë„ë‹¬ ì‹œì—ë§Œ)
      if (_shouldTriggerCleanup()) {
        // ë¹„ë™ê¸°ë¡œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰ (ë¸”ë¡œí‚¹ ë°©ì§€)
        unawaited(_performBatchCleanup());
      }
    } catch (e) {
      log.e('Failed to cache trade', e);
      throw AppException(
        'Failed to cache trade for market ${trade.market}',
        originalException: e is Exception ? e : Exception(e.toString()),
      );
    }
  }
  
  /// ğŸ§¹ ë°°ì¹˜ ì •ë¦¬ íŠ¸ë¦¬ê±° ì¡°ê±´ í™•ì¸
  bool _shouldTriggerCleanup() {
    return _box.length > _cleanupThreshold && !_isCleaningUp;
  }
  
  /// ğŸ”„ ë°°ì¹˜ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
  Future<void> _performBatchCleanup() async {
    if (_isCleaningUp) return; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    
    _isCleaningUp = true;
    
    try {
      // í˜„ì¬ ìƒíƒœ ì¬í™•ì¸ (ë™ì‹œì„± ì´ìŠˆ ë°©ì§€)
      if (_box.length <= _maxCacheSize) {
        return;
      }
      
      // ì œê±°í•  ê°œìˆ˜ ê³„ì‚°
      final currentSize = _box.length;
      final targetRemoveCount = currentSize - _maxCacheSize;
      final actualRemoveCount = targetRemoveCount.clamp(0, _cleanupBatchSize);
      
      if (actualRemoveCount > 0) {
        // ì˜¤ë˜ëœ í‚¤ë¶€í„° ì œê±° (FIFO ë°©ì‹)
        final keysToRemove = _box.keys
            .take(actualRemoveCount)
            .toList();
        
        await _box.deleteAll(keysToRemove);
        
        _cleanupCount++;
        
        log.d('ğŸ§¹ Cache cleanup: ${keysToRemove.length} items removed, '
              'size: $currentSize â†’ ${_box.length}');
      }
    } catch (e) {
      log.e('Cache cleanup failed', e);
    } finally {
      _isCleaningUp = false;
    }
  }
  
  /// ğŸ“‹ ìºì‹œëœ Trade ì „ë¶€ ë°˜í™˜ (ê¸°ì¡´ API ìœ ì§€)
  List<Trade> getCachedTrades() {
    try {
      return _box.values.map((dto) => dto.toEntity()).toList();
    } catch (e) {
      log.w('Failed to get cached trades', e);
      return [];
    }
  }
  
  /// ğŸ”„ ìµœê·¼ Nê°œ Trade ë°˜í™˜ (ìƒˆë¡œìš´ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ)
  List<Trade> getRecentTrades([int? limit]) {
    try {
      final allTrades = getCachedTrades();
      
      if (limit == null || limit >= allTrades.length) {
        return allTrades;
      }
      
      // timestampMs ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ í›„ ìµœì‹  Nê°œ ë°˜í™˜
      allTrades.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
      return allTrades.take(limit).toList();
    } catch (e) {
      log.w('Failed to get recent trades', e);
      return [];
    }
  }
  
  /// ğŸ—‘ï¸ ìºì‹œ í´ë¦¬ì–´ (ê¸°ì¡´ API ìœ ì§€)
  Future<void> clearCache() async {
    try {
      await _box.clear();
      _totalCacheOps = 0;
      _cleanupCount = 0;
      log.i('Cache cleared completely');
    } catch (e) {
      log.e('Failed to clear cache', e);
      throw AppException(
        'Failed to clear cache', 
        originalException: e is Exception ? e : Exception(e.toString())
      );
    }
  }
  
  /// ğŸ”§ ìˆ˜ë™ ì •ë¦¬ íŠ¸ë¦¬ê±° (í•„ìš”ì‹œ ì™¸ë¶€ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥)
  Future<void> forceCleanup() async {
    if (!_isCleaningUp) {
      await _performBatchCleanup();
    }
  }
  
  /// ğŸ“Š ìºì‹œ ìƒíƒœ ì •ë³´ ë°˜í™˜ (ë””ë²„ê¹…/ëª¨ë‹ˆí„°ë§ìš©)
  Map<String, dynamic> getCacheStats() {
    return {
      'currentSize': _box.length,
      'maxSize': _maxCacheSize,
      'threshold': _cleanupThreshold,
      'totalOperations': _totalCacheOps,
      'cleanupCount': _cleanupCount,
      'isCleaningUp': _isCleaningUp,
      'utilizationPercent': (_box.length / _maxCacheSize * 100).toInt(),
    };
  }
  
  /// ğŸ›ï¸ ëŸ°íƒ€ì„ ì„¤ì • ì¡°ì • (ê³ ê¸‰ ì‚¬ìš©ììš©)
  void adjustCacheSettings({
    int? maxSize,
    int? threshold,
    int? batchSize,
  }) {
    // Note: static const ê°’ë“¤ì€ ëŸ°íƒ€ì„ì— ë³€ê²½ ë¶ˆê°€í•˜ë¯€ë¡œ
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë³€ê²½ í•„ìš”
    log.d('Runtime cache adjustment requested - implement if needed');
  }
}\n\n// ====== lib/data/datasources/trade_remote_ds.dart ======\n
// lib/data/datasources/trade_remote_ds.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../../core/bridge/signal_bus.dart';
import '../../../core/event/app_event.dart';
import '../../../core/network/websocket/trade_ws_client.dart';
import '../models/trade_dto.dart';
import '../../domain/entities/trade.dart';

/// ğŸ”„ ë¦¬íŒ©í† ë§: ë‹¨ìˆœí•˜ê³  ê¹”ë”í•œ Trade ë°ì´í„° ì†ŒìŠ¤
/// - BaseWsClientë¥¼ ë¯¿ê³  ë§¡ê¹€
/// - ê°€ì§œ ë°ì´í„° fallback ì œê±°  
/// - ë³µì¡í•œ êµ¬ë…ì ê´€ë¦¬ ë¡œì§ ì œê±°
/// - ìˆœìˆ˜í•˜ê²Œ "ë°ì´í„° ë³€í™˜ + ë¸Œë¡œë“œìºìŠ¤íŒ…"ë§Œ ë‹´ë‹¹
class TradeRemoteDataSource {
  final TradeWsClient _ws;
  final SignalBus _signalBus;
  final bool _useTestData;

  // ğŸ¯ í•µì‹¬: ë‹¨ìˆœí•œ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _currentStream;
  List<String> _currentMarkets = [];
  bool _disposed = false;

  TradeRemoteDataSource(
    this._ws,
    this._signalBus, {
    bool useTestData = false,
  }) : _useTestData = useTestData;

  /// ğŸ¯ í•µì‹¬ ë©”ì†Œë“œ: ë§ˆì¼“ì´ ë°”ë€” ë•Œë§Œ ìƒˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
  Stream<Trade> watch(List<String> markets) {
    if (_disposed) {
      throw StateError('TradeRemoteDataSource has been disposed');
    }

    if (_useTestData) {
      return _testStream();
    }

    // ë§ˆì¼“ì´ ë°”ë€Œë©´ ìƒˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
    if (!_marketsEqual(_currentMarkets, markets)) {
      debugPrint('TradeRemoteDataSource: Creating new stream for ${markets.length} markets');
      _currentMarkets = List.from(markets);
      _currentStream = _createTradeStream(markets);
    }

    return _currentStream!;
  }

  /// ğŸ”¥ ê³ ê¸‰: ìˆœìˆ˜ì„±ê³¼ ë¶€ìˆ˜íš¨ê³¼ ë¶„ë¦¬
  Stream<Trade> _createTradeStream(List<String> markets) {
    // WebSocket ì—°ê²° ì‹œì‘ (ë¹„ë™ê¸°)
    _ws.connect(markets);
    
    // BaseWsClientì˜ ìŠ¤íŠ¸ë¦¼ ì‚¬ìš©
    return _ws.stream
        .expand((batch) => batch)              // List<Map> â†’ Map
        .map(_parseToTradeDto)                 // Map â†’ TradeDto? (ìˆœìˆ˜ í•¨ìˆ˜)
        .where((dto) => dto != null)           // null í•„í„°ë§
        .cast<TradeDto>()                      // TradeDto? â†’ TradeDto
        .transform(_sideEffectTransformer())   // ë¶€ìˆ˜ íš¨ê³¼ ì²˜ë¦¬ (ì´ë²¤íŠ¸ ë°œì†¡)
        .map((dto) => dto.toEntity())          // TradeDto â†’ Trade (ìˆœìˆ˜ í•¨ìˆ˜)
        .asBroadcastStream();                  // ì—¬ëŸ¬ Repository êµ¬ë… ê°€ëŠ¥
  }

  /// ğŸ¯ ìˆœìˆ˜ í•¨ìˆ˜: íŒŒì‹±ë§Œ ë‹´ë‹¹ (ë¶€ìˆ˜ íš¨ê³¼ ì—†ìŒ)
  TradeDto? _parseToTradeDto(Map<String, dynamic> json) {
    try {
      return TradeDto.tryParse(json);
    } catch (e) {
      debugPrint('TradeRemoteDataSource: Parse error - $e');
      return null;
    }
  }

  /// ğŸ¯ ë¶€ìˆ˜ íš¨ê³¼ ì „ìš© Transformer: ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œ í†µê³¼ì‹œí‚¤ë˜ ì´ë²¤íŠ¸ ë°œì†¡
  StreamTransformer<TradeDto, TradeDto> _sideEffectTransformer() {
    return StreamTransformer.fromHandlers(
      handleData: (TradeDto dto, EventSink<TradeDto> sink) {
        // ğŸ¯ ë¶€ìˆ˜ íš¨ê³¼: SignalBus ì´ë²¤íŠ¸ ë°œì†¡
        _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
        
        // ë°ì´í„°ëŠ” ê·¸ëŒ€ë¡œ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬
        sink.add(dto);
      },
      handleError: (error, stackTrace, EventSink<TradeDto> sink) {
        debugPrint('TradeRemoteDataSource: Stream error - $error');
        // ì—ëŸ¬ë„ ê·¸ëŒ€ë¡œ ì „íŒŒ
        sink.addError(error, stackTrace);
      },
    );
  }

  /// ğŸ¯ ë§ˆì¼“ ë¦¬ìŠ¤íŠ¸ ë¹„êµ (ìˆœì„œ ë¬´ê´€)
  bool _marketsEqual(List<String> a, List<String> b) {
    if (a.length != b.length) return false;
    final setA = Set<String>.from(a);
    final setB = Set<String>.from(b);
    return setA.containsAll(setB) && setB.containsAll(setA);
  }

  /// ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ìš© ìŠ¤íŠ¸ë¦¼ (ê°œë°œ/ë””ë²„ê·¸ìš©)
  Stream<Trade> _testStream() async* {
    final rnd = Random();
    const symbols = [
      'KRW-BTC', 'KRW-ETH', 'KRW-XRP',
      'KRW-DOGE', 'KRW-SOL', 'KRW-ADA',
    ];

    while (!_disposed) {
      await Future.delayed(const Duration(milliseconds: 500));
      if (_disposed) break;

      final nowMs = DateTime.now().millisecondsSinceEpoch;
      final dto = TradeDto(
        market: symbols[rnd.nextInt(symbols.length)],
        price: (rnd.nextDouble() * 1000000 + 10000).roundToDouble(),
        volume: rnd.nextDouble() * 10,
        side: rnd.nextBool() ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: nowMs,
        sequentialId: 'test-$nowMs-${rnd.nextInt(1000)}',
      );
      
      yield dto.toEntity();
      _signalBus.fireTradeEvent(AppEvent.now(dto.toMap()));
    }
  }

  /// ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    if (_disposed) return;
    
    _disposed = true;
    _currentStream = null;
    _currentMarkets.clear();
    
    debugPrint('TradeRemoteDataSource: disposed');
    // BaseWsClientëŠ” TradeWsClientì—ì„œ ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ dispose ì•ˆí•¨
  }
}\n\n// ====== lib/data/datasources/market_mood_remote_ds.dart ======\n
// lib/data/datasources/market_mood_remote_ds.dart
// ğŸŒ Data Layer: ì›ê²© ë°ì´í„° ì†ŒìŠ¤ (ì•ˆì •ì„±ì´ ê²€ì¦ëœ Timer ë°©ì‹ìœ¼ë¡œ ë³µì›)

import 'dart:async';
import '../../core/network/api_client_coingecko.dart';
import '../../core/utils/logger.dart';
import '../../data/models/market_mood_dto.dart';

/// ğŸŒ ë§ˆì¼“ë¬´ë“œ ì›ê²© ë°ì´í„° ì†ŒìŠ¤
class MarketMoodRemoteDataSource {
  final CoinGeckoApiClient _apiClient;
  Timer? _globalDataTimer;
  StreamController<CoinGeckoGlobalDataDto>? _globalDataController;

  MarketMoodRemoteDataSource(this._apiClient);

  Stream<CoinGeckoGlobalDataDto> getGlobalMarketDataStream() {
    // ì´ë¯¸ ìŠ¤íŠ¸ë¦¼ì´ í™œì„±í™”ëœ ê²½ìš° ì¬ì‚¬ìš©
    if (_globalDataController != null && !_globalDataController!.isClosed) {
      return _globalDataController!.stream;
    }
    
    _globalDataController = StreamController<CoinGeckoGlobalDataDto>.broadcast();
    
    Future<void> fetch() async {
      try {
        final responseDto = await _apiClient.getGlobalMarketData();
        final dataDto = responseDto.data;

        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.add(dataDto);
          log.d('ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìˆ˜ì‹  ì„±ê³µ (Timer): ${dataDto.totalVolumeUsd.toStringAsFixed(0)}B USD');
        }
      } catch (e, st) {
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.addError(e, st);
          log.e('âŒ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ (Timer): $e');
        }
      }
    }

    // ì²« í˜¸ì¶œ
    fetch();

    // 30ë¶„ë§ˆë‹¤ í˜¸ì¶œ
    _globalDataTimer = Timer.periodic(const Duration(minutes: 30), (_) => fetch());

    _globalDataController!.onCancel = () {
      _globalDataTimer?.cancel();
      _globalDataTimer = null;
      log.d('ğŸ”„ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë„ˆ ì—†ìŒ. íƒ€ì´ë¨¸ ì¤‘ì§€.');
    };

    return _globalDataController!.stream;
  }

  Future<CoinGeckoGlobalDataDto> getGlobalMarketData() async {
    final responseDto = await _apiClient.getGlobalMarketData();
    return responseDto.data;
  }

  Future<double> getUsdToKrwRate() async {
    return _apiClient.getUsdToKrwRate();
  }

  Future<bool> checkApiHealth() async {
    try {
      await getGlobalMarketData();
      return true;
    } catch (_) {
      return false;
    }
  }

  void dispose() {
    _globalDataTimer?.cancel();
    _globalDataTimer = null;
    _globalDataController?.close();
    _globalDataController = null;
    log.d('ğŸ§¹ MarketMoodRemoteDataSource ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/datasources/settings_local_ds.dart ======\n
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../../domain/entities/app_settings.dart';

class SettingsLocalDataSource {
 final SharedPreferences prefs;

 SettingsLocalDataSource(this.prefs);

 // í…Œë§ˆ ëª¨ë“œ ê´€ë¦¬
 ThemeMode getThemeMode() {
   final themeName = prefs.getString('themeMode') ?? 'system';
   return switch (themeName) {
     'light' => ThemeMode.light,
     'dark' => ThemeMode.dark,
     _ => ThemeMode.system,
   };
 }

 Future<void> saveThemeMode(ThemeMode mode) async {
   await prefs.setString('themeMode', mode.name);
 }

 // í™”ë©´ í•­ìƒ ì¼œê¸° ê´€ë¦¬
 bool getKeepScreenOn() {
   return prefs.getBool('keepScreenOn') ?? false;
 }

 Future<void> saveKeepScreenOn(bool value) async {
   await prefs.setBool('keepScreenOn', value);
 }

 // ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ê´€ë¦¬
 SliderPosition getSliderPosition() {
   final raw = prefs.getString('sliderPosition') ?? 'top';
   return raw == 'bottom' ? SliderPosition.bottom : SliderPosition.top;
 }

 Future<void> saveSliderPosition(SliderPosition position) async {
   await prefs.setString('sliderPosition', position.name);
 }

 // ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ê´€ë¦¬
 DisplayMode getDisplayMode() {
   final raw = prefs.getString('displayMode') ?? 'ticker';
   return switch (raw) {
     'korean' => DisplayMode.korean,
     'english' => DisplayMode.english,
     _ => DisplayMode.ticker,
   };
 }

 Future<void> saveDisplayMode(DisplayMode mode) async {
   await prefs.setString('displayMode', mode.name);
 }

 // ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ê´€ë¦¬
 AmountDisplayMode getAmountDisplayMode() {
   final raw = prefs.getString('amountDisplayMode') ?? 'number';
   return switch (raw) {
     'icon' => AmountDisplayMode.icon,
     _ => AmountDisplayMode.number,
   };
 }

 Future<void> saveAmountDisplayMode(AmountDisplayMode mode) async {
   await prefs.setString('amountDisplayMode', mode.name);
 }

 // ë°˜ì§ì„ íš¨ê³¼ ê´€ë¦¬
 bool getBlinkEnabled() {
   return prefs.getBool('blinkEnabled') ?? true;
 }

 Future<void> saveBlinkEnabled(bool enabled) async {
   await prefs.setBool('blinkEnabled', enabled);
 }

 // í°íŠ¸ íŒ¨ë°€ë¦¬ ê´€ë¦¬
 FontFamily getFontFamily() {
   final raw = prefs.getString('fontFamily') ?? 'pretendard';
   for (final font in FontFamily.values) {
     if (font.name == raw) return font;
   }
   return FontFamily.pretendard;
 }

 Future<void> saveFontFamily(FontFamily font) async {
   await prefs.setString('fontFamily', font.name);
 }

 // í–…í‹± í”¼ë“œë°± ê´€ë¦¬ ğŸ†•
 bool getHapticEnabled() {
   return prefs.getBool('hapticEnabled') ?? true; // ê¸°ë³¸ê°’: í™œì„±í™”
 }

 Future<void> saveHapticEnabled(bool enabled) async {
   await prefs.setBool('hapticEnabled', enabled);
 }

 // í™”ë©´ íšŒì „ ì ê¸ˆ ê´€ë¦¬ ğŸ†•
 bool getPortraitLocked() {
   return prefs.getBool('portraitLocked') ?? false; // ê¸°ë³¸ê°’: ìë™ íšŒì „
 }

 Future<void> savePortraitLocked(bool locked) async {
   await prefs.setBool('portraitLocked', locked);
 }

 // ìºì‹œ ë¹„ìš°ê¸°
 Future<void> clearCache() async {
   final cacheKeys = [
     'coinData_cache',
     'priceHistory_cache',
     'chartData_cache',
     'marketData_cache',
     'imageCache_timestamp',
   ];

   for (final key in cacheKeys) {
     await prefs.remove(key);
   }
 }

 // ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
 Future<void> resetAllSettings() async {
   final settingKeys = [
     'themeMode',
     'keepScreenOn',
     'sliderPosition',
     'displayMode',
     'amountDisplayMode',
     'blinkEnabled',
     'fontFamily',
     'hapticEnabled',        // ğŸ†• ì¶”ê°€
     'portraitLocked',       // ğŸ†• ì¶”ê°€
   ];

   for (final key in settingKeys) {
     await prefs.remove(key);
   }
 }
}\n\n// ====== lib/data/datasources/market_mood_local_ds.dart ======\n
// lib/data/datasources/market_mood_local_ds.dart
// ğŸ’¾ Data Layer: ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤ (Hive ê¸°ë°˜, DI íŒ¨í„´)

import 'package:hive_flutter/hive_flutter.dart';
import '../../core/services/hive_service.dart';
import '../../core/utils/logger.dart';
import '../models/market_mood_dto.dart'; // ğŸ”¥ TimestampedVolumeì´ ì—¬ê¸° ìˆìŒ

/// ğŸ’¾ ë§ˆì¼“ë¬´ë“œ ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤
/// HiveServiceë¥¼ í†µí•œ ë³¼ë¥¨ ë°ì´í„° ì €ì¥/ì¡°íšŒ, í™˜ìœ¨ ìºì‹± (DI íŒ¨í„´)
class MarketMoodLocalDataSource {
  final HiveService _hiveService;
  
  static const String _exchangeRateKey = 'exchange_rate';
  static const String _appStartTimeKey = 'app_start_time';

  MarketMoodLocalDataSource(this._hiveService);

  /// Volume Box ì ‘ê·¼
  Box<TimestampedVolume> get _volumeBox => _hiveService.marketMoodVolumeBox;
  
  /// Cache Box ì ‘ê·¼ 
  Box get _cacheBox => _hiveService.marketMoodCacheBox;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ ìŠ¬ë¡¯)
  Future<void> addVolumeData(TimestampedVolume volume) async {
    try {
      // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”ëœ í‚¤ ìƒì„±
      final slotKey = _getSlotKey(volume.timestamp);
      
      await _volumeBox.put(slotKey, volume);
      log.d('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥: $slotKey -> ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<TimestampedVolume?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final targetTime = DateTime.now().subtract(Duration(minutes: minutes));
      final slotKey = _getSlotKey(targetTime);
      
      final volume = _volumeBox.get(slotKey);
      if (volume != null) {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${volume.volumeUsd.toStringAsFixed(0)}B');
      } else {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì—†ìŒ');
      }
      
      return volume;
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days) async {
    try {
      final now = DateTime.now();
      final cutoffTime = now.subtract(Duration(days: days));
      
      final volumes = _volumeBox.values
          .where((volume) => volume.timestamp.isAfter(cutoffTime))
          .map((volume) => volume.volumeUsd)
          .toList();
      
      if (volumes.isEmpty) {
        log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ë°ì´í„° ì—†ìŒ');
        return null;
      }
      
      final average = volumes.reduce((a, b) => a + b) / volumes.length;
      log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ${average.toStringAsFixed(0)}B (${volumes.length}ê°œ ë°ì´í„°)');
      
      return average;
    } catch (e, st) {
      log.e('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ê³„ì‚° ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount() async {
    try {
      final count = _volumeBox.length;
      log.d('ğŸ“Š ì´ ë°ì´í„° ê°œìˆ˜: $count');
      return count;
    } catch (e, st) {
      log.e('ğŸ“Š ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return 0;
    }
  }

  /// ëˆ„ë½ëœ 30ë¶„ ìŠ¬ë¡¯ í™•ì¸ ë° ë³´ì •
  Future<void> checkAndFillMissingSlots() async {
    try {
      final appStartTime = getAppStartTime();
      final now = DateTime.now();
      final totalMinutes = now.difference(appStartTime).inMinutes;
      final expectedSlots = (totalMinutes / 30).floor();
      
      log.i('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬: ì˜ˆìƒ $expectedSlotsê°œ, ì‹¤ì œ ${_volumeBox.length}ê°œ');
      
      if (_volumeBox.length < expectedSlots) {
        final missing = expectedSlots - _volumeBox.length;
        log.w('âš ï¸ $missingê°œ ìŠ¬ë¡¯ ëˆ„ë½ ê°ì§€');
        // ì‹¤ì œ ë³´ì • ë¡œì§ì€ í•„ìš” ì‹œ êµ¬í˜„
      }
    } catch (e, st) {
      log.e('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬ ì‹¤íŒ¨', e, st);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’± í™˜ìœ¨ ìºì‹±
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í™˜ìœ¨ ìºì‹œ ì €ì¥
  Future<void> cacheExchangeRate(double rate) async {
    try {
      await _cacheBox.put(_exchangeRateKey, {
        'rate': rate,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });
      log.d('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ (12ì‹œê°„ ìœ íš¨)
  Future<double?> getCachedExchangeRate() async {
    try {
      final cached = _cacheBox.get(_exchangeRateKey);
      if (cached == null) return null;
      
      final timestamp = DateTime.fromMillisecondsSinceEpoch(cached['timestamp']);
      final rate = cached['rate'] as double;
      
      // 12ì‹œê°„ ì´ë‚´ì¸ì§€ í™•ì¸ (Providerì™€ ë™ì¼í•œ ìºì‹œ ì •ì±…)
      if (DateTime.now().difference(timestamp).inHours < 12) {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì‚¬ìš©: $rate KRW');
        return rate;
      } else {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ë§Œë£Œ');
        return null;
      }
    } catch (e, st) {
      log.e('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ•°ï¸ ì‹œê°„ ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime() {
    try {
      final cached = _cacheBox.get(_appStartTimeKey);
      if (cached != null) {
        return cached as DateTime;
      }
      
      // ìµœì´ˆ ì‹¤í–‰ ì‹œ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      final now = DateTime.now();
      _cacheBox.put(_appStartTimeKey, now);
      log.i('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì„¤ì •: ${now.toIso8601String()}');
      return now;
    } catch (e, st) {
      log.e('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return DateTime.now(); // fallback
    }
  }

  /// 30ë¶„ ìŠ¬ë¡¯ í‚¤ ìƒì„± (ì •ê·œí™”)
  String _getSlotKey(DateTime timestamp) {
    // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”: ì˜ˆ) 14:23 -> 14:00, 14:47 -> 14:30
    final normalized = DateTime(
      timestamp.year,
      timestamp.month,
      timestamp.day,
      timestamp.hour,
      (timestamp.minute ~/ 30) * 30, // 30ë¶„ ë‹¨ìœ„ë¡œ ë‚´ë¦¼
    );
    
    return normalized.toIso8601String();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë””ë²„ê¹…ìš© ì •ë³´ ë°˜í™˜
  Map<String, Object> getDebugInfo() {
    try {
      final volumeInfo = {
        'total_count': _volumeBox.length,
        'box_open': _volumeBox.isOpen,
        'first_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.first.timestamp.toIso8601String() 
            : 'none',
        'last_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.last.timestamp.toIso8601String() 
            : 'none',
      };
      
      final cacheInfo = {
        'cache_keys': _cacheBox.keys.toList(),
        'app_start_time': getAppStartTime().toIso8601String(),
        'has_exchange_rate': _cacheBox.containsKey(_exchangeRateKey),
        'box_open': _cacheBox.isOpen,
      };

      return {
        'volume_storage': volumeInfo,
        'cache_storage': cacheInfo,
        'hive_service': 'injected',
        'status': 'healthy',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  /// ìƒíƒœ ë¡œê¹…
  void logStatus() {
    final info = getDebugInfo();
    log.i('ğŸ’¾ MarketMoodLocalDataSource ìƒíƒœ: $info');
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    try {
      // HiveServiceê°€ Box ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì •ë¦¬ ì•ˆí•¨
      log.i('ğŸ§¹ MarketMoodLocalDataSource ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', e, st);
    }
  }

  /// ê°œë°œìš©: ëª¨ë“  ë°ì´í„° ì‚­ì œ
  Future<void> clearAllData() async {
    try {
      await _volumeBox.clear();
      await _cacheBox.clear();
      log.w('ğŸ—‘ï¸ ëª¨ë“  ë¡œì»¬ ë°ì´í„° ì‚­ì œ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ—‘ï¸ ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ê°œë°œìš©: ìµœê·¼ Nê°œ ë°ì´í„°ë§Œ ìœ ì§€
  Future<void> trimOldData({int keepCount = 100}) async {
    try {
      if (_volumeBox.length <= keepCount) return;

      final allEntries = _volumeBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp)); // ìµœì‹ ìˆœ

      final toKeep = allEntries.take(keepCount).toList();
      
      await _volumeBox.clear();
      for (final volume in toKeep) {
        await addVolumeData(volume);
      }
      
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬: ${allEntries.length} -> $keepCountê°œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/datasources/analysis_isolate_manager.dart ======\n
\n\n// ====== lib/data/repositories/signal_repository_impl.dart ======\n
import 'dart:async';
import 'dart:math';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/signal.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/signal_repository.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';
import '../../core/utils/pattern_detector.dart';
import '../../core/utils/pattern_config.dart';
import '../../core/utils/market_data_context.dart';

/// ğŸš€ SignalRepositoryImpl V4.0 - ì™„ì „íˆ ê°œì„ ëœ êµ¬ì¡°
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - PatternDetector ì˜ì¡´ì„± ì£¼ì… ë°©ì‹ìœ¼ë¡œ ë³€ê²½
/// - MarketDataContextë¡œ íŒŒë¼ë¯¸í„° ì§€ì˜¥ í•´ê²°
/// - ì±…ì„ ë¶„ë¦¬ ë° ì½”ë“œ ë‹¨ìˆœí™”
/// - í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ êµ¬ì¡°
/// - ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê°œì„ 
class SignalRepositoryImpl implements SignalRepository {
  final TradeRemoteDataSource _remote;
  final TradeAggregator _aggregator;
  final PatternDetector _patternDetector;
  final PatternConfig _patternConfig;

  // ğŸ“Š ë§ˆì¼“ë³„ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  final Map<String, MarketDataContext> _marketContexts = {};

  // ğŸ¯ ì‹ í˜¸ ê´€ë¦¬ ì‹œìŠ¤í…œ
  final Map<PatternType, List<Signal>> _signalLists = {};
  final Map<PatternType, bool> _patternEnabled = {};
  final Set<String> _seenIds = {};

  // ğŸ¯ íŒ¨í„´ë³„ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬
  final Map<PatternType, StreamController<List<Signal>>> _patternControllers = {};
  final StreamController<List<Signal>> _allSignalsController = 
      StreamController<List<Signal>>.broadcast();

  // ğŸ”¥ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _signalStream;
  StreamSubscription<Trade>? _signalSubscription;

  // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ ë° ì •ë¦¬ íƒ€ì´ë¨¸
  Timer? _batchUpdateTimer;
  Timer? _cleanupTimer;

  // ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  final Map<PatternType, int> _signalCounts = {};
  final Map<PatternType, DateTime?> _lastSignalTimes = {};
  int _totalProcessedTrades = 0;
  DateTime? _lastProcessingTime;

  // ==========================================================================
  // ì´ˆê¸°í™”
  // ==========================================================================

  SignalRepositoryImpl(
    this._remote, {
    PatternDetector? patternDetector,
    PatternConfig? patternConfig,
  }) : _aggregator = TradeAggregator(),
       _patternDetector = patternDetector ?? PatternDetector(),
       _patternConfig = patternConfig ?? PatternConfig() {
    _initializePatterns();
    _startCleanupTimer();
    log.i('ğŸš€ SignalRepository V4.0 ì´ˆê¸°í™” ì™„ë£Œ - ê°œì„ ëœ êµ¬ì¡°');
  }

  void _initializePatterns() {
    for (final pattern in PatternType.values) {
      _signalLists[pattern] = [];
      _patternEnabled[pattern] = true;
      _signalCounts[pattern] = 0;
      _patternControllers[pattern] = StreamController<List<Signal>>.broadcast();
    }

    if (kDebugMode) {
      log.i('ğŸ¯ íŒ¨í„´ ì´ˆê¸°í™” ì™„ë£Œ: ${PatternType.values.length}ê°œ íŒ¨í„´');
    }
  }

  /// ğŸ§¹ ë©”ëª¨ë¦¬ ì •ë¦¬ íƒ€ì´ë¨¸ ì‹œì‘
  void _startCleanupTimer() {
    _cleanupTimer = Timer.periodic(const Duration(minutes: 5), (_) {
      _cleanupMarketContexts();
      _cleanupSeenIds();
    });
  }

  /// ğŸ§¹ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  void _cleanupMarketContexts() {
    final now = DateTime.now();
    int removedMarkets = 0;

    _marketContexts.removeWhere((market, context) {
      // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬
      final quality = context.getDataQuality(onlineMetrics: _patternDetector.metrics);
      final isHealthy = quality['overall'] != 'POOR';
      
      // ìµœê·¼ í™œë™ í™•ì¸
      final hasRecentActivity = context.shortestPriceWindow.timestamps.isNotEmpty &&
          now.difference(context.shortestPriceWindow.timestamps.last).inMinutes < 30;
      
      if (!isHealthy || !hasRecentActivity) {
        // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œë„ í•¨ê»˜ ì •ë¦¬
        context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
        removedMarkets++;
        return true;
      }
      
      return false;
    });

    if (kDebugMode && removedMarkets > 0) {
      log.d('ğŸ§¹ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬: $removedMarketsê°œ ë¹„í™œì„± ì‹œì¥ ì œê±° (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)');
    }
  }

  /// ğŸ§¹ ì¤‘ë³µ ê°ì§€ ID ì •ë¦¬
  void _cleanupSeenIds() {
    if (_seenIds.length > AppConfig.signalCacheSize) {
      final excess = _seenIds.length - AppConfig.signalCacheSize;
      final toRemove = _seenIds.take(excess).toList();
      _seenIds.removeAll(toRemove);
    }
  }

  // ==========================================================================
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
  // ==========================================================================

  void _initializeSignalStream(List<String> markets) {
    if (_signalStream != null) return;

    log.i('SignalRepositoryImpl V4.0: ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” - ${markets.length}ê°œ ì‹œì¥');

    _signalStream = _remote.watch(markets).asBroadcastStream();

    _signalSubscription = _signalStream!.listen(
      _processRawTradeForSignal,
      onError: (error, stackTrace) {
        log.e('Signal stream error: $error', stackTrace);
      },
      onDone: () {
        log.i('Signal stream done');
      },
    );
  }

  // ==========================================================================
  // ğŸ“Š ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  // ==========================================================================

  /// ë§ˆì¼“ ë°ì´í„° ì»¨í…ìŠ¤íŠ¸ ìƒì„± ë˜ëŠ” ì¡°íšŒ
  MarketDataContext _getOrCreateMarketContext(String market) {
    return _marketContexts.putIfAbsent(
      market,
      () => MarketDataContext.empty(market),
    );
  }

  /// ëª¨ë“  íƒ€ì„í”„ë ˆì„ ìœˆë„ìš° ì—…ë°ì´íŠ¸ (ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™)
  void _updateMarketContext(Trade trade, DateTime timestamp) {
    final context = _getOrCreateMarketContext(trade.market);
    
    // ê±°ë˜ ê°„ê²© ê³„ì‚°
    final interval = context.intervalWindow != null && 
                    context.intervalWindow!.timestamps.isNotEmpty
        ? timestamp.difference(context.intervalWindow!.timestamps.last).inSeconds.toDouble()
        : 10.0;
    
    // ë§¤ìˆ˜ ë¹„ìœ¨ (ê°„ë‹¨í•œ ì¶”ì •)
    final buyRatio = trade.isBuy ? 1.0 : 0.0;
    
    // ğŸ”¥ ì˜¨ë¼ì¸ ì§€í‘œì™€ í•¨ê»˜ ëª¨ë“  ìœˆë„ìš° ì—…ë°ì´íŠ¸
    context.updateWithOnlineMetrics(
      price: trade.price,
      volume: trade.total,
      timestamp: timestamp,
      buyRatio: buyRatio,
      interval: max(interval, 1.0),
      onlineMetrics: _patternDetector.metrics, // ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
    );
  }

  // ==========================================================================
  // ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬
  // ==========================================================================

  void _processRawTradeForSignal(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      if (!_seenIds.add(key)) return;

      _aggregator.processTrade(
        {
          'market': trade.market,
          'price': trade.price,
          'volume': trade.volume,
          'timestamp': trade.timestampMs,
          'isBuy': trade.isBuy,
          'sequential_id': trade.sequentialId,
        },
        onTradeProcessed: _handleAggregatedTrade,
      );
    } catch (e, stackTrace) {
      log.w('_processRawTradeForSignal error: $e', stackTrace);
    }
  }

  void _handleAggregatedTrade(Map<String, dynamic> aggregatedTrade) {
    try {
      final trade = Trade(
        market: aggregatedTrade['market'] as String,
        price: aggregatedTrade['price'] as double,
        volume: aggregatedTrade['volume'] as double,
        side: (aggregatedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
        changePrice: 0.0,
        changeState: 'EVEN',
        timestampMs: aggregatedTrade['timestamp'] as int,
        sequentialId: aggregatedTrade['sequential_id'] as String? ?? '',
      );

      final now = DateTime.fromMillisecondsSinceEpoch(trade.timestampMs);
      _updateMarketContext(trade, now);
      _analyzePatterns(trade, now);
    } catch (e, stackTrace) {
      log.w('_handleAggregatedTrade error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸ¯ íŒ¨í„´ ë¶„ì„ (ë‹¨ìˆœí™”ëœ ë¡œì§)
  // ==========================================================================

  /// ğŸ¯ ë©”ì¸ íŒ¨í„´ ë¶„ì„ ë¡œì§
  void _analyzePatterns(Trade trade, DateTime now) {
    try {
      final context = _getOrCreateMarketContext(trade.market);
      final detectedSignals = <Signal>[];

      // ğŸ”¥ ê° íŒ¨í„´ì— ëŒ€í•´ ê°ì§€ ìˆ˜í–‰
      for (final pattern in PatternType.values) {
        if (!(_patternEnabled[pattern] ?? false)) continue;

        try {
          // ğŸš€ ê°œì„ ëœ íŒ¨í„´ ê°ì§€ (ë‹¨ì¼ ë©”ì„œë“œ, ëª…í™•í•œ íŒŒë¼ë¯¸í„°)
          final signal = _patternDetector.detectPattern(
            patternType: pattern,
            trade: trade,
            timestamp: now,
            context: context,
          );

          if (signal != null) {
            detectedSignals.add(signal);
            _signalCounts[pattern] = (_signalCounts[pattern] ?? 0) + 1;
            _lastSignalTimes[pattern] = now;
          }
        } catch (e, stackTrace) {
          log.w('Pattern analysis error: ${pattern.name} - $e', stackTrace);
        }
      }

      // ì‹ í˜¸ ì¶”ê°€
      for (final signal in detectedSignals) {
        _addSignal(signal.patternType, signal);
      }

      if (detectedSignals.isNotEmpty) {
        _scheduleBatchUpdate();
      }

      _totalProcessedTrades++;
      _lastProcessingTime = now;
    } catch (e, stackTrace) {
      log.e('_analyzePatterns error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // ğŸš€ ì‹œê·¸ë„ ì¶”ê°€ ë° ê´€ë¦¬
  // ==========================================================================

  void _addSignal(PatternType pattern, Signal signal) {
    final signalList = _signalLists[pattern];
    if (signalList == null) return;

    // ì¤‘ë³µ ì‹ í˜¸ ì²´í¬ (5ë¶„ ì´ë‚´)
    final cutoff = signal.detectedAt.subtract(const Duration(minutes: 5));
    final isDuplicate = signalList.any((existingSignal) =>
        existingSignal.market == signal.market &&
        existingSignal.detectedAt.isAfter(cutoff));

    if (isDuplicate) return;

    signalList.insert(0, signal);

    // ìµœëŒ€ ì‹ í˜¸ ê°œìˆ˜ ì œí•œ
    if (signalList.length > AppConfig.maxSignalsPerPattern) {
      signalList.removeLast();
    }

    if (kDebugMode) {
      final confidence = signal.patternDetails['finalConfidence'] ?? 
                       signal.patternDetails['confidence'] ?? 0.0;
      log.i('ğŸš¨ V4.0 ì‹ í˜¸ ê°ì§€: ${signal.patternType.displayName} - ${signal.market} '
          '(${signal.changePercent.toStringAsFixed(2)}%, ì‹ ë¢°ë„: ${(confidence * 100).toStringAsFixed(1)}%)');
    }
  }

  /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    if (_batchUpdateTimer?.isActive != true) {
      _batchUpdateTimer = Timer(AppConfig.signalBatchInterval, _updateSignalStreams);
    }
  }

  /// ğŸ“Š ëª¨ë“  ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  void _updateSignalStreams() {
    try {
      for (final entry in _signalLists.entries) {
        final pattern = entry.key;
        final signals = List<Signal>.from(entry.value);

        final controller = _patternControllers[pattern];
        if (controller != null && !controller.isClosed) {
          controller.add(signals);
        }
      }

      final allSignals = _signalLists.values.expand((list) => list).toList();
      allSignals.sort((a, b) => b.detectedAt.compareTo(a.detectedAt));
      final recentSignals = allSignals.take(50).toList();

      if (!_allSignalsController.isClosed) {
        _allSignalsController.add(recentSignals);
      }

      if (kDebugMode && allSignals.isNotEmpty) {
        log.d('ğŸš€ V4.0 ì‹ í˜¸ ìŠ¤íŠ¸ë¦¼ ì—…ë°ì´íŠ¸: ${allSignals.length}ê°œ ì´ ì‹ í˜¸');
      }
    } catch (e, stackTrace) {
      log.w('_updateSignalStreams error: $e', stackTrace);
    }
  }

  // ==========================================================================
  // SignalRepository ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
  // ==========================================================================

  @override
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    _initializeSignalStream(markets);
    return _patternControllers[patternType]?.stream ?? const Stream.empty();
  }

  @override
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    _initializeSignalStream(markets);
    return _allSignalsController.stream;
  }

  @override
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ì„¤ì • ì—…ë°ì´íŠ¸ ë¡œì§ (êµ¬ì²´ì ì¸ í‚¤ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
    try {
      _patternConfig.updatePatternConfig(patternType, 'priceChangePercent', threshold);
      log.i('V4.0: íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ - ${patternType.name}: $threshold');
    } catch (e) {
      log.w('íŒ¨í„´ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: $e');
    }
  }

  @override
  double getPatternThreshold(PatternType patternType) {
    return _patternConfig.getConfigValue(patternType, 'priceChangePercent');
  }

  @override
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _patternEnabled[patternType] = enabled;
    log.i('íŒ¨í„´ ${patternType.name} ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}');
  }

  @override
  bool isPatternEnabled(PatternType patternType) {
    return _patternEnabled[patternType] ?? false;
  }

  @override
  void clearSignals(PatternType? patternType) {
    if (patternType != null) {
      _signalLists[patternType]?.clear();
      _patternControllers[patternType]?.add([]);
      _signalCounts[patternType] = 0;
    } else {
      for (final pattern in PatternType.values) {
        _signalLists[pattern]?.clear();
        _patternControllers[pattern]?.add([]);
        _signalCounts[pattern] = 0;
      }
      _patternDetector.clearAllCooldowns();
    }
    _scheduleBatchUpdate();
  }

  // ==========================================================================
  // ğŸ†• V4.0 í™•ì¥ ê¸°ëŠ¥ë“¤
  // ==========================================================================

  /// íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸
  @override
  void updatePatternConfig(PatternType pattern, String key, double value) {
    _patternConfig.updatePatternConfig(pattern, key, value);
  }

  /// íŒ¨í„´ë³„ í†µê³„ ì •ë³´
  @override
  Future<Map<String, dynamic>> getPatternStats(PatternType type) async {
    final signals = _signalLists[type] ?? [];
    final lastSignal = _lastSignalTimes[type];

    return {
      'patternType': type.name,
      'totalSignals': _signalCounts[type] ?? 0,
      'recentSignals': signals.length,
      'lastSignalTime': lastSignal?.toIso8601String(),
      'isEnabled': _patternEnabled[type] ?? false,
      'cooldownStatus': _patternDetector.getCooldownStatus(),
      'config': _patternConfig.getPatternConfig(type),
    };
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final now = DateTime.now();
    final uptime = _lastProcessingTime != null
        ? now.difference(_lastProcessingTime!).inMinutes
        : 0;

    final patternStats = <String, dynamic>{};
    for (final pattern in PatternType.values) {
      patternStats[pattern.name] = await getPatternStats(pattern);
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ìƒíƒœ
    final marketStats = <String, dynamic>{};
    for (final entry in _marketContexts.entries) {
      final quality = entry.value.getDataQuality(onlineMetrics: _patternDetector.metrics);
      marketStats[entry.key] = {
        'quality': quality['overall'],
        'score': quality['overallScore'],
        'timeframes': entry.value.availableTimeframes.length,
        'onlineMetrics': quality['onlineMetrics'], // ì˜¨ë¼ì¸ ì§€í‘œ ìƒíƒœ í¬í•¨
      };
    }

    // ğŸ†• ì „ì²´ ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ê±´ê°•ì„±
    final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'version': '4.1-Online',
      'status': 'healthy',
      'uptime': uptime,
      'totalProcessedTrades': _totalProcessedTrades,
      'lastProcessingTime': _lastProcessingTime?.toIso8601String(),
      'activePatterns': _patternEnabled.values.where((enabled) => enabled).length,
      'trackedMarkets': _marketContexts.length,
      'patternStats': patternStats,
      'marketStats': marketStats,
      'onlineMetricsSystem': onlineMetricsHealth, // ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ì „ì²´ ìƒíƒœ
      'improvements': [
        'Online RSI/MACD Integration',
        'Stream Gap Auto-Recovery', 
        'O(1) Indicator Calculation',
        'Real Divergence Detection',
        'Dependency Injection Architecture',
        'Fixed Parameter Hell',
        'Enhanced Memory Management',
        'Testable Structure',
      ],
    };
  }

  /// ë§ˆì¼“ë³„ ë°ì´í„° í’ˆì§ˆ ì¡°íšŒ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Map<String, dynamic> getMarketDataQuality() {
    final qualityReport = <String, dynamic>{};

    for (final entry in _marketContexts.entries) {
      // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨ í’ˆì§ˆ ê²€ì‚¬
      qualityReport[entry.key] = entry.value.getDataQuality(
        onlineMetrics: _patternDetector.metrics
      );
    }

    // ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± ìš”ì•½
    final onlineHealth = _patternDetector.metrics.getSystemHealth();

    return {
      'totalMarkets': _marketContexts.length,
      'markets': qualityReport,
      'healthyMarkets': qualityReport.values
          .where((q) => q['overall'] == 'EXCELLENT' || q['overall'] == 'GOOD')
          .length,
      'onlineMetricsSummary': {
        'totalMarkets': onlineHealth['totalMarkets'],
        'healthyMarkets': onlineHealth['healthyMarkets'],
        'staleMarkets': onlineHealth['staleMarkets'],
      },
    };
  }

  /// íŒ¨í„´ ì„¤ì • í”„ë¦¬ì…‹ ì ìš©
  @override
  void applyPatternPreset(String presetName) {
    switch (presetName.toLowerCase()) {
      case 'conservative':
        _patternConfig.applyConservativePreset();
        break;
      case 'aggressive':
        _patternConfig.applyAggressivePreset();
        break;
      case 'balanced':
        _patternConfig.applyBalancedPreset();
        break;
      default:
        throw ArgumentError('Unknown preset: $presetName');
    }

    log.i('íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš©: $presetName');
  }

  /// ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
  @override
  Map<String, dynamic> exportConfiguration() {
    return {
      'version': '4.0',
      'timestamp': DateTime.now().toIso8601String(),
      'patternConfig': _patternConfig.exportConfig(),
      'patternEnabled': _patternEnabled.map((k, v) => MapEntry(k.name, v)),
      'systemSettings': {
        'maxSignalsPerPattern': AppConfig.maxSignalsPerPattern,
        'signalCacheSize': AppConfig.signalCacheSize,
        'batchInterval': AppConfig.signalBatchInterval.inMilliseconds,
      },
    };
  }

  @override
  void importConfiguration(Map<String, dynamic> config) {
    try {
      // íŒ¨í„´ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
      if (config['patternConfig'] != null) {
        _patternConfig.importConfig(config['patternConfig']);
      }

      // íŒ¨í„´ í™œì„±í™” ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
      if (config['patternEnabled'] != null) {
        final enabledMap = config['patternEnabled'] as Map<String, dynamic>;
        for (final pattern in PatternType.values) {
          if (enabledMap.containsKey(pattern.name)) {
            _patternEnabled[pattern] = enabledMap[pattern.name] as bool;
          }
        }
      }

      log.i('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ');
    } catch (e, stackTrace) {
      log.e('ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: $e', stackTrace);
      rethrow;
    }
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ìŠ¤íŠ¸ë¦¼ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  @override
  Stream<Map<String, dynamic>> watchPerformanceMetrics() {
    return Stream.periodic(const Duration(seconds: 10), (_) {
      final onlineMetricsHealth = _patternDetector.metrics.getSystemHealth();
      
      return {
        'timestamp': DateTime.now().toIso8601String(),
        'version': '4.1-Online',
        'totalProcessedTrades': _totalProcessedTrades,
        'signalCounts': Map.from(_signalCounts),
        'activeMarkets': _marketContexts.length,
        'cooldownStatus': _patternDetector.getCooldownStatus(),
        'memoryUsage': {
          'totalSignals': _signalLists.values.fold(0, (sum, list) => sum + list.length),
          'seenIdsCount': _seenIds.length,
          'marketContexts': _marketContexts.length,
        },
        'onlineMetrics': {
          'totalMarkets': onlineMetricsHealth['totalMarkets'],
          'healthyMarkets': onlineMetricsHealth['healthyMarkets'],
          'staleMarkets': onlineMetricsHealth['staleMarkets'],
        },
        'architecture': 'V4.1 - Online Indicators + Dependency Injection + Clean Structure',
      };
    });
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  @override
  Future<void> dispose() async {
    log.i('SignalRepositoryImpl V4.0: dispose() ì‹œì‘');

    _batchUpdateTimer?.cancel();
    _cleanupTimer?.cancel();

    _aggregator.flushTrades(onTradeProcessed: (_) {});

    await _signalSubscription?.cancel();
    _signalStream = null;

    // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ì •ë¦¬
    for (final controller in _patternControllers.values) {
      await controller.close();
    }
    await _allSignalsController.close();

    // ë§ˆì¼“ ì»¨í…ìŠ¤íŠ¸ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
    for (final context in _marketContexts.values) {
      context.cleanup(force: true, onlineMetrics: _patternDetector.metrics);
    }
    _marketContexts.clear();

    // ì‹ í˜¸ ë° ìºì‹œ ì •ë¦¬
    _signalLists.clear();
    _signalCounts.clear();
    _lastSignalTimes.clear();
    _seenIds.clear();

    // PatternDetector ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
    _patternDetector.dispose();

    log.i('SignalRepositoryImpl V4.1: dispose() ì™„ë£Œ - ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨');
  }
}\n\n// ====== lib/data/repositories/settings_repository_impl.dart ======\n
import 'package:flutter/material.dart';
import '../../domain/entities/app_settings.dart';
import '../../domain/repositories/settings_repository.dart';
import '../datasources/settings_local_ds.dart';

class SettingsRepositoryImpl implements SettingsRepository {
 final SettingsLocalDataSource dataSource;

 SettingsRepositoryImpl(this.dataSource);

 @override
 Future<AppSettings> getSettings() async {
   return AppSettings(
     themeMode: dataSource.getThemeMode(),
     keepScreenOn: dataSource.getKeepScreenOn(),
     sliderPosition: dataSource.getSliderPosition(),
     displayMode: dataSource.getDisplayMode(),
     amountDisplayMode: dataSource.getAmountDisplayMode(),
     blinkEnabled: dataSource.getBlinkEnabled(),
     fontFamily: dataSource.getFontFamily(),
     isHapticEnabled: dataSource.getHapticEnabled(),        // ğŸ†• ì¶”ê°€
     isPortraitLocked: dataSource.getPortraitLocked(),      // ğŸ†• ì¶”ê°€
   );
 }

 @override
 Future<void> updateThemeMode(ThemeMode mode) async {
   await dataSource.saveThemeMode(mode);
 }

 @override
 Future<void> updateKeepScreenOn(bool value) async {
   await dataSource.saveKeepScreenOn(value);
 }

 @override
 Future<void> updateSliderPosition(SliderPosition position) async {
   await dataSource.saveSliderPosition(position);
 }

 @override
 Future<void> updateDisplayMode(DisplayMode mode) async {
   await dataSource.saveDisplayMode(mode);
 }

 @override
 Future<void> updateAmountDisplayMode(AmountDisplayMode mode) async {
   await dataSource.saveAmountDisplayMode(mode);
 }

 @override
 Future<void> updateBlinkEnabled(bool enabled) async {
   await dataSource.saveBlinkEnabled(enabled);
 }

 @override
 Future<void> updateFontFamily(FontFamily font) async {
   await dataSource.saveFontFamily(font);
 }

 @override
 Future<void> updateHapticEnabled(bool enabled) async {    // ğŸ†• ì¶”ê°€
   await dataSource.saveHapticEnabled(enabled);
 }

 @override
 Future<void> updatePortraitLocked(bool locked) async {    // ğŸ†• ì¶”ê°€
   await dataSource.savePortraitLocked(locked);
 }

 @override
 Future<void> clearCache() async {
   await dataSource.clearCache();
 }

 @override
 Future<void> resetSettings() async {
   await dataSource.resetAllSettings();
 }
}\n\n// ====== lib/data/repositories/surge_repository_impl.dart ======\n
import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/surge.dart';
import '../../domain/repositories/surge_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° í´ë˜ìŠ¤
class SurgeData {
  double? basePrice;      // ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  double currentPrice = 0; // í˜„ì¬ ê°€ê²© (ê³„ì† ì—…ë°ì´íŠ¸)
  double changePercent = 0; // ë³€ë™ë¥  (ê³„ì† ì¬ê³„ì‚°)

  SurgeData({this.basePrice, this.currentPrice = 0, this.changePercent = 0});

  void updatePrice(double price) {
    basePrice ??= price;
    currentPrice = price;
    changePercent = basePrice != null && basePrice! > 0 
        ? ((currentPrice - basePrice!) / basePrice!) * 100 
        : 0.0;
  }

  void reset(double price) {
    basePrice = price;
    currentPrice = price;
    changePercent = 0.0;
  }
}

/// â™»ï¸ 100ms ë°°ì¹˜ ì‹œìŠ¤í…œ + ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë°ì„ ì ìš©í•œ ê¸‰ë“±/ê¸‰ë½ Repository
class SurgeRepositoryImpl implements SurgeRepository {
  final TradeRemoteDataSource _remote;

  // ğŸ“Š ê¸‰ë“±/ê¸‰ë½ ìƒíƒœ ê´€ë¦¬ (ì‹¤ì‹œê°„ ë³€ë™ë¥ )
  final Map<String, Map<String, SurgeData>> _surgeByTimeFrame = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„)
  final Map<String, StreamController<Map<String, SurgeData>>> _surgeControllers = {};
  
  // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
  final Map<String, DateTime> _timeFrameStartTimes = {};
  
  // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  Stream<Trade>? _surgeStream;
  StreamSubscription<Trade>? _surgeSubscription;
  
  // ğŸ†• ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ íƒ€ì´ë¨¸
  Timer? _batchUpdateTimer;
  
  // ğŸ†• dispose ìƒíƒœ ê´€ë¦¬
  bool _disposed = false;

  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxMarketsPerTimeFrame = 200; // ğŸ†• ë©”ëª¨ë¦¬ ì œí•œ ì¶”ê°€
  static const int _maxCacheSize = 1000;
  // ğŸ†• ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì£¼ê¸° (100ms)
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

  SurgeRepositoryImpl(this._remote) {
    _initializeSurgeTracking();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // SURGE ì „ìš© ë©”ì„œë“œë“¤
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê¸‰ë“±/ê¸‰ë½ ì¶”ì  ì´ˆê¸°í™”
  void _initializeSurgeTracking() {
    for (final timeFrameMinutes in AppConfig.timeFrames) {
      final timeFrameStr = '${timeFrameMinutes}m';
      
      // ë¹ˆ ê¸‰ë“±/ê¸‰ë½ ë§µ ì´ˆê¸°í™”
      _surgeByTimeFrame[timeFrameStr] = <String, SurgeData>{};
      
      // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
      _surgeControllers[timeFrameStr] = StreamController<Map<String, SurgeData>>.broadcast();
      
      // ì‹œì‘ ì‹œê°„ ì„¤ì •
      _timeFrameStartTimes[timeFrameStr] = DateTime.now();
      
      // ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§ (Volumeê³¼ ë™ì¼)
      _scheduleNextReset(timeFrameStr, timeFrameMinutes);
    }
    
    if (kDebugMode) {
      debugPrint('ğŸš€ Surge tracking initialized for ${AppConfig.timeFrames.length} timeframes');
    }
  }

  /// ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§ (Volumeê³¼ ë™ì¼í•œ íŒ¨í„´)
  void _scheduleNextReset(String timeFrame, int minutes) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame]!;
    final nextReset = startTime.add(Duration(minutes: minutes));
    final delay = nextReset.difference(now);
    
    if (delay.isNegative) {
      // ì´ë¯¸ ì§€ë‚œ ì‹œê°„ì´ë©´ ì¦‰ì‹œ ë¦¬ì…‹ í›„ ë‹¤ìŒ ì£¼ê¸° ì˜ˆì•½
      _resetTimeFrame(timeFrame);
      _timeFrameStartTimes[timeFrame] = now;
      _scheduleNextReset(timeFrame, minutes);
    } else {
      Timer(delay, () {
        _resetTimeFrame(timeFrame);
        _timeFrameStartTimes[timeFrame] = DateTime.now();
        _scheduleNextReset(timeFrame, minutes); // ì¬ê·€ ì˜ˆì•½
      });
    }
  }

  /// ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryì™€ ë…ë¦½ì )
  void _initializeSurgeStream(List<String> markets) {
    if (_surgeStream != null) return;
    
    debugPrint('SurgeRepositoryImpl: initializing surge stream for ${markets.length} markets');
    
    _surgeStream = _remote.watch(markets).asBroadcastStream();
    
    _surgeSubscription = _surgeStream!.listen(
      _processRawTradeForSurge,
      onError: (error, stackTrace) {
        debugPrint('Surge stream error: $error');
        debugPrint('StackTrace: $stackTrace');
      },
      onDone: () {
        debugPrint('Surge stream done');
      },
    );
  }

  /// Map<String, SurgeData>ë¥¼ Surge ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ì •ë ¬ í¬í•¨)
  List<Surge> _createSurgeList(Map<String, SurgeData> surgeMap, String timeFrame) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame] ?? now;
    
    final surgeList = surgeMap.entries
        .where((entry) => entry.value.basePrice != null && entry.value.changePercent != 0)
        .map((entry) => Surge(
              market: entry.key,
              changePercent: entry.value.changePercent,
              basePrice: entry.value.basePrice!,
              currentPrice: entry.value.currentPrice,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame,
              timeFrameStartMs: startTime.millisecondsSinceEpoch,
            ))
        .toList();

    // ğŸš€ ë³€ë™ë¥  ì‹¤ì œê°’ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ê¸‰ë“±ì´ ìœ„ì—, ê¸‰ë½ì´ ì•„ë˜ì—)
    surgeList.sort((a, b) => b.changePercent.compareTo(a.changePercent));
    
    return surgeList;
  }

  @override
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets) {
    debugPrint('SurgeRepositoryImpl: watchSurgeByTimeFrame() - timeFrame: $timeFrame');
    
    _initializeSurgeStream(markets);
    
    return _surgeControllers[timeFrame]?.stream
        .map((surgeMap) => _createSurgeList(surgeMap, timeFrame))
        ?? const Stream.empty();
  }

  /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ë³€ë™ë¥ ë¡œ ê³„ì‚°í•˜ê³  ì—…ë°ì´íŠ¸ ì˜ˆì•½
  void _processRawTradeForSurge(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';
      if (!_seenIds.add(key)) return;

      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ğŸš€ ë³€ë™ë¥  ê³„ì‚° í›„, ì¦‰ì‹œ ì—…ë°ì´íŠ¸ ëŒ€ì‹  'ì—…ë°ì´íŠ¸ ì˜ˆì•½'
      _calculateSurgeAndScheduleUpdate(trade);
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTradeForSurge error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// ğŸš€ ê±°ë˜ ë°ì´í„°ë¥¼ ë°›ì•„ ë³€ë™ë¥  ê³„ì‚° í›„, ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
  void _calculateSurgeAndScheduleUpdate(Trade trade) {
    final market = trade.market;
    final currentPrice = trade.price;
    
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      final surgeMap = _surgeByTimeFrame[timeFrameStr]!;
      
      // ğŸ†• í¬ê¸° ì œí•œ (ìƒìœ„ 200ê°œë§Œ ìœ ì§€) - Volumeê³¼ ë™ì¼í•œ íŒ¨í„´
      if (surgeMap.length > _maxMarketsPerTimeFrame) {
        final sorted = surgeMap.entries.toList()
          ..sort((a, b) => b.value.changePercent.abs().compareTo(a.value.changePercent.abs()));
        surgeMap.clear();
        surgeMap.addAll(Map.fromEntries(sorted.take(_maxMarketsPerTimeFrame)));
      }
      
      final surgeData = surgeMap[market] ??= SurgeData();
      surgeData.updatePrice(currentPrice);
    }
    
    // ğŸš€ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸ ëŒ€ì‹ , ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
    _scheduleBatchUpdate();
  }

  /// ğŸ†• ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    // ì´ë¯¸ ì˜ˆì•½ëœ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì·¨ì†Œ (ë””ë°”ìš´ì‹±)
    _batchUpdateTimer?.cancel();
    
    // ì§€ì •ëœ ì‹œê°„(100ms) í›„ì— ì—…ë°ì´íŠ¸ ì‹¤í–‰
    _batchUpdateTimer = Timer(_batchUpdateInterval, _performBatchUpdate);
  }

  /// ğŸš€ ëª¨ë“  ì‹œê°„ëŒ€ì˜ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ì„ 'ë°°ì¹˜' ì—…ë°ì´íŠ¸ (íƒ€ì´ë¨¸ì— ì˜í•´ í˜¸ì¶œë¨)
  void _performBatchUpdate() {
    // ğŸ†• dispose ê°€ë“œ ì¶”ê°€
    if (_disposed) return;
    
    try {
      for (final entry in _surgeByTimeFrame.entries) {
        final timeFrameStr = entry.key;
        final surgeMap = Map<String, SurgeData>.from(entry.value);
        
        final controller = _surgeControllers[timeFrameStr];
        if (controller != null && !controller.isClosed) {
          controller.add(surgeMap);
        }
      }
      
      if (kDebugMode) {
        final totalMarkets = _surgeByTimeFrame.values.isNotEmpty 
            ? _surgeByTimeFrame.values.first.length 
            : 0;
        if (totalMarkets > 0) {
          debugPrint('ğŸš€ğŸš€ Surge batch update: $totalMarkets markets (every 100ms)');
        }
      }
    } catch (e, stackTrace) {
      debugPrint('_performBatchUpdate error: $e');
      debugPrint('StackTrace: $stackTrace');
    }
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ë¦¬ì…‹
  void _resetTimeFrame(String timeFrameStr) {
    // ğŸš€ ë³€ë™ë¥  ë¦¬ì…‹: í˜„ì¬ ê°€ê²©ì„ ìƒˆë¡œìš´ basePriceë¡œ ì„¤ì •
    final surgeMap = _surgeByTimeFrame[timeFrameStr];
    if (surgeMap != null) {
      for (final surgeData in surgeMap.values) {
        surgeData.reset(surgeData.currentPrice);
      }
    }
    
    // ğŸš€ ë¦¬ì…‹ í›„ì—ë„ ì¦‰ì‹œ UIì— ë°˜ì˜ë˜ë„ë¡ ë°°ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì§ì ‘ í˜¸ì¶œ
    _performBatchUpdate(); 
  }

  @override
  void resetTimeFrame(String timeFrame) {
    debugPrint('ğŸ”„ Manual reset timeFrame: $timeFrame');
    _resetTimeFrame(timeFrame);
  }

  @override
  void resetAllTimeFrames() {
    debugPrint('ğŸ”„ Manual reset all timeFrames');
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      final surgeMap = _surgeByTimeFrame[timeFrameStr];
      if (surgeMap != null) {
        for (final surgeData in surgeMap.values) {
          surgeData.reset(surgeData.currentPrice);
        }
      }
    }
    // ğŸš€ ë¦¬ì…‹ í›„ì—ë„ ì¦‰ì‹œ UIì— ë°˜ì˜ë˜ë„ë¡ ë°°ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì§ì ‘ í˜¸ì¶œ
    _performBatchUpdate();
  }

  @override
  DateTime? getNextResetTime(String timeFrame) {
    final startTime = _timeFrameStartTimes[timeFrame];
    if (startTime == null) return null;
    
    final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (timeFrameMinutes == null) return null;
    
    return startTime.add(Duration(minutes: timeFrameMinutes));
  }

  @override
  List<String> getActiveTimeFrames() {
    return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  }

  @override
  bool isTimeFrameActive(String timeFrame) {
    return getActiveTimeFrames().contains(timeFrame);
  }

  @override
  Future<void> dispose() async {
    debugPrint('SurgeRepositoryImpl: dispose() called');
    
    // ğŸ†• dispose ìƒíƒœ ë¨¼ì € ì„¤ì •
    _disposed = true;
    
    // ğŸ†• ë°°ì¹˜ íƒ€ì´ë¨¸ ì •ë¦¬
    _batchUpdateTimer?.cancel();
    
    await _surgeSubscription?.cancel();
    _surgeStream = null;
    
    for (final controller in _surgeControllers.values) {
      await controller.close();
    }
    
    debugPrint('SurgeRepositoryImpl: dispose completed');
  }
}\n\n// ====== lib/data/repositories/signal_repository_impl copy.dart ======\n
\n\n// ====== lib/data/repositories/market_mood_repository_impl.dart ======\n
// lib/data/repositories/market_mood_repository_impl.dart
// ğŸ—ï¸ Data Layer: Repository êµ¬í˜„ì²´ (Domain ì¸í„°í˜ì´ìŠ¤ ì™„ì „ ë§¤ì¹­)

import 'dart:async';
import 'package:rxdart/rxdart.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/repositories/market_mood_repository.dart';
import '../datasources/market_mood_local_ds.dart';
import '../datasources/market_mood_remote_ds.dart';
import '../models/market_mood_dto.dart';

/// ğŸ—ï¸ ë§ˆì¼“ë¬´ë“œ Repository êµ¬í˜„ì²´
/// Remote + Local DataSourceë¥¼ í†µí•©í•˜ì—¬ Domain Entityë¡œ ë³€í™˜í•˜ì—¬ ì œê³µ
class MarketMoodRepositoryImpl implements MarketMoodRepository {
  final MarketMoodRemoteDataSource _remoteDataSource;
  final MarketMoodLocalDataSource _localDataSource;

  // [ë¦¬íŒ©í† ë§] ìˆ˜ë™ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ê°€ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ë³€ìˆ˜ ì‚­ì œ
  // StreamController<MarketMoodData>? _marketDataController;
  // StreamSubscription? _remoteSubscription;

  MarketMoodRepositoryImpl(this._remoteDataSource, this._localDataSource);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸŒ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Stream<MarketMoodData> getMarketDataStream() {
    // [ë¦¬íŒ©í† ë§] listen-add ëŒ€ì‹ , stream ì—°ì‚°ìë¥¼ ì‚¬ìš©í•œ ì„ ì–¸ì  ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    return _remoteDataSource
        .getGlobalMarketDataStream()
        .doOnData((globalDataDto) async {
          try {
            final volumeDto = TimestampedVolume(
              timestamp: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
              volumeUsd: globalDataDto.totalVolumeUsd,
            );
            await _localDataSource.addVolumeData(volumeDto);
            log.d('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì™„ë£Œ');
          } catch (e, st) {
            log.e('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì‹¤íŒ¨', e, st);
          }
        })
        .map((globalDataDto) {
          log.d('ğŸ“Š DTO -> Entity ë³€í™˜ ì™„ë£Œ');
          return MarketMoodData(
            totalMarketCapUsd: globalDataDto.totalMarketCapUsd,
            totalVolumeUsd: globalDataDto.totalVolumeUsd,
            btcDominance: globalDataDto.btcDominance,
            marketCapChange24h: globalDataDto.marketCapChangePercentage24hUsd,
            updatedAt: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
          );
        });
  }

  @override
  Future<MarketMoodData?> getCurrentMarketData() async {
    try {
      // [ìˆ˜ì •] remoteDataSourceëŠ” ì´ì œ DTOë¥¼ ë°˜í™˜
      final dataDto = await _remoteDataSource.getGlobalMarketData();
      
      final marketData = MarketMoodData(
        totalMarketCapUsd: dataDto.totalMarketCapUsd,
        totalVolumeUsd: dataDto.totalVolumeUsd,
        btcDominance: dataDto.btcDominance,
        marketCapChange24h: dataDto.marketCapChangePercentage24hUsd,
        updatedAt: DateTime.fromMillisecondsSinceEpoch(dataDto.updatedAt * 1000),
      );
      
      log.d('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì„±ê³µ');
      return marketData;
    } catch (e, st) {
      log.e('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double> getExchangeRate() async {
    try {
      final cachedRate = await _localDataSource.getCachedExchangeRate();
      if (cachedRate != null) {
        return cachedRate;
      }
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      return rate;
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©', e, st);
      return 1400.0;
    }
  }

  @override
  Future<void> refreshExchangeRate() async {
    try {
      log.i('ğŸ’± í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      log.i('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (ë³¼ë¥¨ ë²„í¼) - Domain Entity ì‚¬ìš©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> addVolumeData(VolumeData volume) async {
    try {
      final volumeDto = TimestampedVolume.fromEntity(volume);
      await _localDataSource.addVolumeData(volumeDto);
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final volumeDto = await _localDataSource.getVolumeNMinutesAgo(minutes);
      return volumeDto?.toEntity();
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double?> getAverageVolume(int days) async {
    return _localDataSource.getAverageVolume(days);
  }

  @override
  Future<int> getCollectedDataCount() async {
    return _localDataSource.getCollectedDataCount();
  }

  @override
  DateTime getAppStartTime() {
    return _localDataSource.getAppStartTime();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> syncMissingData() async {
    await _localDataSource.checkAndFillMissingSlots();
  }

  @override
  Future<void> clearOldData() async {
    await _localDataSource.trimOldData(keepCount: 336); // 7ì¼ * 48ìŠ¬ë¡¯/ì¼
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final localInfo = _localDataSource.getDebugInfo();
    final remoteHealth = await _remoteDataSource.checkApiHealth();
    final dataCount = await getCollectedDataCount();
    final appStartTime = getAppStartTime();
    final elapsedMinutes = DateTime.now().difference(appStartTime).inMinutes;

    return {
      'status': 'healthy',
      'local_storage': localInfo,
      'remote_api': {'healthy': remoteHealth, 'status': remoteHealth ? 'ok' : 'error'},
      'data_count': dataCount,
      'app_start_time': appStartTime.toIso8601String(),
      'elapsed_minutes': elapsedMinutes,
      'last_check': DateTime.now().toIso8601String(),
    };
  }

  @override
  Future<void> logCurrentStatus() async {
    final health = await getSystemHealth();
    _localDataSource.logStatus();
    log.i('ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì‹œìŠ¤í…œ ìƒíƒœ: $health');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> injectTestVolumeData(List<VolumeData> testData) async {
    if (testData.isEmpty) return;
    for (final volume in testData) {
      await addVolumeData(volume);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> dispose() async {
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘');
    _remoteDataSource.dispose();
    await _localDataSource.dispose();
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/repositories/volume_repository_impl.dart ======\n
// lib/data/repositories/volume_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import
import '../../domain/repositories/volume_repository.dart';
import '../datasources/trade_remote_ds.dart';

/// ë³¼ë¥¨ ì „ìš© Repository - ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ TradeRemoteDataSource ê³µìœ 
class VolumeRepositoryImpl implements VolumeRepository {
 final TradeRemoteDataSource _remote;

 // ğŸ“Š ë³¼ë¥¨ ìƒíƒœ ê´€ë¦¬ (ì‹¤ì‹œê°„ ëˆ„ì )
 final Map<String, Map<String, double>> _volumeByTimeFrame = {};
 final Set<String> _seenIds = {};
 
 // ğŸ¯ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„)
 final Map<String, StreamController<Map<String, double>>> _volumeControllers = {};
 
 // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
 final Map<String, DateTime> _timeFrameStartTimes = {};
 
 // ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
 Stream<Trade>? _volumeStream;
 StreamSubscription<Trade>? _volumeSubscription;
 
 // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ íƒ€ì´ë¨¸
 Timer? _batchUpdateTimer;
 
 // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
 static const int _maxMarketsPerTimeFrame = 200; // ğŸ”§ ë©”ëª¨ë¦¬ ì œí•œ ì¶”ê°€
 static const int _maxCacheSize = 1000;
 static const Duration _batchUpdateInterval = Duration(milliseconds: 100); // ğŸš€ ë°°ì¹˜ ì²˜ë¦¬ ì¶”ê°€

 VolumeRepositoryImpl(this._remote) {
   // ğŸ†• ë³¼ë¥¨ ê´€ë ¨ ì´ˆê¸°í™”
   _initializeVolumeTracking();
 }

 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 // ğŸ†• VOLUME ì „ìš© ë©”ì„œë“œë“¤
 // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

 /// ë³¼ë¥¨ ì¶”ì  ì´ˆê¸°í™”
 void _initializeVolumeTracking() {
   for (final timeFrameMinutes in AppConfig.timeFrames) {
     final timeFrameStr = '${timeFrameMinutes}m';
     
     // ë¹ˆ ë³¼ë¥¨ ë§µ ì´ˆê¸°í™”
     _volumeByTimeFrame[timeFrameStr] = <String, double>{};
     
     // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
     _volumeControllers[timeFrameStr] = StreamController<Map<String, double>>.broadcast();
     
     // ì‹œì‘ ì‹œê°„ ì„¤ì •
     _timeFrameStartTimes[timeFrameStr] = DateTime.now();
     
     // ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
     _scheduleNextReset(timeFrameStr, timeFrameMinutes);
   }
   
   if (kDebugMode) {
     debugPrint('ğŸ¯ Volume tracking initialized for ${AppConfig.timeFrames.length} timeframes');
   }
 }

 /// ğŸš€ ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
 void _scheduleNextReset(String timeFrame, int minutes) {
   final now = DateTime.now();
   final startTime = _timeFrameStartTimes[timeFrame]!;
   final nextReset = startTime.add(Duration(minutes: minutes));
   final delay = nextReset.difference(now);
   
   if (delay.isNegative) {
     // ì´ë¯¸ ì§€ë‚œ ì‹œê°„ì´ë©´ ì¦‰ì‹œ ë¦¬ì…‹ í›„ ë‹¤ìŒ ì£¼ê¸° ì˜ˆì•½
     _resetTimeFrame(timeFrame);
     _timeFrameStartTimes[timeFrame] = now;
     _scheduleNextReset(timeFrame, minutes);
   } else {
     Timer(delay, () {
       _resetTimeFrame(timeFrame);
       _timeFrameStartTimes[timeFrame] = DateTime.now();
       _scheduleNextReset(timeFrame, minutes); // ì¬ê·€ ì˜ˆì•½
     });
   }
 }

 /// ğŸ”¥ í•µì‹¬: ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (TradeRepositoryì™€ ë…ë¦½ì )
 void _initializeVolumeStream(List<String> markets) {
   if (_volumeStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
   
   debugPrint('VolumeRepositoryImpl: initializing volume stream for ${markets.length} markets');
   
   // ğŸ¯ TradeRemoteDataSource ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìŠ¤íŠ¸ë¦¼ êµ¬ë…
   _volumeStream = _remote.watch(markets).asBroadcastStream();
   
   // ğŸ¯ ë³¼ë¥¨ ì „ìš© êµ¬ë… (ì›ì‹œ ë°ì´í„° ë°”ë¡œ ì²˜ë¦¬)
   _volumeSubscription = _volumeStream!.listen(
     _processRawTradeForVolume,
     onError: (error, stackTrace) {
       debugPrint('Volume stream error: $error');
       debugPrint('StackTrace: $stackTrace');
     },
     onDone: () {
       debugPrint('Volume stream done');
     },
   );
 }

 /// Map<String, double>ì„ Volume ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜ (ì •ë ¬ í¬í•¨)
 List<Volume> _createVolumeList(Map<String, double> volumeMap, String timeFrame) {
   final now = DateTime.now();
   final startTime = _timeFrameStartTimes[timeFrame] ?? now;
   
   final volumeList = volumeMap.entries
       .where((entry) => entry.value > 0) // ë³¼ë¥¨ì´ 0ë³´ë‹¤ í° ê²ƒë§Œ
       .map((entry) => Volume(
             market: entry.key,
             totalVolume: entry.value,
             lastUpdatedMs: now.millisecondsSinceEpoch,
             timeFrame: timeFrame,
             timeFrameStartMs: startTime.millisecondsSinceEpoch,
           ))
       .toList();

   // ë³¼ë¥¨ ìˆœìœ¼ë¡œ ì •ë ¬ (ë†’ì€ ìˆœ)
   volumeList.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
   
   return volumeList;
 }

 @override
 Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets) {
   debugPrint('VolumeRepositoryImpl: watchVolumeByTimeFrame() - timeFrame: $timeFrame');
   
   // ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeVolumeStream(markets);
   
   // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (Volume ë¦¬ìŠ¤íŠ¸ë¡œ)
   return _volumeControllers[timeFrame]?.stream
       .map((volumeMap) => _createVolumeList(volumeMap, timeFrame))
       ?? const Stream.empty();
 }

 /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„°ë¥¼ ë³¼ë¥¨ìœ¼ë¡œ ëˆ„ì  (ë°°ì¹˜ ì²˜ë¦¬)
 void _processRawTradeForVolume(Trade trade) {
   try {
     final key = '${trade.market}/${trade.sequentialId}';

     // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
     if (!_seenIds.add(key)) return;

     // ë©”ëª¨ë¦¬ ê´€ë¦¬
     if (_seenIds.length > _maxCacheSize) {
       final removeCount = (_seenIds.length / 4).ceil();
       final toRemove = _seenIds.take(removeCount).toList();
       _seenIds.removeAll(toRemove);
     }

     // ğŸš€ ë³¼ë¥¨ ë°°ì¹˜ ëˆ„ì 
     _accumulateVolume(trade);
     
   } catch (e, stackTrace) {
     debugPrint('_processRawTradeForVolume error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// ğŸ”§ ê±°ë˜ ë°ì´í„°ë¥¼ ë°›ì„ ë•Œë§ˆë‹¤ ë³¼ë¥¨ ëˆ„ì  (ë°°ì¹˜ ì²˜ë¦¬)
 void _accumulateVolume(Trade trade) {
   final market = trade.market;
   final totalAmount = trade.total;
   
   // ëª¨ë“  ì‹œê°„ëŒ€ì— ë™ì‹œ ëˆ„ì 
   for (final timeFrameStr in _volumeByTimeFrame.keys) {
     final volumeMap = _volumeByTimeFrame[timeFrameStr]!;
     
     // ğŸ”§ í¬ê¸° ì œí•œ (ìƒìœ„ 200ê°œë§Œ ìœ ì§€)
     if (volumeMap.length > _maxMarketsPerTimeFrame) {
       final sorted = volumeMap.entries.toList()
         ..sort((a, b) => b.value.compareTo(a.value));
       volumeMap.clear();
       volumeMap.addAll(Map.fromEntries(sorted.take(_maxMarketsPerTimeFrame)));
     }
     
     volumeMap[market] = (volumeMap[market] ?? 0.0) + totalAmount;
   }
   
   // ğŸš€ ë°°ì¹˜ ìŠ¤ì¼€ì¤„ë§ìœ¼ë¡œ ë³€ê²½
   _scheduleBatchUpdate();
 }

 /// ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (Tradeì™€ ë™ì¼í•œ íŒ¨í„´)
 void _scheduleBatchUpdate() {
   _batchUpdateTimer?.cancel();
   _batchUpdateTimer = Timer(_batchUpdateInterval, () {
     _updateVolumeStreams();
   });
 }

 /// ğŸ”§ ëª¨ë“  ì‹œê°„ëŒ€ì˜ ë³¼ë¥¨ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
 void _updateVolumeStreams() {
   try {
     for (final entry in _volumeByTimeFrame.entries) {
       final timeFrameStr = entry.key;
       final volumeMap = Map<String, double>.from(entry.value);
       
       // í•´ë‹¹ ì‹œê°„ëŒ€ ìŠ¤íŠ¸ë¦¼ì— ë°ì´í„° ì „ì†¡
       final controller = _volumeControllers[timeFrameStr];
       if (controller != null && !controller.isClosed) {
         controller.add(volumeMap);
       }
     }
     
     if (kDebugMode) {
       final totalMarkets = _volumeByTimeFrame.values.isNotEmpty 
           ? _volumeByTimeFrame.values.first.length 
           : 0;
       if (totalMarkets > 0) {
         debugPrint('ğŸš€ Volume streams updated (batch): $totalMarkets markets');
       }
     }
   } catch (e, stackTrace) {
     debugPrint('_updateVolumeStreams error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// íŠ¹ì • ì‹œê°„ëŒ€ ë¦¬ì…‹
 void _resetTimeFrame(String timeFrameStr) {
   _volumeByTimeFrame[timeFrameStr]?.clear();
   _updateVolumeStreams(); // ë¦¬ì…‹ í›„ ë¹ˆ ë°ì´í„° ì „ì†¡
 }

 @override
 void resetTimeFrame(String timeFrame) {
   debugPrint('ğŸ”„ Manual reset timeFrame: $timeFrame');
   _resetTimeFrame(timeFrame);
 }

 @override
 void resetAllTimeFrames() {
   debugPrint('ğŸ”„ Manual reset all timeFrames');
   for (final timeFrameStr in _volumeByTimeFrame.keys) {
     _volumeByTimeFrame[timeFrameStr]?.clear();
   }
   _updateVolumeStreams();
 }

 @override
 DateTime? getNextResetTime(String timeFrame) {
   final startTime = _timeFrameStartTimes[timeFrame];
   if (startTime == null) return null;
   
   final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
   if (timeFrameMinutes == null) return null;
   
   return startTime.add(Duration(minutes: timeFrameMinutes));
 }

 @override
 List<String> getActiveTimeFrames() {
   return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
 }

 @override
 bool isTimeFrameActive(String timeFrame) {
   return getActiveTimeFrames().contains(timeFrame);
 }

 @override
 Future<void> dispose() async {
   debugPrint('VolumeRepositoryImpl: dispose() called');
   
   // ğŸš€ ë°°ì¹˜ íƒ€ì´ë¨¸ ì •ë¦¬ ì¶”ê°€
   _batchUpdateTimer?.cancel();
   
   // ë³¼ë¥¨ êµ¬ë… ì •ë¦¬
   await _volumeSubscription?.cancel();
   _volumeStream = null;
   
   // ë³¼ë¥¨ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
   for (final controller in _volumeControllers.values) {
     await controller.close();
   }
   
   debugPrint('VolumeRepositoryImpl: dispose completed');
 }
}\n\n// ====== lib/data/repositories/trade_repository_impl.dart ======\n
// lib/data/repositories/trade_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/repositories/trade_repository.dart';
import '../datasources/trade_cache_ds.dart';
import '../datasources/trade_remote_ds.dart';
import '../processors/trade_aggregator.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹ì˜ íš¨ìœ¨ì ì¸ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ì ìš©í•œ Repository
class TradeRepositoryImpl implements TradeRepository {
 final TradeRemoteDataSource _remote;
 final TradeCacheDataSource _cache;
 final TradeAggregator _aggregator;

 // ğŸ“Š ë‚´ë¶€ ìƒíƒœ ê´€ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ TradeNotifier ë°©ì‹)
 final Map<double, List<Trade>> _filterLists = {};
 final Set<String> _seenIds = {};
 
 // ğŸ¯ ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤
 final StreamController<List<Trade>> _filteredController = StreamController<List<Trade>>.broadcast();
 final StreamController<Trade> _aggregatedController = StreamController<Trade>.broadcast();
 
 // ğŸ”¥ í•µì‹¬: ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
 Stream<Trade>? _masterStream;
 StreamSubscription<Trade>? _masterSubscription;
 Timer? _periodicFlushTimer;
 Timer? _batchUpdateTimer;
 
 // ğŸ¯ ë™ì  ì„ê³„ê°’ ê´€ë¦¬
 double _currentThreshold = 20000000.0; // ê¸°ë³¸ê°’: 2ì²œë§Œì›
 
 // ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ê´€ë¦¬
 bool _isRangeMode = false; // false: ëˆ„ì  ëª¨ë“œ(ê¸°ë³¸), true: êµ¬ê°„ ëª¨ë“œ
 
 // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
 static const int _maxTrades = 200;
 static const int _maxCacheSize = 1000;
 static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

 TradeRepositoryImpl(this._remote, this._cache)
     : _aggregator = TradeAggregator() {
   
   // í•„í„° ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
   for (final filter in AppConfig.tradeFilters) {
     _filterLists[filter] = [];
   }
   
   // ì£¼ê¸°ì  í”ŒëŸ¬ì‹œ íƒ€ì´ë¨¸
   _periodicFlushTimer = Timer.periodic(
     AppConfig.globalResetInterval,
     (_) => _aggregator.flushTrades(onTradeProcessed: _handleProcessedTrade),
   );
 }

 /// ğŸ”¥ í•µì‹¬: ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ í˜¸ì¶œ)
 void _initializeMasterStream(List<String> markets) {
   if (_masterStream != null) return; // ì´ë¯¸ ì´ˆê¸°í™”ë¨
   
   debugPrint('TradeRepositoryImpl: initializing master stream for ${markets.length} markets');
   
   // ğŸ¯ ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ ìƒì„± (ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ ë‹¤ë¥¸ Repositoryë„ êµ¬ë… ê°€ëŠ¥)
   _masterStream = _remote.watch(markets).asBroadcastStream();
   
   // ğŸ¯ ë‹¨ì¼ êµ¬ë…ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì²˜ë¦¬
   _masterSubscription = _masterStream!.listen(
     _processRawTrade,
     onError: (error, stackTrace) {
       debugPrint('Master stream error: $error');
       debugPrint('StackTrace: $stackTrace');
     },
     onDone: () {
       debugPrint('Master stream done');
     },
   );
 }

 @override
 Stream<Trade> watchTrades(List<String> markets) {
   debugPrint('TradeRepositoryImpl: watchTrades() - ${markets.length} markets');
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeMasterStream(markets);
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì¶”ê°€ êµ¬ë… ì—†ìŒ)
   return _masterStream!;
 }

 @override
 Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets) {
   debugPrint('TradeRepositoryImpl: watchFilteredTrades() - threshold: $threshold');
   
   // ğŸ¯ ìˆ˜ì •: ì„ê³„ê°’ ì—…ë°ì´íŠ¸
   _currentThreshold = threshold;
   
   // ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™”
   _initializeMasterStream(markets);
   
   // ì„ê³„ê°’ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ì¦‰ì‹œ ì¬í•„í„°ë§
   _scheduleBatchUpdate();
   
   // ë°°ì¹˜ ì²˜ë¦¬ëœ ê²°ê³¼ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
   return _filteredController.stream;
 }

 @override
 Stream<Trade> watchAggregatedTrades() {
   return _aggregatedController.stream;
 }

 /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
 @override
 void updateThreshold(double threshold) {
   if (_currentThreshold != threshold) {
     _currentThreshold = threshold;
     debugPrint('ğŸ¯ Threshold updated to: ${threshold.toStringAsFixed(0)}');
     
     // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
     _scheduleBatchUpdate();
   }
 }

 /// ğŸ†• êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì—…ë°ì´íŠ¸
 @override
 void updateRangeMode(bool isRangeMode) {
   if (_isRangeMode != isRangeMode) {
     _isRangeMode = isRangeMode;
     debugPrint('ğŸ”„ Range mode updated to: ${isRangeMode ? "êµ¬ê°„" : "ëˆ„ì "}');
     
     // ì¦‰ì‹œ ì¬í•„í„°ë§ ì‹¤í–‰
     _scheduleBatchUpdate();
   }
 }
 
 /// ğŸ“¥ ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬ (ì˜ˆì „ í”„ë¡œì íŠ¸ ë°©ì‹)
 void _processRawTrade(Trade trade) async {
   try {
     final key = '${trade.market}/${trade.sequentialId}';

     // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
     if (!_seenIds.add(key)) return;

     // ë©”ëª¨ë¦¬ ê´€ë¦¬
     if (_seenIds.length > _maxCacheSize) {
       final removeCount = (_seenIds.length / 4).ceil();
       final toRemove = _seenIds.take(removeCount).toList();
       _seenIds.removeAll(toRemove);
     }

     // ìºì‹œ ì €ì¥
     await _cache.cacheTrade(trade);

     // ğŸ”„ Aggregatorë¥¼ í†µí•œ ê±°ë˜ ì²˜ë¦¬
     _aggregator.processTrade(
       {
         'market': trade.market,
         'price': trade.price,
         'volume': trade.volume,
         'timestamp': trade.timestampMs,
         'isBuy': trade.isBuy,
         'sequential_id': trade.sequentialId,
       },
       onTradeProcessed: _handleProcessedTrade,
     );
     
   } catch (e, stackTrace) {
     debugPrint('_processRawTrade error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }
 
 /// ğŸ¯ ì§‘ê³„ëœ ê±°ë˜ ì²˜ë¦¬ ë° í•„í„°ë§ (í•µì‹¬ ë¡œì§)
 void _handleProcessedTrade(Map<String, dynamic> processedTrade) {
   try {
     // Trade ì—”í‹°í‹°ë¡œ ë³€í™˜
     final trade = Trade(
       market: processedTrade['market'] as String,
       price: processedTrade['price'] as double,
       volume: processedTrade['volume'] as double,
       side: (processedTrade['isBuy'] as bool) ? 'BID' : 'ASK',
       changePrice: 0.0,
       changeState: 'EVEN',
       timestampMs: processedTrade['timestamp'] as int,
       sequentialId: processedTrade['sequential_id'] as String,
     );
     
     // ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ì— ì¶”ê°€
     if (!_aggregatedController.isClosed) {
       _aggregatedController.add(trade);
     }
     
     final total = trade.total;
     
     // ğŸ“‹ ê° í•„í„°ì— í•´ë‹¹í•˜ëŠ” ê±°ë˜ ì¶”ê°€
     for (final filter in AppConfig.tradeFilters) {
       if (total >= filter) {
         final list = _filterLists[filter]!;
         list.insert(0, trade);
         
         // ìµœëŒ€ ê±°ë˜ ìˆ˜ ìœ ì§€
         if (list.length > _maxTrades) {
           list.removeLast();
         }
       }
     }
     
     // ğŸš€ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ê³¼ë„í•œ UI ì—…ë°ì´íŠ¸ ë°©ì§€)
     _scheduleBatchUpdate();
     
   } catch (e, stackTrace) {
     debugPrint('_handleProcessedTrade error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }
 
 /// â° ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§ (ì˜ˆì „ í”„ë¡œì íŠ¸ì˜ _updateFilteredTrades ë°©ì‹)
 void _scheduleBatchUpdate() {
   // ì´ë¯¸ ìŠ¤ì¼€ì¤„ëœ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ë¦¬ì…‹
   _batchUpdateTimer?.cancel();
   
   _batchUpdateTimer = Timer(_batchUpdateInterval, () {
     _updateFilteredTrades();
   });
 }
 
 /// ğŸ“Š í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ì—…ë°ì´íŠ¸ (UI ì—…ë°ì´íŠ¸) - ğŸ†• êµ¬ê°„/ëˆ„ì  ë¡œì§ ì¶”ê°€
 void _updateFilteredTrades() {
   try {
     final threshold = _currentThreshold;
     
     final merged = <Trade>[];
     final seen = <String>{};

     if (_isRangeMode) {
       // ğŸ†• êµ¬ê°„ ëª¨ë“œ: í˜„ì¬ ì„ê³„ê°’ ~ ë‹¤ìŒ ì„ê³„ê°’ê¹Œì§€ë§Œ
       final nextThreshold = _getNextThreshold(threshold);
       
       for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
         for (final trade in _filterLists[filter] ?? <Trade>[]) {
           final id = '${trade.sequentialId}-${trade.timestampMs}';
           final total = trade.total;
           
           // ğŸ¯ êµ¬ê°„ í•„í„°ë§: threshold <= total < nextThreshold
           if (total >= threshold && total < nextThreshold && seen.add(id)) {
             merged.add(trade);
           }
         }
       }
       
       if (kDebugMode) {
         debugPrint('ğŸ”„ Range mode: ${threshold.toStringAsFixed(0)} ~ ${nextThreshold.toStringAsFixed(0)}');
       }
     } else {
       // ğŸ”„ ëˆ„ì  ëª¨ë“œ: í˜„ì¬ ì„ê³„ê°’ ì´ìƒ ëª¨ë“  ê±°ë˜ (ê¸°ì¡´ ë°©ì‹)
       for (final filter in AppConfig.tradeFilters.where((f) => f >= threshold)) {
         for (final trade in _filterLists[filter] ?? <Trade>[]) {
           final id = '${trade.sequentialId}-${trade.timestampMs}';
           if (trade.total >= threshold && seen.add(id)) {
             merged.add(trade);
           }
         }
       }
       
       if (kDebugMode) {
         debugPrint('ğŸ“ˆ Cumulative mode: ${threshold.toStringAsFixed(0)} ì´ìƒ');
       }
     }

     // ì‹œê°„ìˆœ ì •ë ¬ (ìµœì‹  ìˆœ)
     merged.sort((a, b) => b.timestampMs.compareTo(a.timestampMs));
     
     // ìµœëŒ€ ê±°ë˜ ìˆ˜ë¡œ ì œí•œ
     final result = merged.take(_maxTrades).toList();
     
     // ğŸš€ UIì— ì—…ë°ì´íŠ¸ ì „ì†¡
     if (!_filteredController.isClosed) {
       _filteredController.add(result);
       
       if (kDebugMode && result.isNotEmpty) {
         final modeText = _isRangeMode ? "êµ¬ê°„" : "ëˆ„ì ";
         debugPrint('ğŸ¯ Batch update ($modeText): ${result.length} filtered trades');
       }
     }
     
   } catch (e, stackTrace) {
     debugPrint('_updateFilteredTrades error: $e');
     debugPrint('StackTrace: $stackTrace');
   }
 }

 /// ğŸ†• ë‹¤ìŒ ì„ê³„ê°’ ì°¾ê¸° (êµ¬ê°„ ëª¨ë“œìš©)
 double _getNextThreshold(double currentThreshold) {
   final sortedFilters = AppConfig.tradeFilters.toList()..sort();
   
   for (int i = 0; i < sortedFilters.length; i++) {
     if (sortedFilters[i] == currentThreshold) {
       // ë‹¤ìŒ ì„ê³„ê°’ì´ ìˆìœ¼ë©´ ë°˜í™˜, ì—†ìœ¼ë©´ ë¬´í•œëŒ€
       return i + 1 < sortedFilters.length 
           ? sortedFilters[i + 1] 
           : double.infinity;
     }
   }
   
   // í˜„ì¬ ì„ê³„ê°’ì´ ë¦¬ìŠ¤íŠ¸ì— ì—†ìœ¼ë©´ ê·¸ë³´ë‹¤ í° ì²« ë²ˆì§¸ ê°’ ë°˜í™˜
   for (final filter in sortedFilters) {
     if (filter > currentThreshold) {
       return filter;
     }
   }
   
   return double.infinity;
 }

 @override
 Future<void> dispose() async {
   debugPrint('TradeRepositoryImpl: dispose() called');
   
   // íƒ€ì´ë¨¸ë“¤ ì •ë¦¬
   _periodicFlushTimer?.cancel();
   _batchUpdateTimer?.cancel();
   
   // ë§ˆìŠ¤í„° êµ¬ë… ì •ë¦¬
   await _masterSubscription?.cancel();
   _masterStream = null;
   
   // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
   await _filteredController.close();
   await _aggregatedController.close();
   
   // ë°ì´í„°ì†ŒìŠ¤ ì •ë¦¬ (remoteë§Œ)
   await _remote.dispose();
   
   // Aggregator í”ŒëŸ¬ì‹œ
   _aggregator.flushTrades(onTradeProcessed: (_) {});
 }
}\n\n// ====== lib/data/models/market_mood_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'market_mood_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TimestampedVolumeAdapter extends TypeAdapter<TimestampedVolume> {
  @override
  final int typeId = 1;

  @override
  TimestampedVolume read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TimestampedVolume(
      timestamp: fields[0] as DateTime,
      volumeUsd: fields[1] as double,
    );
  }

  @override
  void write(BinaryWriter writer, TimestampedVolume obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.volumeUsd);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimestampedVolumeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalDataDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalDataDto> {
  @override
  final int typeId = 2;

  @override
  CoinGeckoGlobalDataDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalDataDto(
      totalMarketCapUsd: fields[0] as double,
      totalVolumeUsd: fields[1] as double,
      btcDominance: fields[2] as double,
      marketCapChangePercentage24hUsd: fields[3] as double,
      updatedAt: fields[4] as int,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalDataDto obj) {
    writer
      ..writeByte(5)
      ..writeByte(0)
      ..write(obj.totalMarketCapUsd)
      ..writeByte(1)
      ..write(obj.totalVolumeUsd)
      ..writeByte(2)
      ..write(obj.btcDominance)
      ..writeByte(3)
      ..write(obj.marketCapChangePercentage24hUsd)
      ..writeByte(4)
      ..write(obj.updatedAt);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalDataDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalResponseDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalResponseDto> {
  @override
  final int typeId = 3;

  @override
  CoinGeckoGlobalResponseDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalResponseDto(
      data: fields[0] as CoinGeckoGlobalDataDto,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalResponseDto obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.data);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalResponseDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/market_mood_dto.dart ======\n
// lib/data/models/market_mood_dto.dart
// ğŸŒ Data Layer: í†µí•© DTO ëª¨ë¸ (Trade ìŠ¤íƒ€ì¼)

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../core/utils/date_time.dart'; // DateTime extension
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';

part 'market_mood_dto.g.dart';

/// ğŸ“ˆ ì¸íŠ¸ë¼ë°ì´ ë³¼ë¥¨ ë°ì´í„° (30ë¶„ ë‹¨ìœ„) - Hive ëª¨ë¸
@HiveType(typeId: 1) // TradeDtoê°€ typeId: 0 ì‚¬ìš©í•˜ë¯€ë¡œ 1 ì‚¬ìš©
class TimestampedVolume extends HiveObject {
  @HiveField(0)
  final DateTime timestamp;

  @HiveField(1)
  final double volumeUsd;

  TimestampedVolume({
    required this.timestamp,
    required this.volumeUsd,
  });

  /// Domain Entityë¡œ ë³€í™˜
  VolumeData toEntity() => VolumeData(
    timestamp: timestamp,
    volumeUsd: volumeUsd,
  );

  /// Domain Entityì—ì„œ ìƒì„±
  factory TimestampedVolume.fromEntity(VolumeData entity) => TimestampedVolume(
    timestamp: entity.timestamp,
    volumeUsd: entity.volumeUsd,
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'timestamp': timestamp.toIso8601String(),
    'volumeUsd': volumeUsd,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹±
  static TimestampedVolume? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final timestampStr = m['timestamp']?.toString() ?? '';
      final volumeUsd = (m['volumeUsd'] as num?)?.toDouble() ?? 0.0;

      if (timestampStr.isEmpty) return null;

      return TimestampedVolume(
        timestamp: DateTime.parse(timestampStr),
        volumeUsd: volumeUsd,
      );
    } catch (e) {
      log.w('TimestampedVolume.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TimestampedVolume.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TimestampedVolume(
        timestamp: DateTime.now(),
        volumeUsd: 0.0,
      );

  /// DateTime extension í™œìš©
  String get formattedTime => timestamp.yyyyMMddhhmm();
  String get timeAgoText => timestamp.timeAgo();
  String get shortTime => timestamp.hhmmss();

  @override
  String toString() => 'TimestampedVolume($formattedTime, ${volumeUsd.toStringAsFixed(2)}B)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° DTO
@HiveType(typeId: 2)
class CoinGeckoGlobalDataDto extends HiveObject {
  @HiveField(0)
  final double totalMarketCapUsd;

  @HiveField(1)
  final double totalVolumeUsd;

  @HiveField(2)
  final double btcDominance;

  @HiveField(3)
  final double marketCapChangePercentage24hUsd;

  @HiveField(4)
  final int updatedAt;

  CoinGeckoGlobalDataDto({
    required this.totalMarketCapUsd,
    required this.totalVolumeUsd,
    required this.btcDominance,
    required this.marketCapChangePercentage24hUsd,
    required this.updatedAt,
  });

  /// Domain Entityë¡œ ë³€í™˜
  MarketMoodData toEntity() => MarketMoodData(
    totalMarketCapUsd: totalMarketCapUsd,
    totalVolumeUsd: totalVolumeUsd,
    btcDominance: btcDominance,
    marketCapChange24h: marketCapChangePercentage24hUsd,
    updatedAt: DateTime.fromMillisecondsSinceEpoch(updatedAt * 1000),
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'total_market_cap_usd': totalMarketCapUsd,
    'total_volume_usd': totalVolumeUsd,
    'btc_dominance': btcDominance,
    'market_cap_change_percentage_24h_usd': marketCapChangePercentage24hUsd,
    'updated_at': updatedAt,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (CoinGecko API ì‘ë‹µ í˜•íƒœ)
  static CoinGeckoGlobalDataDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch ~/ 1000
            : DateTime.now().millisecondsSinceEpoch ~/ 1000;
      }

      final totalMarketCap = m['total_market_cap'] as Map<String, dynamic>?;
      final totalVolume = m['total_volume'] as Map<String, dynamic>?;
      final marketCapPercentage = m['market_cap_percentage'] as Map<String, dynamic>?;

      return CoinGeckoGlobalDataDto(
        totalMarketCapUsd: parseDouble(totalMarketCap?['usd']),
        totalVolumeUsd: parseDouble(totalVolume?['usd']),
        btcDominance: parseDouble(marketCapPercentage?['btc']),
        marketCapChangePercentage24hUsd: parseDouble(m['market_cap_change_percentage_24h_usd']),
        updatedAt: parseInt(m['updated_at']),
      );
    } catch (e) {
      log.w('CoinGeckoGlobalDataDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalDataDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalDataDto(
        totalMarketCapUsd: 0.0,
        totalVolumeUsd: 0.0,
        btcDominance: 0.0,
        marketCapChangePercentage24hUsd: 0.0,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

  @override
  String toString() => 'CoinGeckoGlobalDataDto(volume: ${totalVolumeUsd.toStringAsFixed(0)}B USD)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ì‘ë‹µ ë˜í¼ DTO
@HiveType(typeId: 3)
class CoinGeckoGlobalResponseDto extends HiveObject {
  @HiveField(0)
  final CoinGeckoGlobalDataDto data;

  CoinGeckoGlobalResponseDto({
    required this.data,
  });

  Map<String, dynamic> toMap() => {
    'data': data.toMap(),
  };

  String toJson() => json.encode(toMap());

  static CoinGeckoGlobalResponseDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      final dataMap = m['data'] as Map<String, dynamic>?;
      if (dataMap == null) return null;
      final data = CoinGeckoGlobalDataDto.tryParse(dataMap);
      if (data == null) return null;
      return CoinGeckoGlobalResponseDto(data: data);
    } catch (e) {
      log.w('CoinGeckoGlobalResponseDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalResponseDto.fromJson(Map<String, dynamic> json) {
     final parsed = tryParse(json);
     if(parsed != null) return parsed;
     
     return CoinGeckoGlobalResponseDto(
        data: CoinGeckoGlobalDataDto(
          totalMarketCapUsd: 0.0,
          totalVolumeUsd: 0.0,
          btcDominance: 0.0,
          marketCapChangePercentage24hUsd: 0.0,
          updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        ),
      );
  }

  @override
  String toString() => 'CoinGeckoGlobalResponseDto(data: $data)';
}\n\n// ====== lib/data/models/trade_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trade_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TradeDtoAdapter extends TypeAdapter<TradeDto> {
  @override
  final int typeId = 0;

  @override
  TradeDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TradeDto(
      market: fields[0] as String,
      price: fields[1] as double,
      volume: fields[2] as double,
      side: fields[3] as String,
      changePrice: fields[4] as double,
      changeState: fields[5] as String,
      timestampMs: fields[6] as int,
      sequentialId: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TradeDto obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.market)
      ..writeByte(1)
      ..write(obj.price)
      ..writeByte(2)
      ..write(obj.volume)
      ..writeByte(3)
      ..write(obj.side)
      ..writeByte(4)
      ..write(obj.changePrice)
      ..writeByte(5)
      ..write(obj.changeState)
      ..writeByte(6)
      ..write(obj.timestampMs)
      ..writeByte(7)
      ..write(obj.sequentialId);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TradeDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/volume_dto.dart ======\n
\n\n// ====== lib/data/models/pattern_data_dto.dart ======\n
\n\n// ====== lib/data/models/trade_dto.dart ======\n
// lib/data/models/trade_dto.dart

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../domain/entities/trade.dart';
import '../../core/utils/logger.dart';

part 'trade_dto.g.dart';

@HiveType(typeId: 0)
class TradeDto {
  @HiveField(0)
  final String market;

  @HiveField(1)
  final double price;

  @HiveField(2)
  final double volume;

  @HiveField(3)
  final String side;

  @HiveField(4)
  final double changePrice;

  @HiveField(5)
  final String changeState;

  @HiveField(6)
  final int timestampMs;

  @HiveField(7)
  final String sequentialId;

  TradeDto({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  Trade toEntity() => Trade(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestampMs,
        sequentialId: sequentialId,
      );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜ (camelCase í‚¤ ì‚¬ìš©ìœ¼ë¡œ ì‹œìŠ¤í…œ í†µì¼)
  Map<String, dynamic> toMap() => {
        'market': market,
        'price': price,
        'volume': volume,
        'side': side,
        'changePrice': changePrice,
        'changeState': changeState,
        'timestampMs': timestampMs,
        'sequentialId': sequentialId,
      };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (ì—¬ëŸ¬ í‚¤ ë„¤ì´ë° ì§€ì›)
  static TradeDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      log.d('TradeDto.tryParse: ${m.toString().substring(0, m.toString().length.clamp(0, 100))}');

      String parseString(dynamic v, [String fallback = '']) =>
          v != null ? v.toString() : fallback;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch
                              : DateTime.now().millisecondsSinceEpoch;
      }

      final market = parseString(m['market'] ?? m['symbol'] ?? m['code'], 'UNKNOWN');
      final price = parseDouble(m['price'] ?? m['trade_price']);
      final volume = parseDouble(m['volume'] ?? m['trade_volume']);
      final side = parseString(m['side'] ?? m['ask_bid'], 'UNKNOWN');

      final changePrice = parseDouble(m['changePrice'] ?? m['change_price']);
      final changeState = parseString(m['changeState'] ?? m['change_state'], 'EVEN');
      final timestamp = parseInt(m['timestampMs'] ?? m['timestamp_ms'] ?? m['timestamp']);
      final sequentialId = parseString(
        m['sequentialId'] ?? m['sequential_id'] ?? m['sid'], 
        timestamp.toString(),
      );

      return TradeDto(
        market: market,
        price: price,
        volume: volume,
        side: side,
        changePrice: changePrice,
        changeState: changeState,
        timestampMs: timestamp,
        sequentialId: sequentialId,
      );
    } catch (e) {
      log.w('TradeDto.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TradeDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TradeDto(
        market: 'ERROR',
        price: 0.0,
        volume: 0.0,
        side: 'UNKNOWN',
        changePrice: 0.0,
        changeState: 'UNKNOWN',
        timestampMs: DateTime.now().millisecondsSinceEpoch,
        sequentialId: 'ERROR',
      );
}
\n\n// ====== lib/data/processors/volume_aggregator.dart ======\n
\n\n// ====== lib/data/processors/trade_aggregator.dart ======\n
// lib/features/trade/data/utils/trade_aggregator.dart
import 'package:flutter/foundation.dart';
import '../../../core/config/app_config.dart';

/// ì˜ˆì „ í”„ë¡œì íŠ¸ì™€ ê°™ì´ íš¨ìœ¨ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” ê±°ë˜ ì§‘ê³„ê¸°
class TradeAggregator {
  final Map<String, Map<String, dynamic>> _lastTrades = {};
  final int mergeWindow = AppConfig.mergeWindowMs;

  /// ê±°ë˜ ì²˜ë¦¬ ë° ë³‘í•© ë¡œì§
  void processTrade(
    Map<String, dynamic> trade, {
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      // ì•ˆì „í•œ null ì²´í¬ì™€ íƒ€ì… ìºìŠ¤íŒ…
      final market = trade['market'] as String? ?? '';
      final price = trade['price'] as double? ?? 0.0;
      final volume = trade['volume'] as double? ?? 0.0;
      final timestamp = trade['timestamp'] as int? ?? 0;
      final isBuy = trade['isBuy'] as bool? ?? true;
      final sequentialId = trade['sequential_id'] as String? ?? '';

      // ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (market.isEmpty || price <= 0 || volume <= 0 || timestamp <= 0) {
        if (kDebugMode) {
          debugPrint('TradeAggregator: Invalid trade data, skipping: market=$market, price=$price, volume=$volume, timestamp=$timestamp');
        }
        return;
      }

      final total = price * volume;

      if (_lastTrades.containsKey(market)) {
        final lastTrade = _lastTrades[market]!;
        final lastTs = lastTrade['timestamp'] as int;

        // ì‹œê°„ ìœˆë„ìš° ë‚´ì˜ ê±°ë˜ë©´ ë³‘í•©
        if (timestamp - lastTs <= mergeWindow) {
          final lastTotal = lastTrade['total'] as double;
          final lastVolume = lastTrade['volume'] as double;
          final newTotal = lastTotal + total;
          final newVolume = lastVolume + volume;

          // ê°€ì¤‘ í‰ê·  ê°€ê²© ê³„ì‚°
          final avgPrice = newTotal / newVolume;

          // ë³‘í•©ëœ ê±°ë˜ ì •ë³´ ì—…ë°ì´íŠ¸
          lastTrade['price'] = avgPrice;
          lastTrade['volume'] = newVolume;
          lastTrade['total'] = newTotal;
          lastTrade['timestamp'] = timestamp; // ìµœì‹  ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
          lastTrade['sequential_id'] = sequentialId;
          lastTrade['isBuy'] = isBuy; // ìµœì‹  ê±°ë˜ì˜ ë°©í–¥ ì‚¬ìš©

          if (kDebugMode) {
            debugPrint(
              'Merged trade: $market, total: ${newTotal.toStringAsFixed(0)}, avg_price: ${avgPrice.toStringAsFixed(2)}',
            );
          }
        } else {
          // ì‹œê°„ ìœˆë„ìš°ë¥¼ ë²—ì–´ë‚˜ë©´ ì´ì „ ê±°ë˜ ì²˜ë¦¬í•˜ê³  ìƒˆ ê±°ë˜ë¡œ êµì²´
          onTradeProcessed(Map<String, dynamic>.from(lastTrade));
          _lastTrades[market] = {
            'market': market,
            'price': price,
            'volume': volume,
            'total': total,
            'timestamp': timestamp,
            'isBuy': isBuy,
            'sequential_id': sequentialId,
          };
        }
      } else {
        // ìƒˆë¡œìš´ ë§ˆì¼“ì˜ ì²« ê±°ë˜
        final newTrade = {
          'market': market,
          'price': price,
          'volume': volume,
          'total': total,
          'timestamp': timestamp,
          'isBuy': isBuy,
          'sequential_id': sequentialId,
        };
        _lastTrades[market] = newTrade;
        // ğŸ”¥ ì¤‘ìš”: ì²« ê±°ë˜ë„ ë°”ë¡œ ì²˜ë¦¬í•˜ì—¬ UIì— ë°˜ì˜
        onTradeProcessed(Map<String, dynamic>.from(newTrade));
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator processTrade error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í”ŒëŸ¬ì‹œ
  void flushTrades({
    required Function(Map<String, dynamic>) onTradeProcessed,
  }) {
    try {
      final tradesCount = _lastTrades.length;
      for (final trade in _lastTrades.values) {
        onTradeProcessed(Map<String, dynamic>.from(trade));
      }
      _lastTrades.clear();
      
      if (kDebugMode) {
        debugPrint('TradeAggregator: $tradesCount trades flushed');
      }
    } catch (e, stackTrace) {
      if (kDebugMode) {
        debugPrint('TradeAggregator flushTrades error: $e');
        debugPrint('StackTrace: $stackTrace');
      }
    }
  }

  /// íŠ¹ì • ë§ˆì¼“ì˜ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ê°€ì ¸ì˜¤ê¸° (ë””ë²„ê¹…ìš©)
  Map<String, dynamic>? getPendingTrade(String market) {
    return _lastTrades[market] != null
        ? Map<String, dynamic>.from(_lastTrades[market]!)
        : null;
  }

  /// í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê±°ë˜ ìˆ˜
  int get pendingTradesCount => _lastTrades.length;

  /// ëª¨ë“  ëŒ€ê¸° ê±°ë˜ í´ë¦¬ì–´ (í…ŒìŠ¤íŠ¸/ë””ë²„ê·¸ìš©)
  void clear() {
    _lastTrades.clear();
  }
}\n\n// ====== lib/data/processors/pattern_analyzer.dart ======\n
\n\n// ====== lib/data/processors/pattern_strategy.dart ======\n
\n\n// ====== lib/data/processors/streaming_market_buffer.dart ======\n
\n\n// ====== lib/data/factories/signal_stream_factory.dart ======\n
