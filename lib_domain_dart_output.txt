\n\n// ====== lib/domain/repositories/surge_repository.dart ======\n
// lib/domain/repositories/surge_repository.dart
import '../entities/surge.dart';

/// ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ì¶”ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class SurgeRepository {
  /// ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ìŠ¤íŠ¸ë¦¼ ì œê³µ (Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³€ë™ë¥  ì ˆëŒ“ê°’ ìˆœ ì •ë ¬)
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/market_mood_repository.dart ======\n
// lib/domain/repositories/market_mood_repository.dart
// ğŸ¯ Domain Layer: Repository ì¸í„°í˜ì´ìŠ¤ (í´ë¦° ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)

import '../entities/market_mood.dart';

/// ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
/// Data Layerì—ì„œ êµ¬í˜„í•´ì•¼ í•  ê³„ì•½ì„ ì •ì˜ (Domain â†’ Data ì˜ì¡´ì„± ì œê±°)
abstract class MarketMoodRepository {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¡ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (30ë¶„ ì£¼ê¸°)
  Stream<MarketMoodData> getMarketDataStream();

  /// í˜„ì¬ ë§ˆì¼“ ë°ì´í„° í•œ ë²ˆ ì¡°íšŒ
  Future<MarketMoodData?> getCurrentMarketData();

  /// í˜„ì¬ USD/KRW í™˜ìœ¨ ì¡°íšŒ (ìºì‹œ í¬í•¨)
  Future<double> getExchangeRate();

  /// í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (Hive ë³¼ë¥¨ ë²„í¼)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ë§ˆë‹¤)
  Future<void> addVolumeData(VolumeData volume);

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes);

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days);

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount();

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ëˆ„ë½ëœ ìŠ¬ë¡¯ ë³´ì •
  Future<void> syncMissingData();

  /// ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
  Future<void> clearOldData();

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth();

  /// í˜„ì¬ ìƒíƒœ ë¡œê¹…
  Future<void> logCurrentStatus();

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì…
  Future<void> injectTestVolumeData(List<VolumeData> testData);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë° ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/momentary_repository.dart ======\n
\n\n// ====== lib/domain/repositories/settings_repository.dart ======\n
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';

abstract class SettingsRepository {
 /// í˜„ì¬ ì•± ì„¤ì • ê°€ì ¸ì˜¤ê¸°
 Future<AppSettings> getSettings();

 /// í…Œë§ˆ ëª¨ë“œ ì—…ë°ì´íŠ¸
 Future<void> updateThemeMode(ThemeMode mode);

 /// í™”ë©´ í•­ìƒ ì¼œê¸° ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updateKeepScreenOn(bool value);

 /// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ ì—…ë°ì´íŠ¸
 Future<void> updateSliderPosition(SliderPosition position);

 /// ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
 Future<void> updateDisplayMode(DisplayMode mode);

 /// ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ ì—…ë°ì´íŠ¸
 Future<void> updateAmountDisplayMode(AmountDisplayMode mode);

 /// ë°˜ì§ì„ íš¨ê³¼ ì—…ë°ì´íŠ¸
 Future<void> updateBlinkEnabled(bool enabled);

 /// í°íŠ¸ íŒ¨ë°€ë¦¬ ì—…ë°ì´íŠ¸
 Future<void> updateFontFamily(FontFamily font);

 /// í–…í‹± í”¼ë“œë°± ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updateHapticEnabled(bool enabled);    // ğŸ†• ì¶”ê°€

 /// í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì • ì—…ë°ì´íŠ¸
 Future<void> updatePortraitLocked(bool locked);    // ğŸ†• ì¶”ê°€

 /// ìºì‹œ ë¹„ìš°ê¸°
 Future<void> clearCache();

 /// ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”
 Future<void> resetSettings();
}\n\n// ====== lib/domain/repositories/signal_repository.dart ======\n
import '../entities/signal.dart';

/// ğŸš€ Signal Repository ì¸í„°í˜ì´ìŠ¤ V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì§€ì›
/// - ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
/// - ì„¤ì • ë‚´ë³´ë‚´ê¸°/ê°€ì ¸ì˜¤ê¸°
/// - ì‹¤ì‹œê°„ ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€
abstract class SignalRepository {
  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================
  
  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  );

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets);

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ê¸°ì¡´ + V4.1 í™•ì¥)
  // ==========================================================================
  
  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸
  void updatePatternThreshold(PatternType patternType, double threshold);

  /// í˜„ì¬ ì„¤ì •ëœ íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType);

  /// íŒ¨í„´ë³„ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled);

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType);

  /// ê°ì§€ëœ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearSignals(PatternType? patternType);

  // ==========================================================================
  // ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í™•ì¥ ê¸°ëŠ¥
  // ==========================================================================
  
  /// íŒ¨í„´ë³„ ê³ ê¸‰ ì„¤ì • ì—…ë°ì´íŠ¸ (zScoreThreshold, buyRatioMin ë“±)
  void updatePatternConfig(PatternType pattern, String key, double value);

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (conservative, aggressive, balanced)
  void applyPatternPreset(String presetName);

  /// íŒ¨í„´ë³„ í†µê³„ ì •ë³´ ì¡°íšŒ (ì‹ í˜¸ ê°œìˆ˜, ë§ˆì§€ë§‰ ê°ì§€ ì‹œê°„ ë“±)
  Future<Map<String, dynamic>> getPatternStats(PatternType type);

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<Map<String, dynamic>> getSystemHealth();

  /// ë§ˆì¼“ë³„ ë°ì´í„° í’ˆì§ˆ ì¡°íšŒ (ì˜¨ë¼ì¸ ì§€í‘œ ê±´ê°•ì„± í¬í•¨)
  Map<String, dynamic> getMarketDataQuality();

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  Stream<Map<String, dynamic>> watchPerformanceMetrics();

  // ==========================================================================
  // ğŸ†• V4.1 ì„¤ì • ê´€ë¦¬ (ë°±í…ŒìŠ¤íŒ…, A/B í…ŒìŠ¤íŠ¸ ì§€ì›)
  // ==========================================================================
  
  /// í˜„ì¬ ì„¤ì • ë‚´ë³´ë‚´ê¸° (JSON í˜•íƒœ)
  Map<String, dynamic> exportConfiguration();

  /// ì„¤ì • ê°€ì ¸ì˜¤ê¸° (ë°±ì—… ë³µì›, í”„ë¦¬ì…‹ ì ìš©)
  void importConfiguration(Map<String, dynamic> config);

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================
  
  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  Future<void> dispose();
}\n\n// ====== lib/domain/repositories/trade_repository.dart ======\n
// lib/domain/repositories/trade_repository.dart
import '../entities/trade.dart';

/// Provides streams of trade data and handles resource cleanup.
abstract class TradeRepository {
 /// Streams raw [Trade] events for the given list of market codes.
 Stream<Trade> watchTrades(List<String> markets);
 
 /// Streams lists of [Trade] filtered by a minimum total trade value.
 /// => markets íŒŒë¼ë¯¸í„° ì¶”ê°€
 Stream<List<Trade>> watchFilteredTrades(double threshold, List<String> markets);
 
 /// Streams aggregated [Trade] events over a merge window.
 Stream<Trade> watchAggregatedTrades();
 
 /// ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ë™ì  ì„ê³„ê°’ ì—…ë°ì´íŠ¸
 void updateThreshold(double threshold);
 
 /// ğŸ†• ìƒˆë¡œ ì¶”ê°€: êµ¬ê°„/ëˆ„ì  ëª¨ë“œ ì—…ë°ì´íŠ¸
 void updateRangeMode(bool isRangeMode);
 
 /// Releases any held resources (e.g., WebSocket connections, Hive boxes).
 Future<void> dispose();
}\n\n// ====== lib/domain/repositories/volume_repository.dart ======\n
// lib/domain/repositories/volume_repository.dart

import '../entities/volume.dart'; // ğŸ†• Volume ì—”í‹°í‹° import

/// ë³¼ë¥¨ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ëˆ„ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class VolumeRepository {
  /// ì‹œê°„ëŒ€ë³„ ê±°ë˜ëŸ‰ ìŠ¤íŠ¸ë¦¼ ì œê³µ (Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Volume ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³¼ë¥¨ìˆœ ì •ë ¬)
  Stream<List<Volume>> watchVolumeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/signal_usecase.dart ======\n
import '../entities/signal.dart';
import '../repositories/signal_repository.dart';

/// ğŸš€ Signal UseCase V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì‹œìŠ¤í…œ ì—°ë™
/// - ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™
/// - ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§
/// - ë°±í…ŒìŠ¤íŒ… ì§€ì›
/// - ì„±ëŠ¥ ìµœì í™”ëœ í•„í„°ë§
class SignalUseCase {
  final SignalRepository _repository;

  const SignalUseCase(this._repository);

  // ==========================================================================
  // ê¸°ë³¸ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ (ê¸°ì¡´ í˜¸í™˜ì„±)
  // ==========================================================================

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchSignalsByPattern(
    PatternType patternType,
    List<String> markets,
  ) {
    return _repository.watchSignalsByPattern(patternType, markets);
  }

  /// ëª¨ë“  íŒ¨í„´ì˜ ì‹œê·¸ë„ ìŠ¤íŠ¸ë¦¼ ê°ì‹œ
  Stream<List<Signal>> watchAllSignals(List<String> markets) {
    return _repository.watchAllSignals(markets);
  }

  // ==========================================================================
  // íŒ¨í„´ ì„¤ì • ê´€ë¦¬ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updatePatternThreshold(PatternType patternType, double threshold) {
    // ê¸°ë³¸ ê²€ì¦
    if (threshold <= 0) {
      throw ArgumentError('Threshold must be positive: $threshold');
    }

    // V4.1 íŒ¨í„´ë³„ ì„ê³„ê°’ ë²”ìœ„ ê²€ì¦ (ì™„í™”ëœ ê¸°ì¤€ ì ìš©)
    switch (patternType) {
      case PatternType.surge:
        if (threshold < 0.1 || threshold > 50.0) {
          throw ArgumentError('Surge threshold must be between 0.1% and 50%: $threshold');
        }
        break;
      case PatternType.flashFire:
        if (threshold < 1.1 || threshold > 10.0) {
          throw ArgumentError('FlashFire threshold must be between 1.1x and 10x: $threshold');
        }
        break;
      case PatternType.stackUp:
        if (threshold < 2 || threshold > 10) {
          throw ArgumentError('StackUp threshold must be between 2 and 10: $threshold');
        }
        break;
      case PatternType.stealthIn:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 300ë§Œ ~ 1ì–µ
        if (threshold < 3000000 || threshold > 100000000) {
          throw ArgumentError('StealthIn threshold must be between 3M and 100M: $threshold');
        }
        break;
      case PatternType.blackHole:
        // V4.1 ì™„í™”ëœ ê¸°ì¤€: 0.5% ~ 5%
        if (threshold < 0.5 || threshold > 5.0) {
          throw ArgumentError('BlackHole threshold must be between 0.5% and 5%: $threshold');
        }
        break;
      case PatternType.reboundShot:
        if (threshold < 0.5 || threshold > 20.0) {
          throw ArgumentError('ReboundShot threshold must be between 0.5% and 20%: $threshold');
        }
        break;
    }

    _repository.updatePatternThreshold(patternType, threshold);
  }

  /// íŒ¨í„´ë³„ ì„ê³„ê°’ ì¡°íšŒ
  double getPatternThreshold(PatternType patternType) {
    return _repository.getPatternThreshold(patternType);
  }

  /// íŒ¨í„´ í™œì„±í™”/ë¹„í™œì„±í™” ì„¤ì •
  void setPatternEnabled(PatternType patternType, bool enabled) {
    _repository.setPatternEnabled(patternType, enabled);
  }

  /// íŒ¨í„´ í™œì„±í™” ìƒíƒœ ì¡°íšŒ
  bool isPatternEnabled(PatternType patternType) {
    return _repository.isPatternEnabled(patternType);
  }

  /// íŠ¹ì • íŒ¨í„´ì˜ ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearPatternSignals(PatternType patternType) {
    _repository.clearSignals(patternType);
  }

  /// ëª¨ë“  ì‹œê·¸ë„ ëª©ë¡ ì´ˆê¸°í™”
  void clearAllSignals() {
    _repository.clearSignals(null);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ê³ ê¸‰ íŒ¨í„´ ì„¤ì • (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í¬í•¨)
  // ==========================================================================

  /// ê³ ê¸‰ íŒ¨í„´ ì„¤ì • ì—…ë°ì´íŠ¸ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦)
  void updateAdvancedPatternConfig(PatternType pattern, String key, double value) {
    // ì„¤ì • í‚¤ë³„ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    switch (key) {
      case 'zScoreThreshold':
        if (value < 0.5 || value > 5.0) {
          throw ArgumentError('Z-Score threshold must be between 0.5 and 5.0: $value');
        }
        break;
      case 'buyRatioMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio must be between 0.0 and 1.0: $value');
        }
        break;
      case 'buyRatioMax':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('Buy ratio max must be between 0.0 and 1.0: $value');
        }
        break;
      case 'cvThreshold':
        if (value < 0.001 || value > 0.5) {
          throw ArgumentError('CV threshold must be between 0.001 and 0.5: $value');
        }
        break;
      case 'rSquaredMin':
        if (value < 0.0 || value > 1.0) {
          throw ArgumentError('R-squared must be between 0.0 and 1.0: $value');
        }
        break;
      default:
        // ì¼ë°˜ì ì¸ ì–‘ìˆ˜ ê²€ì¦
        if (value < 0) {
          throw ArgumentError('Configuration value must be non-negative: $value');
        }
    }

    _repository.updatePatternConfig(pattern, key, value);
  }

  /// íŒ¨í„´ í”„ë¦¬ì…‹ ì ìš© (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê²€ì¦)
  void applyPatternPreset(String presetName) {
    final validPresets = ['conservative', 'aggressive', 'balanced'];
    if (!validPresets.contains(presetName.toLowerCase())) {
      throw ArgumentError('Invalid preset name. Valid options: ${validPresets.join(', ')}');
    }

    _repository.applyPatternPreset(presetName);
  }

  // ==========================================================================
  // ğŸ†• V4.1 ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„
  // ==========================================================================

  /// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
  Future<PatternPerformanceStats> getPatternPerformance(PatternType pattern) async {
    final stats = await _repository.getPatternStats(pattern);
    final systemHealth = await _repository.getSystemHealth();
    
    return PatternPerformanceStats(
      patternType: pattern,
      totalSignals: stats['totalSignals'] ?? 0,
      recentSignals: stats['recentSignals'] ?? 0,
      lastSignalTime: stats['lastSignalTime'] != null 
          ? DateTime.parse(stats['lastSignalTime'])
          : null,
      isEnabled: stats['isEnabled'] ?? false,
      config: Map<String, double>.from(stats['config'] ?? {}),
      cooldownStatus: Map<String, dynamic>.from(stats['cooldownStatus'] ?? {}),
      onlineMetricsHealth: systemHealth['onlineMetricsSystem'],
    );
  }

  /// ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
  Future<SystemHealthReport> getSystemHealthReport() async {
    final health = await _repository.getSystemHealth();
    final dataQuality = _repository.getMarketDataQuality();
    
    return SystemHealthReport(
      version: health['version'] ?? 'Unknown',
      status: health['status'] ?? 'Unknown',
      uptime: health['uptime'] ?? 0,
      totalProcessedTrades: health['totalProcessedTrades'] ?? 0,
      activePatterns: health['activePatterns'] ?? 0,
      trackedMarkets: health['trackedMarkets'] ?? 0,
      onlineMetricsHealth: health['onlineMetricsSystem'],
      marketDataQuality: dataQuality,
      lastProcessingTime: health['lastProcessingTime'] != null 
          ? DateTime.parse(health['lastProcessingTime'])
          : null,
    );
  }

  /// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤ ìŠ¤íŠ¸ë¦¼ (í•„í„°ë§ í¬í•¨)
  Stream<PerformanceMetrics> watchFilteredPerformanceMetrics() {
    return _repository.watchPerformanceMetrics().map((raw) {
      return PerformanceMetrics(
        timestamp: DateTime.parse(raw['timestamp']),
        version: raw['version'] ?? 'Unknown',
        totalProcessedTrades: raw['totalProcessedTrades'] ?? 0,
        activeMarkets: raw['activeMarkets'] ?? 0,
        signalCounts: Map<String, int>.from(raw['signalCounts'] ?? {}),
        memoryUsage: Map<String, dynamic>.from(raw['memoryUsage'] ?? {}),
        onlineMetrics: Map<String, dynamic>.from(raw['onlineMetrics'] ?? {}),
        architecture: raw['architecture'] ?? 'Unknown',
      );
    });
  }

  // ==========================================================================
  // ì‹œê·¸ë„ ë¶„ì„ ë° í•„í„°ë§ (ê°œì„ ëœ ë¡œì§)
  // ==========================================================================

  /// ì‹œê·¸ë„ í†µê³„ ì •ë³´ ê³„ì‚° (V4.1 ì˜¨ë¼ì¸ ì§€í‘œ í¬í•¨)
  SignalStats calculateSignalStats(List<Signal> signals) {
    if (signals.isEmpty) {
      return const SignalStats(
        totalCount: 0,
        patternCounts: {},
        avgChangePercent: 0.0,
        maxChangePercent: 0.0,
        minChangePercent: 0.0,
        totalTradeAmount: 0.0,
        avgConfidence: 0.0,
        onlineMetricsCount: 0,
      );
    }

    final patternCounts = <PatternType, int>{};
    double totalChangePercent = 0.0;
    double maxChangePercent = signals.first.changePercent;
    double minChangePercent = signals.first.changePercent;
    double totalTradeAmount = 0.0;
    double totalConfidence = 0.0;
    int onlineMetricsCount = 0;

    for (final signal in signals) {
      // íŒ¨í„´ë³„ ì¹´ìš´íŠ¸
      patternCounts[signal.patternType] = 
          (patternCounts[signal.patternType] ?? 0) + 1;

      // ë³€í™”ìœ¨ í†µê³„
      totalChangePercent += signal.changePercent;
      if (signal.changePercent > maxChangePercent) {
        maxChangePercent = signal.changePercent;
      }
      if (signal.changePercent < minChangePercent) {
        minChangePercent = signal.changePercent;
      }

      // ê±°ë˜ëŒ€ê¸ˆ í•©ê³„
      totalTradeAmount += signal.tradeAmount;
      
      // V4.1 ì‹ ë¢°ë„ í†µê³„
      final confidence = signal.confidence ?? 0.0;
      totalConfidence += confidence;
      
      // V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ ì¹´ìš´íŠ¸
      if (signal.hasOnlineMetrics) {
        onlineMetricsCount++;
      }
    }

    return SignalStats(
      totalCount: signals.length,
      patternCounts: patternCounts,
      avgChangePercent: totalChangePercent / signals.length,
      maxChangePercent: maxChangePercent,
      minChangePercent: minChangePercent,
      totalTradeAmount: totalTradeAmount,
      avgConfidence: totalConfidence / signals.length,
      onlineMetricsCount: onlineMetricsCount,
    );
  }

  /// ê³ ê¸‰ ì‹œê·¸ë„ í•„í„°ë§ (V4.1 í™•ì¥)
  List<Signal> filterSignals(
    List<Signal> signals, {
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes,
    Duration? timeWindow,
    double? minConfidence,
    bool? requireOnlineMetrics,
    Set<String>? markets,
  }) {
    return signals.where((signal) {
      // ê¸°ì¡´ í•„í„°ë“¤
      if (minChangePercent != null && signal.changePercent < minChangePercent) {
        return false;
      }
      if (maxChangePercent != null && signal.changePercent > maxChangePercent) {
        return false;
      }
      if (minTradeAmount != null && signal.tradeAmount < minTradeAmount) {
        return false;
      }
      if (maxTradeAmount != null && signal.tradeAmount > maxTradeAmount) {
        return false;
      }
      if (patternTypes != null && !patternTypes.contains(signal.patternType)) {
        return false;
      }
      if (timeWindow != null) {
        final cutoff = DateTime.now().subtract(timeWindow);
        if (signal.detectedAt.isBefore(cutoff)) {
          return false;
        }
      }
      
      // V4.1 ìƒˆë¡œìš´ í•„í„°ë“¤
      if (minConfidence != null && (signal.confidence ?? 0.0) < minConfidence) {
        return false;
      }
      if (requireOnlineMetrics == true && !signal.hasOnlineMetrics) {
        return false;
      }
      if (markets != null && !markets.contains(signal.market)) {
        return false;
      }

      return true;
    }).toList();
  }

  // ==========================================================================
  // ğŸ†• V4.1 ë°±í…ŒìŠ¤íŒ… ë° ì„¤ì • ê´€ë¦¬
  // ==========================================================================

  /// í˜„ì¬ ì„¤ì • ë°±ì—…
  SignalConfiguration exportCurrentConfiguration() {
    final config = _repository.exportConfiguration();
    return SignalConfiguration.fromJson(config);
  }

  /// ì„¤ì • ë³µì›
  void importConfiguration(SignalConfiguration configuration) {
    _repository.importConfiguration(configuration.toJson());
  }

  /// ì„¤ì • ë¹„êµ (A/B í…ŒìŠ¤íŠ¸ìš©)
  ConfigurationDiff compareConfigurations(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    return ConfigurationDiff.compare(configA, configB);
  }

  // ==========================================================================
  // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // ==========================================================================

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    await _repository.dispose();
  }
}

// ==========================================================================
// ğŸ†• V4.1 í™•ì¥ ë°ì´í„° í´ë˜ìŠ¤ë“¤
// ==========================================================================

/// V4.1 í–¥ìƒëœ Signal í†µê³„ ì •ë³´
class SignalStats {
  final int totalCount;
  final Map<PatternType, int> patternCounts;
  final double avgChangePercent;
  final double maxChangePercent;
  final double minChangePercent;
  final double totalTradeAmount;
  final double avgConfidence;
  final int onlineMetricsCount;

  const SignalStats({
    required this.totalCount,
    required this.patternCounts,
    required this.avgChangePercent,
    required this.maxChangePercent,
    required this.minChangePercent,
    required this.totalTradeAmount,
    required this.avgConfidence,
    required this.onlineMetricsCount,
  });

  double get onlineMetricsRatio => 
      totalCount > 0 ? onlineMetricsCount / totalCount : 0.0;

   /// ğŸ†• V4.1 JSON ì§ë ¬í™”
  Map<String, dynamic> toJson() {
    return {
      'totalCount': totalCount,
      'patternCounts': patternCounts.map((k, v) => MapEntry(k.name, v)),
      'avgChangePercent': avgChangePercent,
      'maxChangePercent': maxChangePercent,
      'minChangePercent': minChangePercent,
      'totalTradeAmount': totalTradeAmount,
      'avgConfidence': avgConfidence,
      'onlineMetricsCount': onlineMetricsCount,
      'onlineMetricsRatio': onlineMetricsRatio,
    };
  }

  @override
  String toString() {
    return 'SignalStats(total: $totalCount, avg: ${avgChangePercent.toStringAsFixed(2)}%, '
        'confidence: ${(avgConfidence * 100).toStringAsFixed(1)}%, '
        'online: ${(onlineMetricsRatio * 100).toStringAsFixed(1)}%)';
  }
}

/// íŒ¨í„´ë³„ ì„±ëŠ¥ í†µê³„
class PatternPerformanceStats {
  final PatternType patternType;
  final int totalSignals;
  final int recentSignals;
  final DateTime? lastSignalTime;
  final bool isEnabled;
  final Map<String, double> config;
  final Map<String, dynamic> cooldownStatus;
  final Map<String, dynamic>? onlineMetricsHealth;

  const PatternPerformanceStats({
    required this.patternType,
    required this.totalSignals,
    required this.recentSignals,
    this.lastSignalTime,
    required this.isEnabled,
    required this.config,
    required this.cooldownStatus,
    this.onlineMetricsHealth,
  });
}

/// ì‹œìŠ¤í…œ í—¬ìŠ¤ ë¦¬í¬íŠ¸
class SystemHealthReport {
  final String version;
  final String status;
  final int uptime;
  final int totalProcessedTrades;
  final int activePatterns;
  final int trackedMarkets;
  final Map<String, dynamic>? onlineMetricsHealth;
  final Map<String, dynamic> marketDataQuality;
  final DateTime? lastProcessingTime;

  const SystemHealthReport({
    required this.version,
    required this.status,
    required this.uptime,
    required this.totalProcessedTrades,
    required this.activePatterns,
    required this.trackedMarkets,
    this.onlineMetricsHealth,
    required this.marketDataQuality,
    this.lastProcessingTime,
  });

  bool get isHealthy => status == 'healthy';
}

/// ì„±ëŠ¥ ë©”íŠ¸ë¦­ìŠ¤
class PerformanceMetrics {
  final DateTime timestamp;
  final String version;
  final int totalProcessedTrades;
  final int activeMarkets;
  final Map<String, int> signalCounts;
  final Map<String, dynamic> memoryUsage;
  final Map<String, dynamic> onlineMetrics;
  final String architecture;

  const PerformanceMetrics({
    required this.timestamp,
    required this.version,
    required this.totalProcessedTrades,
    required this.activeMarkets,
    required this.signalCounts,
    required this.memoryUsage,
    required this.onlineMetrics,
    required this.architecture,
  });
}

/// ì„¤ì • ì •ë³´
class SignalConfiguration {
  final String version;
  final DateTime timestamp;
  final Map<String, dynamic> patternConfig;
  final Map<String, bool> patternEnabled;
  final Map<String, dynamic> systemSettings;

  const SignalConfiguration({
    required this.version,
    required this.timestamp,
    required this.patternConfig,
    required this.patternEnabled,
    required this.systemSettings,
  });

  factory SignalConfiguration.fromJson(Map<String, dynamic> json) {
    return SignalConfiguration(
      version: json['version'] ?? 'Unknown',
      timestamp: DateTime.parse(json['timestamp']),
      patternConfig: Map<String, dynamic>.from(json['patternConfig'] ?? {}),
      patternEnabled: Map<String, bool>.from(json['patternEnabled'] ?? {}),
      systemSettings: Map<String, dynamic>.from(json['systemSettings'] ?? {}),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'version': version,
      'timestamp': timestamp.toIso8601String(),
      'patternConfig': patternConfig,
      'patternEnabled': patternEnabled,
      'systemSettings': systemSettings,
    };
  }
}

/// ì„¤ì • ë¹„êµ ê²°ê³¼
class ConfigurationDiff {
  final List<String> changedPatterns;
  final List<String> changedSettings;
  final Map<String, dynamic> differences;

  const ConfigurationDiff({
    required this.changedPatterns,
    required this.changedSettings,
    required this.differences,
  });

  static ConfigurationDiff compare(
    SignalConfiguration configA,
    SignalConfiguration configB,
  ) {
    // ê°„ë‹¨í•œ ë¹„êµ ë¡œì§ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•˜ê²Œ êµ¬í˜„)
    return const ConfigurationDiff(
      changedPatterns: [],
      changedSettings: [],
      differences: {},
    );
  }

  bool get hasChanges => changedPatterns.isNotEmpty || changedSettings.isNotEmpty;
}\n\n// ====== lib/domain/usecases/settings_usecase.dart ======\n
import 'package:flutter/material.dart';
import '../entities/app_settings.dart';
import '../repositories/settings_repository.dart';

/// ì•± ì„¤ì • ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class SettingsUsecase {
 final SettingsRepository _repo;

 SettingsUsecase(this._repo);

 Future<AppSettings> getSettings() {
   return _repo.getSettings();
 }

 Future<void> updateThemeMode(ThemeMode mode) {
   return _repo.updateThemeMode(mode);
 }

 Future<void> updateKeepScreenOn(bool on) {
   return _repo.updateKeepScreenOn(on);
 }

 Future<void> updateSliderPosition(SliderPosition pos) {
   return _repo.updateSliderPosition(pos);
 }

 Future<void> updateDisplayMode(DisplayMode mode) {
   return _repo.updateDisplayMode(mode);
 }

 Future<void> updateAmountDisplayMode(AmountDisplayMode mode) {
   return _repo.updateAmountDisplayMode(mode);
 }

 Future<void> updateBlinkEnabled(bool enabled) {
   return _repo.updateBlinkEnabled(enabled);
 }

 Future<void> updateFontFamily(FontFamily font) {
   return _repo.updateFontFamily(font);
 }

 Future<void> updateHapticEnabled(bool enabled) {    // ğŸ†• ì¶”ê°€
   return _repo.updateHapticEnabled(enabled);
 }

 Future<void> updatePortraitLocked(bool locked) {    // ğŸ†• ì¶”ê°€
   return _repo.updatePortraitLocked(locked);
 }

 Future<void> clearCache() {
   return _repo.clearCache();
 }

 Future<void> resetSettings() {
   return _repo.resetSettings();
 }
}\n\n// ====== lib/domain/usecases/market_mood_usecase.dart ======\n
// lib/domain/usecases/market_mood_usecase.dart
// ğŸ¯ Domain Layer: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ìˆœìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜)

import 'dart:async';
import 'dart:math';
import '../entities/market_mood.dart';
import '../repositories/market_mood_repository.dart';

/// ğŸ’° ë§ˆì¼“ ë¬´ë“œ ê³„ì‚°ê¸° (ìˆœìˆ˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
class MarketMoodCalculator {
  static MarketMood calculateMoodByComparison(double current, double previous) {
    if (previous <= 0) return MarketMood.sideways;
    final changePercent = ((current - previous) / previous) * 100;
    
    // [ìˆ˜ì •] ìš”ì²­í•˜ì‹  ì„ê³„ê°’ (10, 5, -5, -10)ìœ¼ë¡œ ë³€ê²½
    if (changePercent >= 10) return MarketMood.bull;
    if (changePercent >= 5) return MarketMood.weakBull;
    if (changePercent >= -5) return MarketMood.sideways;
    if (changePercent >= -10) return MarketMood.bear;
    return MarketMood.deepBear;
  }

  static MarketMood calculateMoodByAbsolute(double volumeUsd) {
    if (volumeUsd >= 150e9) return MarketMood.bull;
    if (volumeUsd >= 100e9) return MarketMood.weakBull;
    if (volumeUsd >= 70e9) return MarketMood.sideways;
    if (volumeUsd >= 50e9) return MarketMood.bear;
    return MarketMood.deepBear;
  }
}

/// ğŸ§® ë³¼ë¥¨ ë¹„êµ ê³„ì‚°ê¸° (ìˆœìˆ˜ ê³„ì‚° ë¡œì§)
class VolumeComparator {
  final MarketMoodRepository _repository;

  VolumeComparator(this._repository);

  double _calculateChangePercent(double current, double previous) {
    if (previous <= 0) return 0.0;
    return ((current - previous) / previous) * 100;
  }

  double _calculateProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    if (elapsed < targetMinutes) {
      return min(elapsed / targetMinutes, 1.0);
    }
    final cycleElapsed = (elapsed - targetMinutes) % targetMinutes;
    return cycleElapsed / targetMinutes;
  }

  double _calculateLongTermProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    return min(elapsed / targetMinutes, 1.0);
  }

  Future<ComparisonResult> _compareGeneric({
    required double currentVolume,
    required int targetMinutes,
    required bool isLongTermAverage,
    required int daysForAverage,
  }) async {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;

    if (isLongTermAverage) {
      if (elapsed < targetMinutes) {
        return ComparisonResult.collecting(_calculateLongTermProgress(targetMinutes));
      }
      final average = await _repository.getAverageVolume(daysForAverage);
      if (average == null) {
        return ComparisonResult.unavailable('ìƒ˜í”Œ ë¶€ì¡±');
      }
      return ComparisonResult.ready(_calculateChangePercent(currentVolume, average));
    }

    if (elapsed < targetMinutes) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    final past = await _repository.getVolumeNMinutesAgo(targetMinutes);
    if (past == null) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    return ComparisonResult.ready(_calculateChangePercent(currentVolume, past.volumeUsd));
  }

  Future<ComparisonResult> compare30Minutes(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 30, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare1Hour(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 60, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare2Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 120, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare4Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 240, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare8Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 480, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare12Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 720, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare24Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 1440, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare3DayAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 4320, isLongTermAverage: true, daysForAverage: 3);

  Future<ComparisonResult> compareWeeklyAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 10080, isLongTermAverage: true, daysForAverage: 7);

  /// [ê°œì„ ] ì „ì²´ ë¹„êµ ë°ì´í„° ê³„ì‚° (ë³‘ë ¬ ì²˜ë¦¬)
  Future<ComparisonData> calculateAll(double currentVolume) async {
    final results = await Future.wait([
      compare30Minutes(currentVolume),
      compare1Hour(currentVolume),
      compare2Hours(currentVolume),
      compare4Hours(currentVolume),
      compare8Hours(currentVolume),
      compare12Hours(currentVolume),
      compare24Hours(currentVolume),
      compare3DayAverage(currentVolume),
      compareWeeklyAverage(currentVolume),
    ]);

    return ComparisonData(
      thirtyMin: results[0],
      oneHour: results[1],
      twoHour: results[2],
      fourHour: results[3],
      eightHour: results[4],
      twelveHour: results[5],
      twentyFourHour: results[6],
      threeDayAverage: results[7],
      weeklyAverage: results[8],
    );
  }
}

/// ğŸ¯ ë§ˆì¼“ë¬´ë“œ UseCase (ì „ì²´ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¡°í•©) - Providerì™€ ë§¤ì¹­
class MarketMoodUsecase {
  final MarketMoodRepository _repository;
  final VolumeComparator _comparator;

  MarketMoodUsecase(this._repository) : _comparator = VolumeComparator(_repository);

  Future<void> addVolumeData(double volumeUsd) async {
    final volumeData = VolumeData(
      timestamp: DateTime.now(),
      volumeUsd: volumeUsd,
    );
    await _repository.addVolumeData(volumeData);
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ê¸°ì¤€ì„ 2ì‹œê°„ìœ¼ë¡œ ë³€ê²½
  Future<MarketMood> calculateCurrentMood(double currentVolume) async {
    // 2ì‹œê°„ = 120ë¶„
    final twoHoursAgo = await _repository.getVolumeNMinutesAgo(120);
    
    if (twoHoursAgo != null) {
      return MarketMoodCalculator.calculateMoodByComparison(
        currentVolume, 
        twoHoursAgo.volumeUsd
      );
    }
    return MarketMoodCalculator.calculateMoodByAbsolute(currentVolume);
  }

  Future<ComparisonData> calculateVolumeComparison(double currentVolume) {
    return _comparator.calculateAll(currentVolume);
  }

  MarketMoodSystemState createSystemState({
    required MarketMoodData? marketData,
    required ComparisonData comparisonData,
    required MarketMood currentMood,
    required double exchangeRate,
    required bool isLoading,
    required bool hasError,
  }) {
    return MarketMoodSystemState(
      marketData: marketData,
      comparisonData: comparisonData,
      currentMood: currentMood,
      exchangeRate: exchangeRate,
      isLoading: isLoading,
      hasError: hasError,
    );
  }

  String generateMoodSummary(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull: return 'ğŸš€ ë¶ˆì¥';
      case MarketMood.weakBull: return 'ğŸ”¥ ì•½ë¶ˆì¥';
      case MarketMood.sideways: return 'âš–ï¸ ì¤‘ê°„ì¥';
      case MarketMood.bear: return 'ğŸ’§ ë¬¼ì¥';
      case MarketMood.deepBear: return 'ğŸ§Š ì–¼ìŒì¥';
    }
  }

  Future<void> handleBackgroundResume() async {
    await _repository.syncMissingData();
  }

  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  Future<void> logSystemStatus() async {
    await _repository.logCurrentStatus();
  }

  Future<int> getCollectedDataCount() async {
    return await _repository.getCollectedDataCount();
  }

  DateTime getAppStartTime() {
    return _repository.getAppStartTime();
  }

  Future<double> getExchangeRate() async {
    return await _repository.getExchangeRate();
  }

  Future<void> refreshExchangeRate() async {
    await _repository.refreshExchangeRate();
  }
}\n\n// ====== lib/domain/usecases/volume_usecase.dart ======\n
// lib/domain/usecases/volume_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/volume.dart';
import '../repositories/volume_repository.dart';

/// Volume ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class VolumeUsecase {
  final VolumeRepository _repository;

  VolumeUsecase(this._repository);

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë­í‚¹ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
  Stream<Result<List<Volume>, AppException>> getVolumeRanking(
    String timeFrame,
    List<String> markets,
  ) {
    return _repository
        .watchVolumeByTimeFrame(timeFrame, markets)
        .transform(_wrapWithErrorHandling<List<Volume>>('Volume ranking failed'));
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetTimeFrame(String timeFrame) {
    try {
      _repository.resetTimeFrame(timeFrame);
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset timeframe failed: $e'));
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetAllTimeFrames() {
    try {
      _repository.resetAllTimeFrames();
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset all timeframes failed: $e'));
    }
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  Result<DateTime?, AppException> getNextResetTime(String timeFrame) {
    try {
      final resetTime = _repository.getNextResetTime(timeFrame);
      return Ok(resetTime);
    } catch (e) {
      return Err(AppException('Get reset time failed: $e'));
    }
  }

  /// í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  Result<List<String>, AppException> getActiveTimeFrames() {
    try {
      final timeFrames = _repository.getActiveTimeFrames();
      return Ok(timeFrames);
    } catch (e) {
      return Err(AppException('Get active timeframes failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦
  Result<bool, AppException> validateTimeFrame(String timeFrame) {
    try {
      final isActive = _repository.isTimeFrameActive(timeFrame);
      return Ok(isActive);
    } catch (e) {
      return Err(AppException('Validate timeframe failed: $e'));
    }
  }

  /// ë³¼ë¥¨ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Volume>, AppException> validateVolumeData(List<Volume> volumes) {
    try {
      // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ë³¼ë¥¨ì´ ìˆëŠ” ê²ƒë§Œ, ì¤‘ë³µ ì œê±°, ì •ë ¬ í™•ì¸
      final validVolumes = volumes
          .where((v) => v.hasVolume && v.market.isNotEmpty)
          .toSet() // ì¤‘ë³µ ì œê±°
          .toList();

      // ì •ë ¬ í™•ì¸ (ë³¼ë¥¨ ë‚´ë¦¼ì°¨ìˆœ)
      final isSorted = _isVolumeSorted(validVolumes);
      if (!isSorted) {
        validVolumes.sort((a, b) => b.totalVolume.compareTo(a.totalVolume));
      }

      return Ok(validVolumes);
    } catch (e) {
      return Err(AppException('Volume data validation failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ë³¼ë¥¨ ë¹„êµ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<Map<String, double>, AppException> compareVolumeAcrossTimeFrames(
    String market,
    List<String> timeFrames,
  ) {
    try {
      // ì—¬ëŸ¬ ì‹œê°„ëŒ€ì˜ íŠ¹ì • ì½”ì¸ ë³¼ë¥¨ ë¹„êµ
      // ì‹¤ì œ êµ¬í˜„ì€ Repositoryì—ì„œ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¦¼ì„ ì¡°í•©í•´ì•¼ í•¨
      final comparison = <String, double>{};
      
      // TODO: ì‹¤ì œ êµ¬í˜„ ì‹œ ì—¬ëŸ¬ timeFrameì˜ ë°ì´í„°ë¥¼ ì¡°í•©
      // í˜„ì¬ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ
      for (final tf in timeFrames) {
        comparison[tf] = 0.0; // ì‹¤ì œ ë°ì´í„° ì¡°íšŒ í•„ìš”
      }
      
      return Ok(comparison);
    } catch (e) {
      return Err(AppException('Volume comparison failed: $e'));
    }
  }

  /// í—¬í¼: ë³¼ë¥¨ ì •ë ¬ í™•ì¸
  bool _isVolumeSorted(List<Volume> volumes) {
    if (volumes.length <= 1) return true;
    
    for (int i = 0; i < volumes.length - 1; i++) {
      if (volumes[i].totalVolume < volumes[i + 1].totalVolume) {
        return false;
      }
    }
    return true;
  }

  /// í—¬í¼: ì—ëŸ¬ ì²˜ë¦¬ ë³€í™˜ê¸°
  StreamTransformer<T, Result<T, AppException>> _wrapWithErrorHandling<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/usecases/surge_usecase.dart ======\n
// lib/domain/usecases/surge_usecase.dart
import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/surge.dart';
import '../repositories/surge_repository.dart';

/// Surge(ê¸‰ë“±/ê¸‰ë½) ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class SurgeUsecase {
  final SurgeRepository _repository;

  SurgeUsecase(this._repository);

  /// ì‹œê°„ëŒ€ë³„ ê¸‰ë“±/ê¸‰ë½ ë­í‚¹ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜ (ì—ëŸ¬ ì²˜ë¦¬ í¬í•¨)
  Stream<Result<List<Surge>, AppException>> getSurgeRanking(
    String timeFrame,
    List<String> markets,
  ) {
    return _repository
        .watchSurgeByTimeFrame(timeFrame, markets)
        .transform(_wrapWithErrorHandling<List<Surge>>('Surge ranking failed'));
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetTimeFrame(String timeFrame) {
    try {
      _repository.resetTimeFrame(timeFrame);
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset timeframe failed: $e'));
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  Result<void, AppException> resetAllTimeFrames() {
    try {
      _repository.resetAllTimeFrames();
      return const Ok(null);
    } catch (e) {
      return Err(AppException('Reset all timeframes failed: $e'));
    }
  }

  /// ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ì¡°íšŒ
  Result<DateTime?, AppException> getNextResetTime(String timeFrame) {
    try {
      final resetTime = _repository.getNextResetTime(timeFrame);
      return Ok(resetTime);
    } catch (e) {
      return Err(AppException('Get reset time failed: $e'));
    }
  }

  /// í™œì„± ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  Result<List<String>, AppException> getActiveTimeFrames() {
    try {
      final timeFrames = _repository.getActiveTimeFrames();
      return Ok(timeFrames);
    } catch (e) {
      return Err(AppException('Get active timeframes failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ ìœ íš¨ì„± ê²€ì¦
  Result<bool, AppException> validateTimeFrame(String timeFrame) {
    try {
      final isActive = _repository.isTimeFrameActive(timeFrame);
      return Ok(isActive);
    } catch (e) {
      return Err(AppException('Validate timeframe failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Surge>, AppException> validateSurgeData(List<Surge> surges) {
    try {
      // ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™: ë³€ë™ì´ ìˆëŠ” ê²ƒë§Œ, ì¤‘ë³µ ì œê±°, ì •ë ¬ í™•ì¸
      final validSurges = surges
          .where((s) => s.hasChange && s.market.isNotEmpty)
          .toSet() // ì¤‘ë³µ ì œê±°
          .toList();

      // ì •ë ¬ í™•ì¸ (ë³€ë™ë¥  ì ˆëŒ“ê°’ ë‚´ë¦¼ì°¨ìˆœ)
      final isSorted = _isSurgeSorted(validSurges);
      if (!isSorted) {
        validSurges.sort((a, b) => b.absChangePercent.compareTo(a.absChangePercent));
      }

      return Ok(validSurges);
    } catch (e) {
      return Err(AppException('Surge data validation failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ í•„í„°ë§ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<List<Surge>, AppException> filterSurgesByType(
    List<Surge> surges,
    SurgeFilterType filterType,
  ) {
    try {
      List<Surge> filtered;
      
      switch (filterType) {
        case SurgeFilterType.all:
          filtered = surges;
          break;
        case SurgeFilterType.risingOnly:
          filtered = surges.where((s) => s.isRising).toList();
          break;
        case SurgeFilterType.fallingOnly:
          filtered = surges.where((s) => s.isFalling).toList();
          break;
      }

      return Ok(filtered);
    } catch (e) {
      return Err(AppException('Surge filtering failed: $e'));
    }
  }

  /// ì‹œê°„ëŒ€ë³„ ê¸‰ë“±/ê¸‰ë½ ë¹„êµ (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<Map<String, double>, AppException> compareSurgeAcrossTimeFrames(
    String market,
    List<String> timeFrames,
  ) {
    try {
      // ì—¬ëŸ¬ ì‹œê°„ëŒ€ì˜ íŠ¹ì • ì½”ì¸ ë³€ë™ë¥  ë¹„êµ
      // ì‹¤ì œ êµ¬í˜„ì€ Repositoryì—ì„œ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¦¼ì„ ì¡°í•©í•´ì•¼ í•¨
      final comparison = <String, double>{};
      
      // TODO: ì‹¤ì œ êµ¬í˜„ ì‹œ ì—¬ëŸ¬ timeFrameì˜ ë°ì´í„°ë¥¼ ì¡°í•©
      // í˜„ì¬ëŠ” ë‹¨ìˆœ ì˜ˆì‹œ
      for (final tf in timeFrames) {
        comparison[tf] = 0.0; // ì‹¤ì œ ë°ì´í„° ì¡°íšŒ í•„ìš”
      }
      
      return Ok(comparison);
    } catch (e) {
      return Err(AppException('Surge comparison failed: $e'));
    }
  }

  /// ê¸‰ë“±/ê¸‰ë½ í†µê³„ ê³„ì‚° (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
  Result<SurgeStatistics, AppException> calculateSurgeStatistics(List<Surge> surges) {
    try {
      if (surges.isEmpty) {
        return Ok(SurgeStatistics.empty());
      }

      final risingCount = surges.where((s) => s.isRising).length;
      final fallingCount = surges.where((s) => s.isFalling).length;
      final maxRising = surges.where((s) => s.isRising).isNotEmpty 
          ? surges.where((s) => s.isRising).map((s) => s.changePercent).reduce((a, b) => a > b ? a : b)
          : 0.0;
      final maxFalling = surges.where((s) => s.isFalling).isNotEmpty 
          ? surges.where((s) => s.isFalling).map((s) => s.changePercent).reduce((a, b) => a < b ? a : b)
          : 0.0;

      return Ok(SurgeStatistics(
        totalCount: surges.length,
        risingCount: risingCount,
        fallingCount: fallingCount,
        maxRisingPercent: maxRising,
        maxFallingPercent: maxFalling,
      ));
    } catch (e) {
      return Err(AppException('Surge statistics calculation failed: $e'));
    }
  }

  /// í—¬í¼: ê¸‰ë“±/ê¸‰ë½ ì •ë ¬ í™•ì¸
  bool _isSurgeSorted(List<Surge> surges) {
    if (surges.length <= 1) return true;
    
    for (int i = 0; i < surges.length - 1; i++) {
      if (surges[i].absChangePercent < surges[i + 1].absChangePercent) {
        return false;
      }
    }
    return true;
  }

  /// í—¬í¼: ì—ëŸ¬ ì²˜ë¦¬ ë³€í™˜ê¸°
  StreamTransformer<T, Result<T, AppException>> _wrapWithErrorHandling<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}

/// ê¸‰ë“±/ê¸‰ë½ í•„í„° íƒ€ì…
enum SurgeFilterType {
  all,            // ì „ì²´ (ê¸‰ë“± + ê¸‰ë½)
  risingOnly,     // ìƒìŠ¹ë§Œ
  fallingOnly,    // í•˜ë½ë§Œ
}

/// ê¸‰ë“±/ê¸‰ë½ í†µê³„ ë°ì´í„°
class SurgeStatistics {
  final int totalCount;
  final int risingCount;
  final int fallingCount;
  final double maxRisingPercent;
  final double maxFallingPercent;

  const SurgeStatistics({
    required this.totalCount,
    required this.risingCount,
    required this.fallingCount,
    required this.maxRisingPercent,
    required this.maxFallingPercent,
  });

  factory SurgeStatistics.empty() {
    return const SurgeStatistics(
      totalCount: 0,
      risingCount: 0,
      fallingCount: 0,
      maxRisingPercent: 0.0,
      maxFallingPercent: 0.0,
    );
  }

  /// ê¸‰ë“± ë¹„ìœ¨ (0.0 ~ 1.0)
  double get risingRatio => totalCount > 0 ? risingCount / totalCount : 0.0;
  
  /// ê¸‰ë½ ë¹„ìœ¨ (0.0 ~ 1.0)
  double get fallingRatio => totalCount > 0 ? fallingCount / totalCount : 0.0;
  
  /// ê¸‰ë“± ìš°ì„¸ ì—¬ë¶€
  bool get isRisingDominant => risingCount > fallingCount;
  
  /// ê¸‰ë½ ìš°ì„¸ ì—¬ë¶€
  bool get isFallingDominant => fallingCount > risingCount;
}\n\n// ====== lib/domain/usecases/trade_usecase.dart ======\n
// lib/domain/usecases/trade_usecase.dart

import 'dart:async';
import '../../core/error/app_exception.dart';
import '../../core/extensions/result.dart';
import '../entities/trade.dart';
import '../repositories/trade_repository.dart';

/// Trade ê´€ë ¨ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì œê³µí•˜ëŠ” UseCase
class TradeUsecase {
  final TradeRepository _repository;

  TradeUsecase(this._repository);

  /// thresholdì™€ marketsë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§ëœ ê±°ë˜ ëª©ë¡ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<List<Trade>, AppException>> filterTrades(
    double threshold,
    List<String> markets,
  ) {
    return _repository
        .watchFilteredTrades(threshold, markets)
        .transform(_wrap<List<Trade>>('Filter trades failed'));
  }

  /// ì§‘ê³„ëœ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜
  Stream<Result<Trade, AppException>> aggregateTrades() {
    return _repository
        .watchAggregatedTrades()
        .transform(_wrap<Trade>('Aggregate trades failed'));
  }

  StreamTransformer<T, Result<T, AppException>> _wrap<T>(String errorMsg) {
    return StreamTransformer.fromHandlers(
      handleData: (data, sink) => sink.add(Ok(data)),
      handleError: (error, stack, sink) =>
          sink.add(Err(AppException('$errorMsg: $error'))),
    );
  }
}\n\n// ====== lib/domain/usecases/filter_params.dart ======\n
// ===== lib/domain/usecases/filter_params.dart =====
import '../entities/signal.dart'; // PatternType import ì¶”ê°€

class FilterParams {
  final double? minChangePercent;
  final double? maxChangePercent;
  final double? minTradeAmount;
  final double? maxTradeAmount;
  final Set<PatternType>? patternTypes; // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
  final Duration? timeWindow;
  final double? minSeverityScore;

  const FilterParams({
    this.minChangePercent,
    this.maxChangePercent,
    this.minTradeAmount,
    this.maxTradeAmount,
    this.patternTypes, // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
    this.timeWindow,
    this.minSeverityScore,
  });

  FilterParams copyWith({
    double? minChangePercent,
    double? maxChangePercent,
    double? minTradeAmount,
    double? maxTradeAmount,
    Set<PatternType>? patternTypes, // âœ… ìˆ˜ì •: ì˜¬ë°”ë¥¸ import
    Duration? timeWindow,
    double? minSeverityScore,
  }) {
    return FilterParams(
      minChangePercent: minChangePercent ?? this.minChangePercent,
      maxChangePercent: maxChangePercent ?? this.maxChangePercent,
      minTradeAmount: minTradeAmount ?? this.minTradeAmount,
      maxTradeAmount: maxTradeAmount ?? this.maxTradeAmount,
      patternTypes: patternTypes ?? this.patternTypes,
      timeWindow: timeWindow ?? this.timeWindow,
      minSeverityScore: minSeverityScore ?? this.minSeverityScore,
    );
  }
}
\n\n// ====== lib/domain/entities/app_settings.dart ======\n
import 'package:flutter/material.dart';
import 'package:equatable/equatable.dart';

/// ìŠ¬ë¼ì´ë” ìœ„ì¹˜ë¥¼ í‘œí˜„í•˜ëŠ” enum
enum SliderPosition { top, bottom }

/// ğŸ†• ì½”ì¸ëª… í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum DisplayMode {
 ticker, // BTC, ETH, XRP
 korean, // ë¹„íŠ¸ì½”ì¸, ì´ë”ë¦¬ì›€, ë¦¬í”Œ
 english, // Bitcoin, Ethereum, Ripple
}

/// ğŸ’° ê¸ˆì•¡ í‘œì‹œ ë°©ì‹ì„ í‘œí˜„í•˜ëŠ” enum
enum AmountDisplayMode {
 number, // 1,234ë§Œ (ìˆ«ì)
 icon, // ğŸ’µ (ì•„ì´ì½˜)
}

/// ğŸ”¤ í°íŠ¸ íŒ¨ë°€ë¦¬ë¥¼ í‘œí˜„í•˜ëŠ” enum (âœ¨ pubspec.yaml ê¸°ì¤€ìœ¼ë¡œ ì •ë¦¬)
enum FontFamily {
 // --- ê¸°ë³¸ ---
 pretendard,
 // --- ì „ì²´ ì¶”ê°€ í°íŠ¸ ---
 dotGothic16,
 dynaPuff,
 gloriaHallelujah,
 gowunDodum,
 gugi,
 ibmPlexSansKRLight,
 inconsolata,
 kirangHaerang,
 nanumGothicCoding,
 notoSerifKR,
 novaMono,
 novaSquare,
 permanentMarker,
 pixelifySans,
 sunflowerLight,
 syneMono;

 // ì‹¤ì œ í°íŠ¸ëª… ë§¤í•‘ (âœ¨ pubspec.yaml ê¸°ì¤€ìœ¼ë¡œ ì •ë¦¬)
 String get fontName {
   switch (this) {
     case FontFamily.pretendard: return 'Pretendard';
     case FontFamily.dotGothic16: return 'DotGothic16-Regular';
     case FontFamily.dynaPuff: return 'DynaPuff-VariableFont_wdth,wght';
     case FontFamily.gloriaHallelujah: return 'GloriaHallelujah-Regular';
     case FontFamily.gowunDodum: return 'GowunDodum-Regular';
     case FontFamily.gugi: return 'Gugi-Regular';
     case FontFamily.ibmPlexSansKRLight: return 'IBMPlexSansKR-Light';
     case FontFamily.inconsolata: return 'Inconsolata-VariableFont_wdth,wght';
     case FontFamily.kirangHaerang: return 'KirangHaerang-Regular';
     case FontFamily.nanumGothicCoding: return 'NanumGothicCoding-Regular';
     case FontFamily.notoSerifKR: return 'NotoSerifKR-VariableFont_wght';
     case FontFamily.novaMono: return 'NovaMono-Regular';
     case FontFamily.novaSquare: return 'NovaSquare-Regular';
     case FontFamily.permanentMarker: return 'PermanentMarker-Regular';
     case FontFamily.pixelifySans: return 'PixelifySans-VariableFont_wght';
     case FontFamily.sunflowerLight: return 'Sunflower-Light';
     case FontFamily.syneMono: return 'SyneMono-Regular';
   }
 }
}

class AppSettings extends Equatable {
 final ThemeMode themeMode;
 final bool keepScreenOn;
 final SliderPosition sliderPosition;
 final DisplayMode displayMode;
 final AmountDisplayMode amountDisplayMode;
 final bool blinkEnabled;
 final FontFamily fontFamily;
 final bool isHapticEnabled;      // ğŸ†• í–…í‹± í”¼ë“œë°± ì„¤ì •
 final bool isPortraitLocked;     // ğŸ†• í™”ë©´ íšŒì „ ì ê¸ˆ ì„¤ì •

 const AppSettings({
   this.themeMode = ThemeMode.system,
   this.keepScreenOn = false,
   this.sliderPosition = SliderPosition.top,
   this.displayMode = DisplayMode.ticker,
   this.amountDisplayMode = AmountDisplayMode.number,
   this.blinkEnabled = true,
   this.fontFamily = FontFamily.pretendard,
   this.isHapticEnabled = true,      // ğŸ†• ê¸°ë³¸ê°’: í™œì„±í™”
   this.isPortraitLocked = false,    // ğŸ†• ê¸°ë³¸ê°’: ìë™ íšŒì „
 });

 AppSettings copyWith({
   ThemeMode? themeMode,
   bool? keepScreenOn,
   SliderPosition? sliderPosition,
   DisplayMode? displayMode,
   AmountDisplayMode? amountDisplayMode,
   bool? blinkEnabled,
   FontFamily? fontFamily,
   bool? isHapticEnabled,           // ğŸ†• ì¶”ê°€
   bool? isPortraitLocked,          // ğŸ†• ì¶”ê°€
 }) =>
     AppSettings(
       themeMode: themeMode ?? this.themeMode,
       keepScreenOn: keepScreenOn ?? this.keepScreenOn,
       sliderPosition: sliderPosition ?? this.sliderPosition,
       displayMode: displayMode ?? this.displayMode,
       amountDisplayMode: amountDisplayMode ?? this.amountDisplayMode,
       blinkEnabled: blinkEnabled ?? this.blinkEnabled,
       fontFamily: fontFamily ?? this.fontFamily,
       isHapticEnabled: isHapticEnabled ?? this.isHapticEnabled,        // ğŸ†• ì¶”ê°€
       isPortraitLocked: isPortraitLocked ?? this.isPortraitLocked,     // ğŸ†• ì¶”ê°€
     );

 @override
 List<Object?> get props => [
   themeMode,
   keepScreenOn,
   sliderPosition,
   displayMode,
   amountDisplayMode,
   blinkEnabled,
   fontFamily,
   isHapticEnabled,      // ğŸ†• ì¶”ê°€
   isPortraitLocked,     // ğŸ†• ì¶”ê°€
 ];
}\n\n// ====== lib/domain/entities/momentary.dart ======\n
\n\n// ====== lib/domain/entities/trade.dart ======\n
import 'package:equatable/equatable.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë§Œ í¬í•¨
class Trade extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;

  /// ì²´ê²° ë‹¨ê°€
  final double price;

  /// ì²´ê²° ìˆ˜ëŸ‰
  final double volume;

  /// 'BID' ë˜ëŠ” 'ASK'
  final String side;

  /// ê°€ê²© ë³€ë™ëŸ‰
  final double changePrice;

  /// ë³€ë™ ìƒíƒœ ('RISE'/'FALL'/'EVEN')
  final String changeState;

  /// UTC ë°€ë¦¬ì´ˆ íƒ€ì„ìŠ¤íƒ¬í”„
  final int timestampMs;

  /// ì¤‘ë³µ ì œê±°ìš© ê³ ìœ  ID
  final String sequentialId;

  const Trade({
    required this.market,
    required this.price,
    required this.volume,
    required this.side,
    required this.changePrice,
    required this.changeState,
    required this.timestampMs,
    required this.sequentialId,
  });

  @override
  List<Object?> get props => [
        market,
        price,
        volume,
        side,
        changePrice,
        changeState,
        timestampMs,
        sequentialId,
      ];

  /// ì´ ì²´ê²° ê¸ˆì•¡
  double get total => price * volume;

  /// ë§¤ìˆ˜ ì—¬ë¶€
  bool get isBuy => side == 'BID';

  /// DateTime ë³€í™˜
  DateTime get timestamp => DateTime.fromMillisecondsSinceEpoch(timestampMs);
}
\n\n// ====== lib/domain/entities/surge.dart ======\n
// lib/domain/entities/surge.dart
import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Surge extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ë³€ë™ë¥  (í¼ì„¼íŠ¸ ê¸°ì¤€)
  final double changePercent;
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  final double basePrice;
  
  /// í˜„ì¬ ê°€ê²©
  final double currentPrice;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Surge({
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    changePercent,
    basePrice,
    currentPrice,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³€ë™ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ì´ ì•„ë‹˜)
  bool get hasChange => changePercent != 0;
  
  /// ê¸‰ë“±ì¸ì§€ ì²´í¬ (ì–‘ìˆ˜)
  bool get isRising => changePercent > 0;
  
  /// ê¸‰ë½ì¸ì§€ ì²´í¬ (ìŒìˆ˜)
  bool get isFalling => changePercent < 0;
  
  /// ë³€ë™ë¥  ì ˆëŒ“ê°’
  double get absChangePercent => changePercent.abs();
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³€ë™ë¥  í¬ë§·íŒ… (ì˜ˆ: "+12.34%", "-5.67%")
  String get formattedChangePercent {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Surge copyWith({
    String? market,
    double? changePercent,
    double? basePrice,
    double? currentPrice,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Surge(
      market: market ?? this.market,
      changePercent: changePercent ?? this.changePercent,
      basePrice: basePrice ?? this.basePrice,
      currentPrice: currentPrice ?? this.currentPrice,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/domain/entities/volume.dart ======\n
// lib/domain/entities/volume.dart

import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ë³¼ë¥¨ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Volume extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì´ ê±°ë˜ëŸ‰ (ì›í™” ê¸°ì¤€)
  final double totalVolume;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Volume({
    required this.market,
    required this.totalVolume,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    totalVolume,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³¼ë¥¨ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ë³´ë‹¤ í¼)
  bool get hasVolume => totalVolume > 0;
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Volume copyWith({
    String? market,
    double? totalVolume,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Volume(
      market: market ?? this.market,
      totalVolume: totalVolume ?? this.totalVolume,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/domain/entities/signal.dart ======\n
// lib/domain/entities/signal.dart

/// ğŸš€ Signal Entity V4.1 - ì˜¨ë¼ì¸ ì§€í‘œ ì—°ë™
/// 
/// ì£¼ìš” ê°œì„ ì‚¬í•­:
/// - ì˜¨ë¼ì¸ RSI/MACD ì •ë³´ í¬í•¨
/// - ë‹¤ì´ë²„ì „ìŠ¤ ê°ì§€ ê²°ê³¼
/// - ì‹ ë¢°ë„ ë™ì  ì¡°ì •
/// - ìŠ¤íŠ¸ë¦¼ ê±´ê°•ì„± ì •ë³´
/// - íŒ¨í„´ë³„ ê³ ê¸‰ ë©”íƒ€ë°ì´í„°

/// Signal íŒ¨í„´ íƒ€ì… ì •ì˜ (V4.1 í™•ì¥)
enum PatternType {
  surge,       // 1. ê¸‰ë“± (1ë¶„ ì „ ëŒ€ë¹„ 0.4% ìƒìŠ¹)
  flashFire,   // 2. ë¶ˆí‹°ğŸ”¥ (3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦)
  stackUp,     // 3. ìŠ¤íƒì—…ğŸ’° (1ë¶„ì”© ì—°ì† ì¦ê°€)
  stealthIn,   // 4. ì¹¨íˆ¬ìğŸ‘£ (ì†ŒëŸ‰ ì§€ì† ìœ ì…) - ì™„í™”ë¨
  blackHole,   // 5. ë¸”ë™í™€ğŸ•³ï¸ (ê±°ë˜ëŒ€ê¸ˆâ†‘ ê°€ê²©ë³€ë™â†“) - ì™„í™”ë¨
  reboundShot, // 6. ì‡¼íŠ¸í„°ì¹˜âš¡ (ê¸‰ë½ í›„ ë°˜ë“±)
}

extension PatternTypeExtension on PatternType {
  String get displayName {
    switch (this) {
      case PatternType.surge:
        return 'ê¸‰ë“±';
      case PatternType.flashFire:
        return 'ë¶ˆí‹°ğŸ”¥';
      case PatternType.stackUp:
        return 'ìŠ¤íƒì—…ğŸ’°';
      case PatternType.stealthIn:
        return 'ì¹¨íˆ¬ìğŸ‘£';
      case PatternType.blackHole:
        return 'ë¸”ë™í™€ğŸ•³ï¸';
      case PatternType.reboundShot:
        return 'ì‡¼íŠ¸í„°ì¹˜âš¡';
    }
  }

  String get description {
    switch (this) {
      case PatternType.surge:
        return '1ë¶„ ì „ ëŒ€ë¹„ 0.4% ì´ìƒ ìƒìŠ¹ (V4.1)';
      case PatternType.flashFire:
        return '3ë¶„ ê±°ë˜ëŒ€ê¸ˆ ê¸‰ì¦ + RSI í™•ì¸';
      case PatternType.stackUp:
        return 'ì—°ì† ë§¤ì§‘ + MACD ëª¨ë©˜í…€';
      case PatternType.stealthIn:
        return 'ì€ë°€í•œ ìœ ì… (ì™„í™”ëœ ê¸°ì¤€)';
      case PatternType.blackHole:
        return 'ì´ìƒ ì²´ê²° (ì™„í™”ëœ ê¸°ì¤€)';
      case PatternType.reboundShot:
        return 'ê³¼ë§¤ë„ ë°˜ë“± + ì˜¨ë¼ì¸ ì§€í‘œ';
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì„ê³„ê°’ (ì™„í™”ë¨)
  double get defaultThreshold {
    switch (this) {
      case PatternType.surge:
        return 0.4; // 0.4% ìƒìŠ¹ (ê¸°ì¡´ 1.1%ì—ì„œ ì™„í™”)
      case PatternType.flashFire:
        return 2.0; // 2ë°° ê¸‰ì¦
      case PatternType.stackUp:
        return 2.0; // 2ì—°ì† (ê¸°ì¡´ 3ì—ì„œ ì™„í™”)
      case PatternType.stealthIn:
        return 5000000.0; // 500ë§Œì› (ê¸°ì¡´ 2000ë§Œì—ì„œ ëŒ€í­ ì™„í™”)
      case PatternType.blackHole:
        return 2.0; // 2% ì´í•˜ ë³€ë™ (ê¸°ì¡´ 1%ì—ì„œ ì™„í™”)
      case PatternType.reboundShot:
        return 1.5; // 1.5% ê¸‰ë½ í›„ ë°˜ë“±
    }
  }

  /// íŒ¨í„´ë³„ ì‹œê°„ ìœˆë„ìš° (ë¶„)
  int get timeWindowMinutes {
    switch (this) {
      case PatternType.surge:
        return 1; // 1ë¶„
      case PatternType.flashFire:
        return 1; // 1ë¶„ (V4.1 ë‹¨ì¶•)
      case PatternType.stackUp:
        return 1; // 1ë¶„
      case PatternType.stealthIn:
        return 5; // 5ë¶„
      case PatternType.blackHole:
        return 5; // 5ë¶„ (V4.1 í™•ì¥)
      case PatternType.reboundShot:
        return 1; // 1ë¶„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ê¸°ë³¸ ì¿¨ë‹¤ìš´ ì‹œê°„ (ì´ˆ)
  int get defaultCooldownSeconds {
    switch (this) {
      case PatternType.surge:
        return 3; // ë¹ ë¥¸ ê°ì§€
      case PatternType.flashFire:
        return 2; // ê°€ì¥ ë¹ ë¦„
      case PatternType.stackUp:
        return 4; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 8; // ëŠë¦¼ (ì€ë°€í•¨ íŠ¹ì„±)
      case PatternType.blackHole:
        return 10; // ê°€ì¥ ëŠë¦¼ (ì•ˆì •ì„± íŠ¹ì„±)
      case PatternType.reboundShot:
        return 5; // ì¤‘ê°„
    }
  }

  /// V4.1 íŒ¨í„´ë³„ ì‹ ë¢°ë„ ê¸°ë³¸ê°’
  double get defaultConfidence {
    switch (this) {
      case PatternType.surge:
        return 0.8; // ë†’ìŒ
      case PatternType.flashFire:
        return 0.85; // ë§¤ìš° ë†’ìŒ
      case PatternType.stackUp:
        return 0.75; // ì¤‘ê°„
      case PatternType.stealthIn:
        return 0.7; // ë‚®ìŒ (ì€ë°€í•¨)
      case PatternType.blackHole:
        return 0.8; // ë†’ìŒ (ì•ˆì •ì„±)
      case PatternType.reboundShot:
        return 0.9; // ë§¤ìš° ë†’ìŒ (ëª…í™•í•¨)
    }
  }
}

/// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´
class OnlineIndicatorInfo {
  final double? rsi;
  final double? macd;
  final double? macdSignal;
  final double? macdHistogram;
  final bool isStale;
  final DateTime lastUpdate;

  const OnlineIndicatorInfo({
    this.rsi,
    this.macd,
    this.macdSignal,
    this.macdHistogram,
    required this.isStale,
    required this.lastUpdate,
  });

  /// RSI/MACDê°€ ìœ íš¨í•œì§€ ì²´í¬
  bool get hasValidData => !isStale && (rsi != null || macd != null);

  /// RSI ê³¼ë§¤ìˆ˜/ê³¼ë§¤ë„ ìƒíƒœ
  String get rsiState {
    if (rsi == null) return 'N/A';
    if (rsi! >= 70) return 'Overbought';
    if (rsi! <= 30) return 'Oversold';
    return 'Neutral';
  }

  /// MACD ì‹ í˜¸ ìƒíƒœ
  String get macdState {
    if (macd == null || macdSignal == null) return 'N/A';
    if (macd! > macdSignal!) return 'Bullish';
    if (macd! < macdSignal!) return 'Bearish';
    return 'Neutral';
  }

  Map<String, dynamic> toJson() {
    return {
      'rsi': rsi,
      'macd': macd,
      'macdSignal': macdSignal,
      'macdHistogram': macdHistogram,
      'isStale': isStale,
      'lastUpdate': lastUpdate.toIso8601String(),
      'rsiState': rsiState,
      'macdState': macdState,
    };
  }
}

/// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´
class DivergenceInfo {
  final bool isBullish;
  final bool isBearish;
  final double strength;
  final String source; // 'online-rsi', 'online-macd' ë“±

  const DivergenceInfo({
    required this.isBullish,
    required this.isBearish,
    required this.strength,
    required this.source,
  });

  /// ë‹¤ì´ë²„ì „ìŠ¤ íƒ€ì…
  String get type {
    if (isBullish) return 'Bullish';
    if (isBearish) return 'Bearish';
    return 'None';
  }

  /// ì‹ ë¢°ë„ (ê°•ë„ ê¸°ë°˜)
  String get confidenceLevel {
    if (strength >= 0.8) return 'Very High';
    if (strength >= 0.6) return 'High';
    if (strength >= 0.4) return 'Medium';
    if (strength >= 0.2) return 'Low';
    return 'Very Low';
  }

  Map<String, dynamic> toJson() {
    return {
      'isBullish': isBullish,
      'isBearish': isBearish,
      'strength': strength,
      'source': source,
      'type': type,
      'confidenceLevel': confidenceLevel,
    };
  }
}

/// ğŸš€ Signal ê°ì§€ ê²°ê³¼ ì—”í‹°í‹° V4.1
class Signal {
  final String market;
  final String name;
  final double currentPrice;
  final double changePercent;
  final double volume;
  final double tradeAmount;
  final DateTime detectedAt;
  final PatternType patternType;
  final Map<String, dynamic> patternDetails;

  const Signal({
    required this.market,
    required this.name,
    required this.currentPrice,
    required this.changePercent,
    required this.volume,
    required this.tradeAmount,
    required this.detectedAt,
    required this.patternType,
    required this.patternDetails,
  });

  /// ê±°ë˜ ì´ì•¡ ê³„ì‚°
  double get total => currentPrice * volume;

  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');

  /// ğŸ†• V4.1 ì‹ ë¢°ë„ (ë™ì  ì¡°ì •ëœ ìµœì¢… ì‹ ë¢°ë„)
  double? get confidence {
    final finalConf = patternDetails['finalConfidence'] as double?;
    final originalConf = patternDetails['confidence'] as double?;
    return finalConf ?? originalConf;
  }

  /// ğŸ†• V4.1 ì˜¨ë¼ì¸ ì§€í‘œ ì •ë³´ ì¡°íšŒ
  OnlineIndicatorInfo? get onlineIndicators {
    final rsi = patternDetails['rsi'] as double?;
    final macd = patternDetails['macd'] as double?;
    final macdSignal = patternDetails['macdSignal'] as double?;
    final macdHistogram = patternDetails['macdHistogram'] as double?;
    
    if (rsi == null && macd == null) return null;
    
    return OnlineIndicatorInfo(
      rsi: rsi,
      macd: macd,
      macdSignal: macdSignal,
      macdHistogram: macdHistogram,
      isStale: false, // Signal ìƒì„±ì‹œì ì—ëŠ” ìµœì‹ 
      lastUpdate: detectedAt,
    );
  }

  /// ğŸ†• V4.1 ë‹¤ì´ë²„ì „ìŠ¤ ì •ë³´ ì¡°íšŒ
  DivergenceInfo? get divergence {
    final divData = patternDetails['divergence'] as Map<String, dynamic>?;
    if (divData == null) return null;
    
    return DivergenceInfo(
      isBullish: divData['isBullish'] as bool? ?? false,
      isBearish: divData['isBearish'] as bool? ?? false,
      strength: (divData['strength'] as num?)?.toDouble() ?? 0.0,
      source: divData['source'] as String? ?? 'unknown',
    );
  }

  /// ğŸ†• ì˜¨ë¼ì¸ ì§€í‘œ ê¸°ë°˜ ì‹ í˜¸ì¸ì§€ ì²´í¬
  bool get hasOnlineMetrics {
    return onlineIndicators?.hasValidData ?? false;
  }

  /// ğŸ†• V4.1 ë²„ì „ ì •ë³´
  String? get version => patternDetails['version'] as String?;

  /// íŒ¨í„´ë³„ íŠ¹í™” ì •ë³´ getterë“¤
  
  /// Surge ì „ìš©: ê¸°ì¤€ê°€ (1ë¶„ ì „ ê°€ê²©)
  double? get basePrice => patternDetails['basePrice'] as double?;
  
  /// FlashFire ì „ìš©: ê¸‰ì¦ ë°°ìœ¨
  double? get surgeMultiplier => patternDetails['surgeMultiplier'] as double?;
  
  /// StackUp ì „ìš©: ì—°ì† ì¦ê°€ íšŸìˆ˜
  int? get consecutiveCount => patternDetails['consecutiveCount'] as int?;
  
  /// StealthIn ì „ìš©: ì§€ì† ì‹œê°„ (ì´ˆ)
  int? get sustainedSeconds => patternDetails['sustainedSeconds'] as int?;
  
  /// BlackHole ì „ìš©: ê°€ê²© ë³€ë™ë¥ 
  double? get priceStability => patternDetails['priceStability'] as double?;
  
  /// ReboundShot ì „ìš©: ë°˜ë“± ê°•ë„
  double? get reboundStrength => patternDetails['reboundStrength'] as double?;

  /// ğŸ†• V4.1 ê³ ê¸‰ ì§€í‘œë“¤
  double? get liquidityVortex => patternDetails['liquidityVortex'] as double?;
  double? get flashPulse => patternDetails['flashPulse'] as double?;
  double? get microBurstRadar => patternDetails['microBurstRadar'] as double?;
  double? get machineRush => patternDetails['machineRush'] as double?;
  double? get jumpScore => patternDetails['jumpScore'] as double?;
  double? get zScore => patternDetails['zScore'] as double?;

  /// ğŸ†• ì‹ ë¢°ë„ ë ˆë²¨ (í…ìŠ¤íŠ¸)
  String get confidenceLevel {
    final conf = confidence ?? 0.0;
    if (conf >= 0.9) return 'Excellent';
    if (conf >= 0.8) return 'Very High';
    if (conf >= 0.7) return 'High';
    if (conf >= 0.6) return 'Good';
    if (conf >= 0.5) return 'Medium';
    if (conf >= 0.3) return 'Low';
    return 'Very Low';
  }

  /// ğŸ†• ì‹ í˜¸ ê°•ë„ (ì¢…í•© ì ìˆ˜)
  String get signalStrength {
    double score = 0.0;
    
    // ê¸°ë³¸ ì ìˆ˜ (ë³€í™”ìœ¨ ê¸°ë°˜)
    score += (changePercent.abs() / 10.0).clamp(0.0, 1.0);
    
    // ì‹ ë¢°ë„ ì ìˆ˜
    score += (confidence ?? 0.0);
    
    // ì˜¨ë¼ì¸ ì§€í‘œ ë³´ë„ˆìŠ¤
    if (hasOnlineMetrics) score += 0.3;
    
    // ë‹¤ì´ë²„ì „ìŠ¤ ë³´ë„ˆìŠ¤
    final div = divergence;
    if (div != null && div.strength > 0.5) score += 0.2;
    
    score = score.clamp(0.0, 3.0) / 3.0; // 0-1 ì •ê·œí™”
    
    if (score >= 0.8) return 'Very Strong';
    if (score >= 0.6) return 'Strong';
    if (score >= 0.4) return 'Moderate';
    if (score >= 0.2) return 'Weak';
    return 'Very Weak';
  }

  /// ğŸ†• ìƒì„¸ ì •ë³´ (ë””ë²„ê¹…ìš©)
  Map<String, dynamic> get debugInfo {
    return {
      'market': market,
      'pattern': patternType.name,
      'confidence': confidence,
      'hasOnlineMetrics': hasOnlineMetrics,
      'onlineIndicators': onlineIndicators?.toJson(),
      'divergence': divergence?.toJson(),
      'signalStrength': signalStrength,
      'version': version,
      'detectedAt': detectedAt.toIso8601String(),
    };
  }

  Signal copyWith({
    String? market,
    String? name,
    double? currentPrice,
    double? changePercent,
    double? volume,
    double? tradeAmount,
    DateTime? detectedAt,
    PatternType? patternType,
    Map<String, dynamic>? patternDetails,
  }) {
    return Signal(
      market: market ?? this.market,
      name: name ?? this.name,
      currentPrice: currentPrice ?? this.currentPrice,
      changePercent: changePercent ?? this.changePercent,
      volume: volume ?? this.volume,
      tradeAmount: tradeAmount ?? this.tradeAmount,
      detectedAt: detectedAt ?? this.detectedAt,
      patternType: patternType ?? this.patternType,
      patternDetails: patternDetails ?? this.patternDetails,
    );
  }

  @override
  String toString() {
    final confText = confidence != null 
        ? '${(confidence! * 100).toStringAsFixed(1)}%' 
        : 'N/A';
    final onlineText = hasOnlineMetrics ? '[Online]' : '';
    
    return 'Signal(${patternType.displayName} $onlineText: $market '
        '${changePercent.toStringAsFixed(2)}% @ $currentPrice, '
        'Conf: $confText, at: ${detectedAt.toString().substring(11, 19)})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Signal &&
        other.market == market &&
        other.detectedAt == detectedAt &&
        other.patternType == patternType;
  }

  @override
  int get hashCode {
    return market.hashCode ^ detectedAt.hashCode ^ patternType.hashCode;
  }

  /// ğŸ†• V4.1 JSON ì§ë ¬í™” (ì €ì¥/ë¡œë“œìš©)
  Map<String, dynamic> toJson() {
    return {
      'market': market,
      'name': name,
      'currentPrice': currentPrice,
      'changePercent': changePercent,
      'volume': volume,
      'tradeAmount': tradeAmount,
      'detectedAt': detectedAt.toIso8601String(),
      'patternType': patternType.name,
      'patternDetails': patternDetails,
      'version': 'V4.1-Online',
    };
  }

  /// ğŸ†• V4.1 JSON ì—­ì§ë ¬í™”
  factory Signal.fromJson(Map<String, dynamic> json) {
    return Signal(
      market: json['market'] as String,
      name: json['name'] as String,
      currentPrice: (json['currentPrice'] as num).toDouble(),
      changePercent: (json['changePercent'] as num).toDouble(),
      volume: (json['volume'] as num).toDouble(),
      tradeAmount: (json['tradeAmount'] as num).toDouble(),
      detectedAt: DateTime.parse(json['detectedAt'] as String),
      patternType: PatternType.values.firstWhere(
        (e) => e.name == json['patternType'],
        orElse: () => PatternType.surge,
      ),
      patternDetails: Map<String, dynamic>.from(json['patternDetails'] as Map),
    );
  }
}\n\n// ====== lib/domain/entities/market_mood.dart ======\n
// lib/domain/entities/market_mood.dart
// ğŸ¯ Domain Layer: ìˆœìˆ˜ ì—”í‹°í‹°ë“¤ (VolumeData ì¶”ê°€)

import '../../core/utils/date_time.dart'; // DateTime extension

/// ğŸ•’ ë³¼ë¥¨ ê´€ë ¨ ìƒìˆ˜ ì •ì˜
class VolumeConstants {
 static const int minutesPerSlot = 30;
 static const int slotsPerHour = 60 ~/ minutesPerSlot; // 2
 static const int hoursPerDay = 24;
 static const int daysInBuffer = 7;
 static const int totalSlots = slotsPerHour * hoursPerDay * daysInBuffer; // 336
 static const int maxMinutesBuffer = minutesPerSlot * totalSlots; // 10080
 static const String volumeBoxName = 'market_volumes';
}

/// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° enum
enum MarketMood {
 bull,       // ğŸš€ ë¶ˆì¥
 weakBull,   // ğŸ”¥ ì•½ë¶ˆì¥
 sideways,   // âš–ï¸ ì¤‘ê°„ì¥
 bear,       // ğŸ’§ ë¬¼ì¥
 deepBear,   // ğŸ§Š ì–¼ìŒì¥
}

/// ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì—”í‹°í‹° (30ë¶„ ë‹¨ìœ„)
class VolumeData {
 final DateTime timestamp;
 final double volumeUsd;

 const VolumeData({
   required this.timestamp,
   required this.volumeUsd,
 });

 /// DateTime extension í™œìš©
 String get formattedTime => timestamp.yyyyMMddhhmm();
 String get timeAgoText => timestamp.timeAgo();
 String get shortTime => timestamp.hhmmss();

 /// JSON ì§ë ¬í™”
 Map<String, dynamic> toJson() => {
   'timestamp': timestamp.toIso8601String(),
   'volume_usd': volumeUsd,
 };

 factory VolumeData.fromJson(Map<String, dynamic> json) {
   return VolumeData(
     timestamp: DateTime.parse(json['timestamp']),
     volumeUsd: (json['volume_usd'] as num).toDouble(),
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is VolumeData &&
         runtimeType == other.runtimeType &&
         timestamp == other.timestamp &&
         volumeUsd == other.volumeUsd;

 @override
 int get hashCode => timestamp.hashCode ^ volumeUsd.hashCode;

 @override
 String toString() =>
     'VolumeData(${volumeUsd.toStringAsFixed(0)}B USD at ${timestamp.hhmmss()})';
}

/// ğŸ“Š ë§ˆì¼“ ë¬´ë“œ ë°ì´í„° ì—”í‹°í‹°
class MarketMoodData {
 final double totalMarketCapUsd;
 final double totalVolumeUsd;
 final double btcDominance;
 final double marketCapChange24h;
 final DateTime updatedAt;

 const MarketMoodData({
   required this.totalMarketCapUsd,
   required this.totalVolumeUsd,
   required this.btcDominance,
   required this.marketCapChange24h,
   required this.updatedAt,
 });

 /// JSON ì§ë ¬í™” (DTO í˜¸í™˜ìš©)
 Map<String, dynamic> toJson() => {
   'total_market_cap_usd': totalMarketCapUsd,
   'total_volume_usd': totalVolumeUsd,
   'btc_dominance': btcDominance,
   'market_cap_change_24h': marketCapChange24h,
   'updated_at': updatedAt.toIso8601String(),
 };

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodData &&
         runtimeType == other.runtimeType &&
         totalMarketCapUsd == other.totalMarketCapUsd &&
         totalVolumeUsd == other.totalVolumeUsd &&
         btcDominance == other.btcDominance &&
         marketCapChange24h == other.marketCapChange24h;

 @override
 int get hashCode =>
     totalMarketCapUsd.hashCode ^
     totalVolumeUsd.hashCode ^
     btcDominance.hashCode ^
     marketCapChange24h.hashCode;

 @override
 String toString() =>
     'MarketMoodData(volume: ${totalVolumeUsd.toStringAsFixed(0)}, '
     'cap: ${totalMarketCapUsd.toStringAsFixed(0)}, '
     'btc: ${btcDominance.toStringAsFixed(1)}%)';
}

/// ğŸ“Š ë¹„êµ ê²°ê³¼ ì—”í‹°í‹°
class ComparisonResult {
 final bool isReady;
 final double? changePercent;
 final double progressPercent;
 final String status;

 const ComparisonResult({
   required this.isReady,
   this.changePercent,
   required this.progressPercent,
   required this.status,
 });

 factory ComparisonResult.collecting(double progress) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: progress,
     status: 'ìˆ˜ì§‘ì¤‘',
   );
 }

 factory ComparisonResult.ready(double changePercent) {
   return ComparisonResult(
     isReady: true,
     changePercent: changePercent,
     progressPercent: 1.0,
     status: 'ì™„ë£Œ',
   );
 }

 factory ComparisonResult.unavailable(String message) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: 0.0,
     status: message,
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonResult &&
         runtimeType == other.runtimeType &&
         isReady == other.isReady &&
         changePercent == other.changePercent &&
         progressPercent == other.progressPercent &&
         status == other.status;

 @override
 int get hashCode =>
     isReady.hashCode ^
     changePercent.hashCode ^
     progressPercent.hashCode ^
     status.hashCode;

 @override
 String toString() =>
     'ComparisonResult(ready: $isReady, change: $changePercent%, progress: ${(progressPercent * 100).round()}%)';
}

/// ğŸ“ˆ ì „ì²´ ë¹„êµ ë°ì´í„° ì—”í‹°í‹°
class ComparisonData {
 final ComparisonResult thirtyMin;
 final ComparisonResult oneHour;
 final ComparisonResult twoHour;
 final ComparisonResult fourHour;
 final ComparisonResult eightHour;
 final ComparisonResult twelveHour;
 final ComparisonResult twentyFourHour;
 final ComparisonResult threeDayAverage;
 final ComparisonResult weeklyAverage;

 const ComparisonData({
   required this.thirtyMin,
   required this.oneHour,
   required this.twoHour,
   required this.fourHour,
   required this.eightHour,
   required this.twelveHour,
   required this.twentyFourHour,
   required this.threeDayAverage,
   required this.weeklyAverage,
 });

 factory ComparisonData.loading() {
   final loading = ComparisonResult.collecting(0.0);
   return ComparisonData(
     thirtyMin: loading,
     oneHour: loading,
     twoHour: loading,
     fourHour: loading,
     eightHour: loading,
     twelveHour: loading,
     twentyFourHour: loading,
     threeDayAverage: loading,
     weeklyAverage: loading,
   );
 }

 factory ComparisonData.error() {
   final error = ComparisonResult.unavailable('ì˜¤ë¥˜');
   return ComparisonData(
     thirtyMin: error,
     oneHour: error,
     twoHour: error,
     fourHour: error,
     eightHour: error,
     twelveHour: error,
     twentyFourHour: error,
     threeDayAverage: error,
     weeklyAverage: error,
   );
 }

 /// ëª¨ë“  ë¹„êµ ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜
 List<ComparisonResult> get allResults => [
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     ];

 /// ì¤€ë¹„ëœ ë¹„êµ ê²°ê³¼ ê°œìˆ˜
 int get readyCount => allResults.where((r) => r.isReady).length;

 /// ì „ì²´ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get overallProgress =>
     allResults.map((r) => r.progressPercent).reduce((a, b) => a + b) / 9;

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonData &&
         runtimeType == other.runtimeType &&
         thirtyMin == other.thirtyMin &&
         oneHour == other.oneHour &&
         twoHour == other.twoHour &&
         fourHour == other.fourHour &&
         eightHour == other.eightHour &&
         twelveHour == other.twelveHour &&
         twentyFourHour == other.twentyFourHour &&
         threeDayAverage == other.threeDayAverage &&
         weeklyAverage == other.weeklyAverage;

 @override
 int get hashCode => Object.hash(
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     );

 @override
 String toString() =>
     'ComparisonData(ready: $readyCount/9, progress: ${(overallProgress * 100).round()}%)';
}

/// ğŸ“¦ ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì—”í‹°í‹°
class MarketMoodSystemState {
 final MarketMoodData? marketData;
 final ComparisonData comparisonData;
 final MarketMood currentMood;
 final double exchangeRate;
 final bool isLoading;
 final bool hasError;

 const MarketMoodSystemState({
   required this.marketData,
   required this.comparisonData,
   required this.currentMood,
   required this.exchangeRate,
   required this.isLoading,
   required this.hasError,
 });

 /// ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸
 bool get isHealthy => !hasError && marketData != null;

 /// ë°ì´í„° ìˆ˜ì§‘ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get dataProgress => comparisonData.overallProgress;

 /// ìƒíƒœ ìš”ì•½ ë¬¸ìì—´
 String get statusSummary {
   if (hasError) return 'ì˜¤ë¥˜ ë°œìƒ';
   if (isLoading) return 'ë¡œë”© ì¤‘';
   if (marketData == null) return 'ë°ì´í„° ì—†ìŒ';
   return 'ì •ìƒ ì‘ë™';
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodSystemState &&
         runtimeType == other.runtimeType &&
         marketData == other.marketData &&
         comparisonData == other.comparisonData &&
         currentMood == other.currentMood &&
         exchangeRate == other.exchangeRate &&
         isLoading == other.isLoading &&
         hasError == other.hasError;

 @override
 int get hashCode => Object.hash(
       marketData,
       comparisonData,
       currentMood,
       exchangeRate,
       isLoading,
       hasError,
     );

 @override
 String toString() =>
     'MarketMoodSystemState(mood: $currentMood, status: $statusSummary, progress: ${(dataProgress * 100).round()}%)';
}