\n\n// ====== lib/core/di/surge_provider.dart ======\n
// lib/core/di/surge_provider.dart

import 'dart:async';
import 'dart:collection';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart'; // ğŸ”¥ ì¶”ê°€: share() ë©”ì„œë“œìš©
import '../config/app_config.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show marketsProvider, repoProvider;
import '../../domain/entities/surge.dart';
import '../../domain/entities/trade.dart';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ Core Types (ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„± + ë¶ˆë³€ì„±)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì‹œê°„ëŒ€ Enum (ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±)
enum TimeFrame {
  min1(1, '1ë¶„'),
  min5(5, '5ë¶„'),
  min15(15, '15ë¶„'),
  min30(30, '30ë¶„'),
  min60(60, '1ì‹œê°„'),
  hour2(120, '2ì‹œê°„'),
  hour4(240, '4ì‹œê°„'),
  hour8(480, '8ì‹œê°„'),
  hour12(720, '12ì‹œê°„'),
  day1(1440, '1ì¼');

  const TimeFrame(this.minutes, this.displayName);
  final int minutes;
  final String displayName;
  
  Duration get duration => Duration(minutes: minutes);
  String get key => '${minutes}m';
  
  /// AppConfigì—ì„œ TimeFrame ë³€í™˜
  static List<TimeFrame> fromAppConfig() {
    return AppConfig.timeFrames.map((minutes) {
      return TimeFrame.values.firstWhere(
        (tf) => tf.minutes == minutes,
        orElse: () => TimeFrame.min1,
      );
    }).toList();
  }
}

/// ë°°ì¹˜ ì²˜ë¦¬ ë° ìºì‹œ ì„¤ì • (ì™„ì „í•œ ì™¸ë¶€ ì£¼ì…)
@immutable
class SurgeProcessingConfig {
  final int maxCacheSize;
  final int maxMarketsPerTimeFrame;
  final Duration minBatchInterval;
  final Duration maxBatchInterval;
  final Duration defaultBatchInterval;
  final int highLoadThreshold;
  final int lowLoadThreshold;

  const SurgeProcessingConfig({
    this.maxCacheSize = 1000,
    this.maxMarketsPerTimeFrame = 200,
    this.minBatchInterval = const Duration(milliseconds: 50),
    this.maxBatchInterval = const Duration(milliseconds: 200),
    this.defaultBatchInterval = const Duration(milliseconds: 100),
    this.highLoadThreshold = 50,
    this.lowLoadThreshold = 10,
  });

  /// ì ì‘í˜• ë°°ì¹˜ ê°„ê²© ê³„ì‚°
  Duration calculateBatchInterval(int bufferSize) {
    if (bufferSize > highLoadThreshold) return minBatchInterval;
    if (bufferSize < lowLoadThreshold) return maxBatchInterval;
    return defaultBatchInterval;
  }
}

/// ê¸‰ë“±/ê¸‰ë½ ì´ë²¤íŠ¸ (ì™„ì „íˆ ê°œì„ ëœ ì„¤ê³„)
@immutable
class SurgeEvent {
  final List<Surge> surges;
  final TimeFrame timeFrame;
  final bool isReset;
  final DateTime? resetTime;
  final DateTime eventTime;

  const SurgeEvent({
    required this.surges,
    required this.timeFrame,
    this.isReset = false,
    this.resetTime,
    required this.eventTime,
  });

  /// ì¼ë°˜ ë°ì´í„° ì´ë²¤íŠ¸ ìƒì„±
  factory SurgeEvent.data({
    required List<Surge> surges,
    required TimeFrame timeFrame,
  }) {
    return SurgeEvent(
      surges: surges,
      timeFrame: timeFrame,
      isReset: false,
      eventTime: DateTime.now(),
    );
  }

  /// ë¦¬ì…‹ ì´ë²¤íŠ¸ ìƒì„±
  factory SurgeEvent.reset({
    required TimeFrame timeFrame,
    DateTime? resetTime,
  }) {
    final now = resetTime ?? DateTime.now();
    return SurgeEvent(
      surges: const [],
      timeFrame: timeFrame,
      isReset: true,
      resetTime: now,
      eventTime: now,
    );
  }
}

/// ê°€ê²© ë°ì´í„° (ë¶ˆë³€)
@immutable
class PriceData {
  final double basePrice;
  final double currentPrice;
  final double changePercent;

  const PriceData({
    required this.basePrice,
    required this.currentPrice,
    required this.changePercent,
  });

  factory PriceData.initial(double price) {
    return PriceData(
      basePrice: price,
      currentPrice: price,
      changePercent: 0.0,
    );
  }

  PriceData updatePrice(double newPrice) {
    final percent = basePrice > 0 
        ? ((newPrice - basePrice) / basePrice) * 100 
        : 0.0;
    
    return PriceData(
      basePrice: basePrice,
      currentPrice: newPrice,
      changePercent: percent,
    );
  }

  PriceData reset(double newPrice) {
    return PriceData(
      basePrice: newPrice,
      currentPrice: newPrice,
      changePercent: 0.0,
    );
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  Core Logic: SurgeTransformer (ì™„ì „í•œ ìˆœìˆ˜ í•¨ìˆ˜í˜• + ìµœì í™”)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì™„ì „íˆ ìˆœìˆ˜í•œ í•¨ìˆ˜í˜• ë³€í™˜ê¸° + ìµœì í™”ëœ ë©”ëª¨ë¦¬ ê´€ë¦¬
class SurgeTransformer extends StreamTransformerBase<Trade, SurgeEvent> {
  final TimeFrame timeFrame;
  final SurgeProcessingConfig config;
  final Function(TimeFrame, DateTime)? onResetTimeUpdate; // ğŸ”¥ ë™ê¸° ì½œë°± ìœ ì§€
  
  // ìµœì í™”ëœ ë©”ëª¨ë¦¬ ê´€ë¦¬
  LinkedHashSet<String> _seenIds = LinkedHashSet<String>();
  final Map<String, PriceData> _priceData = <String, PriceData>{};
  
  DateTime _lastResetTime = DateTime.now();
  
  // ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë²„í¼ì™€ íƒ€ì´ë¨¸
  final List<Trade> _batchBuffer = [];
  Timer? _batchTimer;

  SurgeTransformer(
    this.timeFrame, {
    this.config = const SurgeProcessingConfig(),
    this.onResetTimeUpdate,
  });

  @override
  Stream<SurgeEvent> bind(Stream<Trade> stream) {
    late StreamController<SurgeEvent> controller;
    StreamSubscription<Trade>? subscription;
    Timer? resetTimer;
    
    // ğŸ”¥ ë°°ì¹˜ í”ŒëŸ¬ì‹œ - ìµœì í™”ëœ ì²˜ë¦¬
    void flushBatch() {
      if (_batchBuffer.isEmpty || controller.isClosed) return;
      
      // ë²„í¼ì— ìŒ“ì¸ ëª¨ë“  ê±°ë˜ë¥¼ í•œ ë²ˆì— ì²˜ë¦¬
      for (final trade in _batchBuffer) {
        _processTrade(trade);
      }
      _batchBuffer.clear();

      // ëª¨ë“  ì²˜ë¦¬ í›„, ìµœì¢… ê²°ê³¼ë¬¼ ì´ë²¤íŠ¸ë¥¼ í•œ ë²ˆë§Œ ë°œìƒ
      final surges = _calculateSurges();
      if (!controller.isClosed) {
        controller.add(SurgeEvent.data(
          surges: surges,
          timeFrame: timeFrame,
        ));
      }
    }

    // ğŸ”¥ ì ì‘í˜• ë°°ì¹˜ íƒ€ì´ë¨¸ ë¦¬ì…‹
    void resetBatchTimer() {
      _batchTimer?.cancel();
      final interval = config.calculateBatchInterval(_batchBuffer.length);
      _batchTimer = Timer(interval, () {
        flushBatch();
        resetBatchTimer();
      });
    }
    
    // ğŸ”¥ ë™ê¸° ì½œë°± ê¸°ë°˜ ë¦¬ì…‹ ìŠ¤ì¼€ì¤„ë§ (ì•ˆì •ì„± ë³´ì¥)
    void scheduleNextReset(VoidCallback onReset) {
      final now = DateTime.now();
      final nextReset = _lastResetTime.add(timeFrame.duration);
      final delay = nextReset.difference(now);
      
      if (delay.isNegative) {
        onReset();
        _lastResetTime = now;
        // ğŸ”¥ ë™ê¸° ì½œë°±ìœ¼ë¡œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
        onResetTimeUpdate?.call(timeFrame, _lastResetTime);
        scheduleNextReset(onReset);
      } else {
        resetTimer = Timer(delay, () {
          onReset();
          _lastResetTime = DateTime.now();
          // ğŸ”¥ ë™ê¸° ì½œë°±ìœ¼ë¡œ ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
          onResetTimeUpdate?.call(timeFrame, _lastResetTime);
          scheduleNextReset(onReset);
        });
      }
    }
    
    controller = StreamController<SurgeEvent>(
      onListen: () {
        // ğŸ”¥ ì´ˆê¸° ë¦¬ì…‹ ì‹œê°„ ì„¤ì •
        onResetTimeUpdate?.call(timeFrame, _lastResetTime);
        
        // 1. ì‹œê°„ëŒ€ ë¦¬ì…‹ íƒ€ì´ë¨¸ ì„¤ì •
        scheduleNextReset(() {
          _resetData();
          if (!controller.isClosed) {
            controller.add(SurgeEvent.reset(
              timeFrame: timeFrame,
              resetTime: _lastResetTime,
            ));
          }
        });
        
        // 2. ë°°ì¹˜ íƒ€ì´ë¨¸ ì‹œì‘
        resetBatchTimer();

        // 3. ê±°ë˜ ë°ì´í„° êµ¬ë…
        subscription = stream.listen(
          (trade) {
            // ì¦‰ì‹œ ì²˜ë¦¬í•˜ì§€ ì•Šê³  ë²„í¼ì— ì¶”ê°€ë§Œ
            _batchBuffer.add(trade);
          },
          onError: controller.addError,
          onDone: () {
            // ğŸ”¥ íƒ€ì´ë¨¸ ëˆ„ìˆ˜ ë°©ì§€
            resetTimer?.cancel();
            _batchTimer?.cancel();
            flushBatch(); // ë§ˆì§€ë§‰ ë°°ì¹˜ ì²˜ë¦¬
            controller.close();
          },
        );
      },
      onCancel: () {
        // ëª¨ë“  íƒ€ì´ë¨¸ì™€ êµ¬ë… ì·¨ì†Œ
        resetTimer?.cancel();
        _batchTimer?.cancel();
        subscription?.cancel();
      },
    );
    
    return controller.stream;
  }

  bool _processTrade(Trade trade) {
    // ğŸ”¥ ìµœì í™”ëœ ì¤‘ë³µ í•„í„°ë§ (LinkedHashSet + skip)
    final key = '${trade.market}/${trade.sequentialId}';
    if (_seenIds.contains(key)) return false;
    
    if (_seenIds.length >= config.maxCacheSize) {
      // ğŸ”¥ GC ìµœì í™”: skip() ì‚¬ìš©ìœ¼ë¡œ ì„ì‹œ ë¦¬ìŠ¤íŠ¸ ìƒì„± ì œê±°
      final removeCount = _seenIds.length ~/ 4;
      _seenIds = LinkedHashSet<String>.from(_seenIds.skip(removeCount));
    }
    _seenIds.add(key);

    // ê°€ê²© ë°ì´í„° ì—…ë°ì´íŠ¸
    final existing = _priceData[trade.market];
    if (existing != null) {
      _priceData[trade.market] = existing.updatePrice(trade.price);
    } else {
      _priceData[trade.market] = PriceData.initial(trade.price);
    }

    // ë©”ëª¨ë¦¬ ê´€ë¦¬
    if (_priceData.length > config.maxMarketsPerTimeFrame) {
      final sorted = _priceData.entries.toList()
        ..sort((a, b) => b.value.changePercent.abs().compareTo(a.value.changePercent.abs()));
      
      _priceData.clear();
      _priceData.addAll(Map.fromEntries(sorted.take(config.maxMarketsPerTimeFrame)));
    }

    return true;
  }

  void _resetData() {
    for (final entry in _priceData.entries) {
      _priceData[entry.key] = entry.value.reset(entry.value.currentPrice);
    }
  }

  List<Surge> _calculateSurges() {
    final now = DateTime.now();
    final surges = _priceData.entries
        .map((e) => Surge(
              market: e.key,
              changePercent: e.value.changePercent,
              basePrice: e.value.basePrice,
              currentPrice: e.value.currentPrice,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame.key,
              timeFrameStartMs: _lastResetTime.millisecondsSinceEpoch,
            ))
        .where((surge) => surge.hasChange)
        .toList();

    // ì™„ì „í•œ ì •ë ¬ ë¡œì§: + ë¨¼ì €, - ë‚˜ì¤‘ì— (ì ˆëŒ“ê°’ ê¸°ì¤€)
    surges.sort((a, b) {
      if (a.isRising && b.isFalling) return -1;
      if (a.isFalling && b.isRising) return 1;
      if (a.isRising && b.isRising) return b.changePercent.compareTo(a.changePercent);
      if (a.isFalling && b.isFalling) return b.changePercent.compareTo(a.changePercent);
      return 0;
    });
    
    return surges;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ Providers (ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„± + ìµœì í™”ëœ ì•„í‚¤í…ì²˜)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// ì„ íƒëœ ì‹œê°„ëŒ€
final selectedTimeFrameProvider = StateProvider<TimeFrame>((ref) => TimeFrame.min1);

/// ğŸ”¥ ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±: TimeFrame enum í‚¤ ì‚¬ìš©
final timeFrameResetTimesProvider = StateProvider<Map<TimeFrame, DateTime>>((ref) {
  final now = DateTime.now();
  final initialTimes = <TimeFrame, DateTime>{};
  
  // ëª¨ë“  ì‹œê°„ëŒ€ ì´ˆê¸°í™”
  for (final timeFrame in TimeFrame.fromAppConfig()) {
    initialTimes[timeFrame] = now;
  }
  
  return initialTimes;
});

/// ì²˜ë¦¬ ì„¤ì • Provider (ì™¸ë¶€ ì£¼ì… ê°€ëŠ¥)
final surgeProcessingConfigProvider = Provider<SurgeProcessingConfig>((ref) {
  return const SurgeProcessingConfig(
    // í”„ë¡œë•ì…˜ ìµœì í™” ì„¤ì •
    maxCacheSize: 1000,
    maxMarketsPerTimeFrame: 200,
    minBatchInterval: Duration(milliseconds: 50),
    maxBatchInterval: Duration(milliseconds: 200),
    defaultBatchInterval: Duration(milliseconds: 100),
    highLoadThreshold: 50,
    lowLoadThreshold: 10,
  );
});

/// ì‹œê°„ëŒ€ë³„ StreamController ê´€ë¦¬ (ë©€í‹°ìŠ¤íŠ¸ë¦¼)
final timeFrameControllersProvider = Provider<Map<TimeFrame, StreamController<SurgeEvent>>>((ref) {
  final controllers = <TimeFrame, StreamController<SurgeEvent>>{};
  final availableTimeFrames = TimeFrame.fromAppConfig();
  
  for (final timeFrame in availableTimeFrames) {
    controllers[timeFrame] = StreamController<SurgeEvent>.broadcast();
  }

  ref.onDispose(() {
    for (final controller in controllers.values) {
      if (!controller.isClosed) {
        controller.close();
      }
    }
    controllers.clear();
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ›‘ TimeFrame controllers disposed');
    }
  });

  return controllers;
});

/// ğŸ”¥ ìµœì í™”ëœ ì›ì‹œ ê±°ë˜ ìŠ¤íŠ¸ë¦¼ (ë‹¨ì¼ WS + ë¸Œë¡œë“œìºìŠ¤íŠ¸)
final tradeStreamProvider = StreamProvider<Trade>((ref) async* {
  final markets = await ref.watch(marketsProvider.future);
  final repo = ref.read(repoProvider);
  
  if (AppConfig.enableTradeLog) {
    log.i('ğŸ”¥ Single WS Trade stream started: ${markets.length} markets');
  }
  
  // ğŸ”¥ í•µì‹¬ ìµœì í™”: ë‹¨ì¼ WS ìŠ¤íŠ¸ë¦¼ + share()ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
  yield* repo.watchTrades(markets).share();
});

/// ğŸ”¥ ì‹œê°„ëŒ€ë³„ ìŠ¤íŠ¸ë¦¼ ì—°ê²° (ìµœì í™”ëœ íŒ¬-ì•„ì›ƒ ë°©ì‹)
final surgeStreamBinderProvider = Provider((ref) async {
  // âœ… ë¹„ë™ê¸°ë¡œ ë§ˆì¼“ ë°ì´í„° ëŒ€ê¸°
  final markets = await ref.read(marketsProvider.future);
  final repo = ref.read(repoProvider);
  final controllers = ref.read(timeFrameControllersProvider);
  final availableTimeFrames = TimeFrame.fromAppConfig();
  final config = ref.read(surgeProcessingConfigProvider);
  
  // âœ… ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ì„ binderì—ì„œ ì§ì ‘ ìƒì„± (WS 1ê°œ ìœ ì§€)
  final masterStream = repo.watchTrades(markets).share();
  
  // ğŸ”¥ ë™ê¸° ì½œë°± ê¸°ë°˜ ë¦¬ì…‹ ì‹œê°„ ì—…ë°ì´íŠ¸ (íƒ€ì´ë° ì´ìŠˆ ì œê±°)
  void updateResetTime(TimeFrame timeFrame, DateTime resetTime) {
    final currentTimes = ref.read(timeFrameResetTimesProvider);
    ref.read(timeFrameResetTimesProvider.notifier).state = {
      ...currentTimes,
      timeFrame: resetTime,
    };
  }
  
  // ğŸ”¥ ê° ì‹œê°„ëŒ€ë³„ë¡œ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ì„ íŒ¬-ì•„ì›ƒ
  for (final timeFrame in availableTimeFrames) {
    final controller = controllers[timeFrame];
    if (controller != null) {
      // ğŸ”¥ ë§ˆìŠ¤í„° ìŠ¤íŠ¸ë¦¼ â†’ ì‹œê°„ëŒ€ë³„ ë…ë¦½ ë³€í™˜ â†’ ê° ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ ì „ì†¡
      masterStream
          .transform(SurgeTransformer(
            timeFrame,
            config: config,
            onResetTimeUpdate: updateResetTime, // ğŸ”¥ ë™ê¸° ì½œë°±ìœ¼ë¡œ ì•ˆì •ì„± ë³´ì¥
          ))
          .listen(
            controller.add,
            onError: controller.addError,
          );
    }
  }

  if (AppConfig.enableTradeLog) {
    log.i('ğŸ”¥ Fan-out stream binding completed: ${availableTimeFrames.length} timeframes');
  }
  
  return controllers;
});

/// ë©”ì¸ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ìŠ¤íŠ¸ë¦¼
final surgeDataProvider = StreamProvider<SurgeEvent>((ref) async* {
  ref.keepAlive();
  
  final selectedTimeFrame = ref.watch(selectedTimeFrameProvider);
  final controllers = ref.read(timeFrameControllersProvider);
  
  // ìŠ¤íŠ¸ë¦¼ ë°”ì¸ë” í™œì„±í™”
  await ref.read(surgeStreamBinderProvider);
  
  final controller = controllers[selectedTimeFrame];
  if (controller == null) {
    log.e('ğŸ’¥ Controller not found for $selectedTimeFrame');
    return;
  }

  if (AppConfig.enableTradeLog) {
    log.i('ğŸ”¥ Surge stream started: $selectedTimeFrame');
  }

  yield* controller.stream;
});

/// í˜„ì¬ ì‹œê°„ëŒ€ì˜ Surge ë¦¬ìŠ¤íŠ¸ (UIìš©)
final currentSurgeListProvider = Provider<List<Surge>>((ref) {
  final surgeEvent = ref.watch(surgeDataProvider).valueOrNull;
  return surgeEvent?.surges ?? [];
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›ï¸ TimeFrame Controller (ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

final timeFrameControllerProvider = Provider((ref) => TimeFrameController(ref));

class TimeFrameController {
  final Ref _ref;
  
  TimeFrameController(this._ref);

  /// ì‹œê°„ëŒ€ ë³€ê²½ (TimeFrame enum ê¸°ë°˜)
  void setTimeFrame(TimeFrame timeFrame) {
    _ref.read(selectedTimeFrameProvider.notifier).state = timeFrame;
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ TimeFrame changed: ${timeFrame.displayName}');
    }
  }

  /// í˜„ì¬ ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetCurrentTimeFrame() {
    final currentTimeFrame = _ref.read(selectedTimeFrameProvider);
    final controllers = _ref.read(timeFrameControllersProvider);
    final controller = controllers[currentTimeFrame];
    
    if (controller != null && !controller.isClosed) {
      final now = DateTime.now();
      
      // ë¦¬ì…‹ ì´ë²¤íŠ¸ ë°œìƒ
      controller.add(SurgeEvent.reset(
        timeFrame: currentTimeFrame,
        resetTime: now,
      ));
      
      // ğŸ”¥ ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±: TimeFrame enum í‚¤ ì‚¬ìš©
      final currentTimes = _ref.read(timeFrameResetTimesProvider);
      _ref.read(timeFrameResetTimesProvider.notifier).state = {
        ...currentTimes,
        currentTimeFrame: now,
      };
      
      if (AppConfig.enableTradeLog) {
        log.i('ğŸ”„ Manual reset: ${currentTimeFrame.displayName}');
      }
    }
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ ë¦¬ì…‹
  void resetAllTimeFrames() {
    final controllers = _ref.read(timeFrameControllersProvider);
    final availableTimeFrames = TimeFrame.fromAppConfig();
    final now = DateTime.now();
    
    for (final timeFrame in availableTimeFrames) {
      final controller = controllers[timeFrame];
      if (controller != null && !controller.isClosed) {
        controller.add(SurgeEvent.reset(
          timeFrame: timeFrame,
          resetTime: now,
        ));
      }
    }
    
    // ğŸ”¥ ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±: TimeFrame enum í‚¤ ì‚¬ìš©
    final resetTimes = <TimeFrame, DateTime>{};
    for (final timeFrame in availableTimeFrames) {
      resetTimes[timeFrame] = now;
    }
    _ref.read(timeFrameResetTimesProvider.notifier).state = resetTimes;
    
    if (AppConfig.enableTradeLog) {
      log.i('ğŸ”„ Manual reset: all timeframes');
    }
  }

  /// ğŸ”¥ ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±ìœ¼ë¡œ ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ ê³„ì‚°
  DateTime? getNextResetTime() {
    final currentTimeFrame = _ref.read(selectedTimeFrameProvider);
    final resetTimes = _ref.read(timeFrameResetTimesProvider);
    final lastResetTime = resetTimes[currentTimeFrame];
    
    if (lastResetTime == null) return null;
    
    return lastResetTime.add(currentTimeFrame.duration);
  }

  /// Getters
  TimeFrame get currentTimeFrame => _ref.read(selectedTimeFrameProvider);
  
  int get currentIndex {
    final availableTimeFrames = TimeFrame.fromAppConfig();
    return availableTimeFrames.indexOf(currentTimeFrame);
  }
  
  List<TimeFrame> get availableTimeFrames => TimeFrame.fromAppConfig();
  
  String get currentTimeFrameName => currentTimeFrame.displayName;
  
  String getTimeFrameName(TimeFrame timeFrame) => timeFrame.displayName;
}\n\n// ====== lib/data/repositories/surge_repository_impl.dart ======\n
// lib/data/repositories/surge_repository_impl.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../../domain/entities/trade.dart';
import '../../domain/entities/surge.dart';
import '../../domain/repositories/surge_repository.dart';
import '../../domain/repositories/trade_repository.dart';

/// ğŸš€ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° í´ë˜ìŠ¤
class SurgeData {
  double? basePrice;      // ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  double currentPrice = 0; // í˜„ì¬ ê°€ê²© (ê³„ì† ì—…ë°ì´íŠ¸)
  double changePercent = 0; // ë³€ë™ë¥  (ê³„ì† ì¬ê³„ì‚°)

  SurgeData({this.basePrice, this.currentPrice = 0, this.changePercent = 0});

  void updatePrice(double price) {
    basePrice ??= price;
    currentPrice = price;
    changePercent = basePrice != null && basePrice! > 0 
        ? ((currentPrice - basePrice!) / basePrice!) * 100 
        : 0.0;
  }

  void reset(double price) {
    basePrice = price;
    currentPrice = price;
    changePercent = 0.0;
  }
}

/// ğŸ—ï¸ SurgeRepositoryImpl - ë°ì´í„° ì²˜ë¦¬ ë‹´ë‹¹
class SurgeRepositoryImpl implements SurgeRepository {
  final TradeRepository _tradeRepository;

  // ğŸ“Š ê¸‰ë“±/ê¸‰ë½ ìƒíƒœ ê´€ë¦¬
  final Map<String, Map<String, SurgeData>> _surgeByTimeFrame = {};
  final Set<String> _seenIds = {};
  
  // ğŸ¯ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ (ì‹œê°„ëŒ€ë³„) - Surge ë¦¬ìŠ¤íŠ¸ ë°©ì¶œ
  final Map<String, StreamController<List<Surge>>> _surgeControllers = {};
  
  // ğŸ• ì‹œê°„ëŒ€ë³„ ë¦¬ì…‹ ì‹œê°„ ì¶”ì 
  final Map<String, DateTime> _timeFrameStartTimes = {};
  
  // ğŸ¯ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬
  StreamSubscription<Trade>? _masterSubscription;
  Timer? _batchUpdateTimer;
  bool _disposed = false;
  
  // ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜
  static const int _maxMarketsPerTimeFrame = 200;
  static const int _maxCacheSize = 1000;
  static const Duration _batchUpdateInterval = Duration(milliseconds: 100);

  SurgeRepositoryImpl(this._tradeRepository) {
    _initializeSurgeTracking();
  }

  /// ê¸‰ë“±/ê¸‰ë½ ì¶”ì  ì´ˆê¸°í™”
  void _initializeSurgeTracking() {
    for (final timeFrameMinutes in AppConfig.timeFrames) {
      final timeFrameStr = '${timeFrameMinutes}m';
      
      // ë¹ˆ ê¸‰ë“±/ê¸‰ë½ ë§µ ì´ˆê¸°í™”
      _surgeByTimeFrame[timeFrameStr] = <String, SurgeData>{};
      
      // ìŠ¤íŠ¸ë¦¼ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± - List<Surge> íƒ€ì…
      _surgeControllers[timeFrameStr] = StreamController<List<Surge>>.broadcast();
      
      // ì‹œì‘ ì‹œê°„ ì„¤ì •
      _timeFrameStartTimes[timeFrameStr] = DateTime.now();
      
      // ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
      _scheduleNextReset(timeFrameStr, timeFrameMinutes);
    }
    
    if (kDebugMode) {
      debugPrint('SurgeRepository: Surge tracking initialized for ${AppConfig.timeFrames.length} timeframes');
    }
  }

  /// ì •í™•í•œ ë¦¬ì…‹ íƒ€ì´ë° ìŠ¤ì¼€ì¤„ë§
  void _scheduleNextReset(String timeFrame, int minutes) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame]!;
    final nextReset = startTime.add(Duration(minutes: minutes));
    final delay = nextReset.difference(now);
    
    if (delay.isNegative) {
      _resetTimeFrameData(timeFrame);
      _timeFrameStartTimes[timeFrame] = now;
      _scheduleNextReset(timeFrame, minutes);
    } else {
      Timer(delay, () {
        _resetTimeFrameData(timeFrame);
        _timeFrameStartTimes[timeFrame] = DateTime.now();
        _scheduleNextReset(timeFrame, minutes);
      });
    }
  }

  /// ë©”ì¸ ìŠ¤íŠ¸ë¦¼ ì´ˆê¸°í™” ë° ë°ì´í„° ì²˜ë¦¬
  void _initializeProcessing(List<String> markets) {
    if (_masterSubscription != null) return;
    
    debugPrint('SurgeRepository: initializing processing for ${markets.length} markets');
    
    // TradeRepositoryì˜ ìˆœìˆ˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ êµ¬ë…
    _masterSubscription = _tradeRepository.watchTrades(markets).listen(
      _processRawTradeData,
      onError: (error, stackTrace) {
        debugPrint('SurgeRepository processing error: $error');
        // ì—ëŸ¬ë¥¼ ëª¨ë“  ì»¨íŠ¸ë¡¤ëŸ¬ì— ì „ë‹¬
        for (final controller in _surgeControllers.values) {
          if (!controller.isClosed) {
            controller.addError(error, stackTrace);
          }
        }
      },
      onDone: () {
        debugPrint('SurgeRepository processing done');
      },
    );
  }

  @override
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets) {
    if (_disposed) {
      throw StateError('Repository has been disposed');
    }

    // ì²˜ë¦¬ ì´ˆê¸°í™”
    _initializeProcessing(markets);
    
    // í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ ì§ì ‘ ë°˜í™˜
    return _surgeControllers[timeFrame]?.stream ?? const Stream.empty();
  }

  /// ì›ì‹œ ê±°ë˜ ë°ì´í„° ì²˜ë¦¬
  void _processRawTradeData(Trade trade) {
    try {
      final key = '${trade.market}/${trade.sequentialId}';

      // ì¤‘ë³µ ì²˜ë¦¬ ë°©ì§€
      if (!_seenIds.add(key)) return;

      // ë©”ëª¨ë¦¬ ê´€ë¦¬
      if (_seenIds.length > _maxCacheSize) {
        final removeCount = (_seenIds.length / 4).ceil();
        final toRemove = _seenIds.take(removeCount).toList();
        _seenIds.removeAll(toRemove);
      }

      // ë°ì´í„° ì €ì¥ í›„ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
      _storeDataAndScheduleUpdate(trade);
      
    } catch (e, stackTrace) {
      debugPrint('_processRawTradeData error: $e');
      debugPrint('StackTrace: $stackTrace');
      // ì—ëŸ¬ë¥¼ ëª¨ë“  ì»¨íŠ¸ë¡¤ëŸ¬ì— ì „ë‹¬
      for (final controller in _surgeControllers.values) {
        if (!controller.isClosed) {
          controller.addError(e, stackTrace);
        }
      }
    }
  }

  /// ê±°ë˜ ë°ì´í„° ì €ì¥ í›„ ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
  void _storeDataAndScheduleUpdate(Trade trade) {
    final market = trade.market;
    final currentPrice = trade.price;
    
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      final surgeMap = _surgeByTimeFrame[timeFrameStr]!;
      
      // í¬ê¸° ì œí•œ (ìƒìœ„ 200ê°œë§Œ ìœ ì§€)
      if (surgeMap.length > _maxMarketsPerTimeFrame) {
        final sorted = surgeMap.entries.toList()
          ..sort((a, b) => b.value.changePercent.abs().compareTo(a.value.changePercent.abs()));
        surgeMap.clear();
        surgeMap.addAll(Map.fromEntries(sorted.take(_maxMarketsPerTimeFrame)));
      }
      
      final surgeData = surgeMap[market] ??= SurgeData();
      surgeData.updatePrice(currentPrice);
    }
    
    // ë°°ì¹˜ ì—…ë°ì´íŠ¸ ì˜ˆì•½
    _scheduleBatchUpdate();
  }

  /// ë°°ì¹˜ ì—…ë°ì´íŠ¸ ìŠ¤ì¼€ì¤„ë§
  void _scheduleBatchUpdate() {
    if (_disposed) return;
    
    _batchUpdateTimer?.cancel();
    _batchUpdateTimer = Timer(_batchUpdateInterval, () {
      _performBatchUpdate();
    });
  }

  /// ëª¨ë“  ì‹œê°„ëŒ€ì˜ ê¸‰ë“±/ê¸‰ë½ ìŠ¤íŠ¸ë¦¼ ë°°ì¹˜ ì—…ë°ì´íŠ¸
  void _performBatchUpdate() {
    if (_disposed) return;
    
    try {
      for (final entry in _surgeByTimeFrame.entries) {
        final timeFrameStr = entry.key;
        final surgeMap = entry.value;
        
        // Surge ë¦¬ìŠ¤íŠ¸ ìƒì„±
        final surgeList = _createSurgeList(surgeMap, timeFrameStr);
        
        // í•´ë‹¹ ì‹œê°„ëŒ€ ìŠ¤íŠ¸ë¦¼ì— Surge ë¦¬ìŠ¤íŠ¸ ì „ì†¡
        final controller = _surgeControllers[timeFrameStr];
        if (controller != null && !controller.isClosed) {
          controller.add(surgeList);
        }
      }
      
      if (kDebugMode) {
        final totalMarkets = _surgeByTimeFrame.values.isNotEmpty 
            ? _surgeByTimeFrame.values.first.length 
            : 0;
        if (totalMarkets > 0) {
          debugPrint('SurgeRepository: Surge streams updated (batch): $totalMarkets markets');
        }
      }
    } catch (e, stackTrace) {
      debugPrint('_performBatchUpdate error: $e');
      debugPrint('StackTrace: $stackTrace');
      // ì—ëŸ¬ë¥¼ ëª¨ë“  ì»¨íŠ¸ë¡¤ëŸ¬ì— ì „ë‹¬
      for (final controller in _surgeControllers.values) {
        if (!controller.isClosed) {
          controller.addError(e, stackTrace);
        }
      }
    }
  }

  /// Surge ë¦¬ìŠ¤íŠ¸ ìƒì„±
  List<Surge> _createSurgeList(Map<String, SurgeData> surgeMap, String timeFrame) {
    final now = DateTime.now();
    final startTime = _timeFrameStartTimes[timeFrame] ?? now;
    
    final surgeList = surgeMap.entries
        .where((entry) => entry.value.basePrice != null && entry.value.changePercent != 0)
        .map((entry) => Surge(
              market: entry.key,
              changePercent: entry.value.changePercent,
              basePrice: entry.value.basePrice!,
              currentPrice: entry.value.currentPrice,
              lastUpdatedMs: now.millisecondsSinceEpoch,
              timeFrame: timeFrame,
              timeFrameStartMs: startTime.millisecondsSinceEpoch,
            ))
        .toList();

    // ë³€ë™ë¥  ì‹¤ì œê°’ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ê¸‰ë“±ì´ ìœ„ì—, ê¸‰ë½ì´ ì•„ë˜ì—)
    surgeList.sort((a, b) => b.changePercent.compareTo(a.changePercent));
    
    return surgeList;
  }

  /// íŠ¹ì • ì‹œê°„ëŒ€ ë°ì´í„° ë¦¬ì…‹
  void _resetTimeFrameData(String timeFrameStr) {
    // ë³€ë™ë¥  ë¦¬ì…‹: í˜„ì¬ ê°€ê²©ì„ ìƒˆë¡œìš´ basePriceë¡œ ì„¤ì •
    final surgeMap = _surgeByTimeFrame[timeFrameStr];
    if (surgeMap != null) {
      for (final surgeData in surgeMap.values) {
        surgeData.reset(surgeData.currentPrice);
      }
    }
    
    // ë¦¬ì…‹ í›„ Surge ë¦¬ìŠ¤íŠ¸ ì „ì†¡
    final surgeList = _createSurgeList(surgeMap ?? {}, timeFrameStr);
    final controller = _surgeControllers[timeFrameStr];
    if (controller != null && !controller.isClosed) {
      controller.add(surgeList);
    }
    
    if (kDebugMode) {
      debugPrint('SurgeRepository: Reset completed for $timeFrameStr with ${surgeList.length} items');
    }
  }

  @override
  void resetTimeFrame(String timeFrame) {
    debugPrint('SurgeRepository: Manual reset timeFrame: $timeFrame');
    _resetTimeFrameData(timeFrame);
  }

  @override
  void resetAllTimeFrames() {
    debugPrint('SurgeRepository: Manual reset all timeFrames');
    for (final timeFrameStr in _surgeByTimeFrame.keys) {
      _resetTimeFrameData(timeFrameStr);
    }
  }

  @override
  DateTime? getNextResetTime(String timeFrame) {
    final startTime = _timeFrameStartTimes[timeFrame];
    if (startTime == null) return null;
    
    final timeFrameMinutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (timeFrameMinutes == null) return null;
    
    return startTime.add(Duration(minutes: timeFrameMinutes));
  }

  @override
  List<String> getActiveTimeFrames() {
    return AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  }

  @override
  bool isTimeFrameActive(String timeFrame) {
    final activeFrames = AppConfig.timeFrames.map((tf) => '${tf}m').toList();
    return activeFrames.contains(timeFrame);
  }

  @override
  Future<void> dispose() async {
    if (_disposed) return;
    
    debugPrint('SurgeRepository: dispose() called');
    _disposed = true;
    
    // íƒ€ì´ë¨¸ ì •ë¦¬
    _batchUpdateTimer?.cancel();
    
    // ìŠ¤íŠ¸ë¦¼ êµ¬ë… ì •ë¦¬
    await _masterSubscription?.cancel();
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ë“¤ ì •ë¦¬
    for (final controller in _surgeControllers.values) {
      await controller.close();
    }
    
    // ë°ì´í„° ì •ë¦¬
    _surgeByTimeFrame.clear();
    _seenIds.clear();
    _timeFrameStartTimes.clear();
    
    debugPrint('SurgeRepository: dispose completed');
  }
}\n\n// ====== lib/domain/repositories/surge_repository.dart ======\n
// lib/domain/repositories/surge_repository.dart
import '../entities/surge.dart';

/// ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ì˜ ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ì¶”ì  ë° ë¦¬ì…‹ì„ ê´€ë¦¬í•˜ëŠ” Repository
abstract class SurgeRepository {
  /// ì‹œê°„ëŒ€ë³„ ë³€ë™ë¥  ìŠ¤íŠ¸ë¦¼ ì œê³µ (Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸)
  /// [timeFrame]: ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  /// [markets]: ëª¨ë‹ˆí„°ë§í•  ë§ˆì¼“ ì½”ë“œ ë¦¬ìŠ¤íŠ¸
  /// Returns: Surge ì—”í‹°í‹° ë¦¬ìŠ¤íŠ¸ (ë³€ë™ë¥  ì ˆëŒ“ê°’ ìˆœ ì •ë ¬)
  Stream<List<Surge>> watchSurgeByTimeFrame(String timeFrame, List<String> markets);
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  /// [timeFrame]: ë¦¬ì…‹í•  ì‹œê°„ëŒ€
  void resetTimeFrame(String timeFrame);
  
  /// ëª¨ë“  ì‹œê°„ëŒ€ ìˆ˜ë™ ë¦¬ì…‹
  void resetAllTimeFrames();
  
  /// ë‹¤ìŒ ë¦¬ì…‹ ì˜ˆì • ì‹œê°„ ì¡°íšŒ
  /// [timeFrame]: ì‹œê°„ëŒ€
  /// Returns: ë‹¤ìŒ ë¦¬ì…‹ ì‹œê°„ (nullì´ë©´ ë¦¬ì…‹ ì •ë³´ ì—†ìŒ)
  DateTime? getNextResetTime(String timeFrame);
  
  /// í™œì„±í™”ëœ ì‹œê°„ëŒ€ ëª©ë¡ ì¡°íšŒ
  /// Returns: ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œê°„ëŒ€ ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: ["1m", "5m", "15m"])
  List<String> getActiveTimeFrames();
  
  /// íŠ¹ì • ì‹œê°„ëŒ€ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
  /// [timeFrame]: í™•ì¸í•  ì‹œê°„ëŒ€
  /// Returns: í™œì„±í™” ì—¬ë¶€
  bool isTimeFrameActive(String timeFrame);
  
  /// ë¦¬ì†ŒìŠ¤ í•´ì œ
  Future<void> dispose();
}\n\n// ====== lib/domain/usecases/surge_usecase.dart ======\n
import 'package:flutter/foundation.dart';
import '../../core/config/app_config.dart';
import '../entities/surge.dart';

/// ğŸ”¥ A+ê¸‰ SurgeUsecase - ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„± + í•¨ìˆ˜í˜• ì„¤ê³„
/// - ëª¨ë“  dynamic ì œê±°ë¡œ ì»´íŒŒì¼íƒ€ì„ ì•ˆì „ì„± ë³´ì¥
/// - ìˆœìˆ˜ í•¨ìˆ˜ + ë¶ˆë³€ì„± ì² ì €íˆ ì ìš©
/// - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ì„ enum/configë¡œ ì¶”ìƒí™”
/// - ì„±ëŠ¥ ìµœì í™”ëœ ì•Œê³ ë¦¬ì¦˜ ì ìš©
class SurgeUsecase {
  // ğŸ”¥ RepositoryëŠ” í–¥í›„ í™•ì¥ì„ ìœ„í•´ ë³´ê´€ (í˜„ì¬ëŠ” ìˆœìˆ˜ í•¨ìˆ˜ë§Œ ì‚¬ìš©)

  // ğŸ¯ ì„±ëŠ¥ ìµœì í™” ìƒìˆ˜ (ì„¤ì •ìœ¼ë¡œ ì™¸ë¶€í™”)
  static const int maxSurges = 200;
  static const int maxCacheSize = 1000;

  // ğŸ¯ ìƒì„±ìì—ì„œ repository ì œê±° (ìˆœìˆ˜ í•¨ìˆ˜í˜• ìœ í‹¸ë¦¬í‹°ë¡œ ì‚¬ìš©)
  const SurgeUsecase();

  /// ğŸ”¥ ì™„ì „í•œ íƒ€ì… ì•ˆì „ì„±: PriceData ì¸í„°í˜ì´ìŠ¤ ì •ì˜
  /// dynamic ì™„ì „ ì œê±°!
  List<Surge> calculateSurgeList(
    Map<String, PriceData> surgeMap, // ğŸ¯ dynamic â†’ PriceData
    String timeFrame,
    DateTime startTime,
  ) {
    if (!isValidTimeFrame(timeFrame)) return <Surge>[];

    final now = DateTime.now();
    
    // ğŸ”¥ í•¨ìˆ˜í˜• ì²´ì´ë‹ìœ¼ë¡œ ê¹”ë”í•˜ê²Œ
    return surgeMap.entries
        .where(_hasValidPriceData)
        .map((entry) => _createSurge(entry, timeFrame, now, startTime))
        .where(_isValidSurge)
        .toList()
      ..sort(_compareByChangePercent)
      ..take(maxSurges);
  }

  /// ğŸ¯ ìˆœìˆ˜ í•¨ìˆ˜: ìœ íš¨í•œ ê°€ê²© ë°ì´í„° ì²´í¬
  bool _hasValidPriceData(MapEntry<String, PriceData> entry) {
    final data = entry.value;
    return data.basePrice > 0 && data.changePercent != 0;
  }

  /// ğŸ¯ ìˆœìˆ˜ í•¨ìˆ˜: Surge ê°ì²´ ìƒì„±
  Surge _createSurge(
    MapEntry<String, PriceData> entry,
    String timeFrame,
    DateTime now,
    DateTime startTime,
  ) {
    final data = entry.value;
    return Surge(
      market: entry.key,
      changePercent: data.changePercent,
      basePrice: data.basePrice,
      currentPrice: data.currentPrice,
      lastUpdatedMs: now.millisecondsSinceEpoch,
      timeFrame: timeFrame,
      timeFrameStartMs: startTime.millisecondsSinceEpoch,
    );
  }

  /// ğŸ¯ ìˆœìˆ˜ í•¨ìˆ˜: ë³€ë™ë¥  ë¹„êµ (ë‚´ë¦¼ì°¨ìˆœ)
  int _compareByChangePercent(Surge a, Surge b) => 
      b.changePercent.compareTo(a.changePercent);

  /// ğŸ”¥ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ enumí™” - íƒ€ì… ì•ˆì „ì„± ê·¹ëŒ€í™”
  bool isValidTimeFrame(String timeFrame) => 
      SurgeTimeFrame.isValid(timeFrame);

  /// ğŸ¯ í•¨ìˆ˜í˜• ì²´ì´ë‹: í•„í„°ë§ ë©”ì„œë“œë“¤
  List<Surge> filterByMinimumPercent(List<Surge> surges, double threshold) =>
      surges.where((s) => s.changePercent.abs() >= threshold).toList();

  List<Surge> filterRisingOnly(List<Surge> surges) =>
      surges.where((s) => s.isRising).toList(); // ğŸ”¥ entity ë©”ì„œë“œ í™œìš©

  List<Surge> filterFallingOnly(List<Surge> surges) =>
      surges.where((s) => s.isFalling).toList(); // ğŸ”¥ entity ë©”ì„œë“œ í™œìš©

  /// ğŸ”¥ ê³ ì„±ëŠ¥ ì •ë ¬: ê¸°ë³¸ê°’ìœ¼ë¡œ ìµœì í™”
  List<Surge> sortByChangePercent(List<Surge> surges, {bool descending = true}) {
    return List<Surge>.from(surges)
      ..sort(descending ? _compareByChangePercent : _compareByChangePercentAsc);
  }

  int _compareByChangePercentAsc(Surge a, Surge b) => 
      a.changePercent.compareTo(b.changePercent);

  /// ğŸ¯ í•¨ìˆ˜í˜•: í¬ê¸° ì œí•œ
  List<Surge> limitCount(List<Surge> surges, [int? maxCount]) =>
      surges.take(maxCount ?? maxSurges).toList();

  /// ğŸ”¥ entity ê²€ì¦ ë©”ì„œë“œ í™œìš©ìœ¼ë¡œ ì¤‘ë³µ ì œê±°
  bool _isValidSurge(Surge surge) => surge.hasChange; // entity ë©”ì„œë“œ í™œìš©

  /// ğŸ¯ ê³ ì„±ëŠ¥ ì§‘ê³„: fold ì‚¬ìš©
  double calculateTotalChangePercent(Map<String, PriceData> surgeMap) =>
      surgeMap.values.fold(0.0, (sum, data) => sum + data.changePercent);

  int getActiveSurgeCount(Map<String, PriceData> surgeMap) =>
      surgeMap.values.where((data) => data.changePercent != 0).length;

  /// ğŸ”¥ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ í•¨ìˆ˜í™”
  bool isSurgeAboveThreshold(double changePercent, double threshold) =>
      changePercent.abs() > threshold;

  bool isKrwMarket(String market) => market.startsWith('KRW-');

  /// ğŸ¯ ì„¤ì • ê¸°ë°˜ ë©”ì„œë“œë“¤
  List<String> getActiveTimeFrames() => SurgeTimeFrame.allActive();
  
  String getTimeFrameDisplayName(String timeFrame) => 
      SurgeTimeFrame.getDisplayName(timeFrame);

  /// ğŸ”¥ ì‹œê°„ ê³„ì‚° ë©”ì„œë“œë“¤ - null ì•ˆì „ì„± ë³´ì¥
  int? parseTimeFrameMinutes(String timeFrame) => 
      SurgeTimeFrame.parseMinutes(timeFrame);

  DateTime? calculateNextResetTime(String timeFrame, DateTime startTime) {
    final minutes = parseTimeFrameMinutes(timeFrame);
    return minutes != null ? startTime.add(Duration(minutes: minutes)) : null;
  }

  Duration? getTimeUntilReset(String timeFrame, DateTime startTime) {
    final nextReset = calculateNextResetTime(timeFrame, startTime);
    if (nextReset == null) return null;
    
    final remaining = nextReset.difference(DateTime.now());
    return remaining.isNegative ? Duration.zero : remaining;
  }

  /// ğŸ¯ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ - í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼
  String formatChangePercent(double changePercent) {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }

  String formatPrice(double price) {
    return price >= 1000000 ? '${(price / 1000000).toStringAsFixed(1)}M'
         : price >= 1000 ? '${(price / 1000).toStringAsFixed(1)}K'
         : price.toStringAsFixed(0);
  }

  /// ğŸ”¥ ê³ ì„±ëŠ¥ ìˆœìœ„ ê³„ì‚°: Map.fromIterables ì‚¬ìš©
  Map<String, int> calculateSurgeRanks(List<Surge> surges) {
    final markets = surges.map((s) => s.market);
    final ranks = Iterable.generate(surges.length, (i) => i + 1);
    return Map.fromIterables(markets, ranks);
  }

  /// ğŸ¯ ì§„í–‰ë¥  ê³„ì‚° - clampìœ¼ë¡œ ì•ˆì „ì„± ë³´ì¥
  double calculateTimeFrameProgress(String timeFrame, DateTime startTime) {
    final minutes = parseTimeFrameMinutes(timeFrame);
    if (minutes == null) return 0.0;
    
    final elapsed = DateTime.now().difference(startTime);
    final progress = elapsed.inMilliseconds / Duration(minutes: minutes).inMilliseconds;
    return progress.clamp(0.0, 1.0);
  }

  /// ğŸ”¥ ì™„ì „í•œ í•¨ìˆ˜í˜•: í†µê³„ ê³„ì‚° ìµœì í™”
  SurgeStatistics calculateSurgeStatistics(List<Surge> surges) {
    if (surges.isEmpty) return SurgeStatistics.empty();

    final changes = surges.map((s) => s.changePercent).toList();
    final risingCount = surges.where((s) => s.isRising).length;
    final fallingCount = surges.where((s) => s.isFalling).length;
    
    return SurgeStatistics(
      totalCount: surges.length,
      risingCount: risingCount,
      fallingCount: fallingCount,
      averageChange: changes.reduce((a, b) => a + b) / changes.length,
      maxRise: changes.reduce((a, b) => a > b ? a : b),
      maxFall: changes.reduce((a, b) => a < b ? a : b),
    );
  }

  /// ğŸ”¥ enum ê¸°ë°˜ ë¶„ë¥˜: íƒ€ì… ì•ˆì „ì„± + ì„±ëŠ¥ ìµœì í™”
  Map<SurgeRangeType, List<Surge>> classifySurgesByRange(List<Surge> surges) {
    final classification = <SurgeRangeType, List<Surge>>{};
    
    // ëª¨ë“  ë²”ìœ„ íƒ€ì… ì´ˆê¸°í™”
    for (final type in SurgeRangeType.values) {
      classification[type] = <Surge>[];
    }
    
    // í•œ ë²ˆì˜ ìˆœíšŒë¡œ ëª¨ë“  ë¶„ë¥˜ ì™„ë£Œ
    for (final surge in surges) {
      final rangeType = SurgeRangeType.fromPercent(surge.changePercent);
      classification[rangeType]!.add(surge);
    }
    
    return classification;
  }
}

/// ğŸ”¥ íƒ€ì… ì•ˆì „ì„±: PriceData ì¸í„°í˜ì´ìŠ¤ ì •ì˜
/// dynamic ì™„ì „ ì œê±°ë¥¼ ìœ„í•œ ì¶”ìƒí™”
abstract class PriceData {
  double get basePrice;
  double get currentPrice;
  double get changePercent;
}

/// ğŸ”¥ ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ enumí™”: TimeFrame ê´€ë¦¬
enum SurgeTimeFrame {
  min1(1, '1ë¶„'),
  min5(5, '5ë¶„'),
  min15(15, '15ë¶„'),
  min30(30, '30ë¶„'),
  min60(60, '1ì‹œê°„'),
  hour2(120, '2ì‹œê°„'),
  hour4(240, '4ì‹œê°„'),
  hour8(480, '8ì‹œê°„'),
  hour12(720, '12ì‹œê°„'),
  day1(1440, '1ì¼');

  const SurgeTimeFrame(this.minutes, this.displayName);
  final int minutes;
  final String displayName;
  
  String get key => '${minutes}m';
  
  static bool isValid(String timeFrame) => 
      values.any((tf) => tf.key == timeFrame);
  
  static List<String> allActive() => 
      AppConfig.timeFrames.map((tf) => '${tf}m').toList();
  
  static String getDisplayName(String timeFrame) {
    final tf = values.where((tf) => tf.key == timeFrame).firstOrNull;
    return tf?.displayName ?? timeFrame;
  }
  
  static int? parseMinutes(String timeFrame) => 
      int.tryParse(timeFrame.replaceAll('m', ''));
}

/// ğŸ”¥ ë³€ë™ë¥  ë²”ìœ„ enum: íƒ€ì… ì•ˆì „ì„± + ì„±ëŠ¥ ìµœì í™”
enum SurgeRangeType {
  extremeRise(10, double.infinity, 'extreme_rise'),
  strongRise(5, 10, 'strong_rise'),
  moderateRise(2, 5, 'moderate_rise'),
  slightRise(0, 2, 'slight_rise'),
  slightFall(-2, 0, 'slight_fall'),
  moderateFall(-5, -2, 'moderate_fall'),
  strongFall(-10, -5, 'strong_fall'),
  extremeFall(double.negativeInfinity, -10, 'extreme_fall');

  const SurgeRangeType(this.minPercent, this.maxPercent, this.key);
  final double minPercent;
  final double maxPercent;
  final String key;
  
  static SurgeRangeType fromPercent(double percent) {
    return values.firstWhere(
      (type) => percent >= type.minPercent && percent < type.maxPercent,
      orElse: () => percent >= 0 ? slightRise : slightFall,
    );
  }
}

/// ğŸ”¥ í†µê³„ ë°ì´í„° ë¶ˆë³€ í´ë˜ìŠ¤: íƒ€ì… ì•ˆì „ì„±
@immutable
class SurgeStatistics {
  final int totalCount;
  final int risingCount;
  final int fallingCount;
  final double averageChange;
  final double maxRise;
  final double maxFall;

  const SurgeStatistics({
    required this.totalCount,
    required this.risingCount,
    required this.fallingCount,
    required this.averageChange,
    required this.maxRise,
    required this.maxFall,
  });

  factory SurgeStatistics.empty() => const SurgeStatistics(
    totalCount: 0,
    risingCount: 0,
    fallingCount: 0,
    averageChange: 0.0,
    maxRise: 0.0,
    maxFall: 0.0,
  );
}\n\n// ====== lib/domain/entities/surge.dart ======\n
// lib/domain/entities/surge.dart
import 'package:equatable/equatable.dart';
import '../../core/config/app_config.dart';

/// ìˆœìˆ˜ ë„ë©”ì¸ ëª¨ë¸: ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
class Surge extends Equatable {
  /// ì‹œì¥ ì½”ë“œ (ì˜ˆ: "KRW-BTC")
  final String market;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ë³€ë™ë¥  (í¼ì„¼íŠ¸ ê¸°ì¤€)
  final double changePercent;
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ ê°€ê²©
  final double basePrice;
  
  /// í˜„ì¬ ê°€ê²©
  final double currentPrice;
  
  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int lastUpdatedMs;
  
  /// ì‹œê°„ëŒ€ (ì˜ˆ: "1m", "5m", "15m")
  final String timeFrame;
  
  /// í•´ë‹¹ ì‹œê°„ëŒ€ ì‹œì‘ ì‹œê°„ (UTC ë°€ë¦¬ì´ˆ)
  final int timeFrameStartMs;

  const Surge({
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.lastUpdatedMs,
    required this.timeFrame,
    required this.timeFrameStartMs,
  });

  @override
  List<Object?> get props => [
    market,
    changePercent,
    basePrice,
    currentPrice,
    lastUpdatedMs,
    timeFrame,
    timeFrameStartMs,
  ];

  /// ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ DateTime ë³€í™˜
  DateTime get lastUpdated => DateTime.fromMillisecondsSinceEpoch(lastUpdatedMs);
  
  /// ì‹œê°„ëŒ€ ì‹œì‘ DateTime ë³€í™˜
  DateTime get timeFrameStart => DateTime.fromMillisecondsSinceEpoch(timeFrameStartMs);
  
  /// ì‹œê°„ëŒ€ ì¢…ë£Œ ì˜ˆì • ì‹œê°„
  DateTime get timeFrameEnd {
    final duration = _getTimeFrameDuration();
    return timeFrameStart.add(duration);
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ (ì´ˆ)
  int get remainingSeconds {
    final now = DateTime.now();
    final remaining = timeFrameEnd.difference(now).inSeconds;
    return remaining > 0 ? remaining : 0;
  }
  
  /// í˜„ì¬ ì‹œê°„ëŒ€ ë‚¨ì€ ì‹œê°„ í¬ë§· (ì˜ˆ: "3:42", "12:18")
  String get remainingTimeFormatted {
    final remaining = remainingSeconds;
    if (remaining <= 0) return "00:00";
    
    final hours = remaining ~/ 3600;
    final minutes = (remaining % 3600) ~/ 60;
    final seconds = remaining % 60;
    
    if (hours > 0) {
      return "${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    } else {
      return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}";
    }
  }
  
  /// ì‹œê°„ëŒ€ë³„ Duration ê³„ì‚° (AppConfig.timeFrames í™œìš©)
  Duration _getTimeFrameDuration() {
    // timeFrameì—ì„œ ë¶„ ë‹¨ìœ„ ì¶”ì¶œ ("15m" â†’ 15)
    final minutes = int.tryParse(timeFrame.replaceAll('m', ''));
    if (minutes != null && AppConfig.timeFrames.contains(minutes)) {
      return Duration(minutes: minutes);
    }
    return const Duration(minutes: 15); // ê¸°ë³¸ê°’
  }
  
  /// ë³€ë™ì´ ìœ ì˜ë¯¸í•œì§€ ì²´í¬ (0ì´ ì•„ë‹˜)
  bool get hasChange => changePercent != 0;
  
  /// ê¸‰ë“±ì¸ì§€ ì²´í¬ (ì–‘ìˆ˜)
  bool get isRising => changePercent > 0;
  
  /// ê¸‰ë½ì¸ì§€ ì²´í¬ (ìŒìˆ˜)
  bool get isFalling => changePercent < 0;
  
  /// ë³€ë™ë¥  ì ˆëŒ“ê°’
  double get absChangePercent => changePercent.abs();
  
  /// ì½”ì¸ í‹°ì»¤ë§Œ ì¶”ì¶œ (KRW- ì œê±°)
  String get ticker => market.replaceFirst('KRW-', '');
  
  /// ë³€ë™ë¥  í¬ë§·íŒ… (ì˜ˆ: "+12.34%", "-5.67%")
  String get formattedChangePercent {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }
  
  /// ë³µì‚¬ë³¸ ìƒì„± (ë¶ˆë³€ì„± ìœ ì§€)
  Surge copyWith({
    String? market,
    double? changePercent,
    double? basePrice,
    double? currentPrice,
    int? lastUpdatedMs,
    String? timeFrame,
    int? timeFrameStartMs,
  }) {
    return Surge(
      market: market ?? this.market,
      changePercent: changePercent ?? this.changePercent,
      basePrice: basePrice ?? this.basePrice,
      currentPrice: currentPrice ?? this.currentPrice,
      lastUpdatedMs: lastUpdatedMs ?? this.lastUpdatedMs,
      timeFrame: timeFrame ?? this.timeFrame,
      timeFrameStartMs: timeFrameStartMs ?? this.timeFrameStartMs,
    );
  }
}\n\n// ====== lib/presentation/controllers/surge_controller.dart ======\n
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/surge_provider.dart';
import '../../domain/entities/surge.dart';
import '../../shared/utils/rank_tracker.dart';
import '../../shared/utils/rank_hot_mixin.dart';

/// ğŸ¯ ì™„ì „ ìˆ˜ì •ëœ SurgeController - TimeFrame enum ê¸°ë°˜ + íƒ€ì´ë¨¸ ë™ê¸°í™”
class SurgeController extends StateNotifier<SurgeControllerState> with RankHotMixin {
  final Ref _ref;
  
  // âœ… ìˆœìœ„ ì¶”ì ê¸° (ë¸”ë§í¬ìš©)
  final RankTracker _rankTracker = RankTracker();
  
  // âœ… ì‹œê°„ëŒ€ë³„ ë¸”ë§í¬ ìƒíƒœ ê´€ë¦¬ (TimeFrame enum ê¸°ë°˜)
  final Map<TimeFrame, Map<String, bool>> _blinkStatesByTimeFrame = {};
  
  // âœ… Provider êµ¬ë… ê´€ë¦¬
  final List<ProviderSubscription> _subscriptions = [];

  SurgeController(this._ref) : super(const SurgeControllerState()) {
    _initializeAllStates();
    _initializeDataSubscription();
  }

  /// âœ… ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
  void _initializeAllStates() {
    clearAllHot();
    _rankTracker.clearAll();
    _blinkStatesByTimeFrame.clear();
  }

  /// ğŸ”¥ í†µí•© ë°ì´í„° êµ¬ë… ì´ˆê¸°í™”
  void _initializeDataSubscription() {
    final subscription = _ref.listen(
      surgeDataProvider,
      (previous, next) {
        next.when(
          data: (event) {
            // ğŸš€ ë°ì´í„° ì²˜ë¦¬ (ì´ì¤‘ ì •ë ¬ ì œê±°)
            _processSurgeData(event.surges);
            
            // ğŸ”¥ ë¦¬ì…‹ ì •ë³´ ì²˜ë¦¬ (ìƒˆë¡œìš´ SurgeEvent êµ¬ì¡°)
            if (event.isReset) {
              clearTimeFrameHot(event.timeFrame.key);
              _clearTimeFrameBlinkStates(event.timeFrame);
            }
          },
          loading: () => state = state.copyWith(isLoading: true),
          error: (error, _) => state = state.copyWith(
            errorMessage: error.toString(),
            isLoading: false,
          ),
        );
      },
    );
    _subscriptions.add(subscription);
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ë°ì´í„° ì²˜ë¦¬ - ì´ì¤‘ ì •ë ¬ ì œê±°
  void _processSurgeData(List<Surge> surges) {
    // âœ… Providerì—ì„œ ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„°ë¥¼ í•„í„°ë§ + ì œí•œë§Œ ì ìš©
    final processedSurges = _applyFilterAndLimit(surges);
    
    // âœ… ëª¨ë“  ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚°
    _calculateAllStates(processedSurges);
    
    // âœ… ìƒíƒœ ì—…ë°ì´íŠ¸
    state = state.copyWith(
      surges: processedSurges,
      isLoading: false,
      errorMessage: null,
    );
  }

  /// âœ… í•„í„°ë§ + ì œí•œë§Œ ì ìš© (ì •ë ¬ì€ Providerì—ì„œ ì™„ë£Œ)
  List<Surge> _applyFilterAndLimit(List<Surge> surges) {
    // 1) í•„í„° íƒ€ì…ì— ë”°ë¥¸ í•„í„°ë§ë§Œ
    List<Surge> filteredData = _applyFilter(surges, state.filterType);
    
    // 2) í•„í„° íƒ€ì…ì— ë”°ë¥¸ ì¬ì •ë ¬ (Provider ì •ë ¬ê³¼ ë‹¤ë¥¸ ê²½ìš°ë§Œ)
    if (state.filterType == SurgeFilterType.fallingOnly) {
      // í•˜ë½ë§Œ: í•˜ë½ í° ìˆœì„œ (ì˜¤ë¦„ì°¨ìˆœ) - Providerì™€ ë‹¤ë¦„
      filteredData.sort((a, b) => a.changePercent.compareTo(b.changePercent));
    }
    // ì „ì²´/ìƒìŠ¹: Providerì—ì„œ ì´ë¯¸ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ë˜ì–´ ìˆìŒ
    
    // 3) ì œí•œë§Œ ì ìš©
    final int limit = state.isTop100 ? 100 : 50;
    return filteredData.take(limit).toList();
  }

  /// âœ… í•„í„° íƒ€ì… ì ìš© (Providerì—ì„œ ë°›ì€ ì›ë³¸ ë°ì´í„° ê¸°ì¤€)
  List<Surge> _applyFilter(List<Surge> surgeData, SurgeFilterType filterType) {
    switch (filterType) {
      case SurgeFilterType.all:
        return surgeData.where((s) => s.hasChange).toList();
      case SurgeFilterType.risingOnly:
        return surgeData.where((s) => s.isRising).toList();
      case SurgeFilterType.fallingOnly:
        return surgeData.where((s) => s.isFalling).toList();
    }
  }

  /// âœ… ëª¨ë“  ì•„ì´í…œì˜ ìƒíƒœ ë¯¸ë¦¬ ê³„ì‚° - TimeFrame enum ê¸°ë°˜
  void _calculateAllStates(List<Surge> processedSurges) {
    final currentTimeFrame = this.currentTimeFrame;
    final currentTimeFrameKey = currentTimeFrame.key; // TimeFrame â†’ String
    
    // âœ… ì‹œê°„ëŒ€ ì´ˆê¸°í™” (String key ì‚¬ìš© - Mixin í˜¸í™˜)
    initializeTimeFrame(currentTimeFrameKey);
    _rankTracker.initializeTimeFrame(currentTimeFrameKey);
    
    // âœ… í˜„ì¬ ì‹œê°„ëŒ€ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum ì‚¬ìš©)
    _initializeTimeFrameBlinkStates(currentTimeFrame);
    
    for (int i = 0; i < processedSurges.length; i++) {
      final surge = processedSurges[i];
      final market = surge.market;
      final currentRank = i + 1;
      
      // âœ… HOT ìƒíƒœëŠ” Mixinì—ì„œ ì§ì ‘ ê´€ë¦¬ (String key ì‚¬ìš©)
      checkIfHot(
        key: market,
        currentRank: currentRank,
        timeFrame: currentTimeFrameKey,
        menuType: 'surge',
      );
      
      // âœ… ë¸”ë§í¬ ìƒíƒœ ê³„ì‚° (Surge ì „ìš© ë©”ì„œë“œ ì‚¬ìš©)
      final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame]!;
      
      // ê¸‰ë“± ì²´í¬ (ìˆœìœ„ ìƒìŠ¹ + ì‹¤ì œ ìˆ˜ì¹˜ ê°œì„ )
      final isRankUp = _rankTracker.checkRankChangeWithValue(
        key: market,
        currentRank: currentRank,
        currentValue: surge.changePercent,
        timeFrame: currentTimeFrameKey,
      );
      
      // ê¸‰ë½ ì²´í¬ (ìˆœìœ„ í•˜ë½ + ì‹¤ì œ ìˆ˜ì¹˜ ì•…í™”)  
      final isRankDown = _rankTracker.checkRankDropWithValue(
        key: market,
        currentRank: currentRank,
        currentValue: surge.changePercent,
        timeFrame: currentTimeFrameKey,
      );
      
      // ì˜ë¯¸ìˆëŠ” ë³€í™”ê°€ ìˆì„ ë•Œë§Œ ë¸”ë§í¬
      blinkStates[market] = isRankUp || isRankDown;
    }
  }

  /// âœ… ì‹œê°„ëŒ€ë³„ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum)
  void _initializeTimeFrameBlinkStates(TimeFrame timeFrame) {
    if (!_blinkStatesByTimeFrame.containsKey(timeFrame)) {
      _blinkStatesByTimeFrame[timeFrame] = <String, bool>{};
    }
  }

  /// âœ… íŠ¹ì • ì‹œê°„ëŒ€ ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” (TimeFrame enum)
  void _clearTimeFrameBlinkStates(TimeFrame timeFrame) {
    _blinkStatesByTimeFrame[timeFrame]?.clear();
  }

  /// âœ… Top 50/100 í† ê¸€ - Provider êµ¬ë… ì´ìŠˆ í•´ê²°
  void toggleTopLimit() {
    state = state.copyWith(isTop100: !state.isTop100);
    
    // âœ… í˜„ì¬ ë°ì´í„°ë¡œ ì¬ì²˜ë¦¬ (read + whenData ë¬¸ì œ í•´ê²°)
    if (state.surges.isNotEmpty) {
      final currentState = _ref.read(surgeDataProvider).value;
      if (currentState != null) {
        _processSurgeData(currentState.surges);
      }
    }
  }

  /// âœ… í•„í„° íƒ€ì… ë³€ê²½ - Provider êµ¬ë… ì´ìŠˆ í•´ê²°
  void setFilterType(SurgeFilterType filterType) {
    state = state.copyWith(filterType: filterType);
    
    // âœ… í˜„ì¬ ë°ì´í„°ë¡œ ì¬ì²˜ë¦¬
    if (state.surges.isNotEmpty) {
      final currentState = _ref.read(surgeDataProvider).value;
      if (currentState != null) {
        _processSurgeData(currentState.surges);
      }
    }
  }

  /// ğŸ”¥ ì‹œê°„ëŒ€ ë³€ê²½ - timeFrameControllerProviderë¡œ ìˆ˜ì •
  void setTimeFrame(TimeFrame timeFrame) {
    _ref.read(timeFrameControllerProvider).setTimeFrame(timeFrame);
    // ğŸ¯ ìƒíƒœ ì´ˆê¸°í™” ì œê±° - ê° ì‹œê°„ëŒ€ê°€ ë…ë¦½ì ìœ¼ë¡œ ìœ ì§€ë¨
  }

  /// ğŸ”¥ ì‹œê°„ëŒ€ ë³€ê²½ (ì¸ë±ìŠ¤ ê¸°ë°˜) - í˜¸í™˜ì„± ìœ ì§€
  void setTimeFrameByIndex(int index) {
    final availableTimeFrames = TimeFrame.fromAppConfig();
    if (index >= 0 && index < availableTimeFrames.length) {
      setTimeFrame(availableTimeFrames[index]);
    }
  }

  /// âœ… í˜„ì¬ í‘œì‹œ ê°œìˆ˜
  int get currentLimit => state.isTop100 ? 100 : 50;
  
  /// âœ… í˜„ì¬ í‘œì‹œ ëª¨ë“œ ì´ë¦„
  String get currentLimitName => state.isTop100 ? 'Top 100' : 'Top 50';

  /// âœ… í˜„ì¬ í•„í„° íƒ€ì… ì´ë¦„
  String get currentFilterName {
    switch (state.filterType) {
      case SurgeFilterType.all:
        return 'ì „ì²´';
      case SurgeFilterType.risingOnly:
        return 'ìƒìŠ¹';
      case SurgeFilterType.fallingOnly:
        return 'í•˜ë½';
    }
  }

  /// âœ… HOT ìƒíƒœ ì¡°íšŒ (String key ì‚¬ìš© - Mixin í˜¸í™˜)
  bool isHot(String market) {
    final hotItems = getHotItems(currentTimeFrame.key);
    return hotItems.contains(market);
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì¡°íšŒ - TimeFrame enum ê¸°ë°˜
  bool shouldBlink(String market) {
    final currentTimeFrame = this.currentTimeFrame;
    final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame];
    return blinkStates?[market] ?? false;
  }

  /// âœ… ë¸”ë§í¬ ìƒíƒœ ì´ˆê¸°í™” - ê°•ì œ notify ë¬¸ì œ í•´ê²°
  void clearBlinkState(String market) {
    final currentTimeFrame = this.currentTimeFrame;
    final blinkStates = _blinkStatesByTimeFrame[currentTimeFrame];
    if (blinkStates != null) {
      blinkStates[market] = false;
      // âœ… ì‹¤ì œ ë³€í™”ê°€ ìˆì„ ë•Œë§Œ notify (ë¶ˆí•„ìš”í•œ copyWith ì œê±°)
    }
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´íŠ¸ ê³„ì‚°
  Map<String, int> getSurgeCount() {
    final risingCount = state.surges.where((s) => s.isRising).length;
    final fallingCount = state.surges.where((s) => s.isFalling).length;
    
    return {
      'rising': risingCount,
      'falling': fallingCount,
    };
  }

  /// âœ… TimeFrame ê´€ë ¨ ë©”ì„œë“œë“¤ - timeFrameControllerProviderë¡œ ìˆ˜ì •
  TimeFrame get currentTimeFrame => _ref.read(timeFrameControllerProvider).currentTimeFrame;
  
  int get currentIndex => _ref.read(timeFrameControllerProvider).currentIndex;
  
  List<TimeFrame> get availableTimeFrames => _ref.read(timeFrameControllerProvider).availableTimeFrames;

  String getTimeFrameName(TimeFrame timeFrame) {
    return _ref.read(timeFrameControllerProvider).getTimeFrameName(timeFrame);
  }

  void resetCurrentTimeFrame() {
    _ref.read(timeFrameControllerProvider).resetCurrentTimeFrame();
  }

  void resetAllTimeFrames() {
    _ref.read(timeFrameControllerProvider).resetAllTimeFrames();
  }

  /// ğŸ”¥ ì™„ë²½í•œ íƒ€ì´ë¨¸ ë™ê¸°í™” - timeFrameControllerProvider ì‚¬ìš©
  DateTime? getNextResetTime() {
    return _ref.read(timeFrameControllerProvider).getNextResetTime();
  }

  /// âœ… ë””ë²„ê¹…ìš© ë©”ì„œë“œë“¤
  Map<String, int> getBlinkDebugInfo() {
    return _rankTracker.getDebugInfo();
  }

  /// âœ… ë©”ëª¨ë¦¬ ì •ë¦¬
  void cleanupExpiredStates() {
    cleanupExpiredHotStates();
    _cleanupOldBlinkStates();
  }

  /// âœ… ì˜¤ë˜ëœ ë¸”ë§í¬ ìƒíƒœ ì •ë¦¬ (TimeFrame enum ê¸°ë°˜)
  void _cleanupOldBlinkStates() {
    final currentTimeFrame = this.currentTimeFrame;
    final availableTimeFrames = this.availableTimeFrames.toSet();
    
    _blinkStatesByTimeFrame.removeWhere((timeFrame, _) => 
      timeFrame != currentTimeFrame && !availableTimeFrames.contains(timeFrame)
    );
  }

  /// âœ… ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  @override
  void dispose() {
    // Provider êµ¬ë… í•´ì œ
    for (final subscription in _subscriptions) {
      subscription.close();
    }
    _subscriptions.clear();
    
    // âœ… ëª¨ë“  ë¦¬ì†ŒìŠ¤ ì •ë¦¬
    disposeHot();
    _rankTracker.dispose();
    _blinkStatesByTimeFrame.clear();
    
    super.dispose();
  }
}

/// âœ… ìƒíƒœ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class SurgeControllerState {
  final List<Surge> surges;           // ì •ë ¬/í•„í„°ë§ëœ ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°
  final bool isTop100;               // Top 50/100 ëª¨ë“œ
  final SurgeFilterType filterType;  // í•„í„° íƒ€ì…
  final bool isLoading;              // ë¡œë”© ìƒíƒœ
  final String? errorMessage;        // ì—ëŸ¬ ë©”ì‹œì§€

  const SurgeControllerState({
    this.surges = const [],
    this.isTop100 = false,
    this.filterType = SurgeFilterType.all,
    this.isLoading = false,
    this.errorMessage,
  });

  SurgeControllerState copyWith({
    List<Surge>? surges,
    bool? isTop100,
    SurgeFilterType? filterType,
    bool? isLoading,
    String? errorMessage,
  }) {
    return SurgeControllerState(
      surges: surges ?? this.surges,
      isTop100: isTop100 ?? this.isTop100,
      filterType: filterType ?? this.filterType,
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
    );
  }
}

/// Surge í•„í„° íƒ€ì… enum
enum SurgeFilterType {
  all,        // ì „ì²´
  risingOnly, // ìƒìŠ¹ë§Œ
  fallingOnly // í•˜ë½ë§Œ
}

/// Provider ì„ ì–¸ - UIìš© SurgeController
final surgeControllerProvider = StateNotifierProvider<SurgeController, SurgeControllerState>(
  (ref) => SurgeController(ref),
);\n\n// ====== lib/presentation/pages/surge_page.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/config/app_config.dart';
import '../../core/di/app_providers.dart';
import '../../core/di/surge_provider.dart';
import '../../shared/widgets/slider_widget.dart';
import '../controllers/surge_controller.dart';
import '../widgets/surge_tile.dart';

class SurgePage extends ConsumerWidget {
  final ScrollController scrollController;

  const SurgePage({
    Key? key,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // âœ… Controller state watch (ë°ì´í„° + UI ìƒíƒœ)
    final state = ref.watch(surgeControllerProvider);
    final controller = ref.read(surgeControllerProvider.notifier);
    
    // âœ… TimeFrame ê´€ë ¨ - ì§ì ‘ watchë¡œ ë°˜ì‘ì„± í™•ë³´
    final currentTimeFrame = ref.watch(selectedTimeFrameProvider);
    final availableTimeFrames = TimeFrame.fromAppConfig();
    final currentIndex = availableTimeFrames.indexOf(currentTimeFrame);
    final timeFrameController = ref.read(timeFrameControllerProvider);
    
    // âœ… UI ì„¤ì •
    final sliderPosition = ref.watch(appSettingsProvider).sliderPosition;
    
    // âœ… ê³µí†µ ìŠ¬ë¼ì´ë” ìœ„ì ¯ - Surge ê³ ìœ ì˜ ë³µì¡í•œ 5ë¶„í•  êµ¬ì¡°
    final sliderWidget = CommonSliderWidget(
      leftText: 'ì‹œê°„ëŒ€: ${currentTimeFrame.displayName}',
      sliderValue: currentIndex.toDouble(),
      sliderMin: 0.0,
      sliderMax: (availableTimeFrames.length - 1).toDouble(),
      sliderDivisions: availableTimeFrames.length - 1,
      sliderLabel: currentTimeFrame.displayName,
      onSliderChanged: (value) {
        final newIndex = value.round();
        if (newIndex >= 0 && newIndex < availableTimeFrames.length) {
          controller.setTimeFrame(availableTimeFrames[newIndex]); // âœ… ì§ì ‘ í˜¸ì¶œë¡œ ì¦‰ì‹œ ë°˜ì‘
        }
      },
      // ğŸ”¥ Surge ê³ ìœ : ë³µì¡í•œ 5ë¶„í•  ë ˆì´ì•„ì›ƒ (12-6-10-10-11)
      extraWidgets: [
        // í•„í„° í† ê¸€ ë²„íŠ¼ (6/49)
        Expanded(
          flex: 6,
          child: Center(
            child: CommonToggleButton(
              text: controller.currentFilterName,
              isActive: state.filterType != SurgeFilterType.all,
              onTap: () {
                // í•„í„° ìˆœí™˜: ì „ì²´ â†’ ê¸‰ë“±ë§Œ â†’ ê¸‰ë½ë§Œ â†’ ì „ì²´
                SurgeFilterType nextFilter;
                switch (state.filterType) {
                  case SurgeFilterType.all:
                    nextFilter = SurgeFilterType.risingOnly;
                    break;
                  case SurgeFilterType.risingOnly:
                    nextFilter = SurgeFilterType.fallingOnly;
                    break;
                  case SurgeFilterType.fallingOnly:
                    nextFilter = SurgeFilterType.all;
                    break;
                }
                controller.setFilterType(nextFilter);
              },
              activeColor: Colors.blue,
              borderColor: Colors.blue,
              fontSize: 10,
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
            ),
          ),
        ),
        
        // Top 50/100 í† ê¸€ ë²„íŠ¼ (10/49)
        Expanded(
          flex: 10,
          child: Center(
            child: CommonToggleButton(
              text: controller.currentLimitName,
              isActive: state.isTop100,
              onTap: () => controller.toggleTopLimit(),
              fontSize: 10,
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6),
            ),
          ),
        ),
        
        // ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° (10/49)
        Expanded(
          flex: 10,
          child: Center(
            child: _buildSurgeCounter(controller, state),
          ),
        ),
      ],
      rightWidget: CommonCountdownWidget(
        nextResetTime: timeFrameController.getNextResetTime(), // ğŸ”¥ ì™„ë²½í•œ íƒ€ì´ë¨¸ ë™ê¸°í™”
      ),
    );

    return PrimaryScrollController(
      controller: scrollController,
      child: Column(
        children: [
          if (sliderPosition == SliderPosition.top) sliderWidget,
          Expanded(child: _buildSurgeList(state, controller, currentTimeFrame, context)),
          if (sliderPosition == SliderPosition.bottom) sliderWidget,
        ],
      ),
    );
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ì¹´ìš´í„° ìœ„ì ¯
  Widget _buildSurgeCounter(SurgeController controller, SurgeControllerState state) {
    if (state.surges.isEmpty) {
      return Container(
        height: 29,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: Colors.grey.withValues(alpha: 0.1),
        ),
        child: const Center(
          child: Text(
            'ë¡œë”©ì¤‘',
            style: TextStyle(fontSize: 8, color: Colors.grey),
          ),
        ),
      );
    }

    final count = controller.getSurgeCount();
    final risingCount = count['rising'] ?? 0;
    final fallingCount = count['falling'] ?? 0;
    
    return Container(
      height: 29,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.grey.withValues(alpha: 0.3), width: 1),
      ),
      child: Row(
        children: [
          // ì¢Œì¸¡: ê¸‰ë“± ì¹´ìš´í„° (ì´ˆë¡ ë°°ê²½)
          Expanded(
            child: Container(
              decoration: const BoxDecoration(
                color: Colors.green,
                borderRadius: BorderRadius.only(
                  topLeft: Radius.circular(11),
                  bottomLeft: Radius.circular(11),
                ),
              ),
              child: Center(
                child: Text(
                  '$risingCount',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
          // ìš°ì¸¡: ê¸‰ë½ ì¹´ìš´í„° (ë¹¨ê°„ ë°°ê²½)
          Expanded(
            child: Container(
              decoration: const BoxDecoration(
                color: Colors.red,
                borderRadius: BorderRadius.only(
                  topRight: Radius.circular(11),
                  bottomRight: Radius.circular(11),
                ),
              ),
              child: Center(
                child: Text(
                  '$fallingCount',
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// âœ… ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ (Controller state ê¸°ë°˜)
  Widget _buildSurgeList(
    SurgeControllerState state,
    SurgeController controller,
    TimeFrame currentTimeFrame,
    BuildContext context,
  ) {
    // âœ… ë¡œë”© ìƒíƒœ
    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    // âœ… ì—ëŸ¬ ìƒíƒœ
    if (state.errorMessage != null) {
      return Center(child: Text('ê¸‰ë“±/ê¸‰ë½ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${state.errorMessage}'));
    }

    // âœ… ë¹ˆ ë°ì´í„°
    if (state.surges.isEmpty) {
      return Center(
        child: Text(
          'ê¸‰ë“±/ê¸‰ë½ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\n(ì‹œê°„ëŒ€: ${currentTimeFrame.displayName})',
          textAlign: TextAlign.center,
          style: TextStyle(color: Theme.of(context).hintColor, fontSize: 16),
        ),
      );
    }

    // âœ… ê¸‰ë“±/ê¸‰ë½ ë¦¬ìŠ¤íŠ¸ (ì´ë¯¸ ì •ë ¬/í•„í„°ëœ ë°ì´í„° ì‚¬ìš©)
    return CommonScrollableList(
      scrollController: scrollController,
      itemCount: state.surges.length,
      itemBuilder: (_, i) {
        final surge = state.surges[i];
        final rank = i + 1;
        
        return SurgeTile(
          market: surge.market,
          changePercent: surge.changePercent,
          basePrice: surge.basePrice,
          currentPrice: surge.currentPrice,
          rank: rank,
          // âœ… ì•ˆì „í•œ ìƒíƒœ ì¡°íšŒ
          isHot: controller.isHot(surge.market),
          shouldBlink: controller.shouldBlink(surge.market),
        );
      },
    );
  }
}\n\n// ====== lib/presentation/widgets/surge_tile.dart ======\n
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../shared/widgets/coin_logo_provider.dart';
import '../../shared/utils/tile_common.dart';
import '../../shared/utils/blink_animation_mixin.dart';
import '../../shared/utils/amount_formatter.dart';
import '../controllers/surge_controller.dart';

class SurgeTile extends ConsumerStatefulWidget {
  final String market;
  final double changePercent;
  final double basePrice;
  final double currentPrice;
  final int rank;
  final bool isHot;        // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  final bool shouldBlink;  // âœ… Controllerì—ì„œ ê³„ì‚°ëœ ê°’
  
  const SurgeTile({
    Key? key, 
    required this.market,
    required this.changePercent,
    required this.basePrice,
    required this.currentPrice,
    required this.rank,
    required this.isHot,
    required this.shouldBlink,
  }) : super(key: key);

  @override
  ConsumerState<SurgeTile> createState() => _SurgeTileState();
}

class _SurgeTileState extends ConsumerState<SurgeTile> 
    with SingleTickerProviderStateMixin {

  late AnimationController _blinkController;
  late Animation<double> _blinkAnimation;
  bool _isBlinking = false;

  @override
  void initState() {
    super.initState();
    // âœ… ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
    _blinkController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _blinkAnimation = Tween<double>(begin: 1.0, end: 0.3).animate(
      CurvedAnimation(parent: _blinkController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(SurgeTile oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // âœ… shouldBlink props ë³€í™” ê°ì§€í•´ì„œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
    if (widget.shouldBlink && !oldWidget.shouldBlink && !_isBlinking) {
      _startBlink();
    }
  }

  @override
  void dispose() {
    _blinkController.dispose();
    super.dispose();
  }

  /// âœ… ë¸”ë§í¬ ì‹œì‘ (ì„¤ì • ì²´í¬ + Controller ìƒíƒœ ì´ˆê¸°í™”)
  void _startBlink() {
    final blinkEnabled = ref.read(appSettingsProvider).blinkEnabled;
    if (!mounted || !blinkEnabled) return;
    
    _isBlinking = true;
    _blinkController.forward().then((_) {
      if (mounted) {
        _blinkController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _isBlinking = false;
            });
            
            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ Controllerì— ìƒíƒœ ì´ˆê¸°í™” ìš”ì²­
            ref.read(surgeControllerProvider.notifier).clearBlinkState(widget.market);
          }
        });
      }
    });
  }

  // âœ… ë³€ë™ë¥  í¬ë§·íŒ…
  String _formatChangePercent(double changePercent) {
    final sign = changePercent >= 0 ? '+' : '';
    return '$sign${changePercent.toStringAsFixed(2)}%';
  }

  // âœ… ë³€ë™ë¥  í…ìŠ¤íŠ¸ ìƒ‰ìƒ
  Color _getChangeColor() {
    if (widget.changePercent > 0) {
      return Colors.green; 
    } else if (widget.changePercent < 0) {
      return Colors.red; 
    } else {
      return Colors.grey; 
    }
  }

  // âœ… ë¸”ë§í¬ ìƒ‰ìƒ (ìƒìŠ¹=ì´ˆë¡, í•˜ë½=ë¹¨ê°•)
  Color _getBlinkColor() {
    if (widget.changePercent > 0) {
      return Colors.green; // ğŸŸ¢ ìƒìŠ¹ = ì´ˆë¡ ë¸”ë§í¬
    } else {
      return Colors.red;   // ğŸ”´ í•˜ë½ = ë¹¨ê°• ë¸”ë§í¬
    }
  }
  
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final onSurface = theme.colorScheme.onSurface;
    final changeColor = _getChangeColor();
    
    // âœ… í‘œì¤€ ì¹´ë“œ ìœ„ì ¯ ìƒì„±
    Widget cardWidget = TileCommon.buildStandardCard(
      child: TileCommon.buildFlexRow(
        children: [
          // ğŸ† ìˆœìœ„ ë¶€ë¶„
          FlexChild.fixed(
            TileCommon.buildRankWidget(context, widget.rank),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ¨ ì½”ì¸ ë¡œê³  ë¶€ë¶„
          FlexChild.fixed(
            CoinLogoProvider.buildCoinLogo(
              ticker: widget.market.replaceFirst('KRW-', ''),
              radius: 16,
            ),
          ),
          
          const FlexChild.fixed(SizedBox(width: 12)),
          
          // ğŸ“± ì½”ì¸ëª… ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Flexible(
                      child: Text(
                        TileCommon.getDisplayName(ref, widget.market),
                        style: TextStyle(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.primary,
                          fontSize: 16,
                        ),
                        overflow: TextOverflow.ellipsis,
                        maxLines: 1,
                      ),
                    ),
                    const SizedBox(width: 4),
                    // ğŸ”¥ HOT ì•„ì´ì½˜
                    Consumer(
                      builder: (context, ref, child) {
                        final hotEnabled = ref.watch(appSettingsProvider).hotEnabled;
                        if (hotEnabled && widget.isHot) {
                          return TileCommon.buildHotIcon(true) ?? const SizedBox.shrink();
                        }
                        return const SizedBox.shrink();
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Text(
                  widget.market.replaceFirst('KRW-', ''),
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
            flex: 25,
          ),
          
          // ğŸš€ ë³€ë™ë¥  ë¶€ë¶„
          FlexChild.expanded(
            Column(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  _formatChangePercent(widget.changePercent),
                  style: TextStyle(
                    color: changeColor,
                    fontSize: 15,
                    fontWeight: FontWeight.w600,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                const SizedBox(height: 2),
                Text(
                  '${AmountFormatter.formatPrice(widget.currentPrice)}ì›',
                  style: TextStyle(
                    color: onSurface.withValues(alpha: 0.7),
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
            flex: 30,
          ),
        ],
      ),
    );

    // âœ… ë¸”ë§í¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
    final blinkEnabled = ref.watch(appSettingsProvider).blinkEnabled;
    
    if (blinkEnabled && (_isBlinking || widget.shouldBlink)) {
      return BlinkAnimationHelper.wrapWithBlinkEffect(
        child: cardWidget,
        shouldBlink: _isBlinking,
        blinkAnimation: _blinkAnimation,
        blinkColor: _getBlinkColor(), // âœ… ìƒìŠ¹=ì´ˆë¡, í•˜ë½=ë¹¨ê°•
      );
    }
    
    return cardWidget;
  }
}