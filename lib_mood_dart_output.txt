\n\n// ====== lib/core/di/market_mood_provider copy.dart ======\n
\n\n// ====== lib/core/di/market_mood_provider.dart ======\n
// lib/core/di/market_mood_provider.dart
// 🚀 Performance Optimized Provider - 메모이제이션, 배치처리, 선택적 무효화, 주기적 갱신 적용

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart'; // 🚀 debounceTime, distinctUntilChanged
import 'dart:async';

import '../network/api_client_coingecko.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show hiveServiceProvider;
import '../../data/datasources/market_mood_remote_ds.dart';
import '../../data/datasources/market_mood_local_ds.dart';
import '../../data/repositories/market_mood_repository_impl.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/usecases/market_mood_usecase.dart';

/// 🌐 CoinGecko API 클라이언트 Provider
final coinGeckoApiClientProvider = Provider<CoinGeckoApiClient>((ref) {
  return CoinGeckoApiClient();
});

/// 🔥 Remote DataSource Provider
final marketMoodRemoteDSProvider = Provider<MarketMoodRemoteDataSource>((ref) {
  final client = ref.read(coinGeckoApiClientProvider);
  return MarketMoodRemoteDataSource(client);
});

/// 🔥 Local DataSource Provider
final marketMoodLocalDSProvider = Provider<MarketMoodLocalDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return MarketMoodLocalDataSource(hive);
});

/// 🔥 Repository Provider
final marketMoodRepositoryProvider = Provider<MarketMoodRepositoryImpl>((ref) {
  final remoteDS = ref.read(marketMoodRemoteDSProvider);
  final localDS = ref.read(marketMoodLocalDSProvider);
  return MarketMoodRepositoryImpl(remoteDS, localDS);
});

/// 🔥 UseCase Provider
final marketMoodUsecaseProvider = Provider<MarketMoodUsecase>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  return MarketMoodUsecase(repository);
});

/// 🚀 메모이제이션된 환율 Provider - 캐시 유지 (TTL 필요 시 autoDispose로 변경)
final exchangeRateProvider = FutureProvider.autoDispose<double>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);
  try {
    final rate = await usecase.getExchangeRate();
    log.d('환율 조회 성공: $rate (캐시됨)');
    return rate;
  } catch (e, st) {
    log.w('환율 조회 실패, 기본값 1400 사용: $e', e, st);
    return 1400.0;
  }
});

/// 🚀 최적화된 마켓 데이터 스트림 - distinct + debounceTime 적용
final marketMoodProvider = StreamProvider<MarketMoodData>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);

  ref.onDispose(repository.dispose);

  return repository
      .getMarketDataStream()
      .distinct((prev, next) => prev.totalVolumeUsd == next.totalVolumeUsd)
      .debounceTime(const Duration(milliseconds: 100));
});

/// 🚀 통합 계산 Provider - 주기적 갱신 및 포그라운드 복귀 시 자동 invalidate 적용
final marketMoodComputedDataProvider = FutureProvider.autoDispose<MarketMoodComputedData>((ref) async {
  // 1) autoDispose 비활성화 링크 (keepAlive)
  final link = ref.keepAlive();

  // 2) 15분마다 재계산
  final timer = Timer.periodic(const Duration(minutes: 15), (_) {
    ref.invalidateSelf();
  });

  // 3) 앱 복귀 시 재계산
  ref.onResume(() {
    ref.invalidateSelf();
  });

  // 4) 종료 시 정리
  ref.onDispose(() {
    timer.cancel();
    link.close();
  });

  // 기존 로직
  final moodAsync = ref.watch(marketMoodProvider);
  final exchangeAsync = ref.watch(exchangeRateProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (marketData) async {
      final exchangeRate = exchangeAsync.asData?.value ?? 1400.0;
      try {
        final results = await Future.wait(
          [
            usecase.calculateCurrentMood(marketData.totalVolumeUsd),
            usecase.calculateVolumeComparison(marketData.totalVolumeUsd),
          ],
          eagerError: false,
        );
        final currentMood = results[0] as MarketMood;
        final volumeComparison = results[1] as ComparisonData;
        final moodSummary = usecase.generateMoodSummary(currentMood);

        return MarketMoodComputedData(
          marketData: marketData,
          currentMood: currentMood,
          volumeComparison: volumeComparison,
          moodSummary: moodSummary,
          exchangeRate: exchangeRate,
          computedAt: DateTime.now(),
        );
      } catch (e, st) {
        // [수정됨] 이름 있는 파라미터(named parameter) 대신 위치 기반 파라미터(positional parameter) 사용
        log.e('배치 계산 오류: $e', e, st);
        return MarketMoodComputedData.error();
      }
    },
    loading: () async => MarketMoodComputedData.loading(),
    error: (error, stack) async {
      // [수정됨] 이름 있는 파라미터(named parameter) 대신 위치 기반 파라미터(positional parameter) 사용
      log.e('마켓무드 계산 오류: $error', error, stack);
      return MarketMoodComputedData.error();
    },
  );
});

/// 🎯 개별 데이터 접근 Provider들 - 메모이제이션된 결과에서 추출
final currentMarketMoodProvider = Provider<MarketMood>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.currentMood,
    loading: () => MarketMood.sideways,
    error: (_, __) => MarketMood.sideways,
  );
});

final volumeComparisonProvider = Provider<ComparisonData>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.volumeComparison,
    loading: () => ComparisonData.loading(),
    error: (_, __) => ComparisonData.error(),
  );
});

final marketMoodSummaryProvider = Provider<String>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.moodSummary,
    loading: () => '로딩중...',
    error: (_, __) => '오류 발생',
  );
});

/// 🌐 최적화된 시스템 상태 Provider
final marketMoodSystemProvider = Provider<MarketMoodSystemState>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return computedAsync.when(
    data: (computed) => usecase.createSystemState(
      marketData: computed.marketData,
      comparisonData: computed.volumeComparison,
      currentMood: computed.currentMood,
      exchangeRate: computed.exchangeRate,
      isLoading: false,
      hasError: false,
    ),
    loading: () => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.loading(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: true,
      hasError: false,
    ),
    error: (_, __) => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.error(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: false,
      hasError: true,
    ),
  );
});

/// 🎮 최적화된 마켓 무드 컨트롤러
final marketMoodControllerProvider = Provider((ref) => OptimizedMarketMoodController(ref));

class OptimizedMarketMoodController {
  final Ref ref;
  DateTime? _lastRefresh;
  static const _refreshCooldown = Duration(seconds: 30);

  OptimizedMarketMoodController(this.ref);

  /// 🚀 스마트 새로고침 - 쿨다운 적용
  void refresh() {
    final now = DateTime.now();
    if (_lastRefresh != null && now.difference(_lastRefresh!) < _refreshCooldown) {
      // [수정됨] + 연산자 대신 인접 문자열 연결 사용
      log.d('새로고침 쿨다운 중... '
          '${_refreshCooldown.inSeconds - now.difference(_lastRefresh!).inSeconds}초 후 가능');
      return;
    }

    _lastRefresh = now;
    ref.invalidate(marketMoodProvider);
    ref.invalidate(exchangeRateProvider);
    log.d('마켓무드 데이터 새로고침 완료');
  }

  /// 🚀 캐시된 현재 무드 조회
  MarketMood getCurrentMood() => ref.read(currentMarketMoodProvider);

  /// 🚀 캐시된 비교 데이터 조회
  ComparisonData getComparisonData() => ref.read(volumeComparisonProvider);

  /// 🚀 환율만 선택적 새로고침
  Future<void> refreshExchangeRate() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.refreshExchangeRate();
    ref.invalidate(exchangeRateProvider);
    log.d('환율 새로고침 완료');
  }

  /// 🚀 시스템 헬스 체크 (캐시 활용)
  Future<Map<String, dynamic>> getSystemHealth() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final state = ref.read(marketMoodSystemProvider);
    return {
      ...await usecase.getSystemHealth(),
      'cached_state': {
        'is_loading': state.isLoading,
        'has_error': state.hasError,
        'last_update': state.marketData?.updatedAt.toIso8601String(),
      }
    };
  }

  /// 🚀 성능 통계 로깅
  Future<void> logSystemStatus() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final computedAsync = ref.read(marketMoodComputedDataProvider);
    await usecase.logSystemStatus();
    computedAsync.whenData((computed) {
      log.i('성능 통계 - 계산 시간: ${DateTime.now().difference(computed.computedAt).inMilliseconds}ms');
    });
  }

  /// 🚀 메모리 정리 (필요 시 호출)
  void clearCache() {
    ref.invalidate(marketMoodComputedDataProvider);
    ref.invalidate(exchangeRateProvider);
    ref.invalidate(marketMoodProvider);
    log.d('캐시 정리 완료');
  }
}

/// 🚀 통합 계산 결과 데이터 클래스
class MarketMoodComputedData {
  final MarketMoodData? marketData;
  final MarketMood currentMood;
  final ComparisonData volumeComparison;
  final String moodSummary;
  final double exchangeRate;
  final DateTime computedAt;

  const MarketMoodComputedData({
    this.marketData,
    required this.currentMood,
    required this.volumeComparison,
    required this.moodSummary,
    required this.exchangeRate,
    required this.computedAt,
  });

  factory MarketMoodComputedData.loading() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.loading(),
        moodSummary: '로딩중...',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  factory MarketMoodComputedData.error() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.error(),
        moodSummary: '오류 발생',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  /// 🚀 데이터 신선도 체크 (15분 이상 오래되면 갱신 필요)
  bool get isStale => DateTime.now().difference(computedAt) > const Duration(minutes: 15);

  /// 🚀 성능 메트릭
  Duration get age => DateTime.now().difference(computedAt);
}\n\n// ====== lib/shared/widgets/market_mood_modal.dart ======\n
\n\n// ====== lib/shared/widgets/market_mood_indicator.dart ======\n
// lib/shared/widgets/market_mood_indicator.dart
// 🎨 Shared Widget: Market Mood 인디케이터 (클린 아키텍처 완전 대응)

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/controllers/market_mood_controller.dart';

/// 🎨 메인 마켓무드 인디케이터 위젯
class MarketMoodIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const MarketMoodIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false,
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // [수정] 중앙 계산 Provider를 watch하여 로딩/에러/데이터 상태를 한 번에 처리합니다.
    final computedAsync = ref.watch(marketMoodComputedDataProvider);
    
    Widget indicator = computedAsync.when(
      data: (computed) {
        // [수정] marketData가 아직 로드되지 않은 초기 상태일 수 있으므로 null 체크 추가
        if (computed.marketData == null) {
          return _buildLoadingIcon();
        }
        // [수정] computed 객체에서 필요한 marketData와 currentMood를 직접 가져옵니다.
        return _buildMoodIcon(context, ref, computed.marketData!, computed.currentMood);
      },
      loading: () => _buildLoadingIcon(),
      error: (_, __) => _buildErrorIcon(),
    );
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildMoodIcon(BuildContext context, WidgetRef ref, MarketMoodData data, MarketMood mood) {
    Widget moodIcon = _getMoodIcon(mood);
    
    // 롱프레스 제스처 추가
    return GestureDetector(
      onLongPressStart: (details) => _showMarketMoodModal(context, ref, details.globalPosition, data),
      onLongPressEnd: (_) => _hideMarketMoodModal(),
      onLongPressCancel: () => _hideMarketMoodModal(),
      child: moodIcon,
    );
  }

  Widget _buildLoadingIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.refresh,
      color: Colors.grey,
      tooltip: showTooltip ? '시장 데이터 로딩 중...' : null,
      animationType: MoodAnimationType.rotate,
      size: size,
    );
  }

  Widget _buildErrorIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.error_outline,
      color: Colors.red,
      tooltip: showTooltip ? '시장 데이터 로드 실패' : null,
      animationType: MoodAnimationType.blink,
      size: size,
    );
  }

  /// 🔥 시장 분위기 모달 표시 - 컨트롤러의 MarketMoodModalManager 사용
void _showMarketMoodModal(BuildContext context, WidgetRef ref, Offset globalPosition, MarketMoodData data) {
  if (ref.read(appSettingsProvider).isHapticEnabled) {
    HapticFeedback.mediumImpact();
  }
  Tooltip.dismissAllToolTips();
    
    // 화면 크기와 모달 크기 계산
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = screenSize.width * 0.9; // 90% 너비 사용
    
    // 화면 경계 고려한 위치 계산
    double adjustedX = globalPosition.dx - (modalWidth / 2); // 중앙 정렬
    double adjustedY = globalPosition.dy + size + 40; // 🔥 무조건 아래쪽으로 (위쪽 계산 제거)
    
    // 좌측 경계 체크
    if (adjustedX < 16) {
      adjustedX = 16;
    }
    
    // 우측 경계 체크
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16;
    }
    
    // 하단 경계 체크 - 화면 밖으로 나가면 위로 조정
    final bottomSafeArea = MediaQuery.of(context).padding.bottom;
    final maxY = screenSize.height - bottomSafeArea - 300; // 모달 최소 높이 고려
    if (adjustedY > maxY) {
      adjustedY = globalPosition.dy - 250; // 충분히 위로 올려서 표시
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    // 컨트롤러의 MarketMoodModalManager 사용
    MarketMoodModalManager.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
      data: data,
    );
  }

  /// 🔥 시장 분위기 모달 숨기기
  void _hideMarketMoodModal() {
    MarketMoodModalManager.hide();
  }

  Widget _getMoodIcon(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull:
        return _AnimatedMoodIcon(
          icon: Icons.rocket_launch,
          color: const Color(0xFFFF6B35), // 🚀 화염 오렌지-레드 톤
          tooltip: showTooltip ? '🚀 불장 - 30분 전 대비 +15% 이상 (롱프레스: 상세정보)' : null,
          animationType: MoodAnimationType.fastPulse,
          size: size,
        );
        
      case MarketMood.weakBull:
        return _AnimatedMoodIcon(
          icon: Icons.local_fire_department,
          color: const Color(0xFFFF6B35), // 🔥 화염 오렌지-레드 톤
          tooltip: showTooltip ? '🔥 약불장 - 30분 전 대비 +5~15% (롱프레스: 상세정보)' : null,
          animationType: MoodAnimationType.fireFlicker,
          size: size,
        );
        
      case MarketMood.sideways:
        return _AnimatedMoodIcon(
          icon: Icons.balance,
          color: const Color(0xFF757575), // ⚖️ 중성 회색
          tooltip: showTooltip ? '⚖️ 중간장 - 30분 전 대비 -5~+5% (롱프레스: 상세정보)' : null,
          animationType: MoodAnimationType.wiggle,
          size: size,
        );
        
      case MarketMood.bear:
        return _AnimatedMoodIcon(
          icon: Icons.water_drop,
          color: const Color(0xFF4A90E2), // 💧 물방울 블루 톤
          tooltip: showTooltip ? '💧 물장 - 30분 전 대비 -5~-15% (롱프레스: 상세정보)' : null,
          animationType: MoodAnimationType.waterDrop,
          size: size,
        );
        
      case MarketMood.deepBear:
        return _AnimatedMoodIcon(
          icon: Icons.ac_unit,
          color: const Color(0xFF4A90E2), // 🧊 얼음장 블루 톤
          tooltip: showTooltip ? '🧊 얼음장 - 30분 전 대비 -15% 이하 (롱프레스: 상세정보)' : null,
          animationType: MoodAnimationType.coldShiver,
          size: size,
        );
    }
  }
}

/// 🎨 애니메이션 타입 enum
enum MoodAnimationType { 
  none, 
  fastPulse, 
  fireFlicker, 
  wiggle, 
  waterDrop, 
  coldShiver, 
  rotate, 
  blink 
}

/// 🎨 애니메이션 아이콘 위젯
class _AnimatedMoodIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final MoodAnimationType animationType;
  final double size;

  const _AnimatedMoodIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedMoodIcon> createState() => _AnimatedMoodIconState();
}

class _AnimatedMoodIconState extends State<_AnimatedMoodIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case MoodAnimationType.fastPulse:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.6, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.fireFlicker:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 600),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.elasticOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.wiggle:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2000),
          vsync: this,
        );
        _animation = Tween<double>(begin: -0.15, end: 0.15).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.waterDrop:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2500),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.85, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.coldShiver:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 150),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.95, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.linear),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case MoodAnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedMoodIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case MoodAnimationType.fastPulse:
            return Transform.translate(
              offset: Offset(0, (_animation.value - 1) * 2),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.5, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.fireFlicker:
            return Transform.scale(
              scale: _animation.value,
              child: Transform.rotate(
                angle: (_animation.value - 1) * 0.1,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.4, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.wiggle:
            return Transform.rotate(
              angle: _animation.value,
              child: Transform.scale(
                scale: 0.95 + (_animation.value.abs() * 0.1),
                child: icon,
              ),
            );
            
          case MoodAnimationType.waterDrop:
            return Transform.translate(
              offset: Offset(0, (1 - _animation.value) * 1.5),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.6, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.coldShiver:
            return Transform.translate(
              offset: Offset(
                (_animation.value - 0.975) * 40,
                (_animation.value - 0.975) * 20,
              ),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.8, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case MoodAnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value.clamp(0.3, 1.0),
                child: icon,
              ),
            );
            
          case MoodAnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        preferBelow: false,
        verticalOffset: 20,
        waitDuration: const Duration(milliseconds: 500),
        showDuration: const Duration(seconds: 3),
        decoration: BoxDecoration(
          color: Colors.black87,
          borderRadius: BorderRadius.circular(8),
        ),
        textStyle: const TextStyle(
          fontSize: 11,
          color: Colors.white,
        ),
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/data/datasources/market_mood_remote_ds.dart ======\n
// lib/data/datasources/market_mood_remote_ds.dart
// 🌐 Data Layer: 원격 데이터 소스 (안정성이 검증된 Timer 방식으로 복원)

import 'dart:async';
import '../../core/network/api_client_coingecko.dart';
import '../../core/utils/logger.dart';
import '../../data/models/market_mood_dto.dart';

/// 🌐 마켓무드 원격 데이터 소스
class MarketMoodRemoteDataSource {
  final CoinGeckoApiClient _apiClient;
  Timer? _globalDataTimer;
  StreamController<CoinGeckoGlobalDataDto>? _globalDataController;

  MarketMoodRemoteDataSource(this._apiClient);

  Stream<CoinGeckoGlobalDataDto> getGlobalMarketDataStream() {
    // 이미 스트림이 활성화된 경우 재사용
    if (_globalDataController != null && !_globalDataController!.isClosed) {
      return _globalDataController!.stream;
    }
    
    _globalDataController = StreamController<CoinGeckoGlobalDataDto>.broadcast();
    
    Future<void> fetch() async {
      try {
        final responseDto = await _apiClient.getGlobalMarketData();
        final dataDto = responseDto.data;

        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.add(dataDto);
          log.d('📊 글로벌 마켓 데이터 수신 성공 (Timer): ${dataDto.totalVolumeUsd.toStringAsFixed(0)}B USD');
        }
      } catch (e, st) {
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.addError(e, st);
          log.e('❌ 글로벌 마켓 데이터 조회 실패 (Timer): $e');
        }
      }
    }

    // 첫 호출
    fetch();

    // 30분마다 호출
    _globalDataTimer = Timer.periodic(const Duration(minutes: 30), (_) => fetch());

    _globalDataController!.onCancel = () {
      _globalDataTimer?.cancel();
      _globalDataTimer = null;
      log.d('🔄 글로벌 마켓 데이터 스트림 리스너 없음. 타이머 중지.');
    };

    return _globalDataController!.stream;
  }

  Future<CoinGeckoGlobalDataDto> getGlobalMarketData() async {
    final responseDto = await _apiClient.getGlobalMarketData();
    return responseDto.data;
  }

  Future<double> getUsdToKrwRate() async {
    return _apiClient.getUsdToKrwRate();
  }

  Future<bool> checkApiHealth() async {
    try {
      await getGlobalMarketData();
      return true;
    } catch (_) {
      return false;
    }
  }

  void dispose() {
    _globalDataTimer?.cancel();
    _globalDataTimer = null;
    _globalDataController?.close();
    _globalDataController = null;
    log.d('🧹 MarketMoodRemoteDataSource 정리 완료');
  }
}\n\n// ====== lib/data/datasources/market_mood_local_ds.dart ======\n
// lib/data/datasources/market_mood_local_ds.dart
// 💾 Data Layer: 로컬 데이터 소스 (Hive 기반, DI 패턴)

import 'package:hive_flutter/hive_flutter.dart';
import '../../core/services/hive_service.dart';
import '../../core/utils/logger.dart';
import '../models/market_mood_dto.dart'; // 🔥 TimestampedVolume이 여기 있음

/// 💾 마켓무드 로컬 데이터 소스
/// HiveService를 통한 볼륨 데이터 저장/조회, 환율 캐싱 (DI 패턴)
class MarketMoodLocalDataSource {
  final HiveService _hiveService;
  
  static const String _exchangeRateKey = 'exchange_rate';
  static const String _appStartTimeKey = 'app_start_time';

  MarketMoodLocalDataSource(this._hiveService);

  /// Volume Box 접근
  Box<TimestampedVolume> get _volumeBox => _hiveService.marketMoodVolumeBox;
  
  /// Cache Box 접근 
  Box get _cacheBox => _hiveService.marketMoodCacheBox;

  // ═══════════════════════════════════════════════════════════
  // 📈 볼륨 데이터 관리
  // ═══════════════════════════════════════════════════════════

  /// 볼륨 데이터 추가 (30분 슬롯)
  Future<void> addVolumeData(TimestampedVolume volume) async {
    try {
      // 30분 단위로 정규화된 키 생성
      final slotKey = _getSlotKey(volume.timestamp);
      
      await _volumeBox.put(slotKey, volume);
      log.d('📈 볼륨 데이터 저장: $slotKey -> ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('📈 볼륨 데이터 저장 실패', e, st);
      rethrow;
    }
  }

  /// N분 전 볼륨 데이터 조회
  Future<TimestampedVolume?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final targetTime = DateTime.now().subtract(Duration(minutes: minutes));
      final slotKey = _getSlotKey(targetTime);
      
      final volume = _volumeBox.get(slotKey);
      if (volume != null) {
        log.d('📈 $minutes분 전 볼륨 조회 성공: ${volume.volumeUsd.toStringAsFixed(0)}B');
      } else {
        log.d('📈 $minutes분 전 볼륨 데이터 없음');
      }
      
      return volume;
    } catch (e, st) {
      log.e('📈 $minutes분 전 볼륨 조회 실패', e, st);
      return null;
    }
  }

  /// 특정 기간의 평균 볼륨 계산
  Future<double?> getAverageVolume(int days) async {
    try {
      final now = DateTime.now();
      final cutoffTime = now.subtract(Duration(days: days));
      
      final volumes = _volumeBox.values
          .where((volume) => volume.timestamp.isAfter(cutoffTime))
          .map((volume) => volume.volumeUsd)
          .toList();
      
      if (volumes.isEmpty) {
        log.d('📊 $days일 평균 볼륨: 데이터 없음');
        return null;
      }
      
      final average = volumes.reduce((a, b) => a + b) / volumes.length;
      log.d('📊 $days일 평균 볼륨: ${average.toStringAsFixed(0)}B (${volumes.length}개 데이터)');
      
      return average;
    } catch (e, st) {
      log.e('📊 $days일 평균 볼륨 계산 실패', e, st);
      return null;
    }
  }

  /// 수집된 데이터 개수 확인
  Future<int> getCollectedDataCount() async {
    try {
      final count = _volumeBox.length;
      log.d('📊 총 데이터 개수: $count');
      return count;
    } catch (e, st) {
      log.e('📊 데이터 개수 조회 실패', e, st);
      return 0;
    }
  }

  /// 누락된 30분 슬롯 확인 및 보정
  Future<void> checkAndFillMissingSlots() async {
    try {
      final appStartTime = getAppStartTime();
      final now = DateTime.now();
      final totalMinutes = now.difference(appStartTime).inMinutes;
      final expectedSlots = (totalMinutes / 30).floor();
      
      log.i('🔄 슬롯 체크: 예상 $expectedSlots개, 실제 ${_volumeBox.length}개');
      
      if (_volumeBox.length < expectedSlots) {
        final missing = expectedSlots - _volumeBox.length;
        log.w('⚠️ $missing개 슬롯 누락 감지');
        // 실제 보정 로직은 필요 시 구현
      }
    } catch (e, st) {
      log.e('🔄 슬롯 체크 실패', e, st);
    }
  }

  // ═══════════════════════════════════════════════════════════
  // 💱 환율 캐싱
  // ═══════════════════════════════════════════════════════════

  /// 환율 캐시 저장
  Future<void> cacheExchangeRate(double rate) async {
    try {
      await _cacheBox.put(_exchangeRateKey, {
        'rate': rate,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });
      log.d('💱 환율 캐시 저장: $rate KRW');
    } catch (e, st) {
      log.e('💱 환율 캐시 저장 실패', e, st);
      rethrow;
    }
  }

  /// 캐시된 환율 조회 (12시간 유효)
  Future<double?> getCachedExchangeRate() async {
    try {
      final cached = _cacheBox.get(_exchangeRateKey);
      if (cached == null) return null;
      
      final timestamp = DateTime.fromMillisecondsSinceEpoch(cached['timestamp']);
      final rate = cached['rate'] as double;
      
      // 12시간 이내인지 확인 (Provider와 동일한 캐시 정책)
      if (DateTime.now().difference(timestamp).inHours < 12) {
        log.d('💱 캐시된 환율 사용: $rate KRW');
        return rate;
      } else {
        log.d('💱 캐시된 환율 만료');
        return null;
      }
    } catch (e, st) {
      log.e('💱 캐시된 환율 조회 실패', e, st);
      return null;
    }
  }

  // ═══════════════════════════════════════════════════════════
  // 🕰️ 시간 관리
  // ═══════════════════════════════════════════════════════════

  /// 앱 시작 시간 조회
  DateTime getAppStartTime() {
    try {
      final cached = _cacheBox.get(_appStartTimeKey);
      if (cached != null) {
        return cached as DateTime;
      }
      
      // 최초 실행 시 현재 시간으로 설정
      final now = DateTime.now();
      _cacheBox.put(_appStartTimeKey, now);
      log.i('🕰️ 앱 시작 시간 설정: ${now.toIso8601String()}');
      return now;
    } catch (e, st) {
      log.e('🕰️ 앱 시작 시간 조회 실패', e, st);
      return DateTime.now(); // fallback
    }
  }

  /// 30분 슬롯 키 생성 (정규화)
  String _getSlotKey(DateTime timestamp) {
    // 30분 단위로 정규화: 예) 14:23 -> 14:00, 14:47 -> 14:30
    final normalized = DateTime(
      timestamp.year,
      timestamp.month,
      timestamp.day,
      timestamp.hour,
      (timestamp.minute ~/ 30) * 30, // 30분 단위로 내림
    );
    
    return normalized.toIso8601String();
  }

  // ═══════════════════════════════════════════════════════════
  // 🔧 유틸리티
  // ═══════════════════════════════════════════════════════════

  /// 디버깅용 정보 반환
  Map<String, Object> getDebugInfo() {
    try {
      final volumeInfo = {
        'total_count': _volumeBox.length,
        'box_open': _volumeBox.isOpen,
        'first_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.first.timestamp.toIso8601String() 
            : 'none',
        'last_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.last.timestamp.toIso8601String() 
            : 'none',
      };
      
      final cacheInfo = {
        'cache_keys': _cacheBox.keys.toList(),
        'app_start_time': getAppStartTime().toIso8601String(),
        'has_exchange_rate': _cacheBox.containsKey(_exchangeRateKey),
        'box_open': _cacheBox.isOpen,
      };

      return {
        'volume_storage': volumeInfo,
        'cache_storage': cacheInfo,
        'hive_service': 'injected',
        'status': 'healthy',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  /// 상태 로깅
  void logStatus() {
    final info = getDebugInfo();
    log.i('💾 MarketMoodLocalDataSource 상태: $info');
  }

  /// 리소스 정리
  Future<void> dispose() async {
    try {
      // HiveService가 Box 관리하므로 여기서는 정리 안함
      log.i('🧹 MarketMoodLocalDataSource 정리 완료');
    } catch (e, st) {
      log.e('🧹 리소스 정리 중 오류 발생', e, st);
    }
  }

  /// 개발용: 모든 데이터 삭제
  Future<void> clearAllData() async {
    try {
      await _volumeBox.clear();
      await _cacheBox.clear();
      log.w('🗑️ 모든 로컬 데이터 삭제 완료');
    } catch (e, st) {
      log.e('🗑️ 데이터 삭제 실패', e, st);
      rethrow;
    }
  }

  /// 개발용: 최근 N개 데이터만 유지
  Future<void> trimOldData({int keepCount = 100}) async {
    try {
      if (_volumeBox.length <= keepCount) return;

      final allEntries = _volumeBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp)); // 최신순

      final toKeep = allEntries.take(keepCount).toList();
      
      await _volumeBox.clear();
      for (final volume in toKeep) {
        await addVolumeData(volume);
      }
      
      log.i('🧹 오래된 데이터 정리: ${allEntries.length} -> $keepCount개');
    } catch (e, st) {
      log.e('🧹 데이터 정리 실패', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/repositories/market_mood_repository_impl.dart ======\n
// lib/data/repositories/market_mood_repository_impl.dart
// 🏗️ Data Layer: Repository 구현체 (Domain 인터페이스 완전 매칭)

import 'dart:async';
import 'package:rxdart/rxdart.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/repositories/market_mood_repository.dart';
import '../datasources/market_mood_local_ds.dart';
import '../datasources/market_mood_remote_ds.dart';
import '../models/market_mood_dto.dart';

/// 🏗️ 마켓무드 Repository 구현체
/// Remote + Local DataSource를 통합하여 Domain Entity로 변환하여 제공
class MarketMoodRepositoryImpl implements MarketMoodRepository {
  final MarketMoodRemoteDataSource _remoteDataSource;
  final MarketMoodLocalDataSource _localDataSource;

  // [리팩토링] 수동 스트림 관리가 필요 없으므로 변수 삭제
  // StreamController<MarketMoodData>? _marketDataController;
  // StreamSubscription? _remoteSubscription;

  MarketMoodRepositoryImpl(this._remoteDataSource, this._localDataSource);

  // ═══════════════════════════════════════════════════════════
  // 🌐 원격 데이터 (CoinGecko API)
  // ═══════════════════════════════════════════════════════════

  @override
  Stream<MarketMoodData> getMarketDataStream() {
    // [리팩토링] listen-add 대신, stream 연산자를 사용한 선언적 방식으로 변경
    return _remoteDataSource
        .getGlobalMarketDataStream()
        .doOnData((globalDataDto) async {
          try {
            final volumeDto = TimestampedVolume(
              timestamp: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
              volumeUsd: globalDataDto.totalVolumeUsd,
            );
            await _localDataSource.addVolumeData(volumeDto);
            log.d('📊 스트림 데이터 로컬 저장 완료');
          } catch (e, st) {
            log.e('📊 스트림 데이터 로컬 저장 실패', e, st);
          }
        })
        .map((globalDataDto) {
          log.d('📊 DTO -> Entity 변환 완료');
          return MarketMoodData(
            totalMarketCapUsd: globalDataDto.totalMarketCapUsd,
            totalVolumeUsd: globalDataDto.totalVolumeUsd,
            btcDominance: globalDataDto.btcDominance,
            marketCapChange24h: globalDataDto.marketCapChangePercentage24hUsd,
            updatedAt: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
          );
        });
  }

  @override
  Future<MarketMoodData?> getCurrentMarketData() async {
    try {
      // [수정] remoteDataSource는 이제 DTO를 반환
      final dataDto = await _remoteDataSource.getGlobalMarketData();
      
      final marketData = MarketMoodData(
        totalMarketCapUsd: dataDto.totalMarketCapUsd,
        totalVolumeUsd: dataDto.totalVolumeUsd,
        btcDominance: dataDto.btcDominance,
        marketCapChange24h: dataDto.marketCapChangePercentage24hUsd,
        updatedAt: DateTime.fromMillisecondsSinceEpoch(dataDto.updatedAt * 1000),
      );
      
      log.d('📊 현재 마켓 데이터 조회 성공');
      return marketData;
    } catch (e, st) {
      log.e('📊 현재 마켓 데이터 조회 실패', e, st);
      return null;
    }
  }

  @override
  Future<double> getExchangeRate() async {
    try {
      final cachedRate = await _localDataSource.getCachedExchangeRate();
      if (cachedRate != null) {
        return cachedRate;
      }
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      return rate;
    } catch (e, st) {
      log.e('💱 환율 조회 실패, 기본값 사용', e, st);
      return 1400.0;
    }
  }

  @override
  Future<void> refreshExchangeRate() async {
    try {
      log.i('💱 환율 수동 새로고침 시작');
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      log.i('💱 환율 새로고침 완료: $rate KRW');
    } catch (e, st) {
      log.e('💱 환율 새로고침 실패', e, st);
      rethrow;
    }
  }

  // ═══════════════════════════════════════════════════════════
  // 💾 로컬 데이터 (볼륨 버퍼) - Domain Entity 사용
  // ═══════════════════════════════════════════════════════════

  @override
  Future<void> addVolumeData(VolumeData volume) async {
    try {
      final volumeDto = TimestampedVolume.fromEntity(volume);
      await _localDataSource.addVolumeData(volumeDto);
    } catch (e, st) {
      log.e('📈 볼륨 데이터 추가 실패', e, st);
      rethrow;
    }
  }

  @override
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final volumeDto = await _localDataSource.getVolumeNMinutesAgo(minutes);
      return volumeDto?.toEntity();
    } catch (e, st) {
      log.e('📈 $minutes분 전 볼륨 조회 실패', e, st);
      return null;
    }
  }

  @override
  Future<double?> getAverageVolume(int days) async {
    return _localDataSource.getAverageVolume(days);
  }

  @override
  Future<int> getCollectedDataCount() async {
    return _localDataSource.getCollectedDataCount();
  }

  @override
  DateTime getAppStartTime() {
    return _localDataSource.getAppStartTime();
  }

  // ═══════════════════════════════════════════════════════════
  // 🧹 관리 기능
  // ═══════════════════════════════════════════════════════════

  @override
  Future<void> syncMissingData() async {
    await _localDataSource.checkAndFillMissingSlots();
  }

  @override
  Future<void> clearOldData() async {
    await _localDataSource.trimOldData(keepCount: 336); // 7일 * 48슬롯/일
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final localInfo = _localDataSource.getDebugInfo();
    final remoteHealth = await _remoteDataSource.checkApiHealth();
    final dataCount = await getCollectedDataCount();
    final appStartTime = getAppStartTime();
    final elapsedMinutes = DateTime.now().difference(appStartTime).inMinutes;

    return {
      'status': 'healthy',
      'local_storage': localInfo,
      'remote_api': {'healthy': remoteHealth, 'status': remoteHealth ? 'ok' : 'error'},
      'data_count': dataCount,
      'app_start_time': appStartTime.toIso8601String(),
      'elapsed_minutes': elapsedMinutes,
      'last_check': DateTime.now().toIso8601String(),
    };
  }

  @override
  Future<void> logCurrentStatus() async {
    final health = await getSystemHealth();
    _localDataSource.logStatus();
    log.i('📊 마켓무드 시스템 상태: $health');
  }

  // ═══════════════════════════════════════════════════════════
  // 🛠️ 개발/테스트용 기능
  // ═══════════════════════════════════════════════════════════

  @override
  Future<void> injectTestVolumeData(List<VolumeData> testData) async {
    if (testData.isEmpty) return;
    for (final volume in testData) {
      await addVolumeData(volume);
    }
  }

  // ═══════════════════════════════════════════════════════════
  // 🧹 리소스 정리
  // ═══════════════════════════════════════════════════════════

  @override
  Future<void> dispose() async {
    log.i('🧹 MarketMoodRepository 리소스 정리 시작');
    _remoteDataSource.dispose();
    await _localDataSource.dispose();
    log.i('🧹 MarketMoodRepository 리소스 정리 완료');
  }
}\n\n// ====== lib/data/models/market_mood_model.dart ======\n
\n\n// ====== lib/data/models/market_mood_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'market_mood_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TimestampedVolumeAdapter extends TypeAdapter<TimestampedVolume> {
  @override
  final int typeId = 1;

  @override
  TimestampedVolume read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TimestampedVolume(
      timestamp: fields[0] as DateTime,
      volumeUsd: fields[1] as double,
    );
  }

  @override
  void write(BinaryWriter writer, TimestampedVolume obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.volumeUsd);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimestampedVolumeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalDataDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalDataDto> {
  @override
  final int typeId = 2;

  @override
  CoinGeckoGlobalDataDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalDataDto(
      totalMarketCapUsd: fields[0] as double,
      totalVolumeUsd: fields[1] as double,
      btcDominance: fields[2] as double,
      marketCapChangePercentage24hUsd: fields[3] as double,
      updatedAt: fields[4] as int,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalDataDto obj) {
    writer
      ..writeByte(5)
      ..writeByte(0)
      ..write(obj.totalMarketCapUsd)
      ..writeByte(1)
      ..write(obj.totalVolumeUsd)
      ..writeByte(2)
      ..write(obj.btcDominance)
      ..writeByte(3)
      ..write(obj.marketCapChangePercentage24hUsd)
      ..writeByte(4)
      ..write(obj.updatedAt);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalDataDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalResponseDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalResponseDto> {
  @override
  final int typeId = 3;

  @override
  CoinGeckoGlobalResponseDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalResponseDto(
      data: fields[0] as CoinGeckoGlobalDataDto,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalResponseDto obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.data);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalResponseDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/market_mood_dto.dart ======\n
// lib/data/models/market_mood_dto.dart
// 🌐 Data Layer: 통합 DTO 모델 (Trade 스타일)

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../core/utils/date_time.dart'; // DateTime extension
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';

part 'market_mood_dto.g.dart';

/// 📈 인트라데이 볼륨 데이터 (30분 단위) - Hive 모델
@HiveType(typeId: 1) // TradeDto가 typeId: 0 사용하므로 1 사용
class TimestampedVolume extends HiveObject {
  @HiveField(0)
  final DateTime timestamp;

  @HiveField(1)
  final double volumeUsd;

  TimestampedVolume({
    required this.timestamp,
    required this.volumeUsd,
  });

  /// Domain Entity로 변환
  VolumeData toEntity() => VolumeData(
    timestamp: timestamp,
    volumeUsd: volumeUsd,
  );

  /// Domain Entity에서 생성
  factory TimestampedVolume.fromEntity(VolumeData entity) => TimestampedVolume(
    timestamp: entity.timestamp,
    volumeUsd: entity.volumeUsd,
  );

  /// JSON 직렬화용 맵 변환
  Map<String, dynamic> toMap() => {
    'timestamp': timestamp.toIso8601String(),
    'volumeUsd': volumeUsd,
  };

  /// JSON 문자열 직렬화
  String toJson() => json.encode(toMap());

  /// JSON 파싱
  static TimestampedVolume? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final timestampStr = m['timestamp']?.toString() ?? '';
      final volumeUsd = (m['volumeUsd'] as num?)?.toDouble() ?? 0.0;

      if (timestampStr.isEmpty) return null;

      return TimestampedVolume(
        timestamp: DateTime.parse(timestampStr),
        volumeUsd: volumeUsd,
      );
    } catch (e) {
      log.w('TimestampedVolume.tryParse error: $e');
      return null;
    }
  }

  /// JSON 문자열로부터 객체 생성
  factory TimestampedVolume.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TimestampedVolume(
        timestamp: DateTime.now(),
        volumeUsd: 0.0,
      );

  /// DateTime extension 활용
  String get formattedTime => timestamp.yyyyMMddhhmm();
  String get timeAgoText => timestamp.timeAgo();
  String get shortTime => timestamp.hhmmss();

  @override
  String toString() => 'TimestampedVolume($formattedTime, ${volumeUsd.toStringAsFixed(2)}B)';
}

/// 🌐 CoinGecko 글로벌 마켓 데이터 DTO
@HiveType(typeId: 2)
class CoinGeckoGlobalDataDto extends HiveObject {
  @HiveField(0)
  final double totalMarketCapUsd;

  @HiveField(1)
  final double totalVolumeUsd;

  @HiveField(2)
  final double btcDominance;

  @HiveField(3)
  final double marketCapChangePercentage24hUsd;

  @HiveField(4)
  final int updatedAt;

  CoinGeckoGlobalDataDto({
    required this.totalMarketCapUsd,
    required this.totalVolumeUsd,
    required this.btcDominance,
    required this.marketCapChangePercentage24hUsd,
    required this.updatedAt,
  });

  /// Domain Entity로 변환
  MarketMoodData toEntity() => MarketMoodData(
    totalMarketCapUsd: totalMarketCapUsd,
    totalVolumeUsd: totalVolumeUsd,
    btcDominance: btcDominance,
    marketCapChange24h: marketCapChangePercentage24hUsd,
    updatedAt: DateTime.fromMillisecondsSinceEpoch(updatedAt * 1000),
  );

  /// JSON 직렬화용 맵 변환
  Map<String, dynamic> toMap() => {
    'total_market_cap_usd': totalMarketCapUsd,
    'total_volume_usd': totalVolumeUsd,
    'btc_dominance': btcDominance,
    'market_cap_change_percentage_24h_usd': marketCapChangePercentage24hUsd,
    'updated_at': updatedAt,
  };

  /// JSON 문자열 직렬화
  String toJson() => json.encode(toMap());

  /// JSON 파싱 (CoinGecko API 응답 형태)
  static CoinGeckoGlobalDataDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch ~/ 1000
            : DateTime.now().millisecondsSinceEpoch ~/ 1000;
      }

      final totalMarketCap = m['total_market_cap'] as Map<String, dynamic>?;
      final totalVolume = m['total_volume'] as Map<String, dynamic>?;
      final marketCapPercentage = m['market_cap_percentage'] as Map<String, dynamic>?;

      return CoinGeckoGlobalDataDto(
        totalMarketCapUsd: parseDouble(totalMarketCap?['usd']),
        totalVolumeUsd: parseDouble(totalVolume?['usd']),
        btcDominance: parseDouble(marketCapPercentage?['btc']),
        marketCapChangePercentage24hUsd: parseDouble(m['market_cap_change_percentage_24h_usd']),
        updatedAt: parseInt(m['updated_at']),
      );
    } catch (e) {
      log.w('CoinGeckoGlobalDataDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalDataDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalDataDto(
        totalMarketCapUsd: 0.0,
        totalVolumeUsd: 0.0,
        btcDominance: 0.0,
        marketCapChangePercentage24hUsd: 0.0,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

  @override
  String toString() => 'CoinGeckoGlobalDataDto(volume: ${totalVolumeUsd.toStringAsFixed(0)}B USD)';
}

/// 🌐 CoinGecko 글로벌 마켓 응답 래퍼 DTO
@HiveType(typeId: 3)
class CoinGeckoGlobalResponseDto extends HiveObject {
  @HiveField(0)
  final CoinGeckoGlobalDataDto data;

  CoinGeckoGlobalResponseDto({
    required this.data,
  });

  Map<String, dynamic> toMap() => {
    'data': data.toMap(),
  };

  String toJson() => json.encode(toMap());

  static CoinGeckoGlobalResponseDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      final dataMap = m['data'] as Map<String, dynamic>?;
      if (dataMap == null) return null;
      final data = CoinGeckoGlobalDataDto.tryParse(dataMap);
      if (data == null) return null;
      return CoinGeckoGlobalResponseDto(data: data);
    } catch (e) {
      log.w('CoinGeckoGlobalResponseDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalResponseDto.fromJson(Map<String, dynamic> json) {
     final parsed = tryParse(json);
     if(parsed != null) return parsed;
     
     return CoinGeckoGlobalResponseDto(
        data: CoinGeckoGlobalDataDto(
          totalMarketCapUsd: 0.0,
          totalVolumeUsd: 0.0,
          btcDominance: 0.0,
          marketCapChangePercentage24hUsd: 0.0,
          updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        ),
      );
  }

  @override
  String toString() => 'CoinGeckoGlobalResponseDto(data: $data)';
}\n\n// ====== lib/domain/repositories/market_mood_repository.dart ======\n
// lib/domain/repositories/market_mood_repository.dart
// 🎯 Domain Layer: Repository 인터페이스 (클린 아키텍처 준수)

import '../entities/market_mood.dart';

/// 📊 마켓무드 저장소 인터페이스
/// Data Layer에서 구현해야 할 계약을 정의 (Domain → Data 의존성 제거)
abstract class MarketMoodRepository {
  // ═══════════════════════════════════════════════════════════
  // 📡 원격 데이터 (CoinGecko API)
  // ═══════════════════════════════════════════════════════════
  
  /// 글로벌 마켓 데이터 스트림 (30분 주기)
  Stream<MarketMoodData> getMarketDataStream();
  
  /// 현재 마켓 데이터 한 번 조회
  Future<MarketMoodData?> getCurrentMarketData();
  
  /// 현재 USD/KRW 환율 조회 (캐시 포함)
  Future<double> getExchangeRate();
  
  /// 환율 수동 새로고침
  Future<void> refreshExchangeRate();
  
  // ═══════════════════════════════════════════════════════════
  // 💾 로컬 데이터 (Hive 볼륨 버퍼)
  // ═══════════════════════════════════════════════════════════
  
  /// 볼륨 데이터 추가 (30분마다)
  Future<void> addVolumeData(VolumeData volume);
  
  /// N분 전 볼륨 데이터 조회
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes);
  
  /// 특정 기간의 평균 볼륨 계산
  Future<double?> getAverageVolume(int days);
  
  /// 수집된 데이터 개수 확인
  Future<int> getCollectedDataCount();
  
  /// 앱 시작 시간 조회
  DateTime getAppStartTime();
  
  // ═══════════════════════════════════════════════════════════
  // 🧹 관리 기능
  // ═══════════════════════════════════════════════════════════
  
  /// 백그라운드 복귀 시 누락된 슬롯 보정
  Future<void> syncMissingData();
  
  /// 오래된 데이터 정리
  Future<void> clearOldData();
  
  /// 시스템 헬스체크
  Future<Map<String, dynamic>> getSystemHealth();
  
  /// 현재 상태 로깅
  Future<void> logCurrentStatus();
  
  // ═══════════════════════════════════════════════════════════
  // 🛠️ 개발/테스트용 기능
  // ═══════════════════════════════════════════════════════════
  
  /// 테스트 데이터 주입
  Future<void> injectTestVolumeData(List<VolumeData> testData);
}\n\n// ====== lib/domain/usecases/market_mood_usecase.dart ======\n
// lib/domain/usecases/market_mood_usecase.dart
// 🎯 Domain Layer: 비즈니스 로직 (순수 계산 알고리즘)

import 'dart:async';
import 'dart:math';
import '../entities/market_mood.dart';
import '../repositories/market_mood_repository.dart';

/// 💰 마켓 무드 계산기 (순수 비즈니스 로직)
class MarketMoodCalculator {
  static MarketMood calculateMoodByComparison(double current, double previous) {
    if (previous <= 0) return MarketMood.sideways;
    final changePercent = ((current - previous) / previous) * 100;
    
    // [수정] 요청하신 임계값 (10, 5, -5, -10)으로 변경
    if (changePercent >= 10) return MarketMood.bull;
    if (changePercent >= 5) return MarketMood.weakBull;
    if (changePercent >= -5) return MarketMood.sideways;
    if (changePercent >= -10) return MarketMood.bear;
    return MarketMood.deepBear;
  }

  static MarketMood calculateMoodByAbsolute(double volumeUsd) {
    if (volumeUsd >= 150e9) return MarketMood.bull;
    if (volumeUsd >= 100e9) return MarketMood.weakBull;
    if (volumeUsd >= 70e9) return MarketMood.sideways;
    if (volumeUsd >= 50e9) return MarketMood.bear;
    return MarketMood.deepBear;
  }
}

/// 🧮 볼륨 비교 계산기 (순수 계산 로직)
class VolumeComparator {
  final MarketMoodRepository _repository;

  VolumeComparator(this._repository);

  double _calculateChangePercent(double current, double previous) {
    if (previous <= 0) return 0.0;
    return ((current - previous) / previous) * 100;
  }

  double _calculateProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    if (elapsed < targetMinutes) {
      return min(elapsed / targetMinutes, 1.0);
    }
    final cycleElapsed = (elapsed - targetMinutes) % targetMinutes;
    return cycleElapsed / targetMinutes;
  }

  double _calculateLongTermProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    return min(elapsed / targetMinutes, 1.0);
  }

  Future<ComparisonResult> _compareGeneric({
    required double currentVolume,
    required int targetMinutes,
    required bool isLongTermAverage,
    required int daysForAverage,
  }) async {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;

    if (isLongTermAverage) {
      if (elapsed < targetMinutes) {
        return ComparisonResult.collecting(_calculateLongTermProgress(targetMinutes));
      }
      final average = await _repository.getAverageVolume(daysForAverage);
      if (average == null) {
        return ComparisonResult.unavailable('샘플 부족');
      }
      return ComparisonResult.ready(_calculateChangePercent(currentVolume, average));
    }

    if (elapsed < targetMinutes) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    final past = await _repository.getVolumeNMinutesAgo(targetMinutes);
    if (past == null) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    return ComparisonResult.ready(_calculateChangePercent(currentVolume, past.volumeUsd));
  }

  Future<ComparisonResult> compare30Minutes(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 30, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare1Hour(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 60, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare2Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 120, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare4Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 240, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare8Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 480, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare12Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 720, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare24Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 1440, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare3DayAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 4320, isLongTermAverage: true, daysForAverage: 3);

  Future<ComparisonResult> compareWeeklyAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 10080, isLongTermAverage: true, daysForAverage: 7);

  /// [개선] 전체 비교 데이터 계산 (병렬 처리)
  Future<ComparisonData> calculateAll(double currentVolume) async {
    final results = await Future.wait([
      compare30Minutes(currentVolume),
      compare1Hour(currentVolume),
      compare2Hours(currentVolume),
      compare4Hours(currentVolume),
      compare8Hours(currentVolume),
      compare12Hours(currentVolume),
      compare24Hours(currentVolume),
      compare3DayAverage(currentVolume),
      compareWeeklyAverage(currentVolume),
    ]);

    return ComparisonData(
      thirtyMin: results[0],
      oneHour: results[1],
      twoHour: results[2],
      fourHour: results[3],
      eightHour: results[4],
      twelveHour: results[5],
      twentyFourHour: results[6],
      threeDayAverage: results[7],
      weeklyAverage: results[8],
    );
  }
}

/// 🎯 마켓무드 UseCase (전체 비즈니스 로직 조합) - Provider와 매칭
class MarketMoodUsecase {
  final MarketMoodRepository _repository;
  final VolumeComparator _comparator;

  MarketMoodUsecase(this._repository) : _comparator = VolumeComparator(_repository);

  Future<void> addVolumeData(double volumeUsd) async {
    final volumeData = VolumeData(
      timestamp: DateTime.now(),
      volumeUsd: volumeUsd,
    );
    await _repository.addVolumeData(volumeData);
  }

  /// [수정] 현재 마켓무드 계산 기준을 2시간으로 변경
  Future<MarketMood> calculateCurrentMood(double currentVolume) async {
    // 2시간 = 120분
    final twoHoursAgo = await _repository.getVolumeNMinutesAgo(120);
    
    if (twoHoursAgo != null) {
      return MarketMoodCalculator.calculateMoodByComparison(
        currentVolume, 
        twoHoursAgo.volumeUsd
      );
    }
    return MarketMoodCalculator.calculateMoodByAbsolute(currentVolume);
  }

  Future<ComparisonData> calculateVolumeComparison(double currentVolume) {
    return _comparator.calculateAll(currentVolume);
  }

  MarketMoodSystemState createSystemState({
    required MarketMoodData? marketData,
    required ComparisonData comparisonData,
    required MarketMood currentMood,
    required double exchangeRate,
    required bool isLoading,
    required bool hasError,
  }) {
    return MarketMoodSystemState(
      marketData: marketData,
      comparisonData: comparisonData,
      currentMood: currentMood,
      exchangeRate: exchangeRate,
      isLoading: isLoading,
      hasError: hasError,
    );
  }

  String generateMoodSummary(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull: return '🚀 불장';
      case MarketMood.weakBull: return '🔥 약불장';
      case MarketMood.sideways: return '⚖️ 중간장';
      case MarketMood.bear: return '💧 물장';
      case MarketMood.deepBear: return '🧊 얼음장';
    }
  }

  Future<void> handleBackgroundResume() async {
    await _repository.syncMissingData();
  }

  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  Future<void> logSystemStatus() async {
    await _repository.logCurrentStatus();
  }

  Future<int> getCollectedDataCount() async {
    return await _repository.getCollectedDataCount();
  }

  DateTime getAppStartTime() {
    return _repository.getAppStartTime();
  }

  Future<double> getExchangeRate() async {
    return await _repository.getExchangeRate();
  }

  Future<void> refreshExchangeRate() async {
    await _repository.refreshExchangeRate();
  }
}\n\n// ====== lib/domain/entities/market_mood.dart ======\n
// lib/domain/entities/market_mood.dart
// 🎯 Domain Layer: 순수 엔티티들 (VolumeData 추가)

import '../../core/utils/date_time.dart'; // DateTime extension

/// 🕒 볼륨 관련 상수 정의
class VolumeConstants {
 static const int minutesPerSlot = 30;
 static const int slotsPerHour = 60 ~/ minutesPerSlot; // 2
 static const int hoursPerDay = 24;
 static const int daysInBuffer = 7;
 static const int totalSlots = slotsPerHour * hoursPerDay * daysInBuffer; // 336
 static const int maxMinutesBuffer = minutesPerSlot * totalSlots; // 10080
 static const String volumeBoxName = 'market_volumes';
}

/// 🔥 시장 분위기 enum
enum MarketMood {
 bull,       // 🚀 불장
 weakBull,   // 🔥 약불장
 sideways,   // ⚖️ 중간장
 bear,       // 💧 물장
 deepBear,   // 🧊 얼음장
}

/// 📈 볼륨 데이터 엔티티 (30분 단위)
class VolumeData {
 final DateTime timestamp;
 final double volumeUsd;

 const VolumeData({
   required this.timestamp,
   required this.volumeUsd,
 });

 /// DateTime extension 활용
 String get formattedTime => timestamp.yyyyMMddhhmm();
 String get timeAgoText => timestamp.timeAgo();
 String get shortTime => timestamp.hhmmss();

 /// JSON 직렬화
 Map<String, dynamic> toJson() => {
   'timestamp': timestamp.toIso8601String(),
   'volume_usd': volumeUsd,
 };

 factory VolumeData.fromJson(Map<String, dynamic> json) {
   return VolumeData(
     timestamp: DateTime.parse(json['timestamp']),
     volumeUsd: (json['volume_usd'] as num).toDouble(),
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is VolumeData &&
         runtimeType == other.runtimeType &&
         timestamp == other.timestamp &&
         volumeUsd == other.volumeUsd;

 @override
 int get hashCode => timestamp.hashCode ^ volumeUsd.hashCode;

 @override
 String toString() =>
     'VolumeData(${volumeUsd.toStringAsFixed(0)}B USD at ${timestamp.hhmmss()})';
}

/// 📊 마켓 무드 데이터 엔티티
class MarketMoodData {
 final double totalMarketCapUsd;
 final double totalVolumeUsd;
 final double btcDominance;
 final double marketCapChange24h;
 final DateTime updatedAt;

 const MarketMoodData({
   required this.totalMarketCapUsd,
   required this.totalVolumeUsd,
   required this.btcDominance,
   required this.marketCapChange24h,
   required this.updatedAt,
 });

 /// JSON 직렬화 (DTO 호환용)
 Map<String, dynamic> toJson() => {
   'total_market_cap_usd': totalMarketCapUsd,
   'total_volume_usd': totalVolumeUsd,
   'btc_dominance': btcDominance,
   'market_cap_change_24h': marketCapChange24h,
   'updated_at': updatedAt.toIso8601String(),
 };

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodData &&
         runtimeType == other.runtimeType &&
         totalMarketCapUsd == other.totalMarketCapUsd &&
         totalVolumeUsd == other.totalVolumeUsd &&
         btcDominance == other.btcDominance &&
         marketCapChange24h == other.marketCapChange24h;

 @override
 int get hashCode =>
     totalMarketCapUsd.hashCode ^
     totalVolumeUsd.hashCode ^
     btcDominance.hashCode ^
     marketCapChange24h.hashCode;

 @override
 String toString() =>
     'MarketMoodData(volume: ${totalVolumeUsd.toStringAsFixed(0)}, '
     'cap: ${totalMarketCapUsd.toStringAsFixed(0)}, '
     'btc: ${btcDominance.toStringAsFixed(1)}%)';
}

/// 📊 비교 결과 엔티티
class ComparisonResult {
 final bool isReady;
 final double? changePercent;
 final double progressPercent;
 final String status;

 const ComparisonResult({
   required this.isReady,
   this.changePercent,
   required this.progressPercent,
   required this.status,
 });

 factory ComparisonResult.collecting(double progress) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: progress,
     status: '수집중',
   );
 }

 factory ComparisonResult.ready(double changePercent) {
   return ComparisonResult(
     isReady: true,
     changePercent: changePercent,
     progressPercent: 1.0,
     status: '완료',
   );
 }

 factory ComparisonResult.unavailable(String message) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: 0.0,
     status: message,
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonResult &&
         runtimeType == other.runtimeType &&
         isReady == other.isReady &&
         changePercent == other.changePercent &&
         progressPercent == other.progressPercent &&
         status == other.status;

 @override
 int get hashCode =>
     isReady.hashCode ^
     changePercent.hashCode ^
     progressPercent.hashCode ^
     status.hashCode;

 @override
 String toString() =>
     'ComparisonResult(ready: $isReady, change: $changePercent%, progress: ${(progressPercent * 100).round()}%)';
}

/// 📈 전체 비교 데이터 엔티티
class ComparisonData {
 final ComparisonResult thirtyMin;
 final ComparisonResult oneHour;
 final ComparisonResult twoHour;
 final ComparisonResult fourHour;
 final ComparisonResult eightHour;
 final ComparisonResult twelveHour;
 final ComparisonResult twentyFourHour;
 final ComparisonResult threeDayAverage;
 final ComparisonResult weeklyAverage;

 const ComparisonData({
   required this.thirtyMin,
   required this.oneHour,
   required this.twoHour,
   required this.fourHour,
   required this.eightHour,
   required this.twelveHour,
   required this.twentyFourHour,
   required this.threeDayAverage,
   required this.weeklyAverage,
 });

 factory ComparisonData.loading() {
   final loading = ComparisonResult.collecting(0.0);
   return ComparisonData(
     thirtyMin: loading,
     oneHour: loading,
     twoHour: loading,
     fourHour: loading,
     eightHour: loading,
     twelveHour: loading,
     twentyFourHour: loading,
     threeDayAverage: loading,
     weeklyAverage: loading,
   );
 }

 factory ComparisonData.error() {
   final error = ComparisonResult.unavailable('오류');
   return ComparisonData(
     thirtyMin: error,
     oneHour: error,
     twoHour: error,
     fourHour: error,
     eightHour: error,
     twelveHour: error,
     twentyFourHour: error,
     threeDayAverage: error,
     weeklyAverage: error,
   );
 }

 /// 모든 비교 결과를 리스트로 반환
 List<ComparisonResult> get allResults => [
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     ];

 /// 준비된 비교 결과 개수
 int get readyCount => allResults.where((r) => r.isReady).length;

 /// 전체 진행률 (0.0 ~ 1.0)
 double get overallProgress =>
     allResults.map((r) => r.progressPercent).reduce((a, b) => a + b) / 9;

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonData &&
         runtimeType == other.runtimeType &&
         thirtyMin == other.thirtyMin &&
         oneHour == other.oneHour &&
         twoHour == other.twoHour &&
         fourHour == other.fourHour &&
         eightHour == other.eightHour &&
         twelveHour == other.twelveHour &&
         twentyFourHour == other.twentyFourHour &&
         threeDayAverage == other.threeDayAverage &&
         weeklyAverage == other.weeklyAverage;

 @override
 int get hashCode => Object.hash(
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     );

 @override
 String toString() =>
     'ComparisonData(ready: $readyCount/9, progress: ${(overallProgress * 100).round()}%)';
}

/// 📦 전체 시스템 상태 엔티티
class MarketMoodSystemState {
 final MarketMoodData? marketData;
 final ComparisonData comparisonData;
 final MarketMood currentMood;
 final double exchangeRate;
 final bool isLoading;
 final bool hasError;

 const MarketMoodSystemState({
   required this.marketData,
   required this.comparisonData,
   required this.currentMood,
   required this.exchangeRate,
   required this.isLoading,
   required this.hasError,
 });

 /// 시스템이 정상 작동 중인지 확인
 bool get isHealthy => !hasError && marketData != null;

 /// 데이터 수집 진행률 (0.0 ~ 1.0)
 double get dataProgress => comparisonData.overallProgress;

 /// 상태 요약 문자열
 String get statusSummary {
   if (hasError) return '오류 발생';
   if (isLoading) return '로딩 중';
   if (marketData == null) return '데이터 없음';
   return '정상 작동';
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodSystemState &&
         runtimeType == other.runtimeType &&
         marketData == other.marketData &&
         comparisonData == other.comparisonData &&
         currentMood == other.currentMood &&
         exchangeRate == other.exchangeRate &&
         isLoading == other.isLoading &&
         hasError == other.hasError;

 @override
 int get hashCode => Object.hash(
       marketData,
       comparisonData,
       currentMood,
       exchangeRate,
       isLoading,
       hasError,
     );

 @override
 String toString() =>
     'MarketMoodSystemState(mood: $currentMood, status: $statusSummary, progress: ${(dataProgress * 100).round()}%)';
}\n\n// ====== lib/presentation/controllers/market_mood_controller.dart ======\n
// lib/presentation/controllers/market_mood_controller.dart
// 🎮 Presentation Layer: Market Mood 컨트롤러 (리팩토링된 Provider에 맞춰 수정)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/utils/date_time.dart';
import '../pages/market_mood_page.dart';

/// 🎮 마켓무드 페이지 컨트롤러
class MarketMoodPageController extends StateNotifier<MarketMoodPageState> {
  final Ref _ref;

  MarketMoodPageController(this._ref) : super(MarketMoodPageState.initial()) {
    // [수정] 초기화 로직을 생성자에서 분리하여 명확하게 관리
    _initialize();
  }

  /// [수정] 초기화 및 실시간 리스닝 시작
  void _initialize() {
    // 1. 초기 상태 설정
    final initialState = _ref.read(marketMoodSystemProvider);
    state = state.copyWith(
      isLoading: initialState.isLoading,
      error: initialState.hasError ? '데이터 로딩 중 오류 발생' : null,
      systemState: initialState,
    );

    // 2. 실시간 상태 변화 감지 및 동기화
    //    이제 최종 상태인 marketMoodSystemProvider만 listen하면 됩니다.
    _ref.listen<MarketMoodSystemState>(
      marketMoodSystemProvider,
      (previous, next) {
        state = state.copyWith(
          isLoading: next.isLoading,
          error: next.hasError ? '데이터 로딩 중 오류 발생' : null,
          systemState: next,
        );
      },
    );
  }

  /// [수정] 데이터 로드 메서드 제거 -> _initialize()로 통합
  // Future<void> loadData() async { ... }

  /// 수동 새로고침
  void refresh() {
    // [수정] controller를 인스턴스 변수로 두지 않고 필요 시 read
    final controller = _ref.read(marketMoodControllerProvider);
    controller.refresh();
  }

  /// [수정] 현재 마켓무드 조회 (동기식으로 변경)
  MarketMood getCurrentMood() {
    // .when()을 사용할 필요 없이 직접 값을 반환합니다.
    return _ref.read(currentMarketMoodProvider);
  }

  /// 환율 조회 (Future 대응 - 이 부분은 변경 없음)
  Future<double> getExchangeRate() async {
    final exchangeAsync = _ref.read(exchangeRateProvider);
    return exchangeAsync.when(
      data: (rate) => rate,
      loading: () => 1400.0,
      error: (_, __) => 1400.0,
    );
  }

  /// [수정] 볼륨 비교 데이터 조회 (동기식으로 변경)
  ComparisonData getVolumeComparisons() {
    // .when()을 사용할 필요 없이 직접 값을 반환합니다.
    return _ref.read(volumeComparisonProvider);
  }

  /// 시스템 헬스체크
  Future<void> checkSystemHealth() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      final health = await controller.getSystemHealth();

      state = state.copyWith(
        systemHealth: health,
        lastHealthCheck: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// 환율 새로고침
  Future<void> refreshExchangeRate() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.refreshExchangeRate();
      // loadData() 대신 systemProvider가 자동으로 갱신하므로 별도 호출 불필요
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// 시스템 상태 로깅
  Future<void> logSystemStatus() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.logSystemStatus();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// 분위기 이모지 조회
  String getMoodEmoji(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => '🚀',
      MarketMood.weakBull => '🔥',
      MarketMood.sideways => '⚖️',
      MarketMood.bear => '💧',
      MarketMood.deepBear => '🧊',
    };
  }

  /// 분위기 이름 조회
  String getMoodName(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => '불장',
      MarketMood.weakBull => '약불장',
      MarketMood.sideways => '중간장',
      MarketMood.bear => '물장',
      MarketMood.deepBear => '얼음장',
    };
  }

  /// [수정] 분위기 요약 텍스트 조회 (동기식으로 변경)
  String getMoodSummary() {
    // .when()을 사용할 필요 없이 직접 값을 반환합니다.
    return _ref.read(marketMoodSummaryProvider);
  }

  /// 볼륨 포맷팅 (한국 원화)
  Future<String> formatVolume(double volumeUsd) async {
    final rate = await getExchangeRate();
    final volumeKrw = volumeUsd * rate;

    if (volumeKrw >= 1e12) {
      final trillions = (volumeKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}조원';
    }
    if (volumeKrw >= 1e8) {
      final hundreds = (volumeKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}억원';
    }
    return '${(volumeKrw / 1e8).toStringAsFixed(1)}억원';
  }

  /// 시가총액 포맷팅 (한국 원화)
  Future<String> formatMarketCap(double marketCapUsd) async {
    final rate = await getExchangeRate();
    // [수정] marketCapKrw 변수 선언
    final marketCapKrw = marketCapUsd * rate; 

    // [수정] volumeKrw -> marketCapKrw로 변경
    if (marketCapKrw >= 1e12) { 
      final trillions = (marketCapKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}조원';
    }
    // [수정] volumeKrw -> marketCapKrw로 변경
    if (marketCapKrw >= 1e8) {
      final hundreds = (marketCapKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}억원';
    }
    // [수정] volumeKrw -> marketCapKrw로 변경
    return '${(marketCapKrw / 1e8).toStringAsFixed(1)}억원';
  }

  /// 업데이트 시간 포맷팅
  String formatUpdateTime(DateTime updatedAt) {
    return updatedAt.hhmmss(); // DateTime extension 사용
  }

  /// 비교 결과 값 포맷팅
  String formatComparisonValue(ComparisonResult result) {
    if (result.isReady && result.changePercent != null) {
      final value = result.changePercent!;
      final arrow = value > 5 ? '↗️' : value < -5 ? '↘️' : '➡️';
      return '${value >= 0 ? '+' : ''}${value.toStringAsFixed(1)}% $arrow';
    }
    return '${(result.progressPercent * 100).round()}% (${result.status})';
  }

  /// 진행률 계산
  int getProgressPercent(ComparisonResult result) {
    return (result.progressPercent * 100).round();
  }

  /// 하이라이트 색상 판단
  bool isHighlight(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) > 5;
  }

  /// 경고 색상 판단
  bool isWarning(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) < -5;
  }

  /// [수정] 데이터 스트림 리스닝 메서드 제거 -> _initialize()로 통합
  // void startListening() { ... }

  /// 숫자에 콤마 추가
  String _addCommas(String numberStr) {
    final parts = numberStr.split('.');
    final integerPart = parts[0];
    final reversedInteger = integerPart.split('').reversed.join('');
    final withCommas = reversedInteger
        .replaceAllMapped(RegExp(r'.{3}'), (match) => '${match.group(0)},')
        .split('')
        .reversed
        .join('');
    final result =
        withCommas.startsWith(',') ? withCommas.substring(1) : withCommas;
    return parts.length > 1 ? '$result.${parts[1]}' : result;
  }
}

/// 🎮 마켓무드 페이지 상태
class MarketMoodPageState {
  final bool isLoading;
  final String? error;
  final MarketMoodSystemState? systemState;
  final Map<String, dynamic>? systemHealth;
  final DateTime? lastHealthCheck;

  const MarketMoodPageState({
    required this.isLoading,
    this.error,
    this.systemState,
    this.systemHealth,
    this.lastHealthCheck,
  });

  factory MarketMoodPageState.initial() {
    return const MarketMoodPageState(isLoading: true); // [수정] 초기 상태는 로딩중
  }

  MarketMoodPageState copyWith({
    bool? isLoading,
    String? error,
    MarketMoodSystemState? systemState,
    Map<String, dynamic>? systemHealth,
    DateTime? lastHealthCheck,
  }) {
    return MarketMoodPageState(
      isLoading: isLoading ?? this.isLoading,
      error: error, // [수정] null로 덮어쓰기 가능하도록 ?? this.error 제거
      systemState: systemState ?? this.systemState,
      systemHealth: systemHealth ?? this.systemHealth,
      lastHealthCheck: lastHealthCheck ?? this.lastHealthCheck,
    );
  }
}

/// 🎮 마켓무드 페이지 컨트롤러 Provider
final marketMoodPageControllerProvider = StateNotifierProvider.autoDispose<
    MarketMoodPageController, MarketMoodPageState>((ref) {
  // [수정] 컨트롤러 생성 시 바로 _initialize()가 호출되므로 별도 로직 불필요
  return MarketMoodPageController(ref);
});

/// 🎮 모달 오버레이 관리자 (실제 MarketMoodPage 사용)
class MarketMoodModalManager {
  static OverlayEntry? _overlayEntry;

  /// 모달 표시
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
    required MarketMoodData data,
  }) {
    hide(); // 기존 모달 제거

    _overlayEntry = OverlayEntry(
      builder: (context) => MarketMoodModalOverlay(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
        data: data,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// 모달 숨기기
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

/// 🎮 모달 오버레이 (실제 MarketMoodPage 사용)
class MarketMoodModalOverlay extends StatelessWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;
  final MarketMoodData data;

  const MarketMoodModalOverlay({
    super.key,
    required this.position,
    required this.statusIconSize,
    required this.ref,
    required this.data,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => MarketMoodModalManager.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // 투명 배경
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // 실제 MarketMoodPage 위젯
            Positioned(
              left: position.dx,
              top: position.dy,
              child: Consumer(
                builder: (context, ref, child) {
                  return MarketMoodPage(
                    statusIconSize: statusIconSize,
                    data: data,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/market_mood_page.dart ======\n
// lib/presentation/pages/market_mood_page.dart
// 📱 Presentation Layer: Market Mood 페이지 (모달 형태, 클린 아키텍처)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../controllers/market_mood_controller.dart';

/// 📱 마켓무드 상세 페이지 (모달 형태)
class MarketMoodPage extends ConsumerStatefulWidget {
  final double statusIconSize;
  final MarketMoodData data;

  const MarketMoodPage({
    super.key,
    required this.statusIconSize,
    required this.data,
  });

  @override
  ConsumerState<MarketMoodPage> createState() => _MarketMoodPageState();
}

class _MarketMoodPageState extends ConsumerState<MarketMoodPage>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _animationController.forward();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.5),
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          alignment: Alignment.center,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildPageContent(),
          ),
        );
      },
    );
  }

  Widget _buildPageContent() {
    // 화면 크기 계산
    final screenSize = MediaQuery.of(context).size;
    final maxWidth = screenSize.width * 0.9;

    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: widget.statusIconSize * 4.2,
          maxWidth: maxWidth,
        ),
        decoration: _buildContainerDecoration(),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              const SizedBox(height: 8),
              _buildCoreMetrics(),
              const SizedBox(height: 8),
              _buildIntradayAnalysis(),
              const SizedBox(height: 8),
              _buildLongTermAnalysis(),
            ],
          ),
        ),
      ),
    );
  }

  BoxDecoration _buildContainerDecoration() {
    return BoxDecoration(
      color: Theme.of(context).colorScheme.surface,
      borderRadius: BorderRadius.circular(16),
      boxShadow: [
        BoxShadow(
          // [수정] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.08),
          blurRadius: 16,
          offset: const Offset(0, 6),
          spreadRadius: 2,
        ),
        BoxShadow(
          // [수정] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.04),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        // [수정] withOpacity -> withValues
        color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
        width: 0.8,
      ),
    );
  }

  Widget _buildHeader() {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final updateTime = controller.formatUpdateTime(widget.data.updatedAt);

    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final currentMood = ref.watch(currentMarketMoodProvider);
            final moodEmoji = controller.getMoodEmoji(currentMood);
            final moodName = controller.getMoodName(currentMood);

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      moodEmoji,
                      style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '$moodName - 😄',
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w700,
                          color: Theme.of(context).colorScheme.onSurface,
                          letterSpacing: 0.3,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 9,
                      // [수정] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      '실시간 기준 • ',
                      style: TextStyle(
                        fontSize: 8,
                        fontWeight: FontWeight.w500,
                        // [수정] withOpacity -> withValues
                        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                      ),
                    ),
                    Icon(
                      Icons.access_time,
                      size: 9,
                      // [수정] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                    const SizedBox(width: 3),
                    Flexible(
                      child: Text(
                        '$updateTime 업데이트',
                        style: TextStyle(
                          fontSize: 8,
                          // [수정] withOpacity -> withValues
                          color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
          loading: () => _buildLoadingHeader(),
          error: (_, __) => _buildErrorHeader(),
        );
      },
    );
  }

  Widget _buildLoadingHeader() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 16, height: 16,
              child: CircularProgressIndicator(strokeWidth: 2)
            ),
            SizedBox(width: 8),
            Text(
              '로딩중...',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildErrorHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 12,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 4),
            Text(
              '데이터 로드 오류',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCoreMetrics() {
    return Consumer(
      builder: (context, ref, child) {
        final exchangeAsync = ref.watch(exchangeRateProvider);

        return exchangeAsync.when(
          data: (exchangeRate) => _buildCoreMetricsContent(exchangeRate),
          loading: () => _buildLoadingMetrics(),
          error: (_, __) => _buildCoreMetricsContent(1400.0),
        );
      },
    );
  }

  Widget _buildCoreMetricsContent(double exchangeRate) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    return FutureBuilder<List<String>>(
      future: Future.wait([
        controller.formatVolume(widget.data.totalVolumeUsd),
        controller.formatMarketCap(widget.data.totalMarketCapUsd),
      ]),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingMetrics();
        }
        if (snapshot.hasData) {
          final values = snapshot.data!;
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('핵심 지표', Icons.analytics),
              const SizedBox(height: 4),
              _buildStatRow(
                icon: Icons.monetization_on,
                label: '24시간 거래대금',
                value: values[0],
                isHighlight: true,
              ),
              _buildStatRow(
                icon: Icons.pie_chart,
                label: '총 시가총액',
                value: values[1],
              ),
              _buildStatRow(
                icon: Icons.trending_up,
                label: '시총 24시간 변화',
                value: '${widget.data.marketCapChange24h >= 0 ? '+' : ''}${widget.data.marketCapChange24h.toStringAsFixed(2)}%',
                isHighlight: widget.data.marketCapChange24h > 0,
                isWarning: widget.data.marketCapChange24h < -2,
              ),
              _buildStatRow(
                icon: Icons.flash_on,
                label: 'BTC 도미넌스',
                value: '${widget.data.btcDominance.toStringAsFixed(1)}%',
              ),
            ],
          );
        }
        return _buildLoadingMetrics();
      },
    );
  }

  Widget _buildLoadingMetrics() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle('핵심 지표', Icons.analytics),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildIntradayAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('인트라데이 비교 분석', Icons.schedule),
                const SizedBox(height: 4),
                _buildComparisonRow('30분 대비', comparisonData.thirtyMin, Icons.schedule),
                _buildComparisonRow('1시간 대비', comparisonData.oneHour, Icons.access_time),
                _buildComparisonRow('2시간 대비', comparisonData.twoHour, Icons.timer),
                _buildComparisonRow('4시간 대비', comparisonData.fourHour, Icons.timer_3),
                _buildComparisonRow('8시간 대비', comparisonData.eightHour, Icons.timer_outlined),
                _buildComparisonRow('12시간 대비', comparisonData.twelveHour, Icons.access_time_filled),
              ],
            );
          },
          loading: () => _buildLoadingSection('인트라데이 비교 분석', Icons.schedule),
          error: (_, __) => _buildErrorSection('인트라데이 비교 분석', Icons.schedule),
        );
      },
    );
  }

  Widget _buildLongTermAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('장기 비교 분석', Icons.calendar_month),
                const SizedBox(height: 4),
                _buildComparisonRow('24시간 대비', comparisonData.twentyFourHour, Icons.calendar_today),
                _buildComparisonRow('3일 평균 대비', comparisonData.threeDayAverage, Icons.view_day),
                _buildComparisonRow('일주일 평균 대비', comparisonData.weeklyAverage, Icons.date_range),
              ],
            );
          },
          loading: () => _buildLoadingSection('장기 비교 분석', Icons.calendar_month),
          error: (_, __) => _buildErrorSection('장기 비교 분석', Icons.calendar_month),
        );
      },
    );
  }

  Widget _buildLoadingSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildErrorSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        Text(
          '데이터 로드 오류',
          style: TextStyle(
            fontSize: 9,
            color: Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  Widget _buildComparisonRow(String label, ComparisonResult result, IconData icon) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    if (result.isReady && result.changePercent != null) {
      return _buildStatRow(
        icon: icon,
        label: label,
        value: controller.formatComparisonValue(result),
        isHighlight: controller.isHighlight(result),
        isWarning: controller.isWarning(result),
      );
    } else {
      return _buildProgressRow(icon, label, result);
    }
  }

  Widget _buildProgressRow(IconData icon, String label, ComparisonResult result) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final progressPercent = controller.getProgressPercent(result);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            // [수정] withOpacity -> withValues
            color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
          ),
          const SizedBox(width: 5),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '$label: $progressPercent% (${result.status})',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.w500,
                    // [수정] withOpacity -> withValues
                    color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: result.progressPercent.clamp(0.0, 1.0),
                  // [수정] withOpacity -> withValues
                  backgroundColor: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                  valueColor: AlwaysStoppedAnimation(
                    result.progressPercent >= 1.0
                      ? Colors.green
                      // [수정] withOpacity -> withValues
                      : Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
                  ),
                  minHeight: 3,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          // [수정] withOpacity -> withValues
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            // [수정] withOpacity -> withValues
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Colors.green;
      if (isWarning) return Colors.red;
      // [수정] withOpacity -> withValues
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight
            // [수정] withOpacity -> withValues
            ? Colors.green.withValues(alpha: 0.08)
            : isWarning
            // [수정] withOpacity -> withValues
            ? Colors.red.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              // [수정] withOpacity -> withValues
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}