\n\n// ====== lib/core/di/market_mood_provider copy.dart ======\n
\n\n// ====== lib/core/di/market_mood_provider.dart ======\n
// lib/core/di/market_mood_provider.dart
// ğŸš€ Performance Optimized Provider - ë©”ëª¨ì´ì œì´ì…˜, ë°°ì¹˜ì²˜ë¦¬, ì„ íƒì  ë¬´íš¨í™”, ì£¼ê¸°ì  ê°±ì‹  ì ìš©

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart'; // ğŸš€ debounceTime, distinctUntilChanged
import 'dart:async';

import '../network/api_client_coingecko.dart';
import '../utils/logger.dart';
import 'trade_provider.dart' show hiveServiceProvider;
import '../../data/datasources/market_mood_remote_ds.dart';
import '../../data/datasources/market_mood_local_ds.dart';
import '../../data/repositories/market_mood_repository_impl.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/usecases/market_mood_usecase.dart';

/// ğŸŒ CoinGecko API í´ë¼ì´ì–¸íŠ¸ Provider
final coinGeckoApiClientProvider = Provider<CoinGeckoApiClient>((ref) {
  return CoinGeckoApiClient();
});

/// ğŸ”¥ Remote DataSource Provider
final marketMoodRemoteDSProvider = Provider<MarketMoodRemoteDataSource>((ref) {
  final client = ref.read(coinGeckoApiClientProvider);
  return MarketMoodRemoteDataSource(client);
});

/// ğŸ”¥ Local DataSource Provider
final marketMoodLocalDSProvider = Provider<MarketMoodLocalDataSource>((ref) {
  final hive = ref.watch(hiveServiceProvider);
  return MarketMoodLocalDataSource(hive);
});

/// ğŸ”¥ Repository Provider
final marketMoodRepositoryProvider = Provider<MarketMoodRepositoryImpl>((ref) {
  final remoteDS = ref.read(marketMoodRemoteDSProvider);
  final localDS = ref.read(marketMoodLocalDSProvider);
  return MarketMoodRepositoryImpl(remoteDS, localDS);
});

/// ğŸ”¥ UseCase Provider
final marketMoodUsecaseProvider = Provider<MarketMoodUsecase>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);
  return MarketMoodUsecase(repository);
});

/// ğŸš€ ë©”ëª¨ì´ì œì´ì…˜ëœ í™˜ìœ¨ Provider - ìºì‹œ ìœ ì§€ (TTL í•„ìš” ì‹œ autoDisposeë¡œ ë³€ê²½)
final exchangeRateProvider = FutureProvider.autoDispose<double>((ref) async {
  final usecase = ref.read(marketMoodUsecaseProvider);
  try {
    final rate = await usecase.getExchangeRate();
    log.d('í™˜ìœ¨ ì¡°íšŒ ì„±ê³µ: $rate (ìºì‹œë¨)');
    return rate;
  } catch (e, st) {
    log.w('í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ 1400 ì‚¬ìš©: $e', e, st);
    return 1400.0;
  }
});

/// ğŸš€ ìµœì í™”ëœ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ - distinct + debounceTime ì ìš©
final marketMoodProvider = StreamProvider<MarketMoodData>((ref) {
  final repository = ref.read(marketMoodRepositoryProvider);

  ref.onDispose(repository.dispose);

  return repository
      .getMarketDataStream()
      .distinct((prev, next) => prev.totalVolumeUsd == next.totalVolumeUsd)
      .debounceTime(const Duration(milliseconds: 100));
});

/// ğŸš€ í†µí•© ê³„ì‚° Provider - ì£¼ê¸°ì  ê°±ì‹  ë° í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ìë™ invalidate ì ìš©
final marketMoodComputedDataProvider = FutureProvider.autoDispose<MarketMoodComputedData>((ref) async {
  // 1) autoDispose ë¹„í™œì„±í™” ë§í¬ (keepAlive)
  final link = ref.keepAlive();

  // 2) 15ë¶„ë§ˆë‹¤ ì¬ê³„ì‚°
  final timer = Timer.periodic(const Duration(minutes: 15), (_) {
    ref.invalidateSelf();
  });

  // 3) ì•± ë³µê·€ ì‹œ ì¬ê³„ì‚°
  ref.onResume(() {
    ref.invalidateSelf();
  });

  // 4) ì¢…ë£Œ ì‹œ ì •ë¦¬
  ref.onDispose(() {
    timer.cancel();
    link.close();
  });

  // ê¸°ì¡´ ë¡œì§
  final moodAsync = ref.watch(marketMoodProvider);
  final exchangeAsync = ref.watch(exchangeRateProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return moodAsync.when(
    data: (marketData) async {
      final exchangeRate = exchangeAsync.asData?.value ?? 1400.0;
      try {
        final results = await Future.wait(
          [
            usecase.calculateCurrentMood(marketData.totalVolumeUsd),
            usecase.calculateVolumeComparison(marketData.totalVolumeUsd),
          ],
          eagerError: false,
        );
        final currentMood = results[0] as MarketMood;
        final volumeComparison = results[1] as ComparisonData;
        final moodSummary = usecase.generateMoodSummary(currentMood);

        return MarketMoodComputedData(
          marketData: marketData,
          currentMood: currentMood,
          volumeComparison: volumeComparison,
          moodSummary: moodSummary,
          exchangeRate: exchangeRate,
          computedAt: DateTime.now(),
        );
      } catch (e, st) {
        // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
        log.e('ë°°ì¹˜ ê³„ì‚° ì˜¤ë¥˜: $e', e, st);
        return MarketMoodComputedData.error();
      }
    },
    loading: () async => MarketMoodComputedData.loading(),
    error: (error, stack) async {
      // [ìˆ˜ì •ë¨] ì´ë¦„ ìˆëŠ” íŒŒë¼ë¯¸í„°(named parameter) ëŒ€ì‹  ìœ„ì¹˜ ê¸°ë°˜ íŒŒë¼ë¯¸í„°(positional parameter) ì‚¬ìš©
      log.e('ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ì˜¤ë¥˜: $error', error, stack);
      return MarketMoodComputedData.error();
    },
  );
});

/// ğŸ¯ ê°œë³„ ë°ì´í„° ì ‘ê·¼ Providerë“¤ - ë©”ëª¨ì´ì œì´ì…˜ëœ ê²°ê³¼ì—ì„œ ì¶”ì¶œ
final currentMarketMoodProvider = Provider<MarketMood>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.currentMood,
    loading: () => MarketMood.sideways,
    error: (_, __) => MarketMood.sideways,
  );
});

final volumeComparisonProvider = Provider<ComparisonData>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.volumeComparison,
    loading: () => ComparisonData.loading(),
    error: (_, __) => ComparisonData.error(),
  );
});

final marketMoodSummaryProvider = Provider<String>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  return computedAsync.when(
    data: (computed) => computed.moodSummary,
    loading: () => 'ë¡œë”©ì¤‘...',
    error: (_, __) => 'ì˜¤ë¥˜ ë°œìƒ',
  );
});

/// ğŸŒ ìµœì í™”ëœ ì‹œìŠ¤í…œ ìƒíƒœ Provider
final marketMoodSystemProvider = Provider<MarketMoodSystemState>((ref) {
  final computedAsync = ref.watch(marketMoodComputedDataProvider);
  final usecase = ref.read(marketMoodUsecaseProvider);

  return computedAsync.when(
    data: (computed) => usecase.createSystemState(
      marketData: computed.marketData,
      comparisonData: computed.volumeComparison,
      currentMood: computed.currentMood,
      exchangeRate: computed.exchangeRate,
      isLoading: false,
      hasError: false,
    ),
    loading: () => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.loading(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: true,
      hasError: false,
    ),
    error: (_, __) => usecase.createSystemState(
      marketData: null,
      comparisonData: ComparisonData.error(),
      currentMood: MarketMood.sideways,
      exchangeRate: 1400.0,
      isLoading: false,
      hasError: true,
    ),
  );
});

/// ğŸ® ìµœì í™”ëœ ë§ˆì¼“ ë¬´ë“œ ì»¨íŠ¸ë¡¤ëŸ¬
final marketMoodControllerProvider = Provider((ref) => OptimizedMarketMoodController(ref));

class OptimizedMarketMoodController {
  final Ref ref;
  DateTime? _lastRefresh;
  static const _refreshCooldown = Duration(seconds: 30);

  OptimizedMarketMoodController(this.ref);

  /// ğŸš€ ìŠ¤ë§ˆíŠ¸ ìƒˆë¡œê³ ì¹¨ - ì¿¨ë‹¤ìš´ ì ìš©
  void refresh() {
    final now = DateTime.now();
    if (_lastRefresh != null && now.difference(_lastRefresh!) < _refreshCooldown) {
      // [ìˆ˜ì •ë¨] + ì—°ì‚°ì ëŒ€ì‹  ì¸ì ‘ ë¬¸ìì—´ ì—°ê²° ì‚¬ìš©
      log.d('ìƒˆë¡œê³ ì¹¨ ì¿¨ë‹¤ìš´ ì¤‘... '
          '${_refreshCooldown.inSeconds - now.difference(_lastRefresh!).inSeconds}ì´ˆ í›„ ê°€ëŠ¥');
      return;
    }

    _lastRefresh = now;
    ref.invalidate(marketMoodProvider);
    ref.invalidate(exchangeRateProvider);
    log.d('ë§ˆì¼“ë¬´ë“œ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ìºì‹œëœ í˜„ì¬ ë¬´ë“œ ì¡°íšŒ
  MarketMood getCurrentMood() => ref.read(currentMarketMoodProvider);

  /// ğŸš€ ìºì‹œëœ ë¹„êµ ë°ì´í„° ì¡°íšŒ
  ComparisonData getComparisonData() => ref.read(volumeComparisonProvider);

  /// ğŸš€ í™˜ìœ¨ë§Œ ì„ íƒì  ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    await usecase.refreshExchangeRate();
    ref.invalidate(exchangeRateProvider);
    log.d('í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ');
  }

  /// ğŸš€ ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ (ìºì‹œ í™œìš©)
  Future<Map<String, dynamic>> getSystemHealth() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final state = ref.read(marketMoodSystemProvider);
    return {
      ...await usecase.getSystemHealth(),
      'cached_state': {
        'is_loading': state.isLoading,
        'has_error': state.hasError,
        'last_update': state.marketData?.updatedAt.toIso8601String(),
      }
    };
  }

  /// ğŸš€ ì„±ëŠ¥ í†µê³„ ë¡œê¹…
  Future<void> logSystemStatus() async {
    final usecase = ref.read(marketMoodUsecaseProvider);
    final computedAsync = ref.read(marketMoodComputedDataProvider);
    await usecase.logSystemStatus();
    computedAsync.whenData((computed) {
      log.i('ì„±ëŠ¥ í†µê³„ - ê³„ì‚° ì‹œê°„: ${DateTime.now().difference(computed.computedAt).inMilliseconds}ms');
    });
  }

  /// ğŸš€ ë©”ëª¨ë¦¬ ì •ë¦¬ (í•„ìš” ì‹œ í˜¸ì¶œ)
  void clearCache() {
    ref.invalidate(marketMoodComputedDataProvider);
    ref.invalidate(exchangeRateProvider);
    ref.invalidate(marketMoodProvider);
    log.d('ìºì‹œ ì •ë¦¬ ì™„ë£Œ');
  }
}

/// ğŸš€ í†µí•© ê³„ì‚° ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤
class MarketMoodComputedData {
  final MarketMoodData? marketData;
  final MarketMood currentMood;
  final ComparisonData volumeComparison;
  final String moodSummary;
  final double exchangeRate;
  final DateTime computedAt;

  const MarketMoodComputedData({
    this.marketData,
    required this.currentMood,
    required this.volumeComparison,
    required this.moodSummary,
    required this.exchangeRate,
    required this.computedAt,
  });

  factory MarketMoodComputedData.loading() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.loading(),
        moodSummary: 'ë¡œë”©ì¤‘...',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  factory MarketMoodComputedData.error() => MarketMoodComputedData(
        currentMood: MarketMood.sideways,
        volumeComparison: ComparisonData.error(),
        moodSummary: 'ì˜¤ë¥˜ ë°œìƒ',
        exchangeRate: 1400.0,
        computedAt: DateTime.now(),
      );

  /// ğŸš€ ë°ì´í„° ì‹ ì„ ë„ ì²´í¬ (15ë¶„ ì´ìƒ ì˜¤ë˜ë˜ë©´ ê°±ì‹  í•„ìš”)
  bool get isStale => DateTime.now().difference(computedAt) > const Duration(minutes: 15);

  /// ğŸš€ ì„±ëŠ¥ ë©”íŠ¸ë¦­
  Duration get age => DateTime.now().difference(computedAt);
}\n\n// ====== lib/shared/widgets/market_mood_modal.dart ======\n
\n\n// ====== lib/shared/widgets/market_mood_indicator.dart ======\n
// lib/shared/widgets/market_mood_indicator.dart
// ğŸ¨ Shared Widget: Market Mood ì¸ë””ì¼€ì´í„° (í´ë¦° ì•„í‚¤í…ì²˜ ì™„ì „ ëŒ€ì‘)

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../presentation/controllers/market_mood_controller.dart';

/// ğŸ¨ ë©”ì¸ ë§ˆì¼“ë¬´ë“œ ì¸ë””ì¼€ì´í„° ìœ„ì ¯
class MarketMoodIndicator extends ConsumerWidget {
  final double size;
  final bool showTooltip;
  final EdgeInsets? padding;

  const MarketMoodIndicator({
    Key? key,
    this.size = 16,
    this.showTooltip = false,
    this.padding,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // [ìˆ˜ì •] ì¤‘ì•™ ê³„ì‚° Providerë¥¼ watchí•˜ì—¬ ë¡œë”©/ì—ëŸ¬/ë°ì´í„° ìƒíƒœë¥¼ í•œ ë²ˆì— ì²˜ë¦¬í•©ë‹ˆë‹¤.
    final computedAsync = ref.watch(marketMoodComputedDataProvider);
    
    Widget indicator = computedAsync.when(
      data: (computed) {
        // [ìˆ˜ì •] marketDataê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ì´ˆê¸° ìƒíƒœì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ null ì²´í¬ ì¶”ê°€
        if (computed.marketData == null) {
          return _buildLoadingIcon();
        }
        // [ìˆ˜ì •] computed ê°ì²´ì—ì„œ í•„ìš”í•œ marketDataì™€ currentMoodë¥¼ ì§ì ‘ ê°€ì ¸ì˜µë‹ˆë‹¤.
        return _buildMoodIcon(context, ref, computed.marketData!, computed.currentMood);
      },
      loading: () => _buildLoadingIcon(),
      error: (_, __) => _buildErrorIcon(),
    );
    
    if (padding != null) {
      indicator = Padding(padding: padding!, child: indicator);
    }
    
    return indicator;
  }

  Widget _buildMoodIcon(BuildContext context, WidgetRef ref, MarketMoodData data, MarketMood mood) {
    Widget moodIcon = _getMoodIcon(mood);
    
    // ë¡±í”„ë ˆìŠ¤ ì œìŠ¤ì²˜ ì¶”ê°€
    return GestureDetector(
      onLongPressStart: (details) => _showMarketMoodModal(context, ref, details.globalPosition, data),
      onLongPressEnd: (_) => _hideMarketMoodModal(),
      onLongPressCancel: () => _hideMarketMoodModal(),
      child: moodIcon,
    );
  }

  Widget _buildLoadingIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.refresh,
      color: Colors.grey,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë”© ì¤‘...' : null,
      animationType: MoodAnimationType.rotate,
      size: size,
    );
  }

  Widget _buildErrorIcon() {
    return _AnimatedMoodIcon(
      icon: Icons.error_outline,
      color: Colors.red,
      tooltip: showTooltip ? 'ì‹œì¥ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨' : null,
      animationType: MoodAnimationType.blink,
      size: size,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ í‘œì‹œ - ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
void _showMarketMoodModal(BuildContext context, WidgetRef ref, Offset globalPosition, MarketMoodData data) {
  if (ref.read(appSettingsProvider).isHapticEnabled) {
    HapticFeedback.mediumImpact();
  }
  Tooltip.dismissAllToolTips();
    
    // í™”ë©´ í¬ê¸°ì™€ ëª¨ë‹¬ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final modalWidth = screenSize.width * 0.9; // 90% ë„ˆë¹„ ì‚¬ìš©
    
    // í™”ë©´ ê²½ê³„ ê³ ë ¤í•œ ìœ„ì¹˜ ê³„ì‚°
    double adjustedX = globalPosition.dx - (modalWidth / 2); // ì¤‘ì•™ ì •ë ¬
    double adjustedY = globalPosition.dy + size + 40; // ğŸ”¥ ë¬´ì¡°ê±´ ì•„ë˜ìª½ìœ¼ë¡œ (ìœ„ìª½ ê³„ì‚° ì œê±°)
    
    // ì¢Œì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX < 16) {
      adjustedX = 16;
    }
    
    // ìš°ì¸¡ ê²½ê³„ ì²´í¬
    if (adjustedX + modalWidth > screenSize.width - 16) {
      adjustedX = screenSize.width - modalWidth - 16;
    }
    
    // í•˜ë‹¨ ê²½ê³„ ì²´í¬ - í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ìœ„ë¡œ ì¡°ì •
    final bottomSafeArea = MediaQuery.of(context).padding.bottom;
    final maxY = screenSize.height - bottomSafeArea - 300; // ëª¨ë‹¬ ìµœì†Œ ë†’ì´ ê³ ë ¤
    if (adjustedY > maxY) {
      adjustedY = globalPosition.dy - 250; // ì¶©ë¶„íˆ ìœ„ë¡œ ì˜¬ë ¤ì„œ í‘œì‹œ
    }
    
    final adjustedPosition = Offset(adjustedX, adjustedY);
    
    // ì»¨íŠ¸ë¡¤ëŸ¬ì˜ MarketMoodModalManager ì‚¬ìš©
    MarketMoodModalManager.show(
      context: context,
      ref: ref,
      position: adjustedPosition,
      statusIconSize: size,
      data: data,
    );
  }

  /// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  void _hideMarketMoodModal() {
    MarketMoodModalManager.hide();
  }

  Widget _getMoodIcon(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull:
        return _AnimatedMoodIcon(
          icon: Icons.rocket_launch,
          color: const Color(0xFFFF6B35), // ğŸš€ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸš€ ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +15% ì´ìƒ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fastPulse,
          size: size,
        );
        
      case MarketMood.weakBull:
        return _AnimatedMoodIcon(
          icon: Icons.local_fire_department,
          color: const Color(0xFFFF6B35), // ğŸ”¥ í™”ì—¼ ì˜¤ë Œì§€-ë ˆë“œ í†¤
          tooltip: showTooltip ? 'ğŸ”¥ ì•½ë¶ˆì¥ - 30ë¶„ ì „ ëŒ€ë¹„ +5~15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.fireFlicker,
          size: size,
        );
        
      case MarketMood.sideways:
        return _AnimatedMoodIcon(
          icon: Icons.balance,
          color: const Color(0xFF757575), // âš–ï¸ ì¤‘ì„± íšŒìƒ‰
          tooltip: showTooltip ? 'âš–ï¸ ì¤‘ê°„ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~+5% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.wiggle,
          size: size,
        );
        
      case MarketMood.bear:
        return _AnimatedMoodIcon(
          icon: Icons.water_drop,
          color: const Color(0xFF4A90E2), // ğŸ’§ ë¬¼ë°©ìš¸ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ’§ ë¬¼ì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -5~-15% (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.waterDrop,
          size: size,
        );
        
      case MarketMood.deepBear:
        return _AnimatedMoodIcon(
          icon: Icons.ac_unit,
          color: const Color(0xFF4A90E2), // ğŸ§Š ì–¼ìŒì¥ ë¸”ë£¨ í†¤
          tooltip: showTooltip ? 'ğŸ§Š ì–¼ìŒì¥ - 30ë¶„ ì „ ëŒ€ë¹„ -15% ì´í•˜ (ë¡±í”„ë ˆìŠ¤: ìƒì„¸ì •ë³´)' : null,
          animationType: MoodAnimationType.coldShiver,
          size: size,
        );
    }
  }
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì… enum
enum MoodAnimationType { 
  none, 
  fastPulse, 
  fireFlicker, 
  wiggle, 
  waterDrop, 
  coldShiver, 
  rotate, 
  blink 
}

/// ğŸ¨ ì• ë‹ˆë©”ì´ì…˜ ì•„ì´ì½˜ ìœ„ì ¯
class _AnimatedMoodIcon extends StatefulWidget {
  final IconData icon;
  final Color color;
  final String? tooltip;
  final MoodAnimationType animationType;
  final double size;

  const _AnimatedMoodIcon({
    required this.icon,
    required this.color,
    required this.animationType,
    required this.size,
    this.tooltip,
  });

  @override
  State<_AnimatedMoodIcon> createState() => _AnimatedMoodIconState();
}

class _AnimatedMoodIconState extends State<_AnimatedMoodIcon>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _setupAnimation();
  }

  void _setupAnimation() {
    switch (widget.animationType) {
      case MoodAnimationType.fastPulse:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.6, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.fireFlicker:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 600),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.7, end: 1.3).animate(
          CurvedAnimation(parent: _controller, curve: Curves.elasticOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.wiggle:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2000),
          vsync: this,
        );
        _animation = Tween<double>(begin: -0.15, end: 0.15).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.waterDrop:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 2500),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.85, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.coldShiver:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 150),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.95, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.linear),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.rotate:
        _controller = AnimationController(
          duration: const Duration(seconds: 1),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0, end: 1).animate(_controller);
        _controller.repeat();
        break;
        
      case MoodAnimationType.blink:
        _controller = AnimationController(
          duration: const Duration(milliseconds: 800),
          vsync: this,
        );
        _animation = Tween<double>(begin: 0.3, end: 1.0).animate(
          CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
        );
        _controller.repeat(reverse: true);
        break;
        
      case MoodAnimationType.none:
        _controller = AnimationController(vsync: this);
        _animation = const AlwaysStoppedAnimation(1.0);
        break;
    }
  }

  @override
  void didUpdateWidget(_AnimatedMoodIcon oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.animationType != widget.animationType) {
      _controller.dispose();
      _setupAnimation();
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget iconWidget = AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        Widget icon = Icon(
          widget.icon,
          color: widget.color,
          size: widget.size,
        );

        switch (widget.animationType) {
          case MoodAnimationType.fastPulse:
            return Transform.translate(
              offset: Offset(0, (_animation.value - 1) * 2),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.5, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.fireFlicker:
            return Transform.scale(
              scale: _animation.value,
              child: Transform.rotate(
                angle: (_animation.value - 1) * 0.1,
                child: Opacity(
                  opacity: (_animation.value * 0.8 + 0.2).clamp(0.4, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.wiggle:
            return Transform.rotate(
              angle: _animation.value,
              child: Transform.scale(
                scale: 0.95 + (_animation.value.abs() * 0.1),
                child: icon,
              ),
            );
            
          case MoodAnimationType.waterDrop:
            return Transform.translate(
              offset: Offset(0, (1 - _animation.value) * 1.5),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.6, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.coldShiver:
            return Transform.translate(
              offset: Offset(
                (_animation.value - 0.975) * 40,
                (_animation.value - 0.975) * 20,
              ),
              child: Transform.scale(
                scale: _animation.value,
                child: Opacity(
                  opacity: _animation.value.clamp(0.8, 1.0),
                  child: icon,
                ),
              ),
            );
            
          case MoodAnimationType.rotate:
            return Transform.rotate(
              angle: _animation.value * 2 * 3.14159,
              child: icon,
            );
            
          case MoodAnimationType.blink:
            return Transform.scale(
              scale: _animation.value,
              child: Opacity(
                opacity: _animation.value.clamp(0.3, 1.0),
                child: icon,
              ),
            );
            
          case MoodAnimationType.none:
            return icon;
        }
      },
    );

    if (widget.tooltip != null) {
      return Tooltip(
        message: widget.tooltip!,
        preferBelow: false,
        verticalOffset: 20,
        waitDuration: const Duration(milliseconds: 500),
        showDuration: const Duration(seconds: 3),
        decoration: BoxDecoration(
          color: Colors.black87,
          borderRadius: BorderRadius.circular(8),
        ),
        textStyle: const TextStyle(
          fontSize: 11,
          color: Colors.white,
        ),
        child: iconWidget,
      );
    }
    
    return iconWidget;
  }
}\n\n// ====== lib/data/datasources/market_mood_remote_ds.dart ======\n
// lib/data/datasources/market_mood_remote_ds.dart
// ğŸŒ Data Layer: ì›ê²© ë°ì´í„° ì†ŒìŠ¤ (ì•ˆì •ì„±ì´ ê²€ì¦ëœ Timer ë°©ì‹ìœ¼ë¡œ ë³µì›)

import 'dart:async';
import '../../core/network/api_client_coingecko.dart';
import '../../core/utils/logger.dart';
import '../../data/models/market_mood_dto.dart';

/// ğŸŒ ë§ˆì¼“ë¬´ë“œ ì›ê²© ë°ì´í„° ì†ŒìŠ¤
class MarketMoodRemoteDataSource {
  final CoinGeckoApiClient _apiClient;
  Timer? _globalDataTimer;
  StreamController<CoinGeckoGlobalDataDto>? _globalDataController;

  MarketMoodRemoteDataSource(this._apiClient);

  Stream<CoinGeckoGlobalDataDto> getGlobalMarketDataStream() {
    // ì´ë¯¸ ìŠ¤íŠ¸ë¦¼ì´ í™œì„±í™”ëœ ê²½ìš° ì¬ì‚¬ìš©
    if (_globalDataController != null && !_globalDataController!.isClosed) {
      return _globalDataController!.stream;
    }
    
    _globalDataController = StreamController<CoinGeckoGlobalDataDto>.broadcast();
    
    Future<void> fetch() async {
      try {
        final responseDto = await _apiClient.getGlobalMarketData();
        final dataDto = responseDto.data;

        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.add(dataDto);
          log.d('ğŸ“Š ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìˆ˜ì‹  ì„±ê³µ (Timer): ${dataDto.totalVolumeUsd.toStringAsFixed(0)}B USD');
        }
      } catch (e, st) {
        if (_globalDataController != null && !_globalDataController!.isClosed) {
          _globalDataController!.addError(e, st);
          log.e('âŒ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ (Timer): $e');
        }
      }
    }

    // ì²« í˜¸ì¶œ
    fetch();

    // 30ë¶„ë§ˆë‹¤ í˜¸ì¶œ
    _globalDataTimer = Timer.periodic(const Duration(minutes: 30), (_) => fetch());

    _globalDataController!.onCancel = () {
      _globalDataTimer?.cancel();
      _globalDataTimer = null;
      log.d('ğŸ”„ ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë„ˆ ì—†ìŒ. íƒ€ì´ë¨¸ ì¤‘ì§€.');
    };

    return _globalDataController!.stream;
  }

  Future<CoinGeckoGlobalDataDto> getGlobalMarketData() async {
    final responseDto = await _apiClient.getGlobalMarketData();
    return responseDto.data;
  }

  Future<double> getUsdToKrwRate() async {
    return _apiClient.getUsdToKrwRate();
  }

  Future<bool> checkApiHealth() async {
    try {
      await getGlobalMarketData();
      return true;
    } catch (_) {
      return false;
    }
  }

  void dispose() {
    _globalDataTimer?.cancel();
    _globalDataTimer = null;
    _globalDataController?.close();
    _globalDataController = null;
    log.d('ğŸ§¹ MarketMoodRemoteDataSource ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/datasources/market_mood_local_ds.dart ======\n
// lib/data/datasources/market_mood_local_ds.dart
// ğŸ’¾ Data Layer: ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤ (Hive ê¸°ë°˜, DI íŒ¨í„´)

import 'package:hive_flutter/hive_flutter.dart';
import '../../core/services/hive_service.dart';
import '../../core/utils/logger.dart';
import '../models/market_mood_dto.dart'; // ğŸ”¥ TimestampedVolumeì´ ì—¬ê¸° ìˆìŒ

/// ğŸ’¾ ë§ˆì¼“ë¬´ë“œ ë¡œì»¬ ë°ì´í„° ì†ŒìŠ¤
/// HiveServiceë¥¼ í†µí•œ ë³¼ë¥¨ ë°ì´í„° ì €ì¥/ì¡°íšŒ, í™˜ìœ¨ ìºì‹± (DI íŒ¨í„´)
class MarketMoodLocalDataSource {
  final HiveService _hiveService;
  
  static const String _exchangeRateKey = 'exchange_rate';
  static const String _appStartTimeKey = 'app_start_time';

  MarketMoodLocalDataSource(this._hiveService);

  /// Volume Box ì ‘ê·¼
  Box<TimestampedVolume> get _volumeBox => _hiveService.marketMoodVolumeBox;
  
  /// Cache Box ì ‘ê·¼ 
  Box get _cacheBox => _hiveService.marketMoodCacheBox;

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ ìŠ¬ë¡¯)
  Future<void> addVolumeData(TimestampedVolume volume) async {
    try {
      // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”ëœ í‚¤ ìƒì„±
      final slotKey = _getSlotKey(volume.timestamp);
      
      await _volumeBox.put(slotKey, volume);
      log.d('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥: $slotKey -> ${volume.volumeUsd.toStringAsFixed(0)}B');
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<TimestampedVolume?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final targetTime = DateTime.now().subtract(Duration(minutes: minutes));
      final slotKey = _getSlotKey(targetTime);
      
      final volume = _volumeBox.get(slotKey);
      if (volume != null) {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì„±ê³µ: ${volume.volumeUsd.toStringAsFixed(0)}B');
      } else {
        log.d('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì—†ìŒ');
      }
      
      return volume;
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days) async {
    try {
      final now = DateTime.now();
      final cutoffTime = now.subtract(Duration(days: days));
      
      final volumes = _volumeBox.values
          .where((volume) => volume.timestamp.isAfter(cutoffTime))
          .map((volume) => volume.volumeUsd)
          .toList();
      
      if (volumes.isEmpty) {
        log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ë°ì´í„° ì—†ìŒ');
        return null;
      }
      
      final average = volumes.reduce((a, b) => a + b) / volumes.length;
      log.d('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨: ${average.toStringAsFixed(0)}B (${volumes.length}ê°œ ë°ì´í„°)');
      
      return average;
    } catch (e, st) {
      log.e('ğŸ“Š $daysì¼ í‰ê·  ë³¼ë¥¨ ê³„ì‚° ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount() async {
    try {
      final count = _volumeBox.length;
      log.d('ğŸ“Š ì´ ë°ì´í„° ê°œìˆ˜: $count');
      return count;
    } catch (e, st) {
      log.e('ğŸ“Š ë°ì´í„° ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return 0;
    }
  }

  /// ëˆ„ë½ëœ 30ë¶„ ìŠ¬ë¡¯ í™•ì¸ ë° ë³´ì •
  Future<void> checkAndFillMissingSlots() async {
    try {
      final appStartTime = getAppStartTime();
      final now = DateTime.now();
      final totalMinutes = now.difference(appStartTime).inMinutes;
      final expectedSlots = (totalMinutes / 30).floor();
      
      log.i('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬: ì˜ˆìƒ $expectedSlotsê°œ, ì‹¤ì œ ${_volumeBox.length}ê°œ');
      
      if (_volumeBox.length < expectedSlots) {
        final missing = expectedSlots - _volumeBox.length;
        log.w('âš ï¸ $missingê°œ ìŠ¬ë¡¯ ëˆ„ë½ ê°ì§€');
        // ì‹¤ì œ ë³´ì • ë¡œì§ì€ í•„ìš” ì‹œ êµ¬í˜„
      }
    } catch (e, st) {
      log.e('ğŸ”„ ìŠ¬ë¡¯ ì²´í¬ ì‹¤íŒ¨', e, st);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’± í™˜ìœ¨ ìºì‹±
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// í™˜ìœ¨ ìºì‹œ ì €ì¥
  Future<void> cacheExchangeRate(double rate) async {
    try {
      await _cacheBox.put(_exchangeRateKey, {
        'rate': rate,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      });
      log.d('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìºì‹œ ì €ì¥ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ (12ì‹œê°„ ìœ íš¨)
  Future<double?> getCachedExchangeRate() async {
    try {
      final cached = _cacheBox.get(_exchangeRateKey);
      if (cached == null) return null;
      
      final timestamp = DateTime.fromMillisecondsSinceEpoch(cached['timestamp']);
      final rate = cached['rate'] as double;
      
      // 12ì‹œê°„ ì´ë‚´ì¸ì§€ í™•ì¸ (Providerì™€ ë™ì¼í•œ ìºì‹œ ì •ì±…)
      if (DateTime.now().difference(timestamp).inHours < 12) {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì‚¬ìš©: $rate KRW');
        return rate;
      } else {
        log.d('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ë§Œë£Œ');
        return null;
      }
    } catch (e, st) {
      log.e('ğŸ’± ìºì‹œëœ í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ•°ï¸ ì‹œê°„ ê´€ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime() {
    try {
      final cached = _cacheBox.get(_appStartTimeKey);
      if (cached != null) {
        return cached as DateTime;
      }
      
      // ìµœì´ˆ ì‹¤í–‰ ì‹œ í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      final now = DateTime.now();
      _cacheBox.put(_appStartTimeKey, now);
      log.i('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì„¤ì •: ${now.toIso8601String()}');
      return now;
    } catch (e, st) {
      log.e('ğŸ•°ï¸ ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return DateTime.now(); // fallback
    }
  }

  /// 30ë¶„ ìŠ¬ë¡¯ í‚¤ ìƒì„± (ì •ê·œí™”)
  String _getSlotKey(DateTime timestamp) {
    // 30ë¶„ ë‹¨ìœ„ë¡œ ì •ê·œí™”: ì˜ˆ) 14:23 -> 14:00, 14:47 -> 14:30
    final normalized = DateTime(
      timestamp.year,
      timestamp.month,
      timestamp.day,
      timestamp.hour,
      (timestamp.minute ~/ 30) * 30, // 30ë¶„ ë‹¨ìœ„ë¡œ ë‚´ë¦¼
    );
    
    return normalized.toIso8601String();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ ìœ í‹¸ë¦¬í‹°
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// ë””ë²„ê¹…ìš© ì •ë³´ ë°˜í™˜
  Map<String, Object> getDebugInfo() {
    try {
      final volumeInfo = {
        'total_count': _volumeBox.length,
        'box_open': _volumeBox.isOpen,
        'first_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.first.timestamp.toIso8601String() 
            : 'none',
        'last_entry': _volumeBox.isNotEmpty 
            ? _volumeBox.values.last.timestamp.toIso8601String() 
            : 'none',
      };
      
      final cacheInfo = {
        'cache_keys': _cacheBox.keys.toList(),
        'app_start_time': getAppStartTime().toIso8601String(),
        'has_exchange_rate': _cacheBox.containsKey(_exchangeRateKey),
        'box_open': _cacheBox.isOpen,
      };

      return {
        'volume_storage': volumeInfo,
        'cache_storage': cacheInfo,
        'hive_service': 'injected',
        'status': 'healthy',
      };
    } catch (e) {
      return {
        'status': 'error',
        'error': e.toString(),
      };
    }
  }

  /// ìƒíƒœ ë¡œê¹…
  void logStatus() {
    final info = getDebugInfo();
    log.i('ğŸ’¾ MarketMoodLocalDataSource ìƒíƒœ: $info');
  }

  /// ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    try {
      // HiveServiceê°€ Box ê´€ë¦¬í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì •ë¦¬ ì•ˆí•¨
      log.i('ğŸ§¹ MarketMoodLocalDataSource ì •ë¦¬ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', e, st);
    }
  }

  /// ê°œë°œìš©: ëª¨ë“  ë°ì´í„° ì‚­ì œ
  Future<void> clearAllData() async {
    try {
      await _volumeBox.clear();
      await _cacheBox.clear();
      log.w('ğŸ—‘ï¸ ëª¨ë“  ë¡œì»¬ ë°ì´í„° ì‚­ì œ ì™„ë£Œ');
    } catch (e, st) {
      log.e('ğŸ—‘ï¸ ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  /// ê°œë°œìš©: ìµœê·¼ Nê°œ ë°ì´í„°ë§Œ ìœ ì§€
  Future<void> trimOldData({int keepCount = 100}) async {
    try {
      if (_volumeBox.length <= keepCount) return;

      final allEntries = _volumeBox.values.toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp)); // ìµœì‹ ìˆœ

      final toKeep = allEntries.take(keepCount).toList();
      
      await _volumeBox.clear();
      for (final volume in toKeep) {
        await addVolumeData(volume);
      }
      
      log.i('ğŸ§¹ ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬: ${allEntries.length} -> $keepCountê°œ');
    } catch (e, st) {
      log.e('ğŸ§¹ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }
}\n\n// ====== lib/data/repositories/market_mood_repository_impl.dart ======\n
// lib/data/repositories/market_mood_repository_impl.dart
// ğŸ—ï¸ Data Layer: Repository êµ¬í˜„ì²´ (Domain ì¸í„°í˜ì´ìŠ¤ ì™„ì „ ë§¤ì¹­)

import 'dart:async';
import 'package:rxdart/rxdart.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';
import '../../domain/repositories/market_mood_repository.dart';
import '../datasources/market_mood_local_ds.dart';
import '../datasources/market_mood_remote_ds.dart';
import '../models/market_mood_dto.dart';

/// ğŸ—ï¸ ë§ˆì¼“ë¬´ë“œ Repository êµ¬í˜„ì²´
/// Remote + Local DataSourceë¥¼ í†µí•©í•˜ì—¬ Domain Entityë¡œ ë³€í™˜í•˜ì—¬ ì œê³µ
class MarketMoodRepositoryImpl implements MarketMoodRepository {
  final MarketMoodRemoteDataSource _remoteDataSource;
  final MarketMoodLocalDataSource _localDataSource;

  // [ë¦¬íŒ©í† ë§] ìˆ˜ë™ ìŠ¤íŠ¸ë¦¼ ê´€ë¦¬ê°€ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ë³€ìˆ˜ ì‚­ì œ
  // StreamController<MarketMoodData>? _marketDataController;
  // StreamSubscription? _remoteSubscription;

  MarketMoodRepositoryImpl(this._remoteDataSource, this._localDataSource);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸŒ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Stream<MarketMoodData> getMarketDataStream() {
    // [ë¦¬íŒ©í† ë§] listen-add ëŒ€ì‹ , stream ì—°ì‚°ìë¥¼ ì‚¬ìš©í•œ ì„ ì–¸ì  ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    return _remoteDataSource
        .getGlobalMarketDataStream()
        .doOnData((globalDataDto) async {
          try {
            final volumeDto = TimestampedVolume(
              timestamp: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
              volumeUsd: globalDataDto.totalVolumeUsd,
            );
            await _localDataSource.addVolumeData(volumeDto);
            log.d('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì™„ë£Œ');
          } catch (e, st) {
            log.e('ğŸ“Š ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ë¡œì»¬ ì €ì¥ ì‹¤íŒ¨', e, st);
          }
        })
        .map((globalDataDto) {
          log.d('ğŸ“Š DTO -> Entity ë³€í™˜ ì™„ë£Œ');
          return MarketMoodData(
            totalMarketCapUsd: globalDataDto.totalMarketCapUsd,
            totalVolumeUsd: globalDataDto.totalVolumeUsd,
            btcDominance: globalDataDto.btcDominance,
            marketCapChange24h: globalDataDto.marketCapChangePercentage24hUsd,
            updatedAt: DateTime.fromMillisecondsSinceEpoch(globalDataDto.updatedAt * 1000),
          );
        });
  }

  @override
  Future<MarketMoodData?> getCurrentMarketData() async {
    try {
      // [ìˆ˜ì •] remoteDataSourceëŠ” ì´ì œ DTOë¥¼ ë°˜í™˜
      final dataDto = await _remoteDataSource.getGlobalMarketData();
      
      final marketData = MarketMoodData(
        totalMarketCapUsd: dataDto.totalMarketCapUsd,
        totalVolumeUsd: dataDto.totalVolumeUsd,
        btcDominance: dataDto.btcDominance,
        marketCapChange24h: dataDto.marketCapChangePercentage24hUsd,
        updatedAt: DateTime.fromMillisecondsSinceEpoch(dataDto.updatedAt * 1000),
      );
      
      log.d('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì„±ê³µ');
      return marketData;
    } catch (e, st) {
      log.e('ğŸ“Š í˜„ì¬ ë§ˆì¼“ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double> getExchangeRate() async {
    try {
      final cachedRate = await _localDataSource.getCachedExchangeRate();
      if (cachedRate != null) {
        return cachedRate;
      }
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      return rate;
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©', e, st);
      return 1400.0;
    }
  }

  @override
  Future<void> refreshExchangeRate() async {
    try {
      log.i('ğŸ’± í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
      final rate = await _remoteDataSource.getUsdToKrwRate();
      await _localDataSource.cacheExchangeRate(rate);
      log.i('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ: $rate KRW');
    } catch (e, st) {
      log.e('ğŸ’± í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (ë³¼ë¥¨ ë²„í¼) - Domain Entity ì‚¬ìš©
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> addVolumeData(VolumeData volume) async {
    try {
      final volumeDto = TimestampedVolume.fromEntity(volume);
      await _localDataSource.addVolumeData(volumeDto);
    } catch (e, st) {
      log.e('ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ ì‹¤íŒ¨', e, st);
      rethrow;
    }
  }

  @override
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes) async {
    try {
      final volumeDto = await _localDataSource.getVolumeNMinutesAgo(minutes);
      return volumeDto?.toEntity();
    } catch (e, st) {
      log.e('ğŸ“ˆ $minutesë¶„ ì „ ë³¼ë¥¨ ì¡°íšŒ ì‹¤íŒ¨', e, st);
      return null;
    }
  }

  @override
  Future<double?> getAverageVolume(int days) async {
    return _localDataSource.getAverageVolume(days);
  }

  @override
  Future<int> getCollectedDataCount() async {
    return _localDataSource.getCollectedDataCount();
  }

  @override
  DateTime getAppStartTime() {
    return _localDataSource.getAppStartTime();
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> syncMissingData() async {
    await _localDataSource.checkAndFillMissingSlots();
  }

  @override
  Future<void> clearOldData() async {
    await _localDataSource.trimOldData(keepCount: 336); // 7ì¼ * 48ìŠ¬ë¡¯/ì¼
  }

  @override
  Future<Map<String, dynamic>> getSystemHealth() async {
    final localInfo = _localDataSource.getDebugInfo();
    final remoteHealth = await _remoteDataSource.checkApiHealth();
    final dataCount = await getCollectedDataCount();
    final appStartTime = getAppStartTime();
    final elapsedMinutes = DateTime.now().difference(appStartTime).inMinutes;

    return {
      'status': 'healthy',
      'local_storage': localInfo,
      'remote_api': {'healthy': remoteHealth, 'status': remoteHealth ? 'ok' : 'error'},
      'data_count': dataCount,
      'app_start_time': appStartTime.toIso8601String(),
      'elapsed_minutes': elapsedMinutes,
      'last_check': DateTime.now().toIso8601String(),
    };
  }

  @override
  Future<void> logCurrentStatus() async {
    final health = await getSystemHealth();
    _localDataSource.logStatus();
    log.i('ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì‹œìŠ¤í…œ ìƒíƒœ: $health');
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> injectTestVolumeData(List<VolumeData> testData) async {
    if (testData.isEmpty) return;
    for (final volume in testData) {
      await addVolumeData(volume);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  @override
  Future<void> dispose() async {
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘');
    _remoteDataSource.dispose();
    await _localDataSource.dispose();
    log.i('ğŸ§¹ MarketMoodRepository ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
  }
}\n\n// ====== lib/data/models/market_mood_model.dart ======\n
\n\n// ====== lib/data/models/market_mood_dto.g.dart ======\n
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'market_mood_dto.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TimestampedVolumeAdapter extends TypeAdapter<TimestampedVolume> {
  @override
  final int typeId = 1;

  @override
  TimestampedVolume read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TimestampedVolume(
      timestamp: fields[0] as DateTime,
      volumeUsd: fields[1] as double,
    );
  }

  @override
  void write(BinaryWriter writer, TimestampedVolume obj) {
    writer
      ..writeByte(2)
      ..writeByte(0)
      ..write(obj.timestamp)
      ..writeByte(1)
      ..write(obj.volumeUsd);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimestampedVolumeAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalDataDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalDataDto> {
  @override
  final int typeId = 2;

  @override
  CoinGeckoGlobalDataDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalDataDto(
      totalMarketCapUsd: fields[0] as double,
      totalVolumeUsd: fields[1] as double,
      btcDominance: fields[2] as double,
      marketCapChangePercentage24hUsd: fields[3] as double,
      updatedAt: fields[4] as int,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalDataDto obj) {
    writer
      ..writeByte(5)
      ..writeByte(0)
      ..write(obj.totalMarketCapUsd)
      ..writeByte(1)
      ..write(obj.totalVolumeUsd)
      ..writeByte(2)
      ..write(obj.btcDominance)
      ..writeByte(3)
      ..write(obj.marketCapChangePercentage24hUsd)
      ..writeByte(4)
      ..write(obj.updatedAt);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalDataDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

class CoinGeckoGlobalResponseDtoAdapter
    extends TypeAdapter<CoinGeckoGlobalResponseDto> {
  @override
  final int typeId = 3;

  @override
  CoinGeckoGlobalResponseDto read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return CoinGeckoGlobalResponseDto(
      data: fields[0] as CoinGeckoGlobalDataDto,
    );
  }

  @override
  void write(BinaryWriter writer, CoinGeckoGlobalResponseDto obj) {
    writer
      ..writeByte(1)
      ..writeByte(0)
      ..write(obj.data);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CoinGeckoGlobalResponseDtoAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
\n\n// ====== lib/data/models/market_mood_dto.dart ======\n
// lib/data/models/market_mood_dto.dart
// ğŸŒ Data Layer: í†µí•© DTO ëª¨ë¸ (Trade ìŠ¤íƒ€ì¼)

import 'dart:convert';
import 'package:hive/hive.dart';
import '../../core/utils/date_time.dart'; // DateTime extension
import '../../core/utils/logger.dart';
import '../../domain/entities/market_mood.dart';

part 'market_mood_dto.g.dart';

/// ğŸ“ˆ ì¸íŠ¸ë¼ë°ì´ ë³¼ë¥¨ ë°ì´í„° (30ë¶„ ë‹¨ìœ„) - Hive ëª¨ë¸
@HiveType(typeId: 1) // TradeDtoê°€ typeId: 0 ì‚¬ìš©í•˜ë¯€ë¡œ 1 ì‚¬ìš©
class TimestampedVolume extends HiveObject {
  @HiveField(0)
  final DateTime timestamp;

  @HiveField(1)
  final double volumeUsd;

  TimestampedVolume({
    required this.timestamp,
    required this.volumeUsd,
  });

  /// Domain Entityë¡œ ë³€í™˜
  VolumeData toEntity() => VolumeData(
    timestamp: timestamp,
    volumeUsd: volumeUsd,
  );

  /// Domain Entityì—ì„œ ìƒì„±
  factory TimestampedVolume.fromEntity(VolumeData entity) => TimestampedVolume(
    timestamp: entity.timestamp,
    volumeUsd: entity.volumeUsd,
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'timestamp': timestamp.toIso8601String(),
    'volumeUsd': volumeUsd,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹±
  static TimestampedVolume? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      final timestampStr = m['timestamp']?.toString() ?? '';
      final volumeUsd = (m['volumeUsd'] as num?)?.toDouble() ?? 0.0;

      if (timestampStr.isEmpty) return null;

      return TimestampedVolume(
        timestamp: DateTime.parse(timestampStr),
        volumeUsd: volumeUsd,
      );
    } catch (e) {
      log.w('TimestampedVolume.tryParse error: $e');
      return null;
    }
  }

  /// JSON ë¬¸ìì—´ë¡œë¶€í„° ê°ì²´ ìƒì„±
  factory TimestampedVolume.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      TimestampedVolume(
        timestamp: DateTime.now(),
        volumeUsd: 0.0,
      );

  /// DateTime extension í™œìš©
  String get formattedTime => timestamp.yyyyMMddhhmm();
  String get timeAgoText => timestamp.timeAgo();
  String get shortTime => timestamp.hhmmss();

  @override
  String toString() => 'TimestampedVolume($formattedTime, ${volumeUsd.toStringAsFixed(2)}B)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° DTO
@HiveType(typeId: 2)
class CoinGeckoGlobalDataDto extends HiveObject {
  @HiveField(0)
  final double totalMarketCapUsd;

  @HiveField(1)
  final double totalVolumeUsd;

  @HiveField(2)
  final double btcDominance;

  @HiveField(3)
  final double marketCapChangePercentage24hUsd;

  @HiveField(4)
  final int updatedAt;

  CoinGeckoGlobalDataDto({
    required this.totalMarketCapUsd,
    required this.totalVolumeUsd,
    required this.btcDominance,
    required this.marketCapChangePercentage24hUsd,
    required this.updatedAt,
  });

  /// Domain Entityë¡œ ë³€í™˜
  MarketMoodData toEntity() => MarketMoodData(
    totalMarketCapUsd: totalMarketCapUsd,
    totalVolumeUsd: totalVolumeUsd,
    btcDominance: btcDominance,
    marketCapChange24h: marketCapChangePercentage24hUsd,
    updatedAt: DateTime.fromMillisecondsSinceEpoch(updatedAt * 1000),
  );

  /// JSON ì§ë ¬í™”ìš© ë§µ ë³€í™˜
  Map<String, dynamic> toMap() => {
    'total_market_cap_usd': totalMarketCapUsd,
    'total_volume_usd': totalVolumeUsd,
    'btc_dominance': btcDominance,
    'market_cap_change_percentage_24h_usd': marketCapChangePercentage24hUsd,
    'updated_at': updatedAt,
  };

  /// JSON ë¬¸ìì—´ ì§ë ¬í™”
  String toJson() => json.encode(toMap());

  /// JSON íŒŒì‹± (CoinGecko API ì‘ë‹µ í˜•íƒœ)
  static CoinGeckoGlobalDataDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;

      double parseDouble(dynamic v) {
        if (v is num) return v.toDouble();
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? double.tryParse(str) ?? 0.0 : 0.0;
      }

      int parseInt(dynamic v) {
        if (v is int) return v;
        final str = v?.toString().trim() ?? '';
        return str.isNotEmpty ? int.tryParse(str) ?? DateTime.now().millisecondsSinceEpoch ~/ 1000
            : DateTime.now().millisecondsSinceEpoch ~/ 1000;
      }

      final totalMarketCap = m['total_market_cap'] as Map<String, dynamic>?;
      final totalVolume = m['total_volume'] as Map<String, dynamic>?;
      final marketCapPercentage = m['market_cap_percentage'] as Map<String, dynamic>?;

      return CoinGeckoGlobalDataDto(
        totalMarketCapUsd: parseDouble(totalMarketCap?['usd']),
        totalVolumeUsd: parseDouble(totalVolume?['usd']),
        btcDominance: parseDouble(marketCapPercentage?['btc']),
        marketCapChangePercentage24hUsd: parseDouble(m['market_cap_change_percentage_24h_usd']),
        updatedAt: parseInt(m['updated_at']),
      );
    } catch (e) {
      log.w('CoinGeckoGlobalDataDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalDataDto.fromJson(String src) =>
      tryParse(json.decode(src) as Map<String, dynamic>) ??
      CoinGeckoGlobalDataDto(
        totalMarketCapUsd: 0.0,
        totalVolumeUsd: 0.0,
        btcDominance: 0.0,
        marketCapChangePercentage24hUsd: 0.0,
        updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
      );

  @override
  String toString() => 'CoinGeckoGlobalDataDto(volume: ${totalVolumeUsd.toStringAsFixed(0)}B USD)';
}

/// ğŸŒ CoinGecko ê¸€ë¡œë²Œ ë§ˆì¼“ ì‘ë‹µ ë˜í¼ DTO
@HiveType(typeId: 3)
class CoinGeckoGlobalResponseDto extends HiveObject {
  @HiveField(0)
  final CoinGeckoGlobalDataDto data;

  CoinGeckoGlobalResponseDto({
    required this.data,
  });

  Map<String, dynamic> toMap() => {
    'data': data.toMap(),
  };

  String toJson() => json.encode(toMap());

  static CoinGeckoGlobalResponseDto? tryParse(Map<String, dynamic> m) {
    try {
      if (m.isEmpty) return null;
      final dataMap = m['data'] as Map<String, dynamic>?;
      if (dataMap == null) return null;
      final data = CoinGeckoGlobalDataDto.tryParse(dataMap);
      if (data == null) return null;
      return CoinGeckoGlobalResponseDto(data: data);
    } catch (e) {
      log.w('CoinGeckoGlobalResponseDto.tryParse error: $e');
      return null;
    }
  }

  factory CoinGeckoGlobalResponseDto.fromJson(Map<String, dynamic> json) {
     final parsed = tryParse(json);
     if(parsed != null) return parsed;
     
     return CoinGeckoGlobalResponseDto(
        data: CoinGeckoGlobalDataDto(
          totalMarketCapUsd: 0.0,
          totalVolumeUsd: 0.0,
          btcDominance: 0.0,
          marketCapChangePercentage24hUsd: 0.0,
          updatedAt: DateTime.now().millisecondsSinceEpoch ~/ 1000,
        ),
      );
  }

  @override
  String toString() => 'CoinGeckoGlobalResponseDto(data: $data)';
}\n\n// ====== lib/domain/repositories/market_mood_repository.dart ======\n
// lib/domain/repositories/market_mood_repository.dart
// ğŸ¯ Domain Layer: Repository ì¸í„°í˜ì´ìŠ¤ (í´ë¦° ì•„í‚¤í…ì²˜ ì¤€ìˆ˜)

import '../entities/market_mood.dart';

/// ğŸ“Š ë§ˆì¼“ë¬´ë“œ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
/// Data Layerì—ì„œ êµ¬í˜„í•´ì•¼ í•  ê³„ì•½ì„ ì •ì˜ (Domain â†’ Data ì˜ì¡´ì„± ì œê±°)
abstract class MarketMoodRepository {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ“¡ ì›ê²© ë°ì´í„° (CoinGecko API)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ê¸€ë¡œë²Œ ë§ˆì¼“ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ (30ë¶„ ì£¼ê¸°)
  Stream<MarketMoodData> getMarketDataStream();
  
  /// í˜„ì¬ ë§ˆì¼“ ë°ì´í„° í•œ ë²ˆ ì¡°íšŒ
  Future<MarketMoodData?> getCurrentMarketData();
  
  /// í˜„ì¬ USD/KRW í™˜ìœ¨ ì¡°íšŒ (ìºì‹œ í¬í•¨)
  Future<double> getExchangeRate();
  
  /// í™˜ìœ¨ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ’¾ ë¡œì»¬ ë°ì´í„° (Hive ë³¼ë¥¨ ë²„í¼)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ë³¼ë¥¨ ë°ì´í„° ì¶”ê°€ (30ë¶„ë§ˆë‹¤)
  Future<void> addVolumeData(VolumeData volume);
  
  /// Në¶„ ì „ ë³¼ë¥¨ ë°ì´í„° ì¡°íšŒ
  Future<VolumeData?> getVolumeNMinutesAgo(int minutes);
  
  /// íŠ¹ì • ê¸°ê°„ì˜ í‰ê·  ë³¼ë¥¨ ê³„ì‚°
  Future<double?> getAverageVolume(int days);
  
  /// ìˆ˜ì§‘ëœ ë°ì´í„° ê°œìˆ˜ í™•ì¸
  Future<int> getCollectedDataCount();
  
  /// ì•± ì‹œì‘ ì‹œê°„ ì¡°íšŒ
  DateTime getAppStartTime();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ§¹ ê´€ë¦¬ ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// ë°±ê·¸ë¼ìš´ë“œ ë³µê·€ ì‹œ ëˆ„ë½ëœ ìŠ¬ë¡¯ ë³´ì •
  Future<void> syncMissingData();
  
  /// ì˜¤ë˜ëœ ë°ì´í„° ì •ë¦¬
  Future<void> clearOldData();
  
  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<Map<String, dynamic>> getSystemHealth();
  
  /// í˜„ì¬ ìƒíƒœ ë¡œê¹…
  Future<void> logCurrentStatus();
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ› ï¸ ê°œë°œ/í…ŒìŠ¤íŠ¸ìš© ê¸°ëŠ¥
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// í…ŒìŠ¤íŠ¸ ë°ì´í„° ì£¼ì…
  Future<void> injectTestVolumeData(List<VolumeData> testData);
}\n\n// ====== lib/domain/usecases/market_mood_usecase.dart ======\n
// lib/domain/usecases/market_mood_usecase.dart
// ğŸ¯ Domain Layer: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ìˆœìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜)

import 'dart:async';
import 'dart:math';
import '../entities/market_mood.dart';
import '../repositories/market_mood_repository.dart';

/// ğŸ’° ë§ˆì¼“ ë¬´ë“œ ê³„ì‚°ê¸° (ìˆœìˆ˜ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
class MarketMoodCalculator {
  static MarketMood calculateMoodByComparison(double current, double previous) {
    if (previous <= 0) return MarketMood.sideways;
    final changePercent = ((current - previous) / previous) * 100;
    
    // [ìˆ˜ì •] ìš”ì²­í•˜ì‹  ì„ê³„ê°’ (10, 5, -5, -10)ìœ¼ë¡œ ë³€ê²½
    if (changePercent >= 10) return MarketMood.bull;
    if (changePercent >= 5) return MarketMood.weakBull;
    if (changePercent >= -5) return MarketMood.sideways;
    if (changePercent >= -10) return MarketMood.bear;
    return MarketMood.deepBear;
  }

  static MarketMood calculateMoodByAbsolute(double volumeUsd) {
    if (volumeUsd >= 150e9) return MarketMood.bull;
    if (volumeUsd >= 100e9) return MarketMood.weakBull;
    if (volumeUsd >= 70e9) return MarketMood.sideways;
    if (volumeUsd >= 50e9) return MarketMood.bear;
    return MarketMood.deepBear;
  }
}

/// ğŸ§® ë³¼ë¥¨ ë¹„êµ ê³„ì‚°ê¸° (ìˆœìˆ˜ ê³„ì‚° ë¡œì§)
class VolumeComparator {
  final MarketMoodRepository _repository;

  VolumeComparator(this._repository);

  double _calculateChangePercent(double current, double previous) {
    if (previous <= 0) return 0.0;
    return ((current - previous) / previous) * 100;
  }

  double _calculateProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    if (elapsed < targetMinutes) {
      return min(elapsed / targetMinutes, 1.0);
    }
    final cycleElapsed = (elapsed - targetMinutes) % targetMinutes;
    return cycleElapsed / targetMinutes;
  }

  double _calculateLongTermProgress(int targetMinutes) {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;
    return min(elapsed / targetMinutes, 1.0);
  }

  Future<ComparisonResult> _compareGeneric({
    required double currentVolume,
    required int targetMinutes,
    required bool isLongTermAverage,
    required int daysForAverage,
  }) async {
    final elapsed = DateTime.now().difference(_repository.getAppStartTime()).inMinutes;

    if (isLongTermAverage) {
      if (elapsed < targetMinutes) {
        return ComparisonResult.collecting(_calculateLongTermProgress(targetMinutes));
      }
      final average = await _repository.getAverageVolume(daysForAverage);
      if (average == null) {
        return ComparisonResult.unavailable('ìƒ˜í”Œ ë¶€ì¡±');
      }
      return ComparisonResult.ready(_calculateChangePercent(currentVolume, average));
    }

    if (elapsed < targetMinutes) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    final past = await _repository.getVolumeNMinutesAgo(targetMinutes);
    if (past == null) {
      return ComparisonResult.collecting(_calculateProgress(targetMinutes));
    }
    return ComparisonResult.ready(_calculateChangePercent(currentVolume, past.volumeUsd));
  }

  Future<ComparisonResult> compare30Minutes(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 30, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare1Hour(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 60, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare2Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 120, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare4Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 240, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare8Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 480, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare12Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 720, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare24Hours(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 1440, isLongTermAverage: false, daysForAverage: 0);

  Future<ComparisonResult> compare3DayAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 4320, isLongTermAverage: true, daysForAverage: 3);

  Future<ComparisonResult> compareWeeklyAverage(double currentVolume) =>
      _compareGeneric(currentVolume: currentVolume, targetMinutes: 10080, isLongTermAverage: true, daysForAverage: 7);

  /// [ê°œì„ ] ì „ì²´ ë¹„êµ ë°ì´í„° ê³„ì‚° (ë³‘ë ¬ ì²˜ë¦¬)
  Future<ComparisonData> calculateAll(double currentVolume) async {
    final results = await Future.wait([
      compare30Minutes(currentVolume),
      compare1Hour(currentVolume),
      compare2Hours(currentVolume),
      compare4Hours(currentVolume),
      compare8Hours(currentVolume),
      compare12Hours(currentVolume),
      compare24Hours(currentVolume),
      compare3DayAverage(currentVolume),
      compareWeeklyAverage(currentVolume),
    ]);

    return ComparisonData(
      thirtyMin: results[0],
      oneHour: results[1],
      twoHour: results[2],
      fourHour: results[3],
      eightHour: results[4],
      twelveHour: results[5],
      twentyFourHour: results[6],
      threeDayAverage: results[7],
      weeklyAverage: results[8],
    );
  }
}

/// ğŸ¯ ë§ˆì¼“ë¬´ë“œ UseCase (ì „ì²´ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì¡°í•©) - Providerì™€ ë§¤ì¹­
class MarketMoodUsecase {
  final MarketMoodRepository _repository;
  final VolumeComparator _comparator;

  MarketMoodUsecase(this._repository) : _comparator = VolumeComparator(_repository);

  Future<void> addVolumeData(double volumeUsd) async {
    final volumeData = VolumeData(
      timestamp: DateTime.now(),
      volumeUsd: volumeUsd,
    );
    await _repository.addVolumeData(volumeData);
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ê³„ì‚° ê¸°ì¤€ì„ 2ì‹œê°„ìœ¼ë¡œ ë³€ê²½
  Future<MarketMood> calculateCurrentMood(double currentVolume) async {
    // 2ì‹œê°„ = 120ë¶„
    final twoHoursAgo = await _repository.getVolumeNMinutesAgo(120);
    
    if (twoHoursAgo != null) {
      return MarketMoodCalculator.calculateMoodByComparison(
        currentVolume, 
        twoHoursAgo.volumeUsd
      );
    }
    return MarketMoodCalculator.calculateMoodByAbsolute(currentVolume);
  }

  Future<ComparisonData> calculateVolumeComparison(double currentVolume) {
    return _comparator.calculateAll(currentVolume);
  }

  MarketMoodSystemState createSystemState({
    required MarketMoodData? marketData,
    required ComparisonData comparisonData,
    required MarketMood currentMood,
    required double exchangeRate,
    required bool isLoading,
    required bool hasError,
  }) {
    return MarketMoodSystemState(
      marketData: marketData,
      comparisonData: comparisonData,
      currentMood: currentMood,
      exchangeRate: exchangeRate,
      isLoading: isLoading,
      hasError: hasError,
    );
  }

  String generateMoodSummary(MarketMood mood) {
    switch (mood) {
      case MarketMood.bull: return 'ğŸš€ ë¶ˆì¥';
      case MarketMood.weakBull: return 'ğŸ”¥ ì•½ë¶ˆì¥';
      case MarketMood.sideways: return 'âš–ï¸ ì¤‘ê°„ì¥';
      case MarketMood.bear: return 'ğŸ’§ ë¬¼ì¥';
      case MarketMood.deepBear: return 'ğŸ§Š ì–¼ìŒì¥';
    }
  }

  Future<void> handleBackgroundResume() async {
    await _repository.syncMissingData();
  }

  Future<Map<String, dynamic>> getSystemHealth() async {
    return await _repository.getSystemHealth();
  }

  Future<void> logSystemStatus() async {
    await _repository.logCurrentStatus();
  }

  Future<int> getCollectedDataCount() async {
    return await _repository.getCollectedDataCount();
  }

  DateTime getAppStartTime() {
    return _repository.getAppStartTime();
  }

  Future<double> getExchangeRate() async {
    return await _repository.getExchangeRate();
  }

  Future<void> refreshExchangeRate() async {
    await _repository.refreshExchangeRate();
  }
}\n\n// ====== lib/domain/entities/market_mood.dart ======\n
// lib/domain/entities/market_mood.dart
// ğŸ¯ Domain Layer: ìˆœìˆ˜ ì—”í‹°í‹°ë“¤ (VolumeData ì¶”ê°€)

import '../../core/utils/date_time.dart'; // DateTime extension

/// ğŸ•’ ë³¼ë¥¨ ê´€ë ¨ ìƒìˆ˜ ì •ì˜
class VolumeConstants {
 static const int minutesPerSlot = 30;
 static const int slotsPerHour = 60 ~/ minutesPerSlot; // 2
 static const int hoursPerDay = 24;
 static const int daysInBuffer = 7;
 static const int totalSlots = slotsPerHour * hoursPerDay * daysInBuffer; // 336
 static const int maxMinutesBuffer = minutesPerSlot * totalSlots; // 10080
 static const String volumeBoxName = 'market_volumes';
}

/// ğŸ”¥ ì‹œì¥ ë¶„ìœ„ê¸° enum
enum MarketMood {
 bull,       // ğŸš€ ë¶ˆì¥
 weakBull,   // ğŸ”¥ ì•½ë¶ˆì¥
 sideways,   // âš–ï¸ ì¤‘ê°„ì¥
 bear,       // ğŸ’§ ë¬¼ì¥
 deepBear,   // ğŸ§Š ì–¼ìŒì¥
}

/// ğŸ“ˆ ë³¼ë¥¨ ë°ì´í„° ì—”í‹°í‹° (30ë¶„ ë‹¨ìœ„)
class VolumeData {
 final DateTime timestamp;
 final double volumeUsd;

 const VolumeData({
   required this.timestamp,
   required this.volumeUsd,
 });

 /// DateTime extension í™œìš©
 String get formattedTime => timestamp.yyyyMMddhhmm();
 String get timeAgoText => timestamp.timeAgo();
 String get shortTime => timestamp.hhmmss();

 /// JSON ì§ë ¬í™”
 Map<String, dynamic> toJson() => {
   'timestamp': timestamp.toIso8601String(),
   'volume_usd': volumeUsd,
 };

 factory VolumeData.fromJson(Map<String, dynamic> json) {
   return VolumeData(
     timestamp: DateTime.parse(json['timestamp']),
     volumeUsd: (json['volume_usd'] as num).toDouble(),
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is VolumeData &&
         runtimeType == other.runtimeType &&
         timestamp == other.timestamp &&
         volumeUsd == other.volumeUsd;

 @override
 int get hashCode => timestamp.hashCode ^ volumeUsd.hashCode;

 @override
 String toString() =>
     'VolumeData(${volumeUsd.toStringAsFixed(0)}B USD at ${timestamp.hhmmss()})';
}

/// ğŸ“Š ë§ˆì¼“ ë¬´ë“œ ë°ì´í„° ì—”í‹°í‹°
class MarketMoodData {
 final double totalMarketCapUsd;
 final double totalVolumeUsd;
 final double btcDominance;
 final double marketCapChange24h;
 final DateTime updatedAt;

 const MarketMoodData({
   required this.totalMarketCapUsd,
   required this.totalVolumeUsd,
   required this.btcDominance,
   required this.marketCapChange24h,
   required this.updatedAt,
 });

 /// JSON ì§ë ¬í™” (DTO í˜¸í™˜ìš©)
 Map<String, dynamic> toJson() => {
   'total_market_cap_usd': totalMarketCapUsd,
   'total_volume_usd': totalVolumeUsd,
   'btc_dominance': btcDominance,
   'market_cap_change_24h': marketCapChange24h,
   'updated_at': updatedAt.toIso8601String(),
 };

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodData &&
         runtimeType == other.runtimeType &&
         totalMarketCapUsd == other.totalMarketCapUsd &&
         totalVolumeUsd == other.totalVolumeUsd &&
         btcDominance == other.btcDominance &&
         marketCapChange24h == other.marketCapChange24h;

 @override
 int get hashCode =>
     totalMarketCapUsd.hashCode ^
     totalVolumeUsd.hashCode ^
     btcDominance.hashCode ^
     marketCapChange24h.hashCode;

 @override
 String toString() =>
     'MarketMoodData(volume: ${totalVolumeUsd.toStringAsFixed(0)}, '
     'cap: ${totalMarketCapUsd.toStringAsFixed(0)}, '
     'btc: ${btcDominance.toStringAsFixed(1)}%)';
}

/// ğŸ“Š ë¹„êµ ê²°ê³¼ ì—”í‹°í‹°
class ComparisonResult {
 final bool isReady;
 final double? changePercent;
 final double progressPercent;
 final String status;

 const ComparisonResult({
   required this.isReady,
   this.changePercent,
   required this.progressPercent,
   required this.status,
 });

 factory ComparisonResult.collecting(double progress) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: progress,
     status: 'ìˆ˜ì§‘ì¤‘',
   );
 }

 factory ComparisonResult.ready(double changePercent) {
   return ComparisonResult(
     isReady: true,
     changePercent: changePercent,
     progressPercent: 1.0,
     status: 'ì™„ë£Œ',
   );
 }

 factory ComparisonResult.unavailable(String message) {
   return ComparisonResult(
     isReady: false,
     changePercent: null,
     progressPercent: 0.0,
     status: message,
   );
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonResult &&
         runtimeType == other.runtimeType &&
         isReady == other.isReady &&
         changePercent == other.changePercent &&
         progressPercent == other.progressPercent &&
         status == other.status;

 @override
 int get hashCode =>
     isReady.hashCode ^
     changePercent.hashCode ^
     progressPercent.hashCode ^
     status.hashCode;

 @override
 String toString() =>
     'ComparisonResult(ready: $isReady, change: $changePercent%, progress: ${(progressPercent * 100).round()}%)';
}

/// ğŸ“ˆ ì „ì²´ ë¹„êµ ë°ì´í„° ì—”í‹°í‹°
class ComparisonData {
 final ComparisonResult thirtyMin;
 final ComparisonResult oneHour;
 final ComparisonResult twoHour;
 final ComparisonResult fourHour;
 final ComparisonResult eightHour;
 final ComparisonResult twelveHour;
 final ComparisonResult twentyFourHour;
 final ComparisonResult threeDayAverage;
 final ComparisonResult weeklyAverage;

 const ComparisonData({
   required this.thirtyMin,
   required this.oneHour,
   required this.twoHour,
   required this.fourHour,
   required this.eightHour,
   required this.twelveHour,
   required this.twentyFourHour,
   required this.threeDayAverage,
   required this.weeklyAverage,
 });

 factory ComparisonData.loading() {
   final loading = ComparisonResult.collecting(0.0);
   return ComparisonData(
     thirtyMin: loading,
     oneHour: loading,
     twoHour: loading,
     fourHour: loading,
     eightHour: loading,
     twelveHour: loading,
     twentyFourHour: loading,
     threeDayAverage: loading,
     weeklyAverage: loading,
   );
 }

 factory ComparisonData.error() {
   final error = ComparisonResult.unavailable('ì˜¤ë¥˜');
   return ComparisonData(
     thirtyMin: error,
     oneHour: error,
     twoHour: error,
     fourHour: error,
     eightHour: error,
     twelveHour: error,
     twentyFourHour: error,
     threeDayAverage: error,
     weeklyAverage: error,
   );
 }

 /// ëª¨ë“  ë¹„êµ ê²°ê³¼ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜
 List<ComparisonResult> get allResults => [
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     ];

 /// ì¤€ë¹„ëœ ë¹„êµ ê²°ê³¼ ê°œìˆ˜
 int get readyCount => allResults.where((r) => r.isReady).length;

 /// ì „ì²´ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get overallProgress =>
     allResults.map((r) => r.progressPercent).reduce((a, b) => a + b) / 9;

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is ComparisonData &&
         runtimeType == other.runtimeType &&
         thirtyMin == other.thirtyMin &&
         oneHour == other.oneHour &&
         twoHour == other.twoHour &&
         fourHour == other.fourHour &&
         eightHour == other.eightHour &&
         twelveHour == other.twelveHour &&
         twentyFourHour == other.twentyFourHour &&
         threeDayAverage == other.threeDayAverage &&
         weeklyAverage == other.weeklyAverage;

 @override
 int get hashCode => Object.hash(
       thirtyMin,
       oneHour,
       twoHour,
       fourHour,
       eightHour,
       twelveHour,
       twentyFourHour,
       threeDayAverage,
       weeklyAverage,
     );

 @override
 String toString() =>
     'ComparisonData(ready: $readyCount/9, progress: ${(overallProgress * 100).round()}%)';
}

/// ğŸ“¦ ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ ì—”í‹°í‹°
class MarketMoodSystemState {
 final MarketMoodData? marketData;
 final ComparisonData comparisonData;
 final MarketMood currentMood;
 final double exchangeRate;
 final bool isLoading;
 final bool hasError;

 const MarketMoodSystemState({
   required this.marketData,
   required this.comparisonData,
   required this.currentMood,
   required this.exchangeRate,
   required this.isLoading,
   required this.hasError,
 });

 /// ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™ ì¤‘ì¸ì§€ í™•ì¸
 bool get isHealthy => !hasError && marketData != null;

 /// ë°ì´í„° ìˆ˜ì§‘ ì§„í–‰ë¥  (0.0 ~ 1.0)
 double get dataProgress => comparisonData.overallProgress;

 /// ìƒíƒœ ìš”ì•½ ë¬¸ìì—´
 String get statusSummary {
   if (hasError) return 'ì˜¤ë¥˜ ë°œìƒ';
   if (isLoading) return 'ë¡œë”© ì¤‘';
   if (marketData == null) return 'ë°ì´í„° ì—†ìŒ';
   return 'ì •ìƒ ì‘ë™';
 }

 @override
 bool operator ==(Object other) =>
     identical(this, other) ||
     other is MarketMoodSystemState &&
         runtimeType == other.runtimeType &&
         marketData == other.marketData &&
         comparisonData == other.comparisonData &&
         currentMood == other.currentMood &&
         exchangeRate == other.exchangeRate &&
         isLoading == other.isLoading &&
         hasError == other.hasError;

 @override
 int get hashCode => Object.hash(
       marketData,
       comparisonData,
       currentMood,
       exchangeRate,
       isLoading,
       hasError,
     );

 @override
 String toString() =>
     'MarketMoodSystemState(mood: $currentMood, status: $statusSummary, progress: ${(dataProgress * 100).round()}%)';
}\n\n// ====== lib/presentation/controllers/market_mood_controller.dart ======\n
// lib/presentation/controllers/market_mood_controller.dart
// ğŸ® Presentation Layer: Market Mood ì»¨íŠ¸ë¡¤ëŸ¬ (ë¦¬íŒ©í† ë§ëœ Providerì— ë§ì¶° ìˆ˜ì •)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../../core/utils/date_time.dart';
import '../pages/market_mood_page.dart';

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬
class MarketMoodPageController extends StateNotifier<MarketMoodPageState> {
  final Ref _ref;

  MarketMoodPageController(this._ref) : super(MarketMoodPageState.initial()) {
    // [ìˆ˜ì •] ì´ˆê¸°í™” ë¡œì§ì„ ìƒì„±ìì—ì„œ ë¶„ë¦¬í•˜ì—¬ ëª…í™•í•˜ê²Œ ê´€ë¦¬
    _initialize();
  }

  /// [ìˆ˜ì •] ì´ˆê¸°í™” ë° ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë‹ ì‹œì‘
  void _initialize() {
    // 1. ì´ˆê¸° ìƒíƒœ ì„¤ì •
    final initialState = _ref.read(marketMoodSystemProvider);
    state = state.copyWith(
      isLoading: initialState.isLoading,
      error: initialState.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
      systemState: initialState,
    );

    // 2. ì‹¤ì‹œê°„ ìƒíƒœ ë³€í™” ê°ì§€ ë° ë™ê¸°í™”
    //    ì´ì œ ìµœì¢… ìƒíƒœì¸ marketMoodSystemProviderë§Œ listení•˜ë©´ ë©ë‹ˆë‹¤.
    _ref.listen<MarketMoodSystemState>(
      marketMoodSystemProvider,
      (previous, next) {
        state = state.copyWith(
          isLoading: next.isLoading,
          error: next.hasError ? 'ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ' : null,
          systemState: next,
        );
      },
    );
  }

  /// [ìˆ˜ì •] ë°ì´í„° ë¡œë“œ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // Future<void> loadData() async { ... }

  /// ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
  void refresh() {
    // [ìˆ˜ì •] controllerë¥¼ ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ë¡œ ë‘ì§€ ì•Šê³  í•„ìš” ì‹œ read
    final controller = _ref.read(marketMoodControllerProvider);
    controller.refresh();
  }

  /// [ìˆ˜ì •] í˜„ì¬ ë§ˆì¼“ë¬´ë“œ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  MarketMood getCurrentMood() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(currentMarketMoodProvider);
  }

  /// í™˜ìœ¨ ì¡°íšŒ (Future ëŒ€ì‘ - ì´ ë¶€ë¶„ì€ ë³€ê²½ ì—†ìŒ)
  Future<double> getExchangeRate() async {
    final exchangeAsync = _ref.read(exchangeRateProvider);
    return exchangeAsync.when(
      data: (rate) => rate,
      loading: () => 1400.0,
      error: (_, __) => 1400.0,
    );
  }

  /// [ìˆ˜ì •] ë³¼ë¥¨ ë¹„êµ ë°ì´í„° ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  ComparisonData getVolumeComparisons() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(volumeComparisonProvider);
  }

  /// ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
  Future<void> checkSystemHealth() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      final health = await controller.getSystemHealth();

      state = state.copyWith(
        systemHealth: health,
        lastHealthCheck: DateTime.now(),
      );
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// í™˜ìœ¨ ìƒˆë¡œê³ ì¹¨
  Future<void> refreshExchangeRate() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.refreshExchangeRate();
      // loadData() ëŒ€ì‹  systemProviderê°€ ìë™ìœ¼ë¡œ ê°±ì‹ í•˜ë¯€ë¡œ ë³„ë„ í˜¸ì¶œ ë¶ˆí•„ìš”
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ì‹œìŠ¤í…œ ìƒíƒœ ë¡œê¹…
  Future<void> logSystemStatus() async {
    try {
      final controller = _ref.read(marketMoodControllerProvider);
      await controller.logSystemStatus();
    } catch (e) {
      state = state.copyWith(error: e.toString());
    }
  }

  /// ë¶„ìœ„ê¸° ì´ëª¨ì§€ ì¡°íšŒ
  String getMoodEmoji(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ğŸš€',
      MarketMood.weakBull => 'ğŸ”¥',
      MarketMood.sideways => 'âš–ï¸',
      MarketMood.bear => 'ğŸ’§',
      MarketMood.deepBear => 'ğŸ§Š',
    };
  }

  /// ë¶„ìœ„ê¸° ì´ë¦„ ì¡°íšŒ
  String getMoodName(MarketMood mood) {
    return switch (mood) {
      MarketMood.bull => 'ë¶ˆì¥',
      MarketMood.weakBull => 'ì•½ë¶ˆì¥',
      MarketMood.sideways => 'ì¤‘ê°„ì¥',
      MarketMood.bear => 'ë¬¼ì¥',
      MarketMood.deepBear => 'ì–¼ìŒì¥',
    };
  }

  /// [ìˆ˜ì •] ë¶„ìœ„ê¸° ìš”ì•½ í…ìŠ¤íŠ¸ ì¡°íšŒ (ë™ê¸°ì‹ìœ¼ë¡œ ë³€ê²½)
  String getMoodSummary() {
    // .when()ì„ ì‚¬ìš©í•  í•„ìš” ì—†ì´ ì§ì ‘ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    return _ref.read(marketMoodSummaryProvider);
  }

  /// ë³¼ë¥¨ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatVolume(double volumeUsd) async {
    final rate = await getExchangeRate();
    final volumeKrw = volumeUsd * rate;

    if (volumeKrw >= 1e12) {
      final trillions = (volumeKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    if (volumeKrw >= 1e8) {
      final hundreds = (volumeKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    return '${(volumeKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì‹œê°€ì´ì•¡ í¬ë§·íŒ… (í•œêµ­ ì›í™”)
  Future<String> formatMarketCap(double marketCapUsd) async {
    final rate = await getExchangeRate();
    // [ìˆ˜ì •] marketCapKrw ë³€ìˆ˜ ì„ ì–¸
    final marketCapKrw = marketCapUsd * rate; 

    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e12) { 
      final trillions = (marketCapKrw / 1e12).toStringAsFixed(0);
      return '${_addCommas(trillions)}ì¡°ì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    if (marketCapKrw >= 1e8) {
      final hundreds = (marketCapKrw / 1e8).toStringAsFixed(0);
      return '${_addCommas(hundreds)}ì–µì›';
    }
    // [ìˆ˜ì •] volumeKrw -> marketCapKrwë¡œ ë³€ê²½
    return '${(marketCapKrw / 1e8).toStringAsFixed(1)}ì–µì›';
  }

  /// ì—…ë°ì´íŠ¸ ì‹œê°„ í¬ë§·íŒ…
  String formatUpdateTime(DateTime updatedAt) {
    return updatedAt.hhmmss(); // DateTime extension ì‚¬ìš©
  }

  /// ë¹„êµ ê²°ê³¼ ê°’ í¬ë§·íŒ…
  String formatComparisonValue(ComparisonResult result) {
    if (result.isReady && result.changePercent != null) {
      final value = result.changePercent!;
      final arrow = value > 5 ? 'â†—ï¸' : value < -5 ? 'â†˜ï¸' : 'â¡ï¸';
      return '${value >= 0 ? '+' : ''}${value.toStringAsFixed(1)}% $arrow';
    }
    return '${(result.progressPercent * 100).round()}% (${result.status})';
  }

  /// ì§„í–‰ë¥  ê³„ì‚°
  int getProgressPercent(ComparisonResult result) {
    return (result.progressPercent * 100).round();
  }

  /// í•˜ì´ë¼ì´íŠ¸ ìƒ‰ìƒ íŒë‹¨
  bool isHighlight(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) > 5;
  }

  /// ê²½ê³  ìƒ‰ìƒ íŒë‹¨
  bool isWarning(ComparisonResult result) {
    return result.isReady && (result.changePercent ?? 0) < -5;
  }

  /// [ìˆ˜ì •] ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ë¦¬ìŠ¤ë‹ ë©”ì„œë“œ ì œê±° -> _initialize()ë¡œ í†µí•©
  // void startListening() { ... }

  /// ìˆ«ìì— ì½¤ë§ˆ ì¶”ê°€
  String _addCommas(String numberStr) {
    final parts = numberStr.split('.');
    final integerPart = parts[0];
    final reversedInteger = integerPart.split('').reversed.join('');
    final withCommas = reversedInteger
        .replaceAllMapped(RegExp(r'.{3}'), (match) => '${match.group(0)},')
        .split('')
        .reversed
        .join('');
    final result =
        withCommas.startsWith(',') ? withCommas.substring(1) : withCommas;
    return parts.length > 1 ? '$result.${parts[1]}' : result;
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ìƒíƒœ
class MarketMoodPageState {
  final bool isLoading;
  final String? error;
  final MarketMoodSystemState? systemState;
  final Map<String, dynamic>? systemHealth;
  final DateTime? lastHealthCheck;

  const MarketMoodPageState({
    required this.isLoading,
    this.error,
    this.systemState,
    this.systemHealth,
    this.lastHealthCheck,
  });

  factory MarketMoodPageState.initial() {
    return const MarketMoodPageState(isLoading: true); // [ìˆ˜ì •] ì´ˆê¸° ìƒíƒœëŠ” ë¡œë”©ì¤‘
  }

  MarketMoodPageState copyWith({
    bool? isLoading,
    String? error,
    MarketMoodSystemState? systemState,
    Map<String, dynamic>? systemHealth,
    DateTime? lastHealthCheck,
  }) {
    return MarketMoodPageState(
      isLoading: isLoading ?? this.isLoading,
      error: error, // [ìˆ˜ì •] nullë¡œ ë®ì–´ì“°ê¸° ê°€ëŠ¥í•˜ë„ë¡ ?? this.error ì œê±°
      systemState: systemState ?? this.systemState,
      systemHealth: systemHealth ?? this.systemHealth,
      lastHealthCheck: lastHealthCheck ?? this.lastHealthCheck,
    );
  }
}

/// ğŸ® ë§ˆì¼“ë¬´ë“œ í˜ì´ì§€ ì»¨íŠ¸ë¡¤ëŸ¬ Provider
final marketMoodPageControllerProvider = StateNotifierProvider.autoDispose<
    MarketMoodPageController, MarketMoodPageState>((ref) {
  // [ìˆ˜ì •] ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± ì‹œ ë°”ë¡œ _initialize()ê°€ í˜¸ì¶œë˜ë¯€ë¡œ ë³„ë„ ë¡œì§ ë¶ˆí•„ìš”
  return MarketMoodPageController(ref);
});

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ ê´€ë¦¬ì (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalManager {
  static OverlayEntry? _overlayEntry;

  /// ëª¨ë‹¬ í‘œì‹œ
  static void show({
    required BuildContext context,
    required WidgetRef ref,
    required Offset position,
    required double statusIconSize,
    required MarketMoodData data,
  }) {
    hide(); // ê¸°ì¡´ ëª¨ë‹¬ ì œê±°

    _overlayEntry = OverlayEntry(
      builder: (context) => MarketMoodModalOverlay(
        position: position,
        statusIconSize: statusIconSize,
        ref: ref,
        data: data,
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  /// ëª¨ë‹¬ ìˆ¨ê¸°ê¸°
  static void hide() {
    _overlayEntry?.remove();
    _overlayEntry = null;
  }
}

/// ğŸ® ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ (ì‹¤ì œ MarketMoodPage ì‚¬ìš©)
class MarketMoodModalOverlay extends StatelessWidget {
  final Offset position;
  final double statusIconSize;
  final WidgetRef ref;
  final MarketMoodData data;

  const MarketMoodModalOverlay({
    super.key,
    required this.position,
    required this.statusIconSize,
    required this.ref,
    required this.data,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => MarketMoodModalManager.hide(),
      behavior: HitTestBehavior.translucent,
      child: Material(
        color: Colors.transparent,
        child: Stack(
          children: [
            // íˆ¬ëª… ë°°ê²½
            Positioned.fill(
              child: Container(color: Colors.transparent),
            ),
            // ì‹¤ì œ MarketMoodPage ìœ„ì ¯
            Positioned(
              left: position.dx,
              top: position.dy,
              child: Consumer(
                builder: (context, ref, child) {
                  return MarketMoodPage(
                    statusIconSize: statusIconSize,
                    data: data,
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}\n\n// ====== lib/presentation/pages/market_mood_page.dart ======\n
// lib/presentation/pages/market_mood_page.dart
// ğŸ“± Presentation Layer: Market Mood í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ, í´ë¦° ì•„í‚¤í…ì²˜)

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../core/di/app_providers.dart';
import '../controllers/market_mood_controller.dart';

/// ğŸ“± ë§ˆì¼“ë¬´ë“œ ìƒì„¸ í˜ì´ì§€ (ëª¨ë‹¬ í˜•íƒœ)
class MarketMoodPage extends ConsumerStatefulWidget {
  final double statusIconSize;
  final MarketMoodData data;

  const MarketMoodPage({
    super.key,
    required this.statusIconSize,
    required this.data,
  });

  @override
  ConsumerState<MarketMoodPage> createState() => _MarketMoodPageState();
}

class _MarketMoodPageState extends ConsumerState<MarketMoodPage>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _animationController.forward();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.elasticOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: const Interval(0.0, 0.5),
    ));
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animationController,
      builder: (context, child) {
        return Transform.scale(
          scale: _scaleAnimation.value,
          alignment: Alignment.center,
          child: Opacity(
            opacity: _opacityAnimation.value,
            child: _buildPageContent(),
          ),
        );
      },
    );
  }

  Widget _buildPageContent() {
    // í™”ë©´ í¬ê¸° ê³„ì‚°
    final screenSize = MediaQuery.of(context).size;
    final maxWidth = screenSize.width * 0.9;

    return IntrinsicWidth(
      child: Container(
        constraints: BoxConstraints(
          minWidth: widget.statusIconSize * 4.2,
          maxWidth: maxWidth,
        ),
        decoration: _buildContainerDecoration(),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildHeader(),
              const SizedBox(height: 8),
              _buildCoreMetrics(),
              const SizedBox(height: 8),
              _buildIntradayAnalysis(),
              const SizedBox(height: 8),
              _buildLongTermAnalysis(),
            ],
          ),
        ),
      ),
    );
  }

  BoxDecoration _buildContainerDecoration() {
    return BoxDecoration(
      color: Theme.of(context).colorScheme.surface,
      borderRadius: BorderRadius.circular(16),
      boxShadow: [
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.08),
          blurRadius: 16,
          offset: const Offset(0, 6),
          spreadRadius: 2,
        ),
        BoxShadow(
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Colors.black.withValues(alpha: 0.04),
          blurRadius: 4,
          offset: const Offset(0, 2),
        ),
      ],
      border: Border.all(
        // [ìˆ˜ì •] withOpacity -> withValues
        color: Theme.of(context).colorScheme.outline.withValues(alpha: 0.12),
        width: 0.8,
      ),
    );
  }

  Widget _buildHeader() {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final updateTime = controller.formatUpdateTime(widget.data.updatedAt);

    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final currentMood = ref.watch(currentMarketMoodProvider);
            final moodEmoji = controller.getMoodEmoji(currentMood);
            final moodName = controller.getMoodName(currentMood);

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      moodEmoji,
                      style: const TextStyle(fontSize: 12),
                    ),
                    const SizedBox(width: 4),
                    Flexible(
                      child: Text(
                        '$moodName - ğŸ˜„',
                        style: TextStyle(
                          fontSize: 11,
                          fontWeight: FontWeight.w700,
                          color: Theme.of(context).colorScheme.onSurface,
                          letterSpacing: 0.3,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 2),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.schedule,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                    ),
                    const SizedBox(width: 3),
                    Text(
                      'ì‹¤ì‹œê°„ ê¸°ì¤€ â€¢ ',
                      style: TextStyle(
                        fontSize: 8,
                        fontWeight: FontWeight.w500,
                        // [ìˆ˜ì •] withOpacity -> withValues
                        color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.7),
                      ),
                    ),
                    Icon(
                      Icons.access_time,
                      size: 9,
                      // [ìˆ˜ì •] withOpacity -> withValues
                      color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                    ),
                    const SizedBox(width: 3),
                    Flexible(
                      child: Text(
                        '$updateTime ì—…ë°ì´íŠ¸',
                        style: TextStyle(
                          fontSize: 8,
                          // [ìˆ˜ì •] withOpacity -> withValues
                          color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            );
          },
          loading: () => _buildLoadingHeader(),
          error: (_, __) => _buildErrorHeader(),
        );
      },
    );
  }

  Widget _buildLoadingHeader() {
    return const Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            SizedBox(
              width: 16, height: 16,
              child: CircularProgressIndicator(strokeWidth: 2)
            ),
            SizedBox(width: 8),
            Text(
              'ë¡œë”©ì¤‘...',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildErrorHeader() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 12,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(width: 4),
            Text(
              'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w700,
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCoreMetrics() {
    return Consumer(
      builder: (context, ref, child) {
        final exchangeAsync = ref.watch(exchangeRateProvider);

        return exchangeAsync.when(
          data: (exchangeRate) => _buildCoreMetricsContent(exchangeRate),
          loading: () => _buildLoadingMetrics(),
          error: (_, __) => _buildCoreMetricsContent(1400.0),
        );
      },
    );
  }

  Widget _buildCoreMetricsContent(double exchangeRate) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    return FutureBuilder<List<String>>(
      future: Future.wait([
        controller.formatVolume(widget.data.totalVolumeUsd),
        controller.formatMarketCap(widget.data.totalMarketCapUsd),
      ]),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingMetrics();
        }
        if (snapshot.hasData) {
          final values = snapshot.data!;
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
              const SizedBox(height: 4),
              _buildStatRow(
                icon: Icons.monetization_on,
                label: '24ì‹œê°„ ê±°ë˜ëŒ€ê¸ˆ',
                value: values[0],
                isHighlight: true,
              ),
              _buildStatRow(
                icon: Icons.pie_chart,
                label: 'ì´ ì‹œê°€ì´ì•¡',
                value: values[1],
              ),
              _buildStatRow(
                icon: Icons.trending_up,
                label: 'ì‹œì´ 24ì‹œê°„ ë³€í™”',
                value: '${widget.data.marketCapChange24h >= 0 ? '+' : ''}${widget.data.marketCapChange24h.toStringAsFixed(2)}%',
                isHighlight: widget.data.marketCapChange24h > 0,
                isWarning: widget.data.marketCapChange24h < -2,
              ),
              _buildStatRow(
                icon: Icons.flash_on,
                label: 'BTC ë„ë¯¸ë„ŒìŠ¤',
                value: '${widget.data.btcDominance.toStringAsFixed(1)}%',
              ),
            ],
          );
        }
        return _buildLoadingMetrics();
      },
    );
  }

  Widget _buildLoadingMetrics() {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle('í•µì‹¬ ì§€í‘œ', Icons.analytics),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildIntradayAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
                const SizedBox(height: 4),
                _buildComparisonRow('30ë¶„ ëŒ€ë¹„', comparisonData.thirtyMin, Icons.schedule),
                _buildComparisonRow('1ì‹œê°„ ëŒ€ë¹„', comparisonData.oneHour, Icons.access_time),
                _buildComparisonRow('2ì‹œê°„ ëŒ€ë¹„', comparisonData.twoHour, Icons.timer),
                _buildComparisonRow('4ì‹œê°„ ëŒ€ë¹„', comparisonData.fourHour, Icons.timer_3),
                _buildComparisonRow('8ì‹œê°„ ëŒ€ë¹„', comparisonData.eightHour, Icons.timer_outlined),
                _buildComparisonRow('12ì‹œê°„ ëŒ€ë¹„', comparisonData.twelveHour, Icons.access_time_filled),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
          error: (_, __) => _buildErrorSection('ì¸íŠ¸ë¼ë°ì´ ë¹„êµ ë¶„ì„', Icons.schedule),
        );
      },
    );
  }

  Widget _buildLongTermAnalysis() {
    return Consumer(
      builder: (context, ref, child) {
        final computedAsync = ref.watch(marketMoodComputedDataProvider);

        return computedAsync.when(
          data: (computedData) {
            final comparisonData = ref.watch(volumeComparisonProvider);
            return Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildSectionTitle('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
                const SizedBox(height: 4),
                _buildComparisonRow('24ì‹œê°„ ëŒ€ë¹„', comparisonData.twentyFourHour, Icons.calendar_today),
                _buildComparisonRow('3ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.threeDayAverage, Icons.view_day),
                _buildComparisonRow('ì¼ì£¼ì¼ í‰ê·  ëŒ€ë¹„', comparisonData.weeklyAverage, Icons.date_range),
              ],
            );
          },
          loading: () => _buildLoadingSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
          error: (_, __) => _buildErrorSection('ì¥ê¸° ë¹„êµ ë¶„ì„', Icons.calendar_month),
        );
      },
    );
  }

  Widget _buildLoadingSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        const SizedBox(
          width: 16, height: 16,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ],
    );
  }

  Widget _buildErrorSection(String title, IconData icon) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSectionTitle(title, icon),
        const SizedBox(height: 4),
        Text(
          'ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜',
          style: TextStyle(
            fontSize: 9,
            color: Theme.of(context).colorScheme.error,
          ),
        ),
      ],
    );
  }

  Widget _buildComparisonRow(String label, ComparisonResult result, IconData icon) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);

    if (result.isReady && result.changePercent != null) {
      return _buildStatRow(
        icon: icon,
        label: label,
        value: controller.formatComparisonValue(result),
        isHighlight: controller.isHighlight(result),
        isWarning: controller.isWarning(result),
      );
    } else {
      return _buildProgressRow(icon, label, result);
    }
  }

  Widget _buildProgressRow(IconData icon, String label, ComparisonResult result) {
    final controller = ref.read(marketMoodPageControllerProvider.notifier);
    final progressPercent = controller.getProgressPercent(result);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6),
          ),
          const SizedBox(width: 5),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  '$label: $progressPercent% (${result.status})',
                  style: TextStyle(
                    fontSize: 9,
                    fontWeight: FontWeight.w500,
                    // [ìˆ˜ì •] withOpacity -> withValues
                    color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
                  ),
                ),
                const SizedBox(height: 2),
                LinearProgressIndicator(
                  value: result.progressPercent.clamp(0.0, 1.0),
                  // [ìˆ˜ì •] withOpacity -> withValues
                  backgroundColor: Theme.of(context).colorScheme.outline.withValues(alpha: 0.2),
                  valueColor: AlwaysStoppedAnimation(
                    result.progressPercent >= 1.0
                      ? Colors.green
                      // [ìˆ˜ì •] withOpacity -> withValues
                      : Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
                  ),
                  minHeight: 3,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(String title, IconData icon) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon,
          size: 11,
          // [ìˆ˜ì •] withOpacity -> withValues
          color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
        ),
        const SizedBox(width: 4),
        Text(
          title,
          style: TextStyle(
            fontSize: 9,
            fontWeight: FontWeight.w700,
            // [ìˆ˜ì •] withOpacity -> withValues
            color: Theme.of(context).colorScheme.primary.withValues(alpha: 0.8),
            letterSpacing: 0.3,
          ),
        ),
      ],
    );
  }

  Widget _buildStatRow({
    required IconData icon,
    required String label,
    required String value,
    bool isError = false,
    bool isHighlight = false,
    bool isWarning = false,
  }) {
    Color getColor() {
      if (isError) return Theme.of(context).colorScheme.error;
      if (isHighlight) return Colors.green;
      if (isWarning) return Colors.red;
      // [ìˆ˜ì •] withOpacity -> withValues
      return Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6);
    }

    return Container(
      margin: const EdgeInsets.symmetric(vertical: 1),
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: isHighlight
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.green.withValues(alpha: 0.08)
            : isWarning
            // [ìˆ˜ì •] withOpacity -> withValues
            ? Colors.red.withValues(alpha: 0.08)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            icon,
            size: 11,
            color: getColor(),
          ),
          const SizedBox(width: 5),
          Text(
            '$label: ',
            style: TextStyle(
              fontSize: 9,
              fontWeight: FontWeight.w500,
              // [ìˆ˜ì •] withOpacity -> withValues
              color: Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          Flexible(
            child: Text(
              value,
              style: TextStyle(
                fontSize: 9,
                fontWeight: FontWeight.w600,
                color: getColor(),
                letterSpacing: 0.2,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}